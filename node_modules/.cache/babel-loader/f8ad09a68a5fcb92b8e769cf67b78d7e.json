{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { LineTokens } from '../core/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { TokenizationRegistry } from '../modes.js';\nimport { nullTokenize2 } from '../modes/nullMode.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { MultilineTokensBuilder, countEOL } from './tokensStore.js';\nimport * as platform from '../../../base/common/platform.js';\nexport class TokenizationStateStore {\n  constructor() {\n    this._beginState = [];\n    this._valid = [];\n    this._len = 0;\n    this._invalidLineStartIndex = 0;\n  }\n\n  _reset(initialState) {\n    this._beginState = [];\n    this._valid = [];\n    this._len = 0;\n    this._invalidLineStartIndex = 0;\n\n    if (initialState) {\n      this._setBeginState(0, initialState);\n    }\n  }\n\n  flush(initialState) {\n    this._reset(initialState);\n  }\n\n  get invalidLineStartIndex() {\n    return this._invalidLineStartIndex;\n  }\n\n  _invalidateLine(lineIndex) {\n    if (lineIndex < this._len) {\n      this._valid[lineIndex] = false;\n    }\n\n    if (lineIndex < this._invalidLineStartIndex) {\n      this._invalidLineStartIndex = lineIndex;\n    }\n  }\n\n  _isValid(lineIndex) {\n    if (lineIndex < this._len) {\n      return this._valid[lineIndex];\n    }\n\n    return false;\n  }\n\n  getBeginState(lineIndex) {\n    if (lineIndex < this._len) {\n      return this._beginState[lineIndex];\n    }\n\n    return null;\n  }\n\n  _ensureLine(lineIndex) {\n    while (lineIndex >= this._len) {\n      this._beginState[this._len] = null;\n      this._valid[this._len] = false;\n      this._len++;\n    }\n  }\n\n  _deleteLines(start, deleteCount) {\n    if (deleteCount === 0) {\n      return;\n    }\n\n    if (start + deleteCount > this._len) {\n      deleteCount = this._len - start;\n    }\n\n    this._beginState.splice(start, deleteCount);\n\n    this._valid.splice(start, deleteCount);\n\n    this._len -= deleteCount;\n  }\n\n  _insertLines(insertIndex, insertCount) {\n    if (insertCount === 0) {\n      return;\n    }\n\n    const beginState = [];\n    const valid = [];\n\n    for (let i = 0; i < insertCount; i++) {\n      beginState[i] = null;\n      valid[i] = false;\n    }\n\n    this._beginState = arrays.arrayInsert(this._beginState, insertIndex, beginState);\n    this._valid = arrays.arrayInsert(this._valid, insertIndex, valid);\n    this._len += insertCount;\n  }\n\n  _setValid(lineIndex, valid) {\n    this._ensureLine(lineIndex);\n\n    this._valid[lineIndex] = valid;\n  }\n\n  _setBeginState(lineIndex, beginState) {\n    this._ensureLine(lineIndex);\n\n    this._beginState[lineIndex] = beginState;\n  }\n\n  setEndState(linesLength, lineIndex, endState) {\n    this._setValid(lineIndex, true);\n\n    this._invalidLineStartIndex = lineIndex + 1; // Check if this was the last line\n\n    if (lineIndex === linesLength - 1) {\n      return;\n    } // Check if the end state has changed\n\n\n    const previousEndState = this.getBeginState(lineIndex + 1);\n\n    if (previousEndState === null || !endState.equals(previousEndState)) {\n      this._setBeginState(lineIndex + 1, endState);\n\n      this._invalidateLine(lineIndex + 1);\n\n      return;\n    } // Perhaps we can skip tokenizing some lines...\n\n\n    let i = lineIndex + 1;\n\n    while (i < linesLength) {\n      if (!this._isValid(i)) {\n        break;\n      }\n\n      i++;\n    }\n\n    this._invalidLineStartIndex = i;\n  }\n\n  setFakeTokens(lineIndex) {\n    this._setValid(lineIndex, false);\n  } //#region Editing\n\n\n  applyEdits(range, eolCount) {\n    const deletingLinesCnt = range.endLineNumber - range.startLineNumber;\n    const insertingLinesCnt = eolCount;\n    const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n\n    for (let j = editingLinesCnt; j >= 0; j--) {\n      this._invalidateLine(range.startLineNumber + j - 1);\n    }\n\n    this._acceptDeleteRange(range);\n\n    this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount);\n  }\n\n  _acceptDeleteRange(range) {\n    const firstLineIndex = range.startLineNumber - 1;\n\n    if (firstLineIndex >= this._len) {\n      return;\n    }\n\n    this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n  }\n\n  _acceptInsertText(position, eolCount) {\n    const lineIndex = position.lineNumber - 1;\n\n    if (lineIndex >= this._len) {\n      return;\n    }\n\n    this._insertLines(position.lineNumber, eolCount);\n  }\n\n}\nexport class TextModelTokenization extends Disposable {\n  constructor(_textModel, _languageIdCodec) {\n    super();\n    this._textModel = _textModel;\n    this._languageIdCodec = _languageIdCodec;\n    this._isDisposed = false;\n    this._tokenizationStateStore = new TokenizationStateStore();\n    this._tokenizationSupport = null;\n\n    this._register(TokenizationRegistry.onDidChange(e => {\n      const languageId = this._textModel.getLanguageId();\n\n      if (e.changedLanguages.indexOf(languageId) === -1) {\n        return;\n      }\n\n      this._resetTokenizationState();\n\n      this._textModel.clearTokens();\n    }));\n\n    this._register(this._textModel.onDidChangeContentFast(e => {\n      if (e.isFlush) {\n        this._resetTokenizationState();\n\n        return;\n      }\n\n      for (let i = 0, len = e.changes.length; i < len; i++) {\n        const change = e.changes[i];\n        const [eolCount] = countEOL(change.text);\n\n        this._tokenizationStateStore.applyEdits(change.range, eolCount);\n      }\n\n      this._beginBackgroundTokenization();\n    }));\n\n    this._register(this._textModel.onDidChangeAttached(() => {\n      this._beginBackgroundTokenization();\n    }));\n\n    this._register(this._textModel.onDidChangeLanguage(() => {\n      this._resetTokenizationState();\n\n      this._textModel.clearTokens();\n    }));\n\n    this._resetTokenizationState();\n  }\n\n  dispose() {\n    this._isDisposed = true;\n    super.dispose();\n  }\n\n  _resetTokenizationState() {\n    const [tokenizationSupport, initialState] = initializeTokenization(this._textModel);\n    this._tokenizationSupport = tokenizationSupport;\n\n    this._tokenizationStateStore.flush(initialState);\n\n    this._beginBackgroundTokenization();\n  }\n\n  _beginBackgroundTokenization() {\n    if (this._textModel.isAttachedToEditor() && this._hasLinesToTokenize()) {\n      platform.setImmediate(() => {\n        if (this._isDisposed) {\n          // disposed in the meantime\n          return;\n        }\n\n        this._revalidateTokensNow();\n      });\n    }\n  }\n\n  _revalidateTokensNow() {\n    const textModelLastLineNumber = this._textModel.getLineCount();\n\n    const MAX_ALLOWED_TIME = 1;\n    const builder = new MultilineTokensBuilder();\n    const sw = StopWatch.create(false);\n    let tokenizedLineNumber = -1;\n\n    while (this._hasLinesToTokenize()) {\n      if (sw.elapsed() > MAX_ALLOWED_TIME) {\n        // Stop if MAX_ALLOWED_TIME is reached\n        break;\n      }\n\n      tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n\n      if (tokenizedLineNumber >= textModelLastLineNumber) {\n        break;\n      }\n    }\n\n    this._beginBackgroundTokenization();\n\n    this._textModel.setTokens(builder.tokens, !this._hasLinesToTokenize());\n  }\n\n  tokenizeViewport(startLineNumber, endLineNumber) {\n    const builder = new MultilineTokensBuilder();\n\n    this._tokenizeViewport(builder, startLineNumber, endLineNumber);\n\n    this._textModel.setTokens(builder.tokens, !this._hasLinesToTokenize());\n  }\n\n  reset() {\n    this._resetTokenizationState();\n\n    this._textModel.clearTokens();\n  }\n\n  forceTokenization(lineNumber) {\n    const builder = new MultilineTokensBuilder();\n\n    this._updateTokensUntilLine(builder, lineNumber);\n\n    this._textModel.setTokens(builder.tokens, !this._hasLinesToTokenize());\n  }\n\n  isCheapToTokenize(lineNumber) {\n    if (!this._tokenizationSupport) {\n      return true;\n    }\n\n    const firstInvalidLineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n\n    if (lineNumber > firstInvalidLineNumber) {\n      return false;\n    }\n\n    if (lineNumber < firstInvalidLineNumber) {\n      return true;\n    }\n\n    if (this._textModel.getLineLength(lineNumber) < 2048\n    /* CHEAP_TOKENIZATION_LENGTH_LIMIT */\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  _hasLinesToTokenize() {\n    if (!this._tokenizationSupport) {\n      return false;\n    }\n\n    return this._tokenizationStateStore.invalidLineStartIndex < this._textModel.getLineCount();\n  }\n\n  _tokenizeOneInvalidLine(builder) {\n    if (!this._hasLinesToTokenize()) {\n      return this._textModel.getLineCount() + 1;\n    }\n\n    const lineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n\n    this._updateTokensUntilLine(builder, lineNumber);\n\n    return lineNumber;\n  }\n\n  _updateTokensUntilLine(builder, lineNumber) {\n    if (!this._tokenizationSupport) {\n      return;\n    }\n\n    const languageId = this._textModel.getLanguageId();\n\n    const linesLength = this._textModel.getLineCount();\n\n    const endLineIndex = lineNumber - 1; // Validate all states up to and including endLineIndex\n\n    for (let lineIndex = this._tokenizationStateStore.invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {\n      const text = this._textModel.getLineContent(lineIndex + 1);\n\n      const lineStartState = this._tokenizationStateStore.getBeginState(lineIndex);\n\n      const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationSupport, text, true, lineStartState);\n      builder.add(lineIndex + 1, r.tokens);\n\n      this._tokenizationStateStore.setEndState(linesLength, lineIndex, r.endState);\n\n      lineIndex = this._tokenizationStateStore.invalidLineStartIndex - 1; // -1 because the outer loop increments it\n    }\n  }\n\n  _tokenizeViewport(builder, startLineNumber, endLineNumber) {\n    if (!this._tokenizationSupport) {\n      // nothing to do\n      return;\n    }\n\n    if (endLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n      // nothing to do\n      return;\n    }\n\n    if (startLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n      // tokenization has reached the viewport start...\n      this._updateTokensUntilLine(builder, endLineNumber);\n\n      return;\n    }\n\n    let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(startLineNumber);\n\n    const fakeLines = [];\n    let initialState = null;\n\n    for (let i = startLineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n      const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n\n      if (newNonWhitespaceIndex === 0) {\n        continue;\n      }\n\n      if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n        initialState = this._tokenizationStateStore.getBeginState(i - 1);\n\n        if (initialState) {\n          break;\n        }\n\n        fakeLines.push(this._textModel.getLineContent(i));\n        nonWhitespaceColumn = newNonWhitespaceIndex;\n      }\n    }\n\n    if (!initialState) {\n      initialState = this._tokenizationSupport.getInitialState();\n    }\n\n    const languageId = this._textModel.getLanguageId();\n\n    let state = initialState;\n\n    for (let i = fakeLines.length - 1; i >= 0; i--) {\n      const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationSupport, fakeLines[i], false, state);\n      state = r.endState;\n    }\n\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const text = this._textModel.getLineContent(lineNumber);\n\n      const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationSupport, text, true, state);\n      builder.add(lineNumber, r.tokens);\n\n      this._tokenizationStateStore.setFakeTokens(lineNumber - 1);\n\n      state = r.endState;\n    }\n  }\n\n}\n\nfunction initializeTokenization(textModel) {\n  const languageId = textModel.getLanguageId();\n  let tokenizationSupport = textModel.isTooLargeForTokenization() ? null : TokenizationRegistry.get(languageId);\n  let initialState = null;\n\n  if (tokenizationSupport) {\n    try {\n      initialState = tokenizationSupport.getInitialState();\n    } catch (e) {\n      onUnexpectedError(e);\n      tokenizationSupport = null;\n    }\n  }\n\n  return [tokenizationSupport, initialState];\n}\n\nfunction safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {\n  let r = null;\n\n  if (tokenizationSupport) {\n    try {\n      r = tokenizationSupport.tokenize2(text, hasEOL, state.clone(), 0);\n    } catch (e) {\n      onUnexpectedError(e);\n    }\n  }\n\n  if (!r) {\n    r = nullTokenize2(languageIdCodec.encodeLanguageId(languageId), text, state, 0);\n  }\n\n  LineTokens.convertToEndOffset(r.tokens, text.length);\n  return r;\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js"],"names":["arrays","onUnexpectedError","LineTokens","Position","TokenizationRegistry","nullTokenize2","Disposable","StopWatch","MultilineTokensBuilder","countEOL","platform","TokenizationStateStore","constructor","_beginState","_valid","_len","_invalidLineStartIndex","_reset","initialState","_setBeginState","flush","invalidLineStartIndex","_invalidateLine","lineIndex","_isValid","getBeginState","_ensureLine","_deleteLines","start","deleteCount","splice","_insertLines","insertIndex","insertCount","beginState","valid","i","arrayInsert","_setValid","setEndState","linesLength","endState","previousEndState","equals","setFakeTokens","applyEdits","range","eolCount","deletingLinesCnt","endLineNumber","startLineNumber","insertingLinesCnt","editingLinesCnt","Math","min","j","_acceptDeleteRange","_acceptInsertText","startColumn","firstLineIndex","position","lineNumber","TextModelTokenization","_textModel","_languageIdCodec","_isDisposed","_tokenizationStateStore","_tokenizationSupport","_register","onDidChange","e","languageId","getLanguageId","changedLanguages","indexOf","_resetTokenizationState","clearTokens","onDidChangeContentFast","isFlush","len","changes","length","change","text","_beginBackgroundTokenization","onDidChangeAttached","onDidChangeLanguage","dispose","tokenizationSupport","initializeTokenization","isAttachedToEditor","_hasLinesToTokenize","setImmediate","_revalidateTokensNow","textModelLastLineNumber","getLineCount","MAX_ALLOWED_TIME","builder","sw","create","tokenizedLineNumber","elapsed","_tokenizeOneInvalidLine","setTokens","tokens","tokenizeViewport","_tokenizeViewport","reset","forceTokenization","_updateTokensUntilLine","isCheapToTokenize","firstInvalidLineNumber","getLineLength","endLineIndex","getLineContent","lineStartState","r","safeTokenize","add","nonWhitespaceColumn","getLineFirstNonWhitespaceColumn","fakeLines","newNonWhitespaceIndex","push","getInitialState","state","textModel","isTooLargeForTokenization","get","languageIdCodec","hasEOL","tokenize2","clone","encodeLanguageId","convertToEndOffset"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { LineTokens } from '../core/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { TokenizationRegistry } from '../modes.js';\nimport { nullTokenize2 } from '../modes/nullMode.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { MultilineTokensBuilder, countEOL } from './tokensStore.js';\nimport * as platform from '../../../base/common/platform.js';\nexport class TokenizationStateStore {\n    constructor() {\n        this._beginState = [];\n        this._valid = [];\n        this._len = 0;\n        this._invalidLineStartIndex = 0;\n    }\n    _reset(initialState) {\n        this._beginState = [];\n        this._valid = [];\n        this._len = 0;\n        this._invalidLineStartIndex = 0;\n        if (initialState) {\n            this._setBeginState(0, initialState);\n        }\n    }\n    flush(initialState) {\n        this._reset(initialState);\n    }\n    get invalidLineStartIndex() {\n        return this._invalidLineStartIndex;\n    }\n    _invalidateLine(lineIndex) {\n        if (lineIndex < this._len) {\n            this._valid[lineIndex] = false;\n        }\n        if (lineIndex < this._invalidLineStartIndex) {\n            this._invalidLineStartIndex = lineIndex;\n        }\n    }\n    _isValid(lineIndex) {\n        if (lineIndex < this._len) {\n            return this._valid[lineIndex];\n        }\n        return false;\n    }\n    getBeginState(lineIndex) {\n        if (lineIndex < this._len) {\n            return this._beginState[lineIndex];\n        }\n        return null;\n    }\n    _ensureLine(lineIndex) {\n        while (lineIndex >= this._len) {\n            this._beginState[this._len] = null;\n            this._valid[this._len] = false;\n            this._len++;\n        }\n    }\n    _deleteLines(start, deleteCount) {\n        if (deleteCount === 0) {\n            return;\n        }\n        if (start + deleteCount > this._len) {\n            deleteCount = this._len - start;\n        }\n        this._beginState.splice(start, deleteCount);\n        this._valid.splice(start, deleteCount);\n        this._len -= deleteCount;\n    }\n    _insertLines(insertIndex, insertCount) {\n        if (insertCount === 0) {\n            return;\n        }\n        const beginState = [];\n        const valid = [];\n        for (let i = 0; i < insertCount; i++) {\n            beginState[i] = null;\n            valid[i] = false;\n        }\n        this._beginState = arrays.arrayInsert(this._beginState, insertIndex, beginState);\n        this._valid = arrays.arrayInsert(this._valid, insertIndex, valid);\n        this._len += insertCount;\n    }\n    _setValid(lineIndex, valid) {\n        this._ensureLine(lineIndex);\n        this._valid[lineIndex] = valid;\n    }\n    _setBeginState(lineIndex, beginState) {\n        this._ensureLine(lineIndex);\n        this._beginState[lineIndex] = beginState;\n    }\n    setEndState(linesLength, lineIndex, endState) {\n        this._setValid(lineIndex, true);\n        this._invalidLineStartIndex = lineIndex + 1;\n        // Check if this was the last line\n        if (lineIndex === linesLength - 1) {\n            return;\n        }\n        // Check if the end state has changed\n        const previousEndState = this.getBeginState(lineIndex + 1);\n        if (previousEndState === null || !endState.equals(previousEndState)) {\n            this._setBeginState(lineIndex + 1, endState);\n            this._invalidateLine(lineIndex + 1);\n            return;\n        }\n        // Perhaps we can skip tokenizing some lines...\n        let i = lineIndex + 1;\n        while (i < linesLength) {\n            if (!this._isValid(i)) {\n                break;\n            }\n            i++;\n        }\n        this._invalidLineStartIndex = i;\n    }\n    setFakeTokens(lineIndex) {\n        this._setValid(lineIndex, false);\n    }\n    //#region Editing\n    applyEdits(range, eolCount) {\n        const deletingLinesCnt = range.endLineNumber - range.startLineNumber;\n        const insertingLinesCnt = eolCount;\n        const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n        for (let j = editingLinesCnt; j >= 0; j--) {\n            this._invalidateLine(range.startLineNumber + j - 1);\n        }\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount);\n    }\n    _acceptDeleteRange(range) {\n        const firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._len) {\n            return;\n        }\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n    _acceptInsertText(position, eolCount) {\n        const lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._len) {\n            return;\n        }\n        this._insertLines(position.lineNumber, eolCount);\n    }\n}\nexport class TextModelTokenization extends Disposable {\n    constructor(_textModel, _languageIdCodec) {\n        super();\n        this._textModel = _textModel;\n        this._languageIdCodec = _languageIdCodec;\n        this._isDisposed = false;\n        this._tokenizationStateStore = new TokenizationStateStore();\n        this._tokenizationSupport = null;\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageId = this._textModel.getLanguageId();\n            if (e.changedLanguages.indexOf(languageId) === -1) {\n                return;\n            }\n            this._resetTokenizationState();\n            this._textModel.clearTokens();\n        }));\n        this._register(this._textModel.onDidChangeContentFast((e) => {\n            if (e.isFlush) {\n                this._resetTokenizationState();\n                return;\n            }\n            for (let i = 0, len = e.changes.length; i < len; i++) {\n                const change = e.changes[i];\n                const [eolCount] = countEOL(change.text);\n                this._tokenizationStateStore.applyEdits(change.range, eolCount);\n            }\n            this._beginBackgroundTokenization();\n        }));\n        this._register(this._textModel.onDidChangeAttached(() => {\n            this._beginBackgroundTokenization();\n        }));\n        this._register(this._textModel.onDidChangeLanguage(() => {\n            this._resetTokenizationState();\n            this._textModel.clearTokens();\n        }));\n        this._resetTokenizationState();\n    }\n    dispose() {\n        this._isDisposed = true;\n        super.dispose();\n    }\n    _resetTokenizationState() {\n        const [tokenizationSupport, initialState] = initializeTokenization(this._textModel);\n        this._tokenizationSupport = tokenizationSupport;\n        this._tokenizationStateStore.flush(initialState);\n        this._beginBackgroundTokenization();\n    }\n    _beginBackgroundTokenization() {\n        if (this._textModel.isAttachedToEditor() && this._hasLinesToTokenize()) {\n            platform.setImmediate(() => {\n                if (this._isDisposed) {\n                    // disposed in the meantime\n                    return;\n                }\n                this._revalidateTokensNow();\n            });\n        }\n    }\n    _revalidateTokensNow() {\n        const textModelLastLineNumber = this._textModel.getLineCount();\n        const MAX_ALLOWED_TIME = 1;\n        const builder = new MultilineTokensBuilder();\n        const sw = StopWatch.create(false);\n        let tokenizedLineNumber = -1;\n        while (this._hasLinesToTokenize()) {\n            if (sw.elapsed() > MAX_ALLOWED_TIME) {\n                // Stop if MAX_ALLOWED_TIME is reached\n                break;\n            }\n            tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n            if (tokenizedLineNumber >= textModelLastLineNumber) {\n                break;\n            }\n        }\n        this._beginBackgroundTokenization();\n        this._textModel.setTokens(builder.tokens, !this._hasLinesToTokenize());\n    }\n    tokenizeViewport(startLineNumber, endLineNumber) {\n        const builder = new MultilineTokensBuilder();\n        this._tokenizeViewport(builder, startLineNumber, endLineNumber);\n        this._textModel.setTokens(builder.tokens, !this._hasLinesToTokenize());\n    }\n    reset() {\n        this._resetTokenizationState();\n        this._textModel.clearTokens();\n    }\n    forceTokenization(lineNumber) {\n        const builder = new MultilineTokensBuilder();\n        this._updateTokensUntilLine(builder, lineNumber);\n        this._textModel.setTokens(builder.tokens, !this._hasLinesToTokenize());\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizationSupport) {\n            return true;\n        }\n        const firstInvalidLineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n        if (lineNumber > firstInvalidLineNumber) {\n            return false;\n        }\n        if (lineNumber < firstInvalidLineNumber) {\n            return true;\n        }\n        if (this._textModel.getLineLength(lineNumber) < 2048 /* CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\n            return true;\n        }\n        return false;\n    }\n    _hasLinesToTokenize() {\n        if (!this._tokenizationSupport) {\n            return false;\n        }\n        return (this._tokenizationStateStore.invalidLineStartIndex < this._textModel.getLineCount());\n    }\n    _tokenizeOneInvalidLine(builder) {\n        if (!this._hasLinesToTokenize()) {\n            return this._textModel.getLineCount() + 1;\n        }\n        const lineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n        this._updateTokensUntilLine(builder, lineNumber);\n        return lineNumber;\n    }\n    _updateTokensUntilLine(builder, lineNumber) {\n        if (!this._tokenizationSupport) {\n            return;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const linesLength = this._textModel.getLineCount();\n        const endLineIndex = lineNumber - 1;\n        // Validate all states up to and including endLineIndex\n        for (let lineIndex = this._tokenizationStateStore.invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {\n            const text = this._textModel.getLineContent(lineIndex + 1);\n            const lineStartState = this._tokenizationStateStore.getBeginState(lineIndex);\n            const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationSupport, text, true, lineStartState);\n            builder.add(lineIndex + 1, r.tokens);\n            this._tokenizationStateStore.setEndState(linesLength, lineIndex, r.endState);\n            lineIndex = this._tokenizationStateStore.invalidLineStartIndex - 1; // -1 because the outer loop increments it\n        }\n    }\n    _tokenizeViewport(builder, startLineNumber, endLineNumber) {\n        if (!this._tokenizationSupport) {\n            // nothing to do\n            return;\n        }\n        if (endLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n            // nothing to do\n            return;\n        }\n        if (startLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n            // tokenization has reached the viewport start...\n            this._updateTokensUntilLine(builder, endLineNumber);\n            return;\n        }\n        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(startLineNumber);\n        const fakeLines = [];\n        let initialState = null;\n        for (let i = startLineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n            const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n            if (newNonWhitespaceIndex === 0) {\n                continue;\n            }\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n                initialState = this._tokenizationStateStore.getBeginState(i - 1);\n                if (initialState) {\n                    break;\n                }\n                fakeLines.push(this._textModel.getLineContent(i));\n                nonWhitespaceColumn = newNonWhitespaceIndex;\n            }\n        }\n        if (!initialState) {\n            initialState = this._tokenizationSupport.getInitialState();\n        }\n        const languageId = this._textModel.getLanguageId();\n        let state = initialState;\n        for (let i = fakeLines.length - 1; i >= 0; i--) {\n            const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationSupport, fakeLines[i], false, state);\n            state = r.endState;\n        }\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const text = this._textModel.getLineContent(lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationSupport, text, true, state);\n            builder.add(lineNumber, r.tokens);\n            this._tokenizationStateStore.setFakeTokens(lineNumber - 1);\n            state = r.endState;\n        }\n    }\n}\nfunction initializeTokenization(textModel) {\n    const languageId = textModel.getLanguageId();\n    let tokenizationSupport = (textModel.isTooLargeForTokenization()\n        ? null\n        : TokenizationRegistry.get(languageId));\n    let initialState = null;\n    if (tokenizationSupport) {\n        try {\n            initialState = tokenizationSupport.getInitialState();\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            tokenizationSupport = null;\n        }\n    }\n    return [tokenizationSupport, initialState];\n}\nfunction safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {\n    let r = null;\n    if (tokenizationSupport) {\n        try {\n            r = tokenizationSupport.tokenize2(text, hasEOL, state.clone(), 0);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n    }\n    if (!r) {\n        r = nullTokenize2(languageIdCodec.encodeLanguageId(languageId), text, state, 0);\n    }\n    LineTokens.convertToEndOffset(r.tokens, text.length);\n    return r;\n}\n"]},"metadata":{},"sourceType":"module"}