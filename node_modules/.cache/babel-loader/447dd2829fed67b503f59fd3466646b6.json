{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { implies, expressionsAreEqualWithConstantSubstitution } from '../../contextkey/common/contextkey.js';\nexport class KeybindingResolver {\n  constructor(defaultKeybindings, overrides, log) {\n    this._log = log;\n    this._defaultKeybindings = defaultKeybindings;\n    this._defaultBoundCommands = new Map();\n\n    for (let i = 0, len = defaultKeybindings.length; i < len; i++) {\n      const command = defaultKeybindings[i].command;\n\n      if (command) {\n        this._defaultBoundCommands.set(command, true);\n      }\n    }\n\n    this._map = new Map();\n    this._lookupMap = new Map();\n    this._keybindings = KeybindingResolver.combine(defaultKeybindings, overrides);\n\n    for (let i = 0, len = this._keybindings.length; i < len; i++) {\n      let k = this._keybindings[i];\n\n      if (k.keypressParts.length === 0) {\n        // unbound\n        continue;\n      }\n\n      if (k.when && k.when.type === 0\n      /* False */\n      ) {\n        // when condition is false\n        continue;\n      } // TODO@chords\n\n\n      this._addKeyPress(k.keypressParts[0], k);\n    }\n  }\n\n  static _isTargetedForRemoval(defaultKb, keypressFirstPart, keypressChordPart, command, when) {\n    if (defaultKb.command !== command) {\n      return false;\n    } // TODO@chords\n\n\n    if (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {\n      return false;\n    } // TODO@chords\n\n\n    if (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {\n      return false;\n    }\n\n    if (when) {\n      if (!defaultKb.when) {\n        return false;\n      }\n\n      if (!expressionsAreEqualWithConstantSubstitution(when, defaultKb.when)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Looks for rules containing -command in `overrides` and removes them directly from `defaults`.\n   */\n\n\n  static combine(defaults, rawOverrides) {\n    defaults = defaults.slice(0);\n    let overrides = [];\n\n    for (const override of rawOverrides) {\n      if (!override.command || override.command.length === 0 || override.command.charAt(0) !== '-') {\n        overrides.push(override);\n        continue;\n      }\n\n      const command = override.command.substr(1); // TODO@chords\n\n      const keypressFirstPart = override.keypressParts[0];\n      const keypressChordPart = override.keypressParts[1];\n      const when = override.when;\n\n      for (let j = defaults.length - 1; j >= 0; j--) {\n        if (this._isTargetedForRemoval(defaults[j], keypressFirstPart, keypressChordPart, command, when)) {\n          defaults.splice(j, 1);\n        }\n      }\n    }\n\n    return defaults.concat(overrides);\n  }\n\n  _addKeyPress(keypress, item) {\n    const conflicts = this._map.get(keypress);\n\n    if (typeof conflicts === 'undefined') {\n      // There is no conflict so far\n      this._map.set(keypress, [item]);\n\n      this._addToLookupMap(item);\n\n      return;\n    }\n\n    for (let i = conflicts.length - 1; i >= 0; i--) {\n      let conflict = conflicts[i];\n\n      if (conflict.command === item.command) {\n        continue;\n      }\n\n      const conflictIsChord = conflict.keypressParts.length > 1;\n      const itemIsChord = item.keypressParts.length > 1; // TODO@chords\n\n      if (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {\n        // The conflict only shares the chord start with this command\n        continue;\n      }\n\n      if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n        // `item` completely overwrites `conflict`\n        // Remove conflict from the lookupMap\n        this._removeFromLookupMap(conflict);\n      }\n    }\n\n    conflicts.push(item);\n\n    this._addToLookupMap(item);\n  }\n\n  _addToLookupMap(item) {\n    if (!item.command) {\n      return;\n    }\n\n    let arr = this._lookupMap.get(item.command);\n\n    if (typeof arr === 'undefined') {\n      arr = [item];\n\n      this._lookupMap.set(item.command, arr);\n    } else {\n      arr.push(item);\n    }\n  }\n\n  _removeFromLookupMap(item) {\n    if (!item.command) {\n      return;\n    }\n\n    let arr = this._lookupMap.get(item.command);\n\n    if (typeof arr === 'undefined') {\n      return;\n    }\n\n    for (let i = 0, len = arr.length; i < len; i++) {\n      if (arr[i] === item) {\n        arr.splice(i, 1);\n        return;\n      }\n    }\n  }\n  /**\n   * Returns true if it is provable `a` implies `b`.\n   */\n\n\n  static whenIsEntirelyIncluded(a, b) {\n    if (!b || b.type === 1\n    /* True */\n    ) {\n      return true;\n    }\n\n    if (!a || a.type === 1\n    /* True */\n    ) {\n      return false;\n    }\n\n    return implies(a, b);\n  }\n\n  getKeybindings() {\n    return this._keybindings;\n  }\n\n  lookupPrimaryKeybinding(commandId, context) {\n    const items = this._lookupMap.get(commandId);\n\n    if (typeof items === 'undefined' || items.length === 0) {\n      return null;\n    }\n\n    if (items.length === 1) {\n      return items[0];\n    }\n\n    for (let i = items.length - 1; i >= 0; i--) {\n      const item = items[i];\n\n      if (context.contextMatchesRules(item.when)) {\n        return item;\n      }\n    }\n\n    return items[items.length - 1];\n  }\n\n  resolve(context, currentChord, keypress) {\n    this._log(`| Resolving ${keypress}${currentChord ? ` chorded from ${currentChord}` : ``}`);\n\n    let lookupMap = null;\n\n    if (currentChord !== null) {\n      // Fetch all chord bindings for `currentChord`\n      const candidates = this._map.get(currentChord);\n\n      if (typeof candidates === 'undefined') {\n        // No chords starting with `currentChord`\n        this._log(`\\\\ No keybinding entries.`);\n\n        return null;\n      }\n\n      lookupMap = [];\n\n      for (let i = 0, len = candidates.length; i < len; i++) {\n        let candidate = candidates[i]; // TODO@chords\n\n        if (candidate.keypressParts[1] === keypress) {\n          lookupMap.push(candidate);\n        }\n      }\n    } else {\n      const candidates = this._map.get(keypress);\n\n      if (typeof candidates === 'undefined') {\n        // No bindings with `keypress`\n        this._log(`\\\\ No keybinding entries.`);\n\n        return null;\n      }\n\n      lookupMap = candidates;\n    }\n\n    let result = this._findCommand(context, lookupMap);\n\n    if (!result) {\n      this._log(`\\\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`);\n\n      return null;\n    } // TODO@chords\n\n\n    if (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {\n      this._log(`\\\\ From ${lookupMap.length} keybinding entries, matched chord, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n\n      return {\n        enterChord: true,\n        leaveChord: false,\n        commandId: null,\n        commandArgs: null,\n        bubble: false\n      };\n    }\n\n    this._log(`\\\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n\n    return {\n      enterChord: false,\n      leaveChord: result.keypressParts.length > 1,\n      commandId: result.command,\n      commandArgs: result.commandArgs,\n      bubble: result.bubble\n    };\n  }\n\n  _findCommand(context, matches) {\n    for (let i = matches.length - 1; i >= 0; i--) {\n      let k = matches[i];\n\n      if (!KeybindingResolver.contextMatchesRules(context, k.when)) {\n        continue;\n      }\n\n      return k;\n    }\n\n    return null;\n  }\n\n  static contextMatchesRules(context, rules) {\n    if (!rules) {\n      return true;\n    }\n\n    return rules.evaluate(context);\n  }\n\n}\n\nfunction printWhenExplanation(when) {\n  if (!when) {\n    return `no when condition`;\n  }\n\n  return `${when.serialize()}`;\n}\n\nfunction printSourceExplanation(kb) {\n  return kb.extensionId ? kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}` : kb.isDefault ? `built-in` : `user`;\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingResolver.js"],"names":["implies","expressionsAreEqualWithConstantSubstitution","KeybindingResolver","constructor","defaultKeybindings","overrides","log","_log","_defaultKeybindings","_defaultBoundCommands","Map","i","len","length","command","set","_map","_lookupMap","_keybindings","combine","k","keypressParts","when","type","_addKeyPress","_isTargetedForRemoval","defaultKb","keypressFirstPart","keypressChordPart","defaults","rawOverrides","slice","override","charAt","push","substr","j","splice","concat","keypress","item","conflicts","get","_addToLookupMap","conflict","conflictIsChord","itemIsChord","whenIsEntirelyIncluded","_removeFromLookupMap","arr","a","b","getKeybindings","lookupPrimaryKeybinding","commandId","context","items","contextMatchesRules","resolve","currentChord","lookupMap","candidates","candidate","result","_findCommand","printWhenExplanation","printSourceExplanation","enterChord","leaveChord","commandArgs","bubble","matches","rules","evaluate","serialize","kb","extensionId","isBuiltinExtension","isDefault"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { implies, expressionsAreEqualWithConstantSubstitution } from '../../contextkey/common/contextkey.js';\nexport class KeybindingResolver {\n    constructor(defaultKeybindings, overrides, log) {\n        this._log = log;\n        this._defaultKeybindings = defaultKeybindings;\n        this._defaultBoundCommands = new Map();\n        for (let i = 0, len = defaultKeybindings.length; i < len; i++) {\n            const command = defaultKeybindings[i].command;\n            if (command) {\n                this._defaultBoundCommands.set(command, true);\n            }\n        }\n        this._map = new Map();\n        this._lookupMap = new Map();\n        this._keybindings = KeybindingResolver.combine(defaultKeybindings, overrides);\n        for (let i = 0, len = this._keybindings.length; i < len; i++) {\n            let k = this._keybindings[i];\n            if (k.keypressParts.length === 0) {\n                // unbound\n                continue;\n            }\n            if (k.when && k.when.type === 0 /* False */) {\n                // when condition is false\n                continue;\n            }\n            // TODO@chords\n            this._addKeyPress(k.keypressParts[0], k);\n        }\n    }\n    static _isTargetedForRemoval(defaultKb, keypressFirstPart, keypressChordPart, command, when) {\n        if (defaultKb.command !== command) {\n            return false;\n        }\n        // TODO@chords\n        if (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {\n            return false;\n        }\n        // TODO@chords\n        if (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {\n            return false;\n        }\n        if (when) {\n            if (!defaultKb.when) {\n                return false;\n            }\n            if (!expressionsAreEqualWithConstantSubstitution(when, defaultKb.when)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Looks for rules containing -command in `overrides` and removes them directly from `defaults`.\n     */\n    static combine(defaults, rawOverrides) {\n        defaults = defaults.slice(0);\n        let overrides = [];\n        for (const override of rawOverrides) {\n            if (!override.command || override.command.length === 0 || override.command.charAt(0) !== '-') {\n                overrides.push(override);\n                continue;\n            }\n            const command = override.command.substr(1);\n            // TODO@chords\n            const keypressFirstPart = override.keypressParts[0];\n            const keypressChordPart = override.keypressParts[1];\n            const when = override.when;\n            for (let j = defaults.length - 1; j >= 0; j--) {\n                if (this._isTargetedForRemoval(defaults[j], keypressFirstPart, keypressChordPart, command, when)) {\n                    defaults.splice(j, 1);\n                }\n            }\n        }\n        return defaults.concat(overrides);\n    }\n    _addKeyPress(keypress, item) {\n        const conflicts = this._map.get(keypress);\n        if (typeof conflicts === 'undefined') {\n            // There is no conflict so far\n            this._map.set(keypress, [item]);\n            this._addToLookupMap(item);\n            return;\n        }\n        for (let i = conflicts.length - 1; i >= 0; i--) {\n            let conflict = conflicts[i];\n            if (conflict.command === item.command) {\n                continue;\n            }\n            const conflictIsChord = (conflict.keypressParts.length > 1);\n            const itemIsChord = (item.keypressParts.length > 1);\n            // TODO@chords\n            if (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {\n                // The conflict only shares the chord start with this command\n                continue;\n            }\n            if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n                // `item` completely overwrites `conflict`\n                // Remove conflict from the lookupMap\n                this._removeFromLookupMap(conflict);\n            }\n        }\n        conflicts.push(item);\n        this._addToLookupMap(item);\n    }\n    _addToLookupMap(item) {\n        if (!item.command) {\n            return;\n        }\n        let arr = this._lookupMap.get(item.command);\n        if (typeof arr === 'undefined') {\n            arr = [item];\n            this._lookupMap.set(item.command, arr);\n        }\n        else {\n            arr.push(item);\n        }\n    }\n    _removeFromLookupMap(item) {\n        if (!item.command) {\n            return;\n        }\n        let arr = this._lookupMap.get(item.command);\n        if (typeof arr === 'undefined') {\n            return;\n        }\n        for (let i = 0, len = arr.length; i < len; i++) {\n            if (arr[i] === item) {\n                arr.splice(i, 1);\n                return;\n            }\n        }\n    }\n    /**\n     * Returns true if it is provable `a` implies `b`.\n     */\n    static whenIsEntirelyIncluded(a, b) {\n        if (!b || b.type === 1 /* True */) {\n            return true;\n        }\n        if (!a || a.type === 1 /* True */) {\n            return false;\n        }\n        return implies(a, b);\n    }\n    getKeybindings() {\n        return this._keybindings;\n    }\n    lookupPrimaryKeybinding(commandId, context) {\n        const items = this._lookupMap.get(commandId);\n        if (typeof items === 'undefined' || items.length === 0) {\n            return null;\n        }\n        if (items.length === 1) {\n            return items[0];\n        }\n        for (let i = items.length - 1; i >= 0; i--) {\n            const item = items[i];\n            if (context.contextMatchesRules(item.when)) {\n                return item;\n            }\n        }\n        return items[items.length - 1];\n    }\n    resolve(context, currentChord, keypress) {\n        this._log(`| Resolving ${keypress}${currentChord ? ` chorded from ${currentChord}` : ``}`);\n        let lookupMap = null;\n        if (currentChord !== null) {\n            // Fetch all chord bindings for `currentChord`\n            const candidates = this._map.get(currentChord);\n            if (typeof candidates === 'undefined') {\n                // No chords starting with `currentChord`\n                this._log(`\\\\ No keybinding entries.`);\n                return null;\n            }\n            lookupMap = [];\n            for (let i = 0, len = candidates.length; i < len; i++) {\n                let candidate = candidates[i];\n                // TODO@chords\n                if (candidate.keypressParts[1] === keypress) {\n                    lookupMap.push(candidate);\n                }\n            }\n        }\n        else {\n            const candidates = this._map.get(keypress);\n            if (typeof candidates === 'undefined') {\n                // No bindings with `keypress`\n                this._log(`\\\\ No keybinding entries.`);\n                return null;\n            }\n            lookupMap = candidates;\n        }\n        let result = this._findCommand(context, lookupMap);\n        if (!result) {\n            this._log(`\\\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`);\n            return null;\n        }\n        // TODO@chords\n        if (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {\n            this._log(`\\\\ From ${lookupMap.length} keybinding entries, matched chord, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n            return {\n                enterChord: true,\n                leaveChord: false,\n                commandId: null,\n                commandArgs: null,\n                bubble: false\n            };\n        }\n        this._log(`\\\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n        return {\n            enterChord: false,\n            leaveChord: result.keypressParts.length > 1,\n            commandId: result.command,\n            commandArgs: result.commandArgs,\n            bubble: result.bubble\n        };\n    }\n    _findCommand(context, matches) {\n        for (let i = matches.length - 1; i >= 0; i--) {\n            let k = matches[i];\n            if (!KeybindingResolver.contextMatchesRules(context, k.when)) {\n                continue;\n            }\n            return k;\n        }\n        return null;\n    }\n    static contextMatchesRules(context, rules) {\n        if (!rules) {\n            return true;\n        }\n        return rules.evaluate(context);\n    }\n}\nfunction printWhenExplanation(when) {\n    if (!when) {\n        return `no when condition`;\n    }\n    return `${when.serialize()}`;\n}\nfunction printSourceExplanation(kb) {\n    return (kb.extensionId\n        ? (kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}`)\n        : (kb.isDefault ? `built-in` : `user`));\n}\n"]},"metadata":{},"sourceType":"module"}