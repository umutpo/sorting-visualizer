{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isThenable } from './async.js';\nimport * as extpath from './extpath.js';\nimport { LRUCache } from './map.js';\nimport * as paths from './path.js';\nimport * as strings from './strings.js';\nconst GLOBSTAR = '**';\nconst GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\n\nconst NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\n\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount) {\n  switch (starCount) {\n    case 0:\n      return '';\n\n    case 1:\n      return `${NO_PATH_REGEX}*?`;\n    // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\n    default:\n      // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n      // Group is non capturing because we don't need to capture at all (?:...)\n      // Overall we use non-greedy matching because it could be that we match too much\n      return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}|${PATH_REGEX}${NO_PATH_REGEX}+)*?`;\n  }\n}\n\nexport function splitGlobAware(pattern, splitChar) {\n  if (!pattern) {\n    return [];\n  }\n\n  const segments = [];\n  let inBraces = false;\n  let inBrackets = false;\n  let curVal = '';\n\n  for (const char of pattern) {\n    switch (char) {\n      case splitChar:\n        if (!inBraces && !inBrackets) {\n          segments.push(curVal);\n          curVal = '';\n          continue;\n        }\n\n        break;\n\n      case '{':\n        inBraces = true;\n        break;\n\n      case '}':\n        inBraces = false;\n        break;\n\n      case '[':\n        inBrackets = true;\n        break;\n\n      case ']':\n        inBrackets = false;\n        break;\n    }\n\n    curVal += char;\n  } // Tail\n\n\n  if (curVal) {\n    segments.push(curVal);\n  }\n\n  return segments;\n}\n\nfunction parseRegExp(pattern) {\n  if (!pattern) {\n    return '';\n  }\n\n  let regEx = ''; // Split up into segments for each slash found\n\n  const segments = splitGlobAware(pattern, GLOB_SPLIT); // Special case where we only have globstars\n\n  if (segments.every(s => s === GLOBSTAR)) {\n    regEx = '.*';\n  } // Build regex over segments\n  else {\n    let previousSegmentWasGlobStar = false;\n    segments.forEach((segment, index) => {\n      // Globstar is special\n      if (segment === GLOBSTAR) {\n        // if we have more than one globstar after another, just ignore it\n        if (!previousSegmentWasGlobStar) {\n          regEx += starsToRegExp(2);\n          previousSegmentWasGlobStar = true;\n        }\n\n        return;\n      } // States\n\n\n      let inBraces = false;\n      let braceVal = '';\n      let inBrackets = false;\n      let bracketVal = '';\n\n      for (const char of segment) {\n        // Support brace expansion\n        if (char !== '}' && inBraces) {\n          braceVal += char;\n          continue;\n        } // Support brackets\n\n\n        if (inBrackets && (char !== ']' || !bracketVal)\n        /* ] is literally only allowed as first character in brackets to match it */\n        ) {\n          let res; // range operator\n\n          if (char === '-') {\n            res = char;\n          } // negation operator (only valid on first index in bracket)\n          else if ((char === '^' || char === '!') && !bracketVal) {\n            res = '^';\n          } // glob split matching is not allowed within character ranges\n          // see http://man7.org/linux/man-pages/man7/glob.7.html\n          else if (char === GLOB_SPLIT) {\n            res = '';\n          } // anything else gets escaped\n          else {\n            res = strings.escapeRegExpCharacters(char);\n          }\n\n          bracketVal += res;\n          continue;\n        }\n\n        switch (char) {\n          case '{':\n            inBraces = true;\n            continue;\n\n          case '[':\n            inBrackets = true;\n            continue;\n\n          case '}':\n            const choices = splitGlobAware(braceVal, ','); // Converts {foo,bar} => [foo|bar]\n\n            const braceRegExp = `(?:${choices.map(c => parseRegExp(c)).join('|')})`;\n            regEx += braceRegExp;\n            inBraces = false;\n            braceVal = '';\n            break;\n\n          case ']':\n            regEx += '[' + bracketVal + ']';\n            inBrackets = false;\n            bracketVal = '';\n            break;\n\n          case '?':\n            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\n            continue;\n\n          case '*':\n            regEx += starsToRegExp(1);\n            continue;\n\n          default:\n            regEx += strings.escapeRegExpCharacters(char);\n        }\n      } // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n      // For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n      // a folder called \"something\" to match as well.\n      // However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n      // is to match 0-N segments.\n\n\n      if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n        regEx += PATH_REGEX;\n      } // reset state\n\n\n      previousSegmentWasGlobStar = false;\n    });\n  }\n\n  return regEx;\n} // regexes to check for trivial glob patterns that just check for String#endsWith\n\n\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\n\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\n\nconst T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\n\nconst T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\n\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\n\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\n\nconst CACHE = new LRUCache(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n  return false;\n};\n\nconst NULL = function () {\n  return null;\n};\n\nfunction parsePattern(arg1, options) {\n  if (!arg1) {\n    return NULL;\n  } // Handle IRelativePattern\n\n\n  let pattern;\n\n  if (typeof arg1 !== 'string') {\n    pattern = arg1.pattern;\n  } else {\n    pattern = arg1;\n  } // Whitespace trimming\n\n\n  pattern = pattern.trim(); // Check cache\n\n  const patternKey = `${pattern}_${!!options.trimForExclusions}`;\n  let parsedPattern = CACHE.get(patternKey);\n\n  if (parsedPattern) {\n    return wrapRelativePattern(parsedPattern, arg1);\n  } // Check for Trivials\n\n\n  let match;\n\n  if (T1.test(pattern)) {\n    // common pattern: **/*.txt just need endsWith check\n    const base = pattern.substr(4); // '**/*'.length === 4\n\n    parsedPattern = function (path, basename) {\n      return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n    };\n  } else if (match = T2.exec(trimForExclusions(pattern, options))) {\n    // common pattern: **/some.txt just need basename check\n    parsedPattern = trivia2(match[1], pattern);\n  } else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) {\n    // repetition of common patterns (see above) {**/*.txt,**/*.png}\n    parsedPattern = trivia3(pattern, options);\n  } else if (match = T4.exec(trimForExclusions(pattern, options))) {\n    // common pattern: **/something/else just need endsWith check\n    parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n  } else if (match = T5.exec(trimForExclusions(pattern, options))) {\n    // common pattern: something/else just need equals check\n    parsedPattern = trivia4and5(match[1], pattern, false);\n  } // Otherwise convert to pattern\n  else {\n    parsedPattern = toRegExp(pattern);\n  } // Cache\n\n\n  CACHE.set(patternKey, parsedPattern);\n  return wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern, arg2) {\n  if (typeof arg2 === 'string') {\n    return parsedPattern;\n  }\n\n  return function (path, basename) {\n    if (!extpath.isEqualOrParent(path, arg2.base)) {\n      return null;\n    }\n\n    return parsedPattern(paths.relative(arg2.base, path), basename);\n  };\n}\n\nfunction trimForExclusions(pattern, options) {\n  return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n} // common pattern: **/some.txt just need basename check\n\n\nfunction trivia2(base, originalPattern) {\n  const slashBase = `/${base}`;\n  const backslashBase = `\\\\${base}`;\n\n  const parsedPattern = function (path, basename) {\n    if (typeof path !== 'string') {\n      return null;\n    }\n\n    if (basename) {\n      return basename === base ? originalPattern : null;\n    }\n\n    return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? originalPattern : null;\n  };\n\n  const basenames = [base];\n  parsedPattern.basenames = basenames;\n  parsedPattern.patterns = [originalPattern];\n  parsedPattern.allBasenames = basenames;\n  return parsedPattern;\n} // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\n\nfunction trivia3(pattern, options) {\n  const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',').map(pattern => parsePattern(pattern, options)).filter(pattern => pattern !== NULL), pattern);\n  const n = parsedPatterns.length;\n\n  if (!n) {\n    return NULL;\n  }\n\n  if (n === 1) {\n    return parsedPatterns[0];\n  }\n\n  const parsedPattern = function (path, basename) {\n    for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n      if (parsedPatterns[i](path, basename)) {\n        return pattern;\n      }\n    }\n\n    return null;\n  };\n\n  const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\n  if (withBasenames) {\n    parsedPattern.allBasenames = withBasenames.allBasenames;\n  }\n\n  const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n\n  if (allPaths.length) {\n    parsedPattern.allPaths = allPaths;\n  }\n\n  return parsedPattern;\n} // common patterns: **/something/else just need endsWith check, something/else just needs and equals check\n\n\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n  const usingPosixSep = paths.sep === paths.posix.sep;\n  const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, paths.sep);\n  const nativePathEnd = paths.sep + nativePath;\n  const targetPathEnd = paths.posix.sep + targetPath;\n  const parsedPattern = matchPathEnds ? function (testPath, basename) {\n    return typeof testPath === 'string' && (testPath === nativePath || testPath.endsWith(nativePathEnd) || !usingPosixSep && (testPath === targetPath || testPath.endsWith(targetPathEnd))) ? pattern : null;\n  } : function (testPath, basename) {\n    return typeof testPath === 'string' && (testPath === nativePath || !usingPosixSep && testPath === targetPath) ? pattern : null;\n  };\n  parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n  return parsedPattern;\n}\n\nfunction toRegExp(pattern) {\n  try {\n    const regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n    return function (path) {\n      regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\n      return typeof path === 'string' && regExp.test(path) ? pattern : null;\n    };\n  } catch (error) {\n    return NULL;\n  }\n}\n\nexport function match(arg1, path, hasSibling) {\n  if (!arg1 || typeof path !== 'string') {\n    return false;\n  }\n\n  return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!arg1) {\n    return FALSE;\n  } // Glob with String\n\n\n  if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n    const parsedPattern = parsePattern(arg1, options);\n\n    if (parsedPattern === NULL) {\n      return FALSE;\n    }\n\n    const resultPattern = function (path, basename) {\n      return !!parsedPattern(path, basename);\n    };\n\n    if (parsedPattern.allBasenames) {\n      resultPattern.allBasenames = parsedPattern.allBasenames;\n    }\n\n    if (parsedPattern.allPaths) {\n      resultPattern.allPaths = parsedPattern.allPaths;\n    }\n\n    return resultPattern;\n  } // Glob with Expression\n\n\n  return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n  const rp = obj;\n  return rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nfunction parsedExpression(expression, options) {\n  const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression).map(pattern => parseExpressionPattern(pattern, expression[pattern], options)).filter(pattern => pattern !== NULL));\n  const n = parsedPatterns.length;\n\n  if (!n) {\n    return NULL;\n  }\n\n  if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {\n    if (n === 1) {\n      return parsedPatterns[0];\n    }\n\n    const resultExpression = function (path, basename) {\n      for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n        // Pattern matches path\n        const result = parsedPatterns[i](path, basename);\n\n        if (result) {\n          return result;\n        }\n      }\n\n      return null;\n    };\n\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\n    if (withBasenames) {\n      resultExpression.allBasenames = withBasenames.allBasenames;\n    }\n\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n\n    if (allPaths.length) {\n      resultExpression.allPaths = allPaths;\n    }\n\n    return resultExpression;\n  }\n\n  const resultExpression = function (path, basename, hasSibling) {\n    let name = undefined;\n\n    for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n      // Pattern matches path\n      const parsedPattern = parsedPatterns[i];\n\n      if (parsedPattern.requiresSiblings && hasSibling) {\n        if (!basename) {\n          basename = paths.basename(path);\n        }\n\n        if (!name) {\n          name = basename.substr(0, basename.length - paths.extname(path).length);\n        }\n      }\n\n      const result = parsedPattern(path, basename, name, hasSibling);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  };\n\n  const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\n  if (withBasenames) {\n    resultExpression.allBasenames = withBasenames.allBasenames;\n  }\n\n  const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n\n  if (allPaths.length) {\n    resultExpression.allPaths = allPaths;\n  }\n\n  return resultExpression;\n}\n\nfunction parseExpressionPattern(pattern, value, options) {\n  if (value === false) {\n    return NULL; // pattern is disabled\n  }\n\n  const parsedPattern = parsePattern(pattern, options);\n\n  if (parsedPattern === NULL) {\n    return NULL;\n  } // Expression Pattern is <boolean>\n\n\n  if (typeof value === 'boolean') {\n    return parsedPattern;\n  } // Expression Pattern is <SiblingClause>\n\n\n  if (value) {\n    const when = value.when;\n\n    if (typeof when === 'string') {\n      const result = (path, basename, name, hasSibling) => {\n        if (!hasSibling || !parsedPattern(path, basename)) {\n          return null;\n        }\n\n        const clausePattern = when.replace('$(basename)', name);\n        const matched = hasSibling(clausePattern);\n        return isThenable(matched) ? matched.then(m => m ? pattern : null) : matched ? pattern : null;\n      };\n\n      result.requiresSiblings = true;\n      return result;\n    }\n  } // Expression is Anything\n\n\n  return parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n  const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\n\n  if (basenamePatterns.length < 2) {\n    return parsedPatterns;\n  }\n\n  const basenames = basenamePatterns.reduce((all, current) => {\n    const basenames = current.basenames;\n    return basenames ? all.concat(basenames) : all;\n  }, []);\n  let patterns;\n\n  if (result) {\n    patterns = [];\n\n    for (let i = 0, n = basenames.length; i < n; i++) {\n      patterns.push(result);\n    }\n  } else {\n    patterns = basenamePatterns.reduce((all, current) => {\n      const patterns = current.patterns;\n      return patterns ? all.concat(patterns) : all;\n    }, []);\n  }\n\n  const aggregate = function (path, basename) {\n    if (typeof path !== 'string') {\n      return null;\n    }\n\n    if (!basename) {\n      let i;\n\n      for (i = path.length; i > 0; i--) {\n        const ch = path.charCodeAt(i - 1);\n\n        if (ch === 47\n        /* Slash */\n        || ch === 92\n        /* Backslash */\n        ) {\n          break;\n        }\n      }\n\n      basename = path.substr(i);\n    }\n\n    const index = basenames.indexOf(basename);\n    return index !== -1 ? patterns[index] : null;\n  };\n\n  aggregate.basenames = basenames;\n  aggregate.patterns = patterns;\n  aggregate.allBasenames = basenames;\n  const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\n  aggregatedPatterns.push(aggregate);\n  return aggregatedPatterns;\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/base/common/glob.js"],"names":["isThenable","extpath","LRUCache","paths","strings","GLOBSTAR","GLOB_SPLIT","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","splitGlobAware","pattern","splitChar","segments","inBraces","inBrackets","curVal","char","push","parseRegExp","regEx","every","s","previousSegmentWasGlobStar","forEach","segment","index","braceVal","bracketVal","res","escapeRegExpCharacters","choices","braceRegExp","map","c","join","length","T1","T2","T3","T3_2","T4","T5","CACHE","FALSE","NULL","parsePattern","arg1","options","trim","patternKey","trimForExclusions","parsedPattern","get","wrapRelativePattern","match","test","base","substr","path","basename","endsWith","exec","trivia2","trivia3","trivia4and5","toRegExp","set","arg2","isEqualOrParent","relative","originalPattern","slashBase","backslashBase","basenames","patterns","allBasenames","parsedPatterns","aggregateBasenameMatches","slice","split","filter","n","i","withBasenames","find","allPaths","reduce","all","current","concat","targetPath","matchPathEnds","usingPosixSep","sep","posix","nativePath","replace","nativePathEnd","targetPathEnd","testPath","regExp","RegExp","lastIndex","error","hasSibling","parse","undefined","isRelativePattern","resultPattern","parsedExpression","obj","rp","expression","Object","getOwnPropertyNames","parseExpressionPattern","some","requiresSiblings","resultExpression","result","name","extname","value","when","clausePattern","matched","then","m","basenamePatterns","aggregate","ch","charCodeAt","indexOf","aggregatedPatterns"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isThenable } from './async.js';\nimport * as extpath from './extpath.js';\nimport { LRUCache } from './map.js';\nimport * as paths from './path.js';\nimport * as strings from './strings.js';\nconst GLOBSTAR = '**';\nconst GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\nfunction starsToRegExp(starCount) {\n    switch (starCount) {\n        case 0:\n            return '';\n        case 1:\n            return `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n        default:\n            // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n            // Group is non capturing because we don't need to capture at all (?:...)\n            // Overall we use non-greedy matching because it could be that we match too much\n            return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}|${PATH_REGEX}${NO_PATH_REGEX}+)*?`;\n    }\n}\nexport function splitGlobAware(pattern, splitChar) {\n    if (!pattern) {\n        return [];\n    }\n    const segments = [];\n    let inBraces = false;\n    let inBrackets = false;\n    let curVal = '';\n    for (const char of pattern) {\n        switch (char) {\n            case splitChar:\n                if (!inBraces && !inBrackets) {\n                    segments.push(curVal);\n                    curVal = '';\n                    continue;\n                }\n                break;\n            case '{':\n                inBraces = true;\n                break;\n            case '}':\n                inBraces = false;\n                break;\n            case '[':\n                inBrackets = true;\n                break;\n            case ']':\n                inBrackets = false;\n                break;\n        }\n        curVal += char;\n    }\n    // Tail\n    if (curVal) {\n        segments.push(curVal);\n    }\n    return segments;\n}\nfunction parseRegExp(pattern) {\n    if (!pattern) {\n        return '';\n    }\n    let regEx = '';\n    // Split up into segments for each slash found\n    const segments = splitGlobAware(pattern, GLOB_SPLIT);\n    // Special case where we only have globstars\n    if (segments.every(s => s === GLOBSTAR)) {\n        regEx = '.*';\n    }\n    // Build regex over segments\n    else {\n        let previousSegmentWasGlobStar = false;\n        segments.forEach((segment, index) => {\n            // Globstar is special\n            if (segment === GLOBSTAR) {\n                // if we have more than one globstar after another, just ignore it\n                if (!previousSegmentWasGlobStar) {\n                    regEx += starsToRegExp(2);\n                    previousSegmentWasGlobStar = true;\n                }\n                return;\n            }\n            // States\n            let inBraces = false;\n            let braceVal = '';\n            let inBrackets = false;\n            let bracketVal = '';\n            for (const char of segment) {\n                // Support brace expansion\n                if (char !== '}' && inBraces) {\n                    braceVal += char;\n                    continue;\n                }\n                // Support brackets\n                if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n                    let res;\n                    // range operator\n                    if (char === '-') {\n                        res = char;\n                    }\n                    // negation operator (only valid on first index in bracket)\n                    else if ((char === '^' || char === '!') && !bracketVal) {\n                        res = '^';\n                    }\n                    // glob split matching is not allowed within character ranges\n                    // see http://man7.org/linux/man-pages/man7/glob.7.html\n                    else if (char === GLOB_SPLIT) {\n                        res = '';\n                    }\n                    // anything else gets escaped\n                    else {\n                        res = strings.escapeRegExpCharacters(char);\n                    }\n                    bracketVal += res;\n                    continue;\n                }\n                switch (char) {\n                    case '{':\n                        inBraces = true;\n                        continue;\n                    case '[':\n                        inBrackets = true;\n                        continue;\n                    case '}':\n                        const choices = splitGlobAware(braceVal, ',');\n                        // Converts {foo,bar} => [foo|bar]\n                        const braceRegExp = `(?:${choices.map(c => parseRegExp(c)).join('|')})`;\n                        regEx += braceRegExp;\n                        inBraces = false;\n                        braceVal = '';\n                        break;\n                    case ']':\n                        regEx += ('[' + bracketVal + ']');\n                        inBrackets = false;\n                        bracketVal = '';\n                        break;\n                    case '?':\n                        regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n                        continue;\n                    case '*':\n                        regEx += starsToRegExp(1);\n                        continue;\n                    default:\n                        regEx += strings.escapeRegExpCharacters(char);\n                }\n            }\n            // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n            // For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n            // a folder called \"something\" to match as well.\n            // However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n            // is to match 0-N segments.\n            if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n                regEx += PATH_REGEX;\n            }\n            // reset state\n            previousSegmentWasGlobStar = false;\n        });\n    }\n    return regEx;\n}\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\nconst T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\nconst CACHE = new LRUCache(10000); // bounded to 10000 elements\nconst FALSE = function () {\n    return false;\n};\nconst NULL = function () {\n    return null;\n};\nfunction parsePattern(arg1, options) {\n    if (!arg1) {\n        return NULL;\n    }\n    // Handle IRelativePattern\n    let pattern;\n    if (typeof arg1 !== 'string') {\n        pattern = arg1.pattern;\n    }\n    else {\n        pattern = arg1;\n    }\n    // Whitespace trimming\n    pattern = pattern.trim();\n    // Check cache\n    const patternKey = `${pattern}_${!!options.trimForExclusions}`;\n    let parsedPattern = CACHE.get(patternKey);\n    if (parsedPattern) {\n        return wrapRelativePattern(parsedPattern, arg1);\n    }\n    // Check for Trivials\n    let match;\n    if (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check\n        const base = pattern.substr(4); // '**/*'.length === 4\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n        };\n    }\n    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n        parsedPattern = trivia2(match[1], pattern);\n    }\n    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n        parsedPattern = trivia3(pattern, options);\n    }\n    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n    }\n    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n        parsedPattern = trivia4and5(match[1], pattern, false);\n    }\n    // Otherwise convert to pattern\n    else {\n        parsedPattern = toRegExp(pattern);\n    }\n    // Cache\n    CACHE.set(patternKey, parsedPattern);\n    return wrapRelativePattern(parsedPattern, arg1);\n}\nfunction wrapRelativePattern(parsedPattern, arg2) {\n    if (typeof arg2 === 'string') {\n        return parsedPattern;\n    }\n    return function (path, basename) {\n        if (!extpath.isEqualOrParent(path, arg2.base)) {\n            return null;\n        }\n        return parsedPattern(paths.relative(arg2.base, path), basename);\n    };\n}\nfunction trimForExclusions(pattern, options) {\n    return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base, originalPattern) {\n    const slashBase = `/${base}`;\n    const backslashBase = `\\\\${base}`;\n    const parsedPattern = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (basename) {\n            return basename === base ? originalPattern : null;\n        }\n        return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? originalPattern : null;\n    };\n    const basenames = [base];\n    parsedPattern.basenames = basenames;\n    parsedPattern.patterns = [originalPattern];\n    parsedPattern.allBasenames = basenames;\n    return parsedPattern;\n}\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern, options) {\n    const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')\n        .map(pattern => parsePattern(pattern, options))\n        .filter(pattern => pattern !== NULL), pattern);\n    const n = parsedPatterns.length;\n    if (!n) {\n        return NULL;\n    }\n    if (n === 1) {\n        return parsedPatterns[0];\n    }\n    const parsedPattern = function (path, basename) {\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            if (parsedPatterns[i](path, basename)) {\n                return pattern;\n            }\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        parsedPattern.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        parsedPattern.allPaths = allPaths;\n    }\n    return parsedPattern;\n}\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n    const usingPosixSep = paths.sep === paths.posix.sep;\n    const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, paths.sep);\n    const nativePathEnd = paths.sep + nativePath;\n    const targetPathEnd = paths.posix.sep + targetPath;\n    const parsedPattern = matchPathEnds ? function (testPath, basename) {\n        return typeof testPath === 'string' &&\n            ((testPath === nativePath || testPath.endsWith(nativePathEnd))\n                || !usingPosixSep && (testPath === targetPath || testPath.endsWith(targetPathEnd)))\n            ? pattern : null;\n    } : function (testPath, basename) {\n        return typeof testPath === 'string' &&\n            (testPath === nativePath\n                || (!usingPosixSep && testPath === targetPath))\n            ? pattern : null;\n    };\n    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n    return parsedPattern;\n}\nfunction toRegExp(pattern) {\n    try {\n        const regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n        return function (path) {\n            regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n            return typeof path === 'string' && regExp.test(path) ? pattern : null;\n        };\n    }\n    catch (error) {\n        return NULL;\n    }\n}\nexport function match(arg1, path, hasSibling) {\n    if (!arg1 || typeof path !== 'string') {\n        return false;\n    }\n    return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1, options = {}) {\n    if (!arg1) {\n        return FALSE;\n    }\n    // Glob with String\n    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n        const parsedPattern = parsePattern(arg1, options);\n        if (parsedPattern === NULL) {\n            return FALSE;\n        }\n        const resultPattern = function (path, basename) {\n            return !!parsedPattern(path, basename);\n        };\n        if (parsedPattern.allBasenames) {\n            resultPattern.allBasenames = parsedPattern.allBasenames;\n        }\n        if (parsedPattern.allPaths) {\n            resultPattern.allPaths = parsedPattern.allPaths;\n        }\n        return resultPattern;\n    }\n    // Glob with Expression\n    return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n    const rp = obj;\n    return rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\nfunction parsedExpression(expression, options) {\n    const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n        .map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n        .filter(pattern => pattern !== NULL));\n    const n = parsedPatterns.length;\n    if (!n) {\n        return NULL;\n    }\n    if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {\n        if (n === 1) {\n            return parsedPatterns[0];\n        }\n        const resultExpression = function (path, basename) {\n            for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n                // Pattern matches path\n                const result = parsedPatterns[i](path, basename);\n                if (result) {\n                    return result;\n                }\n            }\n            return null;\n        };\n        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n        if (withBasenames) {\n            resultExpression.allBasenames = withBasenames.allBasenames;\n        }\n        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n        if (allPaths.length) {\n            resultExpression.allPaths = allPaths;\n        }\n        return resultExpression;\n    }\n    const resultExpression = function (path, basename, hasSibling) {\n        let name = undefined;\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            // Pattern matches path\n            const parsedPattern = parsedPatterns[i];\n            if (parsedPattern.requiresSiblings && hasSibling) {\n                if (!basename) {\n                    basename = paths.basename(path);\n                }\n                if (!name) {\n                    name = basename.substr(0, basename.length - paths.extname(path).length);\n                }\n            }\n            const result = parsedPattern(path, basename, name, hasSibling);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        resultExpression.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        resultExpression.allPaths = allPaths;\n    }\n    return resultExpression;\n}\nfunction parseExpressionPattern(pattern, value, options) {\n    if (value === false) {\n        return NULL; // pattern is disabled\n    }\n    const parsedPattern = parsePattern(pattern, options);\n    if (parsedPattern === NULL) {\n        return NULL;\n    }\n    // Expression Pattern is <boolean>\n    if (typeof value === 'boolean') {\n        return parsedPattern;\n    }\n    // Expression Pattern is <SiblingClause>\n    if (value) {\n        const when = value.when;\n        if (typeof when === 'string') {\n            const result = (path, basename, name, hasSibling) => {\n                if (!hasSibling || !parsedPattern(path, basename)) {\n                    return null;\n                }\n                const clausePattern = when.replace('$(basename)', name);\n                const matched = hasSibling(clausePattern);\n                return isThenable(matched) ?\n                    matched.then(m => m ? pattern : null) :\n                    matched ? pattern : null;\n            };\n            result.requiresSiblings = true;\n            return result;\n        }\n    }\n    // Expression is Anything\n    return parsedPattern;\n}\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\n    if (basenamePatterns.length < 2) {\n        return parsedPatterns;\n    }\n    const basenames = basenamePatterns.reduce((all, current) => {\n        const basenames = current.basenames;\n        return basenames ? all.concat(basenames) : all;\n    }, []);\n    let patterns;\n    if (result) {\n        patterns = [];\n        for (let i = 0, n = basenames.length; i < n; i++) {\n            patterns.push(result);\n        }\n    }\n    else {\n        patterns = basenamePatterns.reduce((all, current) => {\n            const patterns = current.patterns;\n            return patterns ? all.concat(patterns) : all;\n        }, []);\n    }\n    const aggregate = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (!basename) {\n            let i;\n            for (i = path.length; i > 0; i--) {\n                const ch = path.charCodeAt(i - 1);\n                if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {\n                    break;\n                }\n            }\n            basename = path.substr(i);\n        }\n        const index = basenames.indexOf(basename);\n        return index !== -1 ? patterns[index] : null;\n    };\n    aggregate.basenames = basenames;\n    aggregate.patterns = patterns;\n    aggregate.allBasenames = basenames;\n    const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\n    aggregatedPatterns.push(aggregate);\n    return aggregatedPatterns;\n}\n"]},"metadata":{},"sourceType":"module"}