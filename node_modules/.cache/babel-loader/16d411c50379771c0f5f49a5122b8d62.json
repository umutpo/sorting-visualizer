{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isLinux, isMacintosh, isWeb, isWindows, userAgent } from '../../../base/common/platform.js';\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\n\nlet _userAgent = userAgent || '';\n\nconst CONSTANT_VALUES = new Map();\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', _userAgent.indexOf('Edg/') >= 0);\nCONSTANT_VALUES.set('isFirefox', _userAgent.indexOf('Firefox') >= 0);\nCONSTANT_VALUES.set('isChrome', _userAgent.indexOf('Chrome') >= 0);\nCONSTANT_VALUES.set('isSafari', _userAgent.indexOf('Safari') >= 0);\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nexport class ContextKeyExpr {\n  static has(key) {\n    return ContextKeyDefinedExpr.create(key);\n  }\n\n  static equals(key, value) {\n    return ContextKeyEqualsExpr.create(key, value);\n  }\n\n  static regex(key, value) {\n    return ContextKeyRegexExpr.create(key, value);\n  }\n\n  static not(key) {\n    return ContextKeyNotExpr.create(key);\n  }\n\n  static and() {\n    for (var _len = arguments.length, expr = new Array(_len), _key = 0; _key < _len; _key++) {\n      expr[_key] = arguments[_key];\n    }\n\n    return ContextKeyAndExpr.create(expr, null);\n  }\n\n  static or() {\n    for (var _len2 = arguments.length, expr = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      expr[_key2] = arguments[_key2];\n    }\n\n    return ContextKeyOrExpr.create(expr, null, true);\n  }\n\n  static deserialize(serialized) {\n    let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (!serialized) {\n      return undefined;\n    }\n\n    return this._deserializeOrExpression(serialized, strict);\n  }\n\n  static _deserializeOrExpression(serialized, strict) {\n    let pieces = serialized.split('||');\n    return ContextKeyOrExpr.create(pieces.map(p => this._deserializeAndExpression(p, strict)), null, true);\n  }\n\n  static _deserializeAndExpression(serialized, strict) {\n    let pieces = serialized.split('&&');\n    return ContextKeyAndExpr.create(pieces.map(p => this._deserializeOne(p, strict)), null);\n  }\n\n  static _deserializeOne(serializedOne, strict) {\n    serializedOne = serializedOne.trim();\n\n    if (serializedOne.indexOf('!=') >= 0) {\n      let pieces = serializedOne.split('!=');\n      return ContextKeyNotEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n    }\n\n    if (serializedOne.indexOf('==') >= 0) {\n      let pieces = serializedOne.split('==');\n      return ContextKeyEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n    }\n\n    if (serializedOne.indexOf('=~') >= 0) {\n      let pieces = serializedOne.split('=~');\n      return ContextKeyRegexExpr.create(pieces[0].trim(), this._deserializeRegexValue(pieces[1], strict));\n    }\n\n    if (serializedOne.indexOf(' in ') >= 0) {\n      let pieces = serializedOne.split(' in ');\n      return ContextKeyInExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n\n    if (/^[^<=>]+>=[^<=>]+$/.test(serializedOne)) {\n      const pieces = serializedOne.split('>=');\n      return ContextKeyGreaterEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n\n    if (/^[^<=>]+>[^<=>]+$/.test(serializedOne)) {\n      const pieces = serializedOne.split('>');\n      return ContextKeyGreaterExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n\n    if (/^[^<=>]+<=[^<=>]+$/.test(serializedOne)) {\n      const pieces = serializedOne.split('<=');\n      return ContextKeySmallerEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n\n    if (/^[^<=>]+<[^<=>]+$/.test(serializedOne)) {\n      const pieces = serializedOne.split('<');\n      return ContextKeySmallerExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n\n    if (/^\\!\\s*/.test(serializedOne)) {\n      return ContextKeyNotExpr.create(serializedOne.substr(1).trim());\n    }\n\n    return ContextKeyDefinedExpr.create(serializedOne);\n  }\n\n  static _deserializeValue(serializedValue, strict) {\n    serializedValue = serializedValue.trim();\n\n    if (serializedValue === 'true') {\n      return true;\n    }\n\n    if (serializedValue === 'false') {\n      return false;\n    }\n\n    let m = /^'([^']*)'$/.exec(serializedValue);\n\n    if (m) {\n      return m[1].trim();\n    }\n\n    return serializedValue;\n  }\n\n  static _deserializeRegexValue(serializedValue, strict) {\n    if (isFalsyOrWhitespace(serializedValue)) {\n      if (strict) {\n        throw new Error('missing regexp-value for =~-expression');\n      } else {\n        console.warn('missing regexp-value for =~-expression');\n      }\n\n      return null;\n    }\n\n    let start = serializedValue.indexOf('/');\n    let end = serializedValue.lastIndexOf('/');\n\n    if (start === end || start < 0\n    /* || to < 0 */\n    ) {\n      if (strict) {\n        throw new Error(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n      } else {\n        console.warn(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n      }\n\n      return null;\n    }\n\n    let value = serializedValue.slice(start + 1, end);\n    let caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n\n    try {\n      return new RegExp(value, caseIgnoreFlag);\n    } catch (e) {\n      if (strict) {\n        throw new Error(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n      } else {\n        console.warn(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n      }\n\n      return null;\n    }\n  }\n\n}\nexport function expressionsAreEqualWithConstantSubstitution(a, b) {\n  const aExpr = a ? a.substituteConstants() : undefined;\n  const bExpr = b ? b.substituteConstants() : undefined;\n\n  if (!aExpr && !bExpr) {\n    return true;\n  }\n\n  if (!aExpr || !bExpr) {\n    return false;\n  }\n\n  return aExpr.equals(bExpr);\n}\n\nfunction cmp(a, b) {\n  return a.cmp(b);\n}\n\nexport class ContextKeyFalseExpr {\n  constructor() {\n    this.type = 0\n    /* False */\n    ;\n  }\n\n  cmp(other) {\n    return this.type - other.type;\n  }\n\n  equals(other) {\n    return other.type === this.type;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    return false;\n  }\n\n  serialize() {\n    return 'false';\n  }\n\n  keys() {\n    return [];\n  }\n\n  negate() {\n    return ContextKeyTrueExpr.INSTANCE;\n  }\n\n}\nContextKeyFalseExpr.INSTANCE = new ContextKeyFalseExpr();\nexport class ContextKeyTrueExpr {\n  constructor() {\n    this.type = 1\n    /* True */\n    ;\n  }\n\n  cmp(other) {\n    return this.type - other.type;\n  }\n\n  equals(other) {\n    return other.type === this.type;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    return true;\n  }\n\n  serialize() {\n    return 'true';\n  }\n\n  keys() {\n    return [];\n  }\n\n  negate() {\n    return ContextKeyFalseExpr.INSTANCE;\n  }\n\n}\nContextKeyTrueExpr.INSTANCE = new ContextKeyTrueExpr();\nexport class ContextKeyDefinedExpr {\n  constructor(key, negated) {\n    this.key = key;\n    this.negated = negated;\n    this.type = 2\n    /* Defined */\n    ;\n  }\n\n  static create(key) {\n    let negated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const constantValue = CONSTANT_VALUES.get(key);\n\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n\n    return new ContextKeyDefinedExpr(key, negated);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return cmp1(this.key, other.key);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n\n    return this;\n  }\n\n  evaluate(context) {\n    return !!context.getValue(this.key);\n  }\n\n  serialize() {\n    return this.key;\n  }\n\n  keys() {\n    return [this.key];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotExpr.create(this.key, this);\n    }\n\n    return this.negated;\n  }\n\n}\nexport class ContextKeyEqualsExpr {\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 4\n    /* Equals */\n    ;\n  }\n\n  static create(key, value) {\n    let negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    if (typeof value === 'boolean') {\n      return value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated);\n    }\n\n    const constantValue = CONSTANT_VALUES.get(key);\n\n    if (typeof constantValue === 'boolean') {\n      const trueValue = constantValue ? 'true' : 'false';\n      return value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n\n    return new ContextKeyEqualsExpr(key, value, negated);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n\n    if (typeof constantValue === 'boolean') {\n      const trueValue = constantValue ? 'true' : 'false';\n      return this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n\n    return this;\n  }\n\n  evaluate(context) {\n    // Intentional ==\n    // eslint-disable-next-line eqeqeq\n    return context.getValue(this.key) == this.value;\n  }\n\n  serialize() {\n    return `${this.key} == '${this.value}'`;\n  }\n\n  keys() {\n    return [this.key];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n    }\n\n    return this.negated;\n  }\n\n}\nexport class ContextKeyInExpr {\n  constructor(key, valueKey) {\n    this.key = key;\n    this.valueKey = valueKey;\n    this.type = 10\n    /* In */\n    ;\n    this.negated = null;\n  }\n\n  static create(key, valueKey) {\n    return new ContextKeyInExpr(key, valueKey);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return cmp2(this.key, this.valueKey, other.key, other.valueKey);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.valueKey === other.valueKey;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    const source = context.getValue(this.valueKey);\n    const item = context.getValue(this.key);\n\n    if (Array.isArray(source)) {\n      return source.indexOf(item) >= 0;\n    }\n\n    if (typeof item === 'string' && typeof source === 'object' && source !== null) {\n      return hasOwnProperty.call(source, item);\n    }\n\n    return false;\n  }\n\n  serialize() {\n    return `${this.key} in '${this.valueKey}'`;\n  }\n\n  keys() {\n    return [this.key, this.valueKey];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotInExpr.create(this);\n    }\n\n    return this.negated;\n  }\n\n}\nexport class ContextKeyNotInExpr {\n  constructor(_actual) {\n    this._actual = _actual;\n    this.type = 11\n    /* NotIn */\n    ; //\n  }\n\n  static create(actual) {\n    return new ContextKeyNotInExpr(actual);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return this._actual.cmp(other._actual);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this._actual.equals(other._actual);\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    return !this._actual.evaluate(context);\n  }\n\n  serialize() {\n    throw new Error('Method not implemented.');\n  }\n\n  keys() {\n    return this._actual.keys();\n  }\n\n  negate() {\n    return this._actual;\n  }\n\n}\nexport class ContextKeyNotEqualsExpr {\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 5\n    /* NotEquals */\n    ;\n  }\n\n  static create(key, value) {\n    let negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    if (typeof value === 'boolean') {\n      if (value) {\n        return ContextKeyNotExpr.create(key, negated);\n      }\n\n      return ContextKeyDefinedExpr.create(key, negated);\n    }\n\n    const constantValue = CONSTANT_VALUES.get(key);\n\n    if (typeof constantValue === 'boolean') {\n      const falseValue = constantValue ? 'true' : 'false';\n      return value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n\n    return new ContextKeyNotEqualsExpr(key, value, negated);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n\n    if (typeof constantValue === 'boolean') {\n      const falseValue = constantValue ? 'true' : 'false';\n      return this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n\n    return this;\n  }\n\n  evaluate(context) {\n    // Intentional !=\n    // eslint-disable-next-line eqeqeq\n    return context.getValue(this.key) != this.value;\n  }\n\n  serialize() {\n    return `${this.key} != '${this.value}'`;\n  }\n\n  keys() {\n    return [this.key];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n    }\n\n    return this.negated;\n  }\n\n}\nexport class ContextKeyNotExpr {\n  constructor(key, negated) {\n    this.key = key;\n    this.negated = negated;\n    this.type = 3\n    /* Not */\n    ;\n  }\n\n  static create(key) {\n    let negated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const constantValue = CONSTANT_VALUES.get(key);\n\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n\n    return new ContextKeyNotExpr(key, negated);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return cmp1(this.key, other.key);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n\n    return this;\n  }\n\n  evaluate(context) {\n    return !context.getValue(this.key);\n  }\n\n  serialize() {\n    return `!${this.key}`;\n  }\n\n  keys() {\n    return [this.key];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyDefinedExpr.create(this.key, this);\n    }\n\n    return this.negated;\n  }\n\n}\n\nfunction withFloatOrStr(value, callback) {\n  if (typeof value === 'string') {\n    const n = parseFloat(value);\n\n    if (!isNaN(n)) {\n      value = n;\n    }\n  }\n\n  if (typeof value === 'string' || typeof value === 'number') {\n    return callback(value);\n  }\n\n  return ContextKeyFalseExpr.INSTANCE;\n}\n\nexport class ContextKeyGreaterExpr {\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 12\n    /* Greater */\n    ;\n  }\n\n  static create(key, _value) {\n    let negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return withFloatOrStr(_value, value => new ContextKeyGreaterExpr(key, value, negated));\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n\n    return parseFloat(context.getValue(this.key)) > this.value;\n  }\n\n  serialize() {\n    return `${this.key} > ${this.value}`;\n  }\n\n  keys() {\n    return [this.key];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n    }\n\n    return this.negated;\n  }\n\n}\nexport class ContextKeyGreaterEqualsExpr {\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 13\n    /* GreaterEquals */\n    ;\n  }\n\n  static create(key, _value) {\n    let negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return withFloatOrStr(_value, value => new ContextKeyGreaterEqualsExpr(key, value, negated));\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n\n    return parseFloat(context.getValue(this.key)) >= this.value;\n  }\n\n  serialize() {\n    return `${this.key} >= ${this.value}`;\n  }\n\n  keys() {\n    return [this.key];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n    }\n\n    return this.negated;\n  }\n\n}\nexport class ContextKeySmallerExpr {\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 14\n    /* Smaller */\n    ;\n  }\n\n  static create(key, _value) {\n    let negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return withFloatOrStr(_value, value => new ContextKeySmallerExpr(key, value, negated));\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n\n    return parseFloat(context.getValue(this.key)) < this.value;\n  }\n\n  serialize() {\n    return `${this.key} < ${this.value}`;\n  }\n\n  keys() {\n    return [this.key];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n    }\n\n    return this.negated;\n  }\n\n}\nexport class ContextKeySmallerEqualsExpr {\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 15\n    /* SmallerEquals */\n    ;\n  }\n\n  static create(key, _value) {\n    let negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return withFloatOrStr(_value, value => new ContextKeySmallerEqualsExpr(key, value, negated));\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n\n    return parseFloat(context.getValue(this.key)) <= this.value;\n  }\n\n  serialize() {\n    return `${this.key} <= ${this.value}`;\n  }\n\n  keys() {\n    return [this.key];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n    }\n\n    return this.negated;\n  }\n\n}\nexport class ContextKeyRegexExpr {\n  constructor(key, regexp) {\n    this.key = key;\n    this.regexp = regexp;\n    this.type = 7\n    /* Regex */\n    ;\n    this.negated = null; //\n  }\n\n  static create(key, regexp) {\n    return new ContextKeyRegexExpr(key, regexp);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    if (this.key < other.key) {\n      return -1;\n    }\n\n    if (this.key > other.key) {\n      return 1;\n    }\n\n    const thisSource = this.regexp ? this.regexp.source : '';\n    const otherSource = other.regexp ? other.regexp.source : '';\n\n    if (thisSource < otherSource) {\n      return -1;\n    }\n\n    if (thisSource > otherSource) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      const thisSource = this.regexp ? this.regexp.source : '';\n      const otherSource = other.regexp ? other.regexp.source : '';\n      return this.key === other.key && thisSource === otherSource;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    let value = context.getValue(this.key);\n    return this.regexp ? this.regexp.test(value) : false;\n  }\n\n  serialize() {\n    const value = this.regexp ? `/${this.regexp.source}/${this.regexp.ignoreCase ? 'i' : ''}` : '/invalid/';\n    return `${this.key} =~ ${value}`;\n  }\n\n  keys() {\n    return [this.key];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotRegexExpr.create(this);\n    }\n\n    return this.negated;\n  }\n\n}\nexport class ContextKeyNotRegexExpr {\n  constructor(_actual) {\n    this._actual = _actual;\n    this.type = 8\n    /* NotRegex */\n    ; //\n  }\n\n  static create(actual) {\n    return new ContextKeyNotRegexExpr(actual);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return this._actual.cmp(other._actual);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this._actual.equals(other._actual);\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    return !this._actual.evaluate(context);\n  }\n\n  serialize() {\n    throw new Error('Method not implemented.');\n  }\n\n  keys() {\n    return this._actual.keys();\n  }\n\n  negate() {\n    return this._actual;\n  }\n\n}\n/**\n * @returns the same instance if nothing changed.\n */\n\nfunction eliminateConstantsInArray(arr) {\n  // Allocate array only if there is a difference\n  let newArr = null;\n\n  for (let i = 0, len = arr.length; i < len; i++) {\n    const newExpr = arr[i].substituteConstants();\n\n    if (arr[i] !== newExpr) {\n      // something has changed!\n      // allocate array on first difference\n      if (newArr === null) {\n        newArr = [];\n\n        for (let j = 0; j < i; j++) {\n          newArr[j] = arr[j];\n        }\n      }\n    }\n\n    if (newArr !== null) {\n      newArr[i] = newExpr;\n    }\n  }\n\n  if (newArr === null) {\n    return arr;\n  }\n\n  return newArr;\n}\n\nclass ContextKeyAndExpr {\n  constructor(expr, negated) {\n    this.expr = expr;\n    this.negated = negated;\n    this.type = 6\n    /* And */\n    ;\n  }\n\n  static create(_expr, negated) {\n    return ContextKeyAndExpr._normalizeArr(_expr, negated);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    if (this.expr.length < other.expr.length) {\n      return -1;\n    }\n\n    if (this.expr.length > other.expr.length) {\n      return 1;\n    }\n\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      const r = cmp(this.expr[i], other.expr[i]);\n\n      if (r !== 0) {\n        return r;\n      }\n    }\n\n    return 0;\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      if (this.expr.length !== other.expr.length) {\n        return false;\n      }\n\n      for (let i = 0, len = this.expr.length; i < len; i++) {\n        if (!this.expr[i].equals(other.expr[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    const exprArr = eliminateConstantsInArray(this.expr);\n\n    if (exprArr === this.expr) {\n      // no change\n      return this;\n    }\n\n    return ContextKeyAndExpr.create(exprArr, this.negated);\n  }\n\n  evaluate(context) {\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      if (!this.expr[i].evaluate(context)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  static _normalizeArr(arr, negated) {\n    const expr = [];\n    let hasTrue = false;\n\n    for (const e of arr) {\n      if (!e) {\n        continue;\n      }\n\n      if (e.type === 1\n      /* True */\n      ) {\n        // anything && true ==> anything\n        hasTrue = true;\n        continue;\n      }\n\n      if (e.type === 0\n      /* False */\n      ) {\n        // anything && false ==> false\n        return ContextKeyFalseExpr.INSTANCE;\n      }\n\n      if (e.type === 6\n      /* And */\n      ) {\n        expr.push(...e.expr);\n        continue;\n      }\n\n      expr.push(e);\n    }\n\n    if (expr.length === 0 && hasTrue) {\n      return ContextKeyTrueExpr.INSTANCE;\n    }\n\n    if (expr.length === 0) {\n      return undefined;\n    }\n\n    if (expr.length === 1) {\n      return expr[0];\n    }\n\n    expr.sort(cmp); // eliminate duplicate terms\n\n    for (let i = 1; i < expr.length; i++) {\n      if (expr[i - 1].equals(expr[i])) {\n        expr.splice(i, 1);\n        i--;\n      }\n    }\n\n    if (expr.length === 1) {\n      return expr[0];\n    } // We must distribute any OR expression because we don't support parens\n    // OR extensions will be at the end (due to sorting rules)\n\n\n    while (expr.length > 1) {\n      const lastElement = expr[expr.length - 1];\n\n      if (lastElement.type !== 9\n      /* Or */\n      ) {\n        break;\n      } // pop the last element\n\n\n      expr.pop(); // pop the second to last element\n\n      const secondToLastElement = expr.pop();\n      const isFinished = expr.length === 0; // distribute `lastElement` over `secondToLastElement`\n\n      const resultElement = ContextKeyOrExpr.create(lastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement], null)), null, isFinished);\n\n      if (resultElement) {\n        expr.push(resultElement);\n        expr.sort(cmp);\n      }\n    }\n\n    if (expr.length === 1) {\n      return expr[0];\n    }\n\n    return new ContextKeyAndExpr(expr, negated);\n  }\n\n  serialize() {\n    return this.expr.map(e => e.serialize()).join(' && ');\n  }\n\n  keys() {\n    const result = [];\n\n    for (let expr of this.expr) {\n      result.push(...expr.keys());\n    }\n\n    return result;\n  }\n\n  negate() {\n    if (!this.negated) {\n      const result = [];\n\n      for (let expr of this.expr) {\n        result.push(expr.negate());\n      }\n\n      this.negated = ContextKeyOrExpr.create(result, this, true);\n    }\n\n    return this.negated;\n  }\n\n}\n\nclass ContextKeyOrExpr {\n  constructor(expr, negated) {\n    this.expr = expr;\n    this.negated = negated;\n    this.type = 9\n    /* Or */\n    ;\n  }\n\n  static create(_expr, negated, extraRedundantCheck) {\n    return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    if (this.expr.length < other.expr.length) {\n      return -1;\n    }\n\n    if (this.expr.length > other.expr.length) {\n      return 1;\n    }\n\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      const r = cmp(this.expr[i], other.expr[i]);\n\n      if (r !== 0) {\n        return r;\n      }\n    }\n\n    return 0;\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      if (this.expr.length !== other.expr.length) {\n        return false;\n      }\n\n      for (let i = 0, len = this.expr.length; i < len; i++) {\n        if (!this.expr[i].equals(other.expr[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    const exprArr = eliminateConstantsInArray(this.expr);\n\n    if (exprArr === this.expr) {\n      // no change\n      return this;\n    }\n\n    return ContextKeyOrExpr.create(exprArr, this.negated, false);\n  }\n\n  evaluate(context) {\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      if (this.expr[i].evaluate(context)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  static _normalizeArr(arr, negated, extraRedundantCheck) {\n    let expr = [];\n    let hasFalse = false;\n\n    if (arr) {\n      for (let i = 0, len = arr.length; i < len; i++) {\n        const e = arr[i];\n\n        if (!e) {\n          continue;\n        }\n\n        if (e.type === 0\n        /* False */\n        ) {\n          // anything || false ==> anything\n          hasFalse = true;\n          continue;\n        }\n\n        if (e.type === 1\n        /* True */\n        ) {\n          // anything || true ==> true\n          return ContextKeyTrueExpr.INSTANCE;\n        }\n\n        if (e.type === 9\n        /* Or */\n        ) {\n          expr = expr.concat(e.expr);\n          continue;\n        }\n\n        expr.push(e);\n      }\n\n      if (expr.length === 0 && hasFalse) {\n        return ContextKeyFalseExpr.INSTANCE;\n      }\n\n      expr.sort(cmp);\n    }\n\n    if (expr.length === 0) {\n      return undefined;\n    }\n\n    if (expr.length === 1) {\n      return expr[0];\n    } // eliminate duplicate terms\n\n\n    for (let i = 1; i < expr.length; i++) {\n      if (expr[i - 1].equals(expr[i])) {\n        expr.splice(i, 1);\n        i--;\n      }\n    }\n\n    if (expr.length === 1) {\n      return expr[0];\n    } // eliminate redundant terms\n\n\n    if (extraRedundantCheck) {\n      for (let i = 0; i < expr.length; i++) {\n        for (let j = i + 1; j < expr.length; j++) {\n          if (implies(expr[i], expr[j])) {\n            expr.splice(j, 1);\n            j--;\n          }\n        }\n      }\n\n      if (expr.length === 1) {\n        return expr[0];\n      }\n    }\n\n    return new ContextKeyOrExpr(expr, negated);\n  }\n\n  serialize() {\n    return this.expr.map(e => e.serialize()).join(' || ');\n  }\n\n  keys() {\n    const result = [];\n\n    for (let expr of this.expr) {\n      result.push(...expr.keys());\n    }\n\n    return result;\n  }\n\n  negate() {\n    if (!this.negated) {\n      let result = [];\n\n      for (let expr of this.expr) {\n        result.push(expr.negate());\n      } // We don't support parens, so here we distribute the AND over the OR terminals\n      // We always take the first 2 AND pairs and distribute them\n\n\n      while (result.length > 1) {\n        const LEFT = result.shift();\n        const RIGHT = result.shift();\n        const all = [];\n\n        for (const left of getTerminals(LEFT)) {\n          for (const right of getTerminals(RIGHT)) {\n            all.push(ContextKeyAndExpr.create([left, right], null));\n          }\n        }\n\n        const isFinished = result.length === 0;\n        result.unshift(ContextKeyOrExpr.create(all, null, isFinished));\n      }\n\n      this.negated = result[0];\n    }\n\n    return this.negated;\n  }\n\n}\n\nexport class RawContextKey extends ContextKeyDefinedExpr {\n  constructor(key, defaultValue, metaOrHide) {\n    super(key, null);\n    this._defaultValue = defaultValue; // collect all context keys into a central place\n\n    if (typeof metaOrHide === 'object') {\n      RawContextKey._info.push(Object.assign(Object.assign({}, metaOrHide), {\n        key\n      }));\n    } else if (metaOrHide !== true) {\n      RawContextKey._info.push({\n        key,\n        description: metaOrHide,\n        type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined\n      });\n    }\n  }\n\n  static all() {\n    return RawContextKey._info.values();\n  }\n\n  bindTo(target) {\n    return target.createKey(this.key, this._defaultValue);\n  }\n\n  getValue(target) {\n    return target.getContextKeyValue(this.key);\n  }\n\n  toNegated() {\n    return this.negate();\n  }\n\n  isEqualTo(value) {\n    return ContextKeyEqualsExpr.create(this.key, value);\n  }\n\n}\nRawContextKey._info = [];\nexport const IContextKeyService = createDecorator('contextKeyService');\nexport const SET_CONTEXT_COMMAND_ID = 'setContext';\n\nfunction cmp1(key1, key2) {\n  if (key1 < key2) {\n    return -1;\n  }\n\n  if (key1 > key2) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction cmp2(key1, value1, key2, value2) {\n  if (key1 < key2) {\n    return -1;\n  }\n\n  if (key1 > key2) {\n    return 1;\n  }\n\n  if (value1 < value2) {\n    return -1;\n  }\n\n  if (value1 > value2) {\n    return 1;\n  }\n\n  return 0;\n}\n/**\n * Returns true if it is provable `p` implies `q`.\n */\n\n\nexport function implies(p, q) {\n  if (q.type === 6\n  /* And */\n  && p.type !== 9\n  /* Or */\n  && p.type !== 6\n  /* And */\n  ) {\n    // covers the case: A implies A && B\n    for (const qTerm of q.expr) {\n      if (p.equals(qTerm)) {\n        return true;\n      }\n    }\n  }\n\n  const notP = p.negate();\n  const expr = getTerminals(notP).concat(getTerminals(q));\n  expr.sort(cmp);\n\n  for (let i = 0; i < expr.length; i++) {\n    const a = expr[i];\n    const notA = a.negate();\n\n    for (let j = i + 1; j < expr.length; j++) {\n      const b = expr[j];\n\n      if (notA.equals(b)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction getTerminals(node) {\n  if (node.type === 9\n  /* Or */\n  ) {\n    return node.expr;\n  }\n\n  return [node];\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js"],"names":["isLinux","isMacintosh","isWeb","isWindows","userAgent","isFalsyOrWhitespace","createDecorator","_userAgent","CONSTANT_VALUES","Map","set","indexOf","hasOwnProperty","Object","prototype","ContextKeyExpr","has","key","ContextKeyDefinedExpr","create","equals","value","ContextKeyEqualsExpr","regex","ContextKeyRegexExpr","not","ContextKeyNotExpr","and","expr","ContextKeyAndExpr","or","ContextKeyOrExpr","deserialize","serialized","strict","undefined","_deserializeOrExpression","pieces","split","map","p","_deserializeAndExpression","_deserializeOne","serializedOne","trim","ContextKeyNotEqualsExpr","_deserializeValue","_deserializeRegexValue","ContextKeyInExpr","test","ContextKeyGreaterEqualsExpr","ContextKeyGreaterExpr","ContextKeySmallerEqualsExpr","ContextKeySmallerExpr","substr","serializedValue","m","exec","Error","console","warn","start","end","lastIndexOf","slice","caseIgnoreFlag","RegExp","e","expressionsAreEqualWithConstantSubstitution","a","b","aExpr","substituteConstants","bExpr","cmp","ContextKeyFalseExpr","constructor","type","other","evaluate","context","serialize","keys","negate","ContextKeyTrueExpr","INSTANCE","negated","constantValue","get","cmp1","getValue","trueValue","cmp2","valueKey","source","item","Array","isArray","call","ContextKeyNotInExpr","_actual","actual","falseValue","withFloatOrStr","callback","n","parseFloat","isNaN","_value","regexp","thisSource","otherSource","ignoreCase","ContextKeyNotRegexExpr","eliminateConstantsInArray","arr","newArr","i","len","length","newExpr","j","_expr","_normalizeArr","r","exprArr","hasTrue","push","sort","splice","lastElement","pop","secondToLastElement","isFinished","resultElement","el","join","result","extraRedundantCheck","hasFalse","concat","implies","LEFT","shift","RIGHT","all","left","getTerminals","right","unshift","RawContextKey","defaultValue","metaOrHide","_defaultValue","_info","assign","description","values","bindTo","target","createKey","getContextKeyValue","toNegated","isEqualTo","IContextKeyService","SET_CONTEXT_COMMAND_ID","key1","key2","value1","value2","q","qTerm","notP","notA","node"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isLinux, isMacintosh, isWeb, isWindows, userAgent } from '../../../base/common/platform.js';\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nlet _userAgent = userAgent || '';\nconst CONSTANT_VALUES = new Map();\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', _userAgent.indexOf('Edg/') >= 0);\nCONSTANT_VALUES.set('isFirefox', _userAgent.indexOf('Firefox') >= 0);\nCONSTANT_VALUES.set('isChrome', _userAgent.indexOf('Chrome') >= 0);\nCONSTANT_VALUES.set('isSafari', _userAgent.indexOf('Safari') >= 0);\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nexport class ContextKeyExpr {\n    static has(key) {\n        return ContextKeyDefinedExpr.create(key);\n    }\n    static equals(key, value) {\n        return ContextKeyEqualsExpr.create(key, value);\n    }\n    static regex(key, value) {\n        return ContextKeyRegexExpr.create(key, value);\n    }\n    static not(key) {\n        return ContextKeyNotExpr.create(key);\n    }\n    static and(...expr) {\n        return ContextKeyAndExpr.create(expr, null);\n    }\n    static or(...expr) {\n        return ContextKeyOrExpr.create(expr, null, true);\n    }\n    static deserialize(serialized, strict = false) {\n        if (!serialized) {\n            return undefined;\n        }\n        return this._deserializeOrExpression(serialized, strict);\n    }\n    static _deserializeOrExpression(serialized, strict) {\n        let pieces = serialized.split('||');\n        return ContextKeyOrExpr.create(pieces.map(p => this._deserializeAndExpression(p, strict)), null, true);\n    }\n    static _deserializeAndExpression(serialized, strict) {\n        let pieces = serialized.split('&&');\n        return ContextKeyAndExpr.create(pieces.map(p => this._deserializeOne(p, strict)), null);\n    }\n    static _deserializeOne(serializedOne, strict) {\n        serializedOne = serializedOne.trim();\n        if (serializedOne.indexOf('!=') >= 0) {\n            let pieces = serializedOne.split('!=');\n            return ContextKeyNotEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n        }\n        if (serializedOne.indexOf('==') >= 0) {\n            let pieces = serializedOne.split('==');\n            return ContextKeyEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n        }\n        if (serializedOne.indexOf('=~') >= 0) {\n            let pieces = serializedOne.split('=~');\n            return ContextKeyRegexExpr.create(pieces[0].trim(), this._deserializeRegexValue(pieces[1], strict));\n        }\n        if (serializedOne.indexOf(' in ') >= 0) {\n            let pieces = serializedOne.split(' in ');\n            return ContextKeyInExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+>=[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('>=');\n            return ContextKeyGreaterEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+>[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('>');\n            return ContextKeyGreaterExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+<=[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('<=');\n            return ContextKeySmallerEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+<[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('<');\n            return ContextKeySmallerExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^\\!\\s*/.test(serializedOne)) {\n            return ContextKeyNotExpr.create(serializedOne.substr(1).trim());\n        }\n        return ContextKeyDefinedExpr.create(serializedOne);\n    }\n    static _deserializeValue(serializedValue, strict) {\n        serializedValue = serializedValue.trim();\n        if (serializedValue === 'true') {\n            return true;\n        }\n        if (serializedValue === 'false') {\n            return false;\n        }\n        let m = /^'([^']*)'$/.exec(serializedValue);\n        if (m) {\n            return m[1].trim();\n        }\n        return serializedValue;\n    }\n    static _deserializeRegexValue(serializedValue, strict) {\n        if (isFalsyOrWhitespace(serializedValue)) {\n            if (strict) {\n                throw new Error('missing regexp-value for =~-expression');\n            }\n            else {\n                console.warn('missing regexp-value for =~-expression');\n            }\n            return null;\n        }\n        let start = serializedValue.indexOf('/');\n        let end = serializedValue.lastIndexOf('/');\n        if (start === end || start < 0 /* || to < 0 */) {\n            if (strict) {\n                throw new Error(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n            }\n            else {\n                console.warn(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n            }\n            return null;\n        }\n        let value = serializedValue.slice(start + 1, end);\n        let caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n        try {\n            return new RegExp(value, caseIgnoreFlag);\n        }\n        catch (e) {\n            if (strict) {\n                throw new Error(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n            }\n            else {\n                console.warn(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n            }\n            return null;\n        }\n    }\n}\nexport function expressionsAreEqualWithConstantSubstitution(a, b) {\n    const aExpr = a ? a.substituteConstants() : undefined;\n    const bExpr = b ? b.substituteConstants() : undefined;\n    if (!aExpr && !bExpr) {\n        return true;\n    }\n    if (!aExpr || !bExpr) {\n        return false;\n    }\n    return aExpr.equals(bExpr);\n}\nfunction cmp(a, b) {\n    return a.cmp(b);\n}\nexport class ContextKeyFalseExpr {\n    constructor() {\n        this.type = 0 /* False */;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return false;\n    }\n    serialize() {\n        return 'false';\n    }\n    keys() {\n        return [];\n    }\n    negate() {\n        return ContextKeyTrueExpr.INSTANCE;\n    }\n}\nContextKeyFalseExpr.INSTANCE = new ContextKeyFalseExpr();\nexport class ContextKeyTrueExpr {\n    constructor() {\n        this.type = 1 /* True */;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return true;\n    }\n    serialize() {\n        return 'true';\n    }\n    keys() {\n        return [];\n    }\n    negate() {\n        return ContextKeyFalseExpr.INSTANCE;\n    }\n}\nContextKeyTrueExpr.INSTANCE = new ContextKeyTrueExpr();\nexport class ContextKeyDefinedExpr {\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 2 /* Defined */;\n    }\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return new ContextKeyDefinedExpr(key, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!!context.getValue(this.key));\n    }\n    serialize() {\n        return this.key;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotExpr.create(this.key, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyEqualsExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 4 /* Equals */;\n    }\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            return (value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated));\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return new ContextKeyEqualsExpr(key, value, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        // Intentional ==\n        // eslint-disable-next-line eqeqeq\n        return (context.getValue(this.key) == this.value);\n    }\n    serialize() {\n        return `${this.key} == '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyInExpr {\n    constructor(key, valueKey) {\n        this.key = key;\n        this.valueKey = valueKey;\n        this.type = 10 /* In */;\n        this.negated = null;\n    }\n    static create(key, valueKey) {\n        return new ContextKeyInExpr(key, valueKey);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.valueKey, other.key, other.valueKey);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.valueKey === other.valueKey);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        const source = context.getValue(this.valueKey);\n        const item = context.getValue(this.key);\n        if (Array.isArray(source)) {\n            return (source.indexOf(item) >= 0);\n        }\n        if (typeof item === 'string' && typeof source === 'object' && source !== null) {\n            return hasOwnProperty.call(source, item);\n        }\n        return false;\n    }\n    serialize() {\n        return `${this.key} in '${this.valueKey}'`;\n    }\n    keys() {\n        return [this.key, this.valueKey];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotInExpr.create(this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotInExpr {\n    constructor(_actual) {\n        this._actual = _actual;\n        this.type = 11 /* NotIn */;\n        //\n    }\n    static create(actual) {\n        return new ContextKeyNotInExpr(actual);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._actual.cmp(other._actual);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._actual.equals(other._actual);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._actual.evaluate(context);\n    }\n    serialize() {\n        throw new Error('Method not implemented.');\n    }\n    keys() {\n        return this._actual.keys();\n    }\n    negate() {\n        return this._actual;\n    }\n}\nexport class ContextKeyNotEqualsExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 5 /* NotEquals */;\n    }\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            if (value) {\n                return ContextKeyNotExpr.create(key, negated);\n            }\n            return ContextKeyDefinedExpr.create(key, negated);\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return new ContextKeyNotEqualsExpr(key, value, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        // Intentional !=\n        // eslint-disable-next-line eqeqeq\n        return (context.getValue(this.key) != this.value);\n    }\n    serialize() {\n        return `${this.key} != '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotExpr {\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 3 /* Not */;\n    }\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return new ContextKeyNotExpr(key, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!context.getValue(this.key));\n    }\n    serialize() {\n        return `!${this.key}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyDefinedExpr.create(this.key, this);\n        }\n        return this.negated;\n    }\n}\nfunction withFloatOrStr(value, callback) {\n    if (typeof value === 'string') {\n        const n = parseFloat(value);\n        if (!isNaN(n)) {\n            value = n;\n        }\n    }\n    if (typeof value === 'string' || typeof value === 'number') {\n        return callback(value);\n    }\n    return ContextKeyFalseExpr.INSTANCE;\n}\nexport class ContextKeyGreaterExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 12 /* Greater */;\n    }\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeyGreaterExpr(key, value, negated));\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) > this.value);\n    }\n    serialize() {\n        return `${this.key} > ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyGreaterEqualsExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 13 /* GreaterEquals */;\n    }\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeyGreaterEqualsExpr(key, value, negated));\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) >= this.value);\n    }\n    serialize() {\n        return `${this.key} >= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeySmallerExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 14 /* Smaller */;\n    }\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeySmallerExpr(key, value, negated));\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) < this.value);\n    }\n    serialize() {\n        return `${this.key} < ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeySmallerEqualsExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 15 /* SmallerEquals */;\n    }\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeySmallerEqualsExpr(key, value, negated));\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) <= this.value);\n    }\n    serialize() {\n        return `${this.key} <= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyRegexExpr {\n    constructor(key, regexp) {\n        this.key = key;\n        this.regexp = regexp;\n        this.type = 7 /* Regex */;\n        this.negated = null;\n        //\n    }\n    static create(key, regexp) {\n        return new ContextKeyRegexExpr(key, regexp);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.key < other.key) {\n            return -1;\n        }\n        if (this.key > other.key) {\n            return 1;\n        }\n        const thisSource = this.regexp ? this.regexp.source : '';\n        const otherSource = other.regexp ? other.regexp.source : '';\n        if (thisSource < otherSource) {\n            return -1;\n        }\n        if (thisSource > otherSource) {\n            return 1;\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            const thisSource = this.regexp ? this.regexp.source : '';\n            const otherSource = other.regexp ? other.regexp.source : '';\n            return (this.key === other.key && thisSource === otherSource);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        let value = context.getValue(this.key);\n        return this.regexp ? this.regexp.test(value) : false;\n    }\n    serialize() {\n        const value = this.regexp\n            ? `/${this.regexp.source}/${this.regexp.ignoreCase ? 'i' : ''}`\n            : '/invalid/';\n        return `${this.key} =~ ${value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotRegexExpr.create(this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotRegexExpr {\n    constructor(_actual) {\n        this._actual = _actual;\n        this.type = 8 /* NotRegex */;\n        //\n    }\n    static create(actual) {\n        return new ContextKeyNotRegexExpr(actual);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._actual.cmp(other._actual);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._actual.equals(other._actual);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._actual.evaluate(context);\n    }\n    serialize() {\n        throw new Error('Method not implemented.');\n    }\n    keys() {\n        return this._actual.keys();\n    }\n    negate() {\n        return this._actual;\n    }\n}\n/**\n * @returns the same instance if nothing changed.\n */\nfunction eliminateConstantsInArray(arr) {\n    // Allocate array only if there is a difference\n    let newArr = null;\n    for (let i = 0, len = arr.length; i < len; i++) {\n        const newExpr = arr[i].substituteConstants();\n        if (arr[i] !== newExpr) {\n            // something has changed!\n            // allocate array on first difference\n            if (newArr === null) {\n                newArr = [];\n                for (let j = 0; j < i; j++) {\n                    newArr[j] = arr[j];\n                }\n            }\n        }\n        if (newArr !== null) {\n            newArr[i] = newExpr;\n        }\n    }\n    if (newArr === null) {\n        return arr;\n    }\n    return newArr;\n}\nclass ContextKeyAndExpr {\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 6 /* And */;\n    }\n    static create(_expr, negated) {\n        return ContextKeyAndExpr._normalizeArr(_expr, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            // no change\n            return this;\n        }\n        return ContextKeyAndExpr.create(exprArr, this.negated);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (!this.expr[i].evaluate(context)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _normalizeArr(arr, negated) {\n        const expr = [];\n        let hasTrue = false;\n        for (const e of arr) {\n            if (!e) {\n                continue;\n            }\n            if (e.type === 1 /* True */) {\n                // anything && true ==> anything\n                hasTrue = true;\n                continue;\n            }\n            if (e.type === 0 /* False */) {\n                // anything && false ==> false\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            if (e.type === 6 /* And */) {\n                expr.push(...e.expr);\n                continue;\n            }\n            expr.push(e);\n        }\n        if (expr.length === 0 && hasTrue) {\n            return ContextKeyTrueExpr.INSTANCE;\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        expr.sort(cmp);\n        // eliminate duplicate terms\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // We must distribute any OR expression because we don't support parens\n        // OR extensions will be at the end (due to sorting rules)\n        while (expr.length > 1) {\n            const lastElement = expr[expr.length - 1];\n            if (lastElement.type !== 9 /* Or */) {\n                break;\n            }\n            // pop the last element\n            expr.pop();\n            // pop the second to last element\n            const secondToLastElement = expr.pop();\n            const isFinished = (expr.length === 0);\n            // distribute `lastElement` over `secondToLastElement`\n            const resultElement = ContextKeyOrExpr.create(lastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement], null)), null, isFinished);\n            if (resultElement) {\n                expr.push(resultElement);\n                expr.sort(cmp);\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        return new ContextKeyAndExpr(expr, negated);\n    }\n    serialize() {\n        return this.expr.map(e => e.serialize()).join(' && ');\n    }\n    keys() {\n        const result = [];\n        for (let expr of this.expr) {\n            result.push(...expr.keys());\n        }\n        return result;\n    }\n    negate() {\n        if (!this.negated) {\n            const result = [];\n            for (let expr of this.expr) {\n                result.push(expr.negate());\n            }\n            this.negated = ContextKeyOrExpr.create(result, this, true);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyOrExpr {\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 9 /* Or */;\n    }\n    static create(_expr, negated, extraRedundantCheck) {\n        return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            // no change\n            return this;\n        }\n        return ContextKeyOrExpr.create(exprArr, this.negated, false);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (this.expr[i].evaluate(context)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static _normalizeArr(arr, negated, extraRedundantCheck) {\n        let expr = [];\n        let hasFalse = false;\n        if (arr) {\n            for (let i = 0, len = arr.length; i < len; i++) {\n                const e = arr[i];\n                if (!e) {\n                    continue;\n                }\n                if (e.type === 0 /* False */) {\n                    // anything || false ==> anything\n                    hasFalse = true;\n                    continue;\n                }\n                if (e.type === 1 /* True */) {\n                    // anything || true ==> true\n                    return ContextKeyTrueExpr.INSTANCE;\n                }\n                if (e.type === 9 /* Or */) {\n                    expr = expr.concat(e.expr);\n                    continue;\n                }\n                expr.push(e);\n            }\n            if (expr.length === 0 && hasFalse) {\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            expr.sort(cmp);\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // eliminate duplicate terms\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // eliminate redundant terms\n        if (extraRedundantCheck) {\n            for (let i = 0; i < expr.length; i++) {\n                for (let j = i + 1; j < expr.length; j++) {\n                    if (implies(expr[i], expr[j])) {\n                        expr.splice(j, 1);\n                        j--;\n                    }\n                }\n            }\n            if (expr.length === 1) {\n                return expr[0];\n            }\n        }\n        return new ContextKeyOrExpr(expr, negated);\n    }\n    serialize() {\n        return this.expr.map(e => e.serialize()).join(' || ');\n    }\n    keys() {\n        const result = [];\n        for (let expr of this.expr) {\n            result.push(...expr.keys());\n        }\n        return result;\n    }\n    negate() {\n        if (!this.negated) {\n            let result = [];\n            for (let expr of this.expr) {\n                result.push(expr.negate());\n            }\n            // We don't support parens, so here we distribute the AND over the OR terminals\n            // We always take the first 2 AND pairs and distribute them\n            while (result.length > 1) {\n                const LEFT = result.shift();\n                const RIGHT = result.shift();\n                const all = [];\n                for (const left of getTerminals(LEFT)) {\n                    for (const right of getTerminals(RIGHT)) {\n                        all.push(ContextKeyAndExpr.create([left, right], null));\n                    }\n                }\n                const isFinished = (result.length === 0);\n                result.unshift(ContextKeyOrExpr.create(all, null, isFinished));\n            }\n            this.negated = result[0];\n        }\n        return this.negated;\n    }\n}\nexport class RawContextKey extends ContextKeyDefinedExpr {\n    constructor(key, defaultValue, metaOrHide) {\n        super(key, null);\n        this._defaultValue = defaultValue;\n        // collect all context keys into a central place\n        if (typeof metaOrHide === 'object') {\n            RawContextKey._info.push(Object.assign(Object.assign({}, metaOrHide), { key }));\n        }\n        else if (metaOrHide !== true) {\n            RawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined });\n        }\n    }\n    static all() {\n        return RawContextKey._info.values();\n    }\n    bindTo(target) {\n        return target.createKey(this.key, this._defaultValue);\n    }\n    getValue(target) {\n        return target.getContextKeyValue(this.key);\n    }\n    toNegated() {\n        return this.negate();\n    }\n    isEqualTo(value) {\n        return ContextKeyEqualsExpr.create(this.key, value);\n    }\n}\nRawContextKey._info = [];\nexport const IContextKeyService = createDecorator('contextKeyService');\nexport const SET_CONTEXT_COMMAND_ID = 'setContext';\nfunction cmp1(key1, key2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    return 0;\n}\nfunction cmp2(key1, value1, key2, value2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    if (value1 < value2) {\n        return -1;\n    }\n    if (value1 > value2) {\n        return 1;\n    }\n    return 0;\n}\n/**\n * Returns true if it is provable `p` implies `q`.\n */\nexport function implies(p, q) {\n    if (q.type === 6 /* And */ && (p.type !== 9 /* Or */ && p.type !== 6 /* And */)) {\n        // covers the case: A implies A && B\n        for (const qTerm of q.expr) {\n            if (p.equals(qTerm)) {\n                return true;\n            }\n        }\n    }\n    const notP = p.negate();\n    const expr = getTerminals(notP).concat(getTerminals(q));\n    expr.sort(cmp);\n    for (let i = 0; i < expr.length; i++) {\n        const a = expr[i];\n        const notA = a.negate();\n        for (let j = i + 1; j < expr.length; j++) {\n            const b = expr[j];\n            if (notA.equals(b)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction getTerminals(node) {\n    if (node.type === 9 /* Or */) {\n        return node.expr;\n    }\n    return [node];\n}\n"]},"metadata":{},"sourceType":"module"}