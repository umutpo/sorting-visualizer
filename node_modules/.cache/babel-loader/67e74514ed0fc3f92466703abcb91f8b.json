{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IdleValue } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { SyncDescriptor } from './descriptors.js';\nimport { Graph } from './graph.js';\nimport { IInstantiationService, optional, _util } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js'; // TRACING\n\nconst _enableTracing = false;\n\nclass CyclicDependencyError extends Error {\n  constructor(graph) {\n    var _a;\n\n    super('cyclic dependency between services');\n    this.message = (_a = graph.findCycleSlow()) !== null && _a !== void 0 ? _a : `UNABLE to detect cycle, dumping graph: \\n${graph.toString()}`;\n  }\n\n}\n\nexport class InstantiationService {\n  constructor() {\n    let services = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new ServiceCollection();\n    let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let parent = arguments.length > 2 ? arguments[2] : undefined;\n    this._activeInstantiations = new Set();\n    this._services = services;\n    this._strict = strict;\n    this._parent = parent;\n\n    this._services.set(IInstantiationService, this);\n  }\n\n  createChild(services) {\n    return new InstantiationService(services, this._strict, this);\n  }\n\n  invokeFunction(fn) {\n    let _trace = Trace.traceInvocation(fn);\n\n    let _done = false;\n\n    try {\n      const accessor = {\n        get: (id, isOptional) => {\n          if (_done) {\n            throw illegalState('service accessor is only valid during the invocation of its target method');\n          }\n\n          const result = this._getOrCreateServiceInstance(id, _trace);\n\n          if (!result && isOptional !== optional) {\n            throw new Error(`[invokeFunction] unknown service '${id}'`);\n          }\n\n          return result;\n        }\n      };\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return fn(accessor, ...args);\n    } finally {\n      _done = true;\n\n      _trace.stop();\n    }\n  }\n\n  createInstance(ctorOrDescriptor) {\n    let _trace;\n\n    let result;\n\n    for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      rest[_key2 - 1] = arguments[_key2];\n    }\n\n    if (ctorOrDescriptor instanceof SyncDescriptor) {\n      _trace = Trace.traceCreation(ctorOrDescriptor.ctor);\n      result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n    } else {\n      _trace = Trace.traceCreation(ctorOrDescriptor);\n      result = this._createInstance(ctorOrDescriptor, rest, _trace);\n    }\n\n    _trace.stop();\n\n    return result;\n  }\n\n  _createInstance(ctor) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    let _trace = arguments.length > 2 ? arguments[2] : undefined;\n\n    // arguments defined by service decorators\n    let serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n\n    let serviceArgs = [];\n\n    for (const dependency of serviceDependencies) {\n      let service = this._getOrCreateServiceInstance(dependency.id, _trace);\n\n      if (!service && this._strict && !dependency.optional) {\n        throw new Error(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`);\n      }\n\n      serviceArgs.push(service);\n    }\n\n    let firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length; // check for argument mismatches, adjust static args if needed\n\n    if (args.length !== firstServiceArgPos) {\n      console.warn(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n      let delta = firstServiceArgPos - args.length;\n\n      if (delta > 0) {\n        args = args.concat(new Array(delta));\n      } else {\n        args = args.slice(0, firstServiceArgPos);\n      }\n    } // now create the instance\n\n\n    return new ctor(...[...args, ...serviceArgs]);\n  }\n\n  _setServiceInstance(id, instance) {\n    if (this._services.get(id) instanceof SyncDescriptor) {\n      this._services.set(id, instance);\n    } else if (this._parent) {\n      this._parent._setServiceInstance(id, instance);\n    } else {\n      throw new Error('illegalState - setting UNKNOWN service instance');\n    }\n  }\n\n  _getServiceInstanceOrDescriptor(id) {\n    let instanceOrDesc = this._services.get(id);\n\n    if (!instanceOrDesc && this._parent) {\n      return this._parent._getServiceInstanceOrDescriptor(id);\n    } else {\n      return instanceOrDesc;\n    }\n  }\n\n  _getOrCreateServiceInstance(id, _trace) {\n    let thing = this._getServiceInstanceOrDescriptor(id);\n\n    if (thing instanceof SyncDescriptor) {\n      return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n    } else {\n      _trace.branch(id, false);\n\n      return thing;\n    }\n  }\n\n  _safeCreateAndCacheServiceInstance(id, desc, _trace) {\n    if (this._activeInstantiations.has(id)) {\n      throw new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);\n    }\n\n    this._activeInstantiations.add(id);\n\n    try {\n      return this._createAndCacheServiceInstance(id, desc, _trace);\n    } finally {\n      this._activeInstantiations.delete(id);\n    }\n  }\n\n  _createAndCacheServiceInstance(id, desc, _trace) {\n    const graph = new Graph(data => data.id.toString());\n    let cycleCount = 0;\n    const stack = [{\n      id,\n      desc,\n      _trace\n    }];\n\n    while (stack.length) {\n      const item = stack.pop();\n      graph.lookupOrInsertNode(item); // a weak but working heuristic for cycle checks\n\n      if (cycleCount++ > 1000) {\n        throw new CyclicDependencyError(graph);\n      } // check all dependencies for existence and if they need to be created first\n\n\n      for (let dependency of _util.getServiceDependencies(item.desc.ctor)) {\n        let instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n\n        if (!instanceOrDesc && !dependency.optional) {\n          console.warn(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`);\n        }\n\n        if (instanceOrDesc instanceof SyncDescriptor) {\n          const d = {\n            id: dependency.id,\n            desc: instanceOrDesc,\n            _trace: item._trace.branch(dependency.id, true)\n          };\n          graph.insertEdge(item, d);\n          stack.push(d);\n        }\n      }\n    }\n\n    while (true) {\n      const roots = graph.roots(); // if there is no more roots but still\n      // nodes in the graph we have a cycle\n\n      if (roots.length === 0) {\n        if (!graph.isEmpty()) {\n          throw new CyclicDependencyError(graph);\n        }\n\n        break;\n      }\n\n      for (const {\n        data\n      } of roots) {\n        // Repeat the check for this still being a service sync descriptor. That's because\n        // instantiating a dependency might have side-effect and recursively trigger instantiation\n        // so that some dependencies are now fullfilled already.\n        const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n\n        if (instanceOrDesc instanceof SyncDescriptor) {\n          // create instance and overwrite the service collections\n          const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n\n          this._setServiceInstance(data.id, instance);\n        }\n\n        graph.removeNode(data);\n      }\n    }\n\n    return this._getServiceInstanceOrDescriptor(id);\n  }\n\n  _createServiceInstanceWithOwner(id, ctor) {\n    let args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let supportsDelayedInstantiation = arguments.length > 3 ? arguments[3] : undefined;\n\n    let _trace = arguments.length > 4 ? arguments[4] : undefined;\n\n    if (this._services.get(id) instanceof SyncDescriptor) {\n      return this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);\n    } else if (this._parent) {\n      return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n    } else {\n      throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);\n    }\n  }\n\n  _createServiceInstance(ctor) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    let _supportsDelayedInstantiation = arguments.length > 2 ? arguments[2] : undefined;\n\n    let _trace = arguments.length > 3 ? arguments[3] : undefined;\n\n    if (!_supportsDelayedInstantiation) {\n      // eager instantiation\n      return this._createInstance(ctor, args, _trace);\n    } else {\n      // Return a proxy object that's backed by an idle value. That\n      // strategy is to instantiate services in our idle time or when actually\n      // needed but not when injected into a consumer\n      const idle = new IdleValue(() => this._createInstance(ctor, args, _trace));\n      return new Proxy(Object.create(null), {\n        get(target, key) {\n          if (key in target) {\n            return target[key];\n          }\n\n          let obj = idle.value;\n          let prop = obj[key];\n\n          if (typeof prop !== 'function') {\n            return prop;\n          }\n\n          prop = prop.bind(obj);\n          target[key] = prop;\n          return prop;\n        },\n\n        set(_target, p, value) {\n          idle.value[p] = value;\n          return true;\n        }\n\n      });\n    }\n  }\n\n}\n\nclass Trace {\n  constructor(type, name) {\n    this.type = type;\n    this.name = name;\n    this._start = Date.now();\n    this._dep = [];\n  }\n\n  static traceInvocation(ctor) {\n    return !_enableTracing ? Trace._None : new Trace(1\n    /* Invocation */\n    , ctor.name || ctor.toString().substring(0, 42).replace(/\\n/g, ''));\n  }\n\n  static traceCreation(ctor) {\n    return !_enableTracing ? Trace._None : new Trace(0\n    /* Creation */\n    , ctor.name);\n  }\n\n  branch(id, first) {\n    let child = new Trace(2\n    /* Branch */\n    , id.toString());\n\n    this._dep.push([id, first, child]);\n\n    return child;\n  }\n\n  stop() {\n    let dur = Date.now() - this._start;\n\n    Trace._totals += dur;\n    let causedCreation = false;\n\n    function printChild(n, trace) {\n      let res = [];\n      let prefix = new Array(n + 1).join('\\t');\n\n      for (const [id, first, child] of trace._dep) {\n        if (first && child) {\n          causedCreation = true;\n          res.push(`${prefix}CREATES -> ${id}`);\n          let nested = printChild(n + 1, child);\n\n          if (nested) {\n            res.push(nested);\n          }\n        } else {\n          res.push(`${prefix}uses -> ${id}`);\n        }\n      }\n\n      return res.join('\\n');\n    }\n\n    let lines = [`${this.type === 0\n    /* Creation */\n    ? 'CREATE' : 'CALL'} ${this.name}`, `${printChild(1, this)}`, `DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`];\n\n    if (dur > 2 || causedCreation) {\n      console.log(lines.join('\\n'));\n    }\n  }\n\n}\n\nTrace._None = new class extends Trace {\n  constructor() {\n    super(-1, null);\n  }\n\n  stop() {}\n\n  branch() {\n    return this;\n  }\n\n}();\nTrace._totals = 0; //#endregion","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiationService.js"],"names":["IdleValue","illegalState","SyncDescriptor","Graph","IInstantiationService","optional","_util","ServiceCollection","_enableTracing","CyclicDependencyError","Error","constructor","graph","_a","message","findCycleSlow","toString","InstantiationService","services","strict","parent","_activeInstantiations","Set","_services","_strict","_parent","set","createChild","invokeFunction","fn","_trace","Trace","traceInvocation","_done","accessor","get","id","isOptional","result","_getOrCreateServiceInstance","args","stop","createInstance","ctorOrDescriptor","rest","traceCreation","ctor","_createInstance","staticArguments","concat","serviceDependencies","getServiceDependencies","sort","a","b","index","serviceArgs","dependency","service","name","push","firstServiceArgPos","length","console","warn","delta","Array","slice","_setServiceInstance","instance","_getServiceInstanceOrDescriptor","instanceOrDesc","thing","_safeCreateAndCacheServiceInstance","branch","desc","has","add","_createAndCacheServiceInstance","delete","data","cycleCount","stack","item","pop","lookupOrInsertNode","d","insertEdge","roots","isEmpty","_createServiceInstanceWithOwner","supportsDelayedInstantiation","removeNode","_createServiceInstance","_supportsDelayedInstantiation","idle","Proxy","Object","create","target","key","obj","value","prop","bind","_target","p","type","_start","Date","now","_dep","_None","substring","replace","first","child","dur","_totals","causedCreation","printChild","n","trace","res","prefix","join","nested","lines","toFixed","log"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IdleValue } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { SyncDescriptor } from './descriptors.js';\nimport { Graph } from './graph.js';\nimport { IInstantiationService, optional, _util } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js';\n// TRACING\nconst _enableTracing = false;\nclass CyclicDependencyError extends Error {\n    constructor(graph) {\n        var _a;\n        super('cyclic dependency between services');\n        this.message = (_a = graph.findCycleSlow()) !== null && _a !== void 0 ? _a : `UNABLE to detect cycle, dumping graph: \\n${graph.toString()}`;\n    }\n}\nexport class InstantiationService {\n    constructor(services = new ServiceCollection(), strict = false, parent) {\n        this._activeInstantiations = new Set();\n        this._services = services;\n        this._strict = strict;\n        this._parent = parent;\n        this._services.set(IInstantiationService, this);\n    }\n    createChild(services) {\n        return new InstantiationService(services, this._strict, this);\n    }\n    invokeFunction(fn, ...args) {\n        let _trace = Trace.traceInvocation(fn);\n        let _done = false;\n        try {\n            const accessor = {\n                get: (id, isOptional) => {\n                    if (_done) {\n                        throw illegalState('service accessor is only valid during the invocation of its target method');\n                    }\n                    const result = this._getOrCreateServiceInstance(id, _trace);\n                    if (!result && isOptional !== optional) {\n                        throw new Error(`[invokeFunction] unknown service '${id}'`);\n                    }\n                    return result;\n                }\n            };\n            return fn(accessor, ...args);\n        }\n        finally {\n            _done = true;\n            _trace.stop();\n        }\n    }\n    createInstance(ctorOrDescriptor, ...rest) {\n        let _trace;\n        let result;\n        if (ctorOrDescriptor instanceof SyncDescriptor) {\n            _trace = Trace.traceCreation(ctorOrDescriptor.ctor);\n            result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n        }\n        else {\n            _trace = Trace.traceCreation(ctorOrDescriptor);\n            result = this._createInstance(ctorOrDescriptor, rest, _trace);\n        }\n        _trace.stop();\n        return result;\n    }\n    _createInstance(ctor, args = [], _trace) {\n        // arguments defined by service decorators\n        let serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n        let serviceArgs = [];\n        for (const dependency of serviceDependencies) {\n            let service = this._getOrCreateServiceInstance(dependency.id, _trace);\n            if (!service && this._strict && !dependency.optional) {\n                throw new Error(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`);\n            }\n            serviceArgs.push(service);\n        }\n        let firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n        // check for argument mismatches, adjust static args if needed\n        if (args.length !== firstServiceArgPos) {\n            console.warn(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n            let delta = firstServiceArgPos - args.length;\n            if (delta > 0) {\n                args = args.concat(new Array(delta));\n            }\n            else {\n                args = args.slice(0, firstServiceArgPos);\n            }\n        }\n        // now create the instance\n        return new ctor(...[...args, ...serviceArgs]);\n    }\n    _setServiceInstance(id, instance) {\n        if (this._services.get(id) instanceof SyncDescriptor) {\n            this._services.set(id, instance);\n        }\n        else if (this._parent) {\n            this._parent._setServiceInstance(id, instance);\n        }\n        else {\n            throw new Error('illegalState - setting UNKNOWN service instance');\n        }\n    }\n    _getServiceInstanceOrDescriptor(id) {\n        let instanceOrDesc = this._services.get(id);\n        if (!instanceOrDesc && this._parent) {\n            return this._parent._getServiceInstanceOrDescriptor(id);\n        }\n        else {\n            return instanceOrDesc;\n        }\n    }\n    _getOrCreateServiceInstance(id, _trace) {\n        let thing = this._getServiceInstanceOrDescriptor(id);\n        if (thing instanceof SyncDescriptor) {\n            return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n        }\n        else {\n            _trace.branch(id, false);\n            return thing;\n        }\n    }\n    _safeCreateAndCacheServiceInstance(id, desc, _trace) {\n        if (this._activeInstantiations.has(id)) {\n            throw new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);\n        }\n        this._activeInstantiations.add(id);\n        try {\n            return this._createAndCacheServiceInstance(id, desc, _trace);\n        }\n        finally {\n            this._activeInstantiations.delete(id);\n        }\n    }\n    _createAndCacheServiceInstance(id, desc, _trace) {\n        const graph = new Graph(data => data.id.toString());\n        let cycleCount = 0;\n        const stack = [{ id, desc, _trace }];\n        while (stack.length) {\n            const item = stack.pop();\n            graph.lookupOrInsertNode(item);\n            // a weak but working heuristic for cycle checks\n            if (cycleCount++ > 1000) {\n                throw new CyclicDependencyError(graph);\n            }\n            // check all dependencies for existence and if they need to be created first\n            for (let dependency of _util.getServiceDependencies(item.desc.ctor)) {\n                let instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n                if (!instanceOrDesc && !dependency.optional) {\n                    console.warn(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`);\n                }\n                if (instanceOrDesc instanceof SyncDescriptor) {\n                    const d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\n                    graph.insertEdge(item, d);\n                    stack.push(d);\n                }\n            }\n        }\n        while (true) {\n            const roots = graph.roots();\n            // if there is no more roots but still\n            // nodes in the graph we have a cycle\n            if (roots.length === 0) {\n                if (!graph.isEmpty()) {\n                    throw new CyclicDependencyError(graph);\n                }\n                break;\n            }\n            for (const { data } of roots) {\n                // Repeat the check for this still being a service sync descriptor. That's because\n                // instantiating a dependency might have side-effect and recursively trigger instantiation\n                // so that some dependencies are now fullfilled already.\n                const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n                if (instanceOrDesc instanceof SyncDescriptor) {\n                    // create instance and overwrite the service collections\n                    const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n                    this._setServiceInstance(data.id, instance);\n                }\n                graph.removeNode(data);\n            }\n        }\n        return this._getServiceInstanceOrDescriptor(id);\n    }\n    _createServiceInstanceWithOwner(id, ctor, args = [], supportsDelayedInstantiation, _trace) {\n        if (this._services.get(id) instanceof SyncDescriptor) {\n            return this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);\n        }\n        else if (this._parent) {\n            return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n        }\n        else {\n            throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);\n        }\n    }\n    _createServiceInstance(ctor, args = [], _supportsDelayedInstantiation, _trace) {\n        if (!_supportsDelayedInstantiation) {\n            // eager instantiation\n            return this._createInstance(ctor, args, _trace);\n        }\n        else {\n            // Return a proxy object that's backed by an idle value. That\n            // strategy is to instantiate services in our idle time or when actually\n            // needed but not when injected into a consumer\n            const idle = new IdleValue(() => this._createInstance(ctor, args, _trace));\n            return new Proxy(Object.create(null), {\n                get(target, key) {\n                    if (key in target) {\n                        return target[key];\n                    }\n                    let obj = idle.value;\n                    let prop = obj[key];\n                    if (typeof prop !== 'function') {\n                        return prop;\n                    }\n                    prop = prop.bind(obj);\n                    target[key] = prop;\n                    return prop;\n                },\n                set(_target, p, value) {\n                    idle.value[p] = value;\n                    return true;\n                }\n            });\n        }\n    }\n}\nclass Trace {\n    constructor(type, name) {\n        this.type = type;\n        this.name = name;\n        this._start = Date.now();\n        this._dep = [];\n    }\n    static traceInvocation(ctor) {\n        return !_enableTracing ? Trace._None : new Trace(1 /* Invocation */, ctor.name || ctor.toString().substring(0, 42).replace(/\\n/g, ''));\n    }\n    static traceCreation(ctor) {\n        return !_enableTracing ? Trace._None : new Trace(0 /* Creation */, ctor.name);\n    }\n    branch(id, first) {\n        let child = new Trace(2 /* Branch */, id.toString());\n        this._dep.push([id, first, child]);\n        return child;\n    }\n    stop() {\n        let dur = Date.now() - this._start;\n        Trace._totals += dur;\n        let causedCreation = false;\n        function printChild(n, trace) {\n            let res = [];\n            let prefix = new Array(n + 1).join('\\t');\n            for (const [id, first, child] of trace._dep) {\n                if (first && child) {\n                    causedCreation = true;\n                    res.push(`${prefix}CREATES -> ${id}`);\n                    let nested = printChild(n + 1, child);\n                    if (nested) {\n                        res.push(nested);\n                    }\n                }\n                else {\n                    res.push(`${prefix}uses -> ${id}`);\n                }\n            }\n            return res.join('\\n');\n        }\n        let lines = [\n            `${this.type === 0 /* Creation */ ? 'CREATE' : 'CALL'} ${this.name}`,\n            `${printChild(1, this)}`,\n            `DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`\n        ];\n        if (dur > 2 || causedCreation) {\n            console.log(lines.join('\\n'));\n        }\n    }\n}\nTrace._None = new class extends Trace {\n    constructor() { super(-1, null); }\n    stop() { }\n    branch() { return this; }\n};\nTrace._totals = 0;\n//#endregion\n"]},"metadata":{},"sourceType":"module"}