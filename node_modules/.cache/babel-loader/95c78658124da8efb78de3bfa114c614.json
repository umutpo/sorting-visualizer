{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from '../core/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IndentGuide, IndentGuideHorizontalLine } from '../model.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport * as viewEvents from '../view/viewEvents.js';\nimport { PrefixSumIndexOfResult } from './prefixSumComputer.js';\nimport { SingleLineInlineDecoration, ViewLineData } from './viewModel.js';\nimport { LineInjectedText } from '../model/textModelEvents.js';\nexport class CoordinatesConverter {\n  constructor(lines) {\n    this._lines = lines;\n  } // View -> Model conversion and related methods\n\n\n  convertViewPositionToModelPosition(viewPosition) {\n    return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n  }\n\n  convertViewRangeToModelRange(viewRange) {\n    return this._lines.convertViewRangeToModelRange(viewRange);\n  }\n\n  validateViewPosition(viewPosition, expectedModelPosition) {\n    return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n  }\n\n  validateViewRange(viewRange, expectedModelRange) {\n    return this._lines.validateViewRange(viewRange, expectedModelRange);\n  } // Model -> View conversion and related methods\n\n\n  convertModelPositionToViewPosition(modelPosition, affinity) {\n    return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity);\n  }\n\n  convertModelRangeToViewRange(modelRange, affinity) {\n    return this._lines.convertModelRangeToViewRange(modelRange, affinity);\n  }\n\n  modelPositionIsVisible(modelPosition) {\n    return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n  }\n\n  getModelLineViewLineCount(modelLineNumber) {\n    return this._lines.getModelLineViewLineCount(modelLineNumber);\n  }\n\n  getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n    return this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n  }\n\n}\n\nclass LineNumberMapper {\n  constructor(viewLineCounts) {\n    this._counts = viewLineCounts;\n    this._isValid = false;\n    this._validEndIndex = -1;\n    this._modelToView = [];\n    this._viewToModel = [];\n  }\n\n  _invalidate(index) {\n    this._isValid = false;\n    this._validEndIndex = Math.min(this._validEndIndex, index - 1);\n  }\n\n  _ensureValid() {\n    if (this._isValid) {\n      return;\n    }\n\n    for (let i = this._validEndIndex + 1, len = this._counts.length; i < len; i++) {\n      const viewLineCount = this._counts[i];\n      const viewLinesAbove = i > 0 ? this._modelToView[i - 1] : 0;\n      this._modelToView[i] = viewLinesAbove + viewLineCount;\n\n      for (let j = 0; j < viewLineCount; j++) {\n        this._viewToModel[viewLinesAbove + j] = i;\n      }\n    } // trim things\n\n\n    this._modelToView.length = this._counts.length;\n    this._viewToModel.length = this._modelToView[this._modelToView.length - 1]; // mark as valid\n\n    this._isValid = true;\n    this._validEndIndex = this._counts.length - 1;\n  }\n\n  changeValue(index, value) {\n    if (this._counts[index] === value) {\n      // no change\n      return;\n    }\n\n    this._counts[index] = value;\n\n    this._invalidate(index);\n  }\n\n  removeValues(start, deleteCount) {\n    this._counts.splice(start, deleteCount);\n\n    this._invalidate(start);\n  }\n\n  insertValues(insertIndex, insertArr) {\n    this._counts = arrays.arrayInsert(this._counts, insertIndex, insertArr);\n\n    this._invalidate(insertIndex);\n  }\n\n  getTotalValue() {\n    this._ensureValid();\n\n    return this._viewToModel.length;\n  }\n\n  getAccumulatedValue(index) {\n    this._ensureValid();\n\n    return this._modelToView[index];\n  }\n\n  getIndexOf(accumulatedValue) {\n    this._ensureValid();\n\n    const modelLineIndex = this._viewToModel[accumulatedValue];\n    const viewLinesAbove = modelLineIndex > 0 ? this._modelToView[modelLineIndex - 1] : 0;\n    return new PrefixSumIndexOfResult(modelLineIndex, accumulatedValue - viewLinesAbove);\n  }\n\n}\n\nexport class SplitLinesCollection {\n  constructor(editorId, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent) {\n    this._editorId = editorId;\n    this.model = model;\n    this._validModelVersionId = -1;\n    this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n    this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n    this.fontInfo = fontInfo;\n    this.tabSize = tabSize;\n    this.wrappingStrategy = wrappingStrategy;\n    this.wrappingColumn = wrappingColumn;\n    this.wrappingIndent = wrappingIndent;\n\n    this._constructLines(\n    /*resetHiddenAreas*/\n    true, null);\n  }\n\n  dispose() {\n    this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, []);\n  }\n\n  createCoordinatesConverter() {\n    return new CoordinatesConverter(this);\n  }\n\n  _constructLines(resetHiddenAreas, previousLineBreaks) {\n    this.lines = [];\n\n    if (resetHiddenAreas) {\n      this.hiddenAreasIds = [];\n    }\n\n    const linesContent = this.model.getLinesContent();\n    const injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n    const lineCount = linesContent.length;\n    const lineBreaksComputer = this.createLineBreaksComputer();\n    const injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n\n    for (let i = 0; i < lineCount; i++) {\n      const lineInjectedText = injectedTextQueue.takeWhile(t => t.lineNumber === i + 1);\n      lineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n    }\n\n    const linesBreaks = lineBreaksComputer.finalize();\n    let values = [];\n    let hiddenAreas = this.hiddenAreasIds.map(areaId => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n    let hiddenAreaStart = 1,\n        hiddenAreaEnd = 0;\n    let hiddenAreaIdx = -1;\n    let nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : lineCount + 2;\n\n    for (let i = 0; i < lineCount; i++) {\n      let lineNumber = i + 1;\n\n      if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n        hiddenAreaIdx++;\n        hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n        hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n        nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : lineCount + 2;\n      }\n\n      let isInHiddenArea = lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd;\n      let line = createSplitLine(linesBreaks[i], !isInHiddenArea);\n      values[i] = line.getViewLineCount();\n      this.lines[i] = line;\n    }\n\n    this._validModelVersionId = this.model.getVersionId();\n    this.prefixSumComputer = new LineNumberMapper(values);\n  }\n\n  getHiddenAreas() {\n    return this.hiddenAreasIds.map(decId => {\n      return this.model.getDecorationRange(decId);\n    });\n  }\n\n  _reduceRanges(_ranges) {\n    if (_ranges.length === 0) {\n      return [];\n    }\n\n    let ranges = _ranges.map(r => this.model.validateRange(r)).sort(Range.compareRangesUsingStarts);\n\n    let result = [];\n    let currentRangeStart = ranges[0].startLineNumber;\n    let currentRangeEnd = ranges[0].endLineNumber;\n\n    for (let i = 1, len = ranges.length; i < len; i++) {\n      let range = ranges[i];\n\n      if (range.startLineNumber > currentRangeEnd + 1) {\n        result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n        currentRangeStart = range.startLineNumber;\n        currentRangeEnd = range.endLineNumber;\n      } else if (range.endLineNumber > currentRangeEnd) {\n        currentRangeEnd = range.endLineNumber;\n      }\n    }\n\n    result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n    return result;\n  }\n\n  setHiddenAreas(_ranges) {\n    let newRanges = this._reduceRanges(_ranges); // BEGIN TODO@Martin: Please stop calling this method on each model change!\n\n\n    let oldRanges = this.hiddenAreasIds.map(areaId => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n\n    if (newRanges.length === oldRanges.length) {\n      let hasDifference = false;\n\n      for (let i = 0; i < newRanges.length; i++) {\n        if (!newRanges[i].equalsRange(oldRanges[i])) {\n          hasDifference = true;\n          break;\n        }\n      }\n\n      if (!hasDifference) {\n        return false;\n      }\n    } // END TODO@Martin: Please stop calling this method on each model change!\n\n\n    let newDecorations = [];\n\n    for (const newRange of newRanges) {\n      newDecorations.push({\n        range: newRange,\n        options: ModelDecorationOptions.EMPTY\n      });\n    }\n\n    this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, newDecorations);\n    let hiddenAreas = newRanges;\n    let hiddenAreaStart = 1,\n        hiddenAreaEnd = 0;\n    let hiddenAreaIdx = -1;\n    let nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : this.lines.length + 2;\n    let hasVisibleLine = false;\n\n    for (let i = 0; i < this.lines.length; i++) {\n      let lineNumber = i + 1;\n\n      if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n        hiddenAreaIdx++;\n        hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n        hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n        nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : this.lines.length + 2;\n      }\n\n      let lineChanged = false;\n\n      if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n        // Line should be hidden\n        if (this.lines[i].isVisible()) {\n          this.lines[i] = this.lines[i].setVisible(false);\n          lineChanged = true;\n        }\n      } else {\n        hasVisibleLine = true; // Line should be visible\n\n        if (!this.lines[i].isVisible()) {\n          this.lines[i] = this.lines[i].setVisible(true);\n          lineChanged = true;\n        }\n      }\n\n      if (lineChanged) {\n        let newOutputLineCount = this.lines[i].getViewLineCount();\n        this.prefixSumComputer.changeValue(i, newOutputLineCount);\n      }\n    }\n\n    if (!hasVisibleLine) {\n      // Cannot have everything be hidden => reveal everything!\n      this.setHiddenAreas([]);\n    }\n\n    return true;\n  }\n\n  modelPositionIsVisible(modelLineNumber, _modelColumn) {\n    if (modelLineNumber < 1 || modelLineNumber > this.lines.length) {\n      // invalid arguments\n      return false;\n    }\n\n    return this.lines[modelLineNumber - 1].isVisible();\n  }\n\n  getModelLineViewLineCount(modelLineNumber) {\n    if (modelLineNumber < 1 || modelLineNumber > this.lines.length) {\n      // invalid arguments\n      return 1;\n    }\n\n    return this.lines[modelLineNumber - 1].getViewLineCount();\n  }\n\n  setTabSize(newTabSize) {\n    if (this.tabSize === newTabSize) {\n      return false;\n    }\n\n    this.tabSize = newTabSize;\n\n    this._constructLines(\n    /*resetHiddenAreas*/\n    false, null);\n\n    return true;\n  }\n\n  setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent) {\n    const equalFontInfo = this.fontInfo.equals(fontInfo);\n    const equalWrappingStrategy = this.wrappingStrategy === wrappingStrategy;\n    const equalWrappingColumn = this.wrappingColumn === wrappingColumn;\n    const equalWrappingIndent = this.wrappingIndent === wrappingIndent;\n\n    if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent) {\n      return false;\n    }\n\n    const onlyWrappingColumnChanged = equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent;\n    this.fontInfo = fontInfo;\n    this.wrappingStrategy = wrappingStrategy;\n    this.wrappingColumn = wrappingColumn;\n    this.wrappingIndent = wrappingIndent;\n    let previousLineBreaks = null;\n\n    if (onlyWrappingColumnChanged) {\n      previousLineBreaks = [];\n\n      for (let i = 0, len = this.lines.length; i < len; i++) {\n        previousLineBreaks[i] = this.lines[i].getLineBreakData();\n      }\n    }\n\n    this._constructLines(\n    /*resetHiddenAreas*/\n    false, previousLineBreaks);\n\n    return true;\n  }\n\n  createLineBreaksComputer() {\n    const lineBreaksComputerFactory = this.wrappingStrategy === 'advanced' ? this._domLineBreaksComputerFactory : this._monospaceLineBreaksComputerFactory;\n    return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent);\n  }\n\n  onModelFlushed() {\n    this._constructLines(\n    /*resetHiddenAreas*/\n    true, null);\n  }\n\n  onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n    if (!versionId || versionId <= this._validModelVersionId) {\n      // Here we check for versionId in case the lines were reconstructed in the meantime.\n      // We don't want to apply stale change events on top of a newer read model state.\n      return null;\n    }\n\n    let outputFromLineNumber = fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1;\n    let outputToLineNumber = this.prefixSumComputer.getAccumulatedValue(toLineNumber - 1);\n    this.lines.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n    this.prefixSumComputer.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n    return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n  }\n\n  onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n    if (!versionId || versionId <= this._validModelVersionId) {\n      // Here we check for versionId in case the lines were reconstructed in the meantime.\n      // We don't want to apply stale change events on top of a newer read model state.\n      return null;\n    } // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n\n\n    const isInHiddenArea = fromLineNumber > 2 && !this.lines[fromLineNumber - 2].isVisible();\n    let outputFromLineNumber = fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1;\n    let totalOutputLineCount = 0;\n    let insertLines = [];\n    let insertPrefixSumValues = [];\n\n    for (let i = 0, len = lineBreaks.length; i < len; i++) {\n      let line = createSplitLine(lineBreaks[i], !isInHiddenArea);\n      insertLines.push(line);\n      let outputLineCount = line.getViewLineCount();\n      totalOutputLineCount += outputLineCount;\n      insertPrefixSumValues[i] = outputLineCount;\n    } // TODO@Alex: use arrays.arrayInsert\n\n\n    this.lines = this.lines.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.lines.slice(fromLineNumber - 1));\n    this.prefixSumComputer.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n    return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n  }\n\n  onModelLineChanged(versionId, lineNumber, lineBreakData) {\n    if (versionId !== null && versionId <= this._validModelVersionId) {\n      // Here we check for versionId in case the lines were reconstructed in the meantime.\n      // We don't want to apply stale change events on top of a newer read model state.\n      return [false, null, null, null];\n    }\n\n    let lineIndex = lineNumber - 1;\n    let oldOutputLineCount = this.lines[lineIndex].getViewLineCount();\n    let isVisible = this.lines[lineIndex].isVisible();\n    let line = createSplitLine(lineBreakData, isVisible);\n    this.lines[lineIndex] = line;\n    let newOutputLineCount = this.lines[lineIndex].getViewLineCount();\n    let lineMappingChanged = false;\n    let changeFrom = 0;\n    let changeTo = -1;\n    let insertFrom = 0;\n    let insertTo = -1;\n    let deleteFrom = 0;\n    let deleteTo = -1;\n\n    if (oldOutputLineCount > newOutputLineCount) {\n      changeFrom = lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1;\n      changeTo = changeFrom + newOutputLineCount - 1;\n      deleteFrom = changeTo + 1;\n      deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n      lineMappingChanged = true;\n    } else if (oldOutputLineCount < newOutputLineCount) {\n      changeFrom = lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1;\n      changeTo = changeFrom + oldOutputLineCount - 1;\n      insertFrom = changeTo + 1;\n      insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n      lineMappingChanged = true;\n    } else {\n      changeFrom = lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1;\n      changeTo = changeFrom + newOutputLineCount - 1;\n    }\n\n    this.prefixSumComputer.changeValue(lineIndex, newOutputLineCount);\n    const viewLinesChangedEvent = changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo) : null;\n    const viewLinesInsertedEvent = insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null;\n    const viewLinesDeletedEvent = deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null;\n    return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n  }\n\n  acceptVersionId(versionId) {\n    this._validModelVersionId = versionId;\n\n    if (this.lines.length === 1 && !this.lines[0].isVisible()) {\n      // At least one line must be visible => reset hidden areas\n      this.setHiddenAreas([]);\n    }\n  }\n\n  getViewLineCount() {\n    return this.prefixSumComputer.getTotalValue();\n  }\n\n  _toValidViewLineNumber(viewLineNumber) {\n    if (viewLineNumber < 1) {\n      return 1;\n    }\n\n    const viewLineCount = this.getViewLineCount();\n\n    if (viewLineNumber > viewLineCount) {\n      return viewLineCount;\n    }\n\n    return viewLineNumber | 0;\n  }\n\n  getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    minLineNumber = this._toValidViewLineNumber(minLineNumber);\n    maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n    const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n    const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n    const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n    const result = this.model.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n    const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n    const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n    return {\n      startLineNumber: viewStartPosition.lineNumber,\n      endLineNumber: viewEndPosition.lineNumber,\n      indent: result.indent\n    };\n  } // #region ViewLineInfo\n\n\n  getViewLineInfo(viewLineNumber) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    let lineIndex = r.index;\n    let remainder = r.remainder;\n    return new ViewLineInfo(lineIndex + 1, remainder);\n  }\n\n  getMinColumnOfViewLine(viewLineInfo) {\n    return this.lines[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n  }\n\n  getModelStartPositionOfViewLine(viewLineInfo) {\n    const line = this.lines[viewLineInfo.modelLineNumber - 1];\n    const minViewColumn = line.getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, minViewColumn);\n    return new Position(viewLineInfo.modelLineNumber, column);\n  }\n\n  getModelEndPositionOfViewLine(viewLineInfo) {\n    const line = this.lines[viewLineInfo.modelLineNumber - 1];\n    const maxViewColumn = line.getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, maxViewColumn);\n    return new Position(viewLineInfo.modelLineNumber, column);\n  }\n\n  getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber) {\n    const startViewLine = this.getViewLineInfo(viewStartLineNumber);\n    const endViewLine = this.getViewLineInfo(viewEndLineNumber);\n    const result = new Array();\n    let lastVisibleModelPos = this.getModelStartPositionOfViewLine(startViewLine);\n    let viewLines = new Array();\n\n    for (let curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n      const line = this.lines[curModelLine - 1];\n\n      if (line.isVisible()) {\n        let startOffset = curModelLine === startViewLine.modelLineNumber ? startViewLine.modelLineWrappedLineIdx : 0;\n        let endOffset = curModelLine === endViewLine.modelLineNumber ? endViewLine.modelLineWrappedLineIdx + 1 : line.getViewLineCount();\n\n        for (let i = startOffset; i < endOffset; i++) {\n          viewLines.push(new ViewLineInfo(curModelLine, i));\n        }\n      }\n\n      if (!line.isVisible() && lastVisibleModelPos) {\n        const lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n        const modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n        result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n        viewLines = [];\n        lastVisibleModelPos = null;\n      } else if (line.isVisible() && !lastVisibleModelPos) {\n        lastVisibleModelPos = new Position(curModelLine, 1);\n      }\n    }\n\n    if (lastVisibleModelPos) {\n      const modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n      result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n    }\n\n    return result;\n  } // #endregion\n\n\n  getViewLinesBracketGuides(viewStartLineNumber, viewEndLineNumber, activeViewPosition, options) {\n    const modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n    const resultPerViewLine = [];\n\n    for (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {\n      const modelRangeStartLineNumber = group.modelRange.startLineNumber;\n      const bracketGuidesPerModelLine = this.model.getLinesBracketGuides(modelRangeStartLineNumber, group.modelRange.endLineNumber, modelActivePosition, options);\n\n      for (const viewLineInfo of group.viewLines) {\n        if (viewLineInfo.isWrappedLineContinuation && this.getMinColumnOfViewLine(viewLineInfo) === 1) {\n          // Don't add indent guides when the wrapped line continuation has no wrapping-indentation.\n          resultPerViewLine.push([]);\n        } else {\n          let bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber]; // visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n          // model-columns must be converted to view-model columns.\n\n          bracketGuides = bracketGuides.map(g => g.horizontalLine ? new IndentGuide(g.visibleColumn, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn).column)) : g);\n          resultPerViewLine.push(bracketGuides);\n        }\n      }\n    }\n\n    return resultPerViewLine;\n  }\n\n  getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n    // TODO: Use the same code as in `getViewLinesBracketGuides`.\n    // Future TODO: Merge with `getViewLinesBracketGuides`.\n    // However, this requires more refactoring of indent guides.\n    viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n    viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n    const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n    const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n    let result = [];\n    let resultRepeatCount = [];\n    let resultRepeatOption = [];\n    const modelStartLineIndex = modelStart.lineNumber - 1;\n    const modelEndLineIndex = modelEnd.lineNumber - 1;\n    let reqStart = null;\n\n    for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n      const line = this.lines[modelLineIndex];\n\n      if (line.isVisible()) {\n        let viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n        let viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n        let count = viewLineEndIndex - viewLineStartIndex + 1;\n        let option = 0\n        /* BlockNone */\n        ;\n\n        if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n          // wrapped lines should block indent guides\n          option = viewLineStartIndex === 0 ? 1\n          /* BlockSubsequent */\n          : 2\n          /* BlockAll */\n          ;\n        }\n\n        resultRepeatCount.push(count);\n        resultRepeatOption.push(option); // merge into previous request\n\n        if (reqStart === null) {\n          reqStart = new Position(modelLineIndex + 1, 0);\n        }\n      } else {\n        // hit invisible line => flush request\n        if (reqStart !== null) {\n          result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n          reqStart = null;\n        }\n      }\n    }\n\n    if (reqStart !== null) {\n      result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n      reqStart = null;\n    }\n\n    const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n    let viewIndents = new Array(viewLineCount);\n    let currIndex = 0;\n\n    for (let i = 0, len = result.length; i < len; i++) {\n      let value = result[i];\n      let count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n      let option = resultRepeatOption[i];\n      let blockAtIndex;\n\n      if (option === 2\n      /* BlockAll */\n      ) {\n        blockAtIndex = 0;\n      } else if (option === 1\n      /* BlockSubsequent */\n      ) {\n        blockAtIndex = 1;\n      } else {\n        blockAtIndex = count;\n      }\n\n      for (let j = 0; j < count; j++) {\n        if (j === blockAtIndex) {\n          value = 0;\n        }\n\n        viewIndents[currIndex++] = value;\n      }\n    }\n\n    return viewIndents;\n  }\n\n  getViewLineContent(viewLineNumber) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    let lineIndex = r.index;\n    let remainder = r.remainder;\n    return this.lines[lineIndex].getViewLineContent(this.model, lineIndex + 1, remainder);\n  }\n\n  getViewLineLength(viewLineNumber) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    let lineIndex = r.index;\n    let remainder = r.remainder;\n    return this.lines[lineIndex].getViewLineLength(this.model, lineIndex + 1, remainder);\n  }\n\n  getViewLineMinColumn(viewLineNumber) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    let lineIndex = r.index;\n    let remainder = r.remainder;\n    return this.lines[lineIndex].getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n  }\n\n  getViewLineMaxColumn(viewLineNumber) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    let lineIndex = r.index;\n    let remainder = r.remainder;\n    return this.lines[lineIndex].getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n  }\n\n  getViewLineData(viewLineNumber) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    let lineIndex = r.index;\n    let remainder = r.remainder;\n    return this.lines[lineIndex].getViewLineData(this.model, lineIndex + 1, remainder);\n  }\n\n  getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n    viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n    viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n    let start = this.prefixSumComputer.getIndexOf(viewStartLineNumber - 1);\n    let viewLineNumber = viewStartLineNumber;\n    let startModelLineIndex = start.index;\n    let startRemainder = start.remainder;\n    let result = [];\n\n    for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n      let line = this.lines[modelLineIndex];\n\n      if (!line.isVisible()) {\n        continue;\n      }\n\n      let fromViewLineIndex = modelLineIndex === startModelLineIndex ? startRemainder : 0;\n      let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n      let lastLine = false;\n\n      if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n        lastLine = true;\n        remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n      }\n\n      let toViewLineIndex = fromViewLineIndex + remainingViewLineCount;\n      line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, toViewLineIndex, viewLineNumber - viewStartLineNumber, needed, result);\n      viewLineNumber += remainingViewLineCount;\n\n      if (lastLine) {\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    let lineIndex = r.index;\n    let remainder = r.remainder;\n    let line = this.lines[lineIndex];\n    let minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n    let maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n\n    if (viewColumn < minColumn) {\n      viewColumn = minColumn;\n    }\n\n    if (viewColumn > maxColumn) {\n      viewColumn = maxColumn;\n    }\n\n    let computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n    let computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n\n    if (computedModelPosition.equals(expectedModelPosition)) {\n      return new Position(viewLineNumber, viewColumn);\n    }\n\n    return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n  }\n\n  validateViewRange(viewRange, expectedModelRange) {\n    const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n    const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n    return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n  }\n\n  convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    let lineIndex = r.index;\n    let remainder = r.remainder;\n    let inputColumn = this.lines[lineIndex].getModelColumnOfViewPosition(remainder, viewColumn); // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n\n    return this.model.validatePosition(new Position(lineIndex + 1, inputColumn));\n  }\n\n  convertViewRangeToModelRange(viewRange) {\n    const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n    const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n  }\n\n  convertModelPositionToViewPosition(_modelLineNumber, _modelColumn) {\n    let affinity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n    const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n    const inputLineNumber = validPosition.lineNumber;\n    const inputColumn = validPosition.column;\n    let lineIndex = inputLineNumber - 1,\n        lineIndexChanged = false;\n\n    while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\n      lineIndex--;\n      lineIndexChanged = true;\n    }\n\n    if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\n      // Could not reach a real line\n      // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n      return new Position(1, 1);\n    }\n\n    const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n    let r;\n\n    if (lineIndexChanged) {\n      r = this.lines[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n    } else {\n      r = this.lines[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n    } // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n\n\n    return r;\n  }\n  /**\n   * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n  */\n\n\n  convertModelRangeToViewRange(modelRange) {\n    let affinity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    if (modelRange.isEmpty()) {\n      const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n      return Range.fromPositions(start);\n    } else {\n      const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, 1\n      /* Right */\n      );\n      const end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, 0\n      /* Left */\n      );\n      return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n  }\n\n  getViewLineNumberOfModelPosition(inputLineNumber, inputColumn) {\n    let lineIndex = inputLineNumber - 1;\n\n    if (this.lines[lineIndex].isVisible()) {\n      // this model line is visible\n      const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n      return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn);\n    } // this model line is not visible\n\n\n    while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\n      lineIndex--;\n    }\n\n    if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\n      // Could not reach a real line\n      return 1;\n    }\n\n    const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n    return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n  }\n\n  getDecorationsInRange(range, ownerId, filterOutValidation) {\n    const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n    const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n\n    if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n      // most likely there are no hidden lines => fast path\n      // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n      return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);\n    }\n\n    let result = [];\n    const modelStartLineIndex = modelStart.lineNumber - 1;\n    const modelEndLineIndex = modelEnd.lineNumber - 1;\n    let reqStart = null;\n\n    for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n      const line = this.lines[modelLineIndex];\n\n      if (line.isVisible()) {\n        // merge into previous request\n        if (reqStart === null) {\n          reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n        }\n      } else {\n        // hit invisible line => flush request\n        if (reqStart !== null) {\n          const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n          result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));\n          reqStart = null;\n        }\n      }\n    }\n\n    if (reqStart !== null) {\n      result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));\n      reqStart = null;\n    }\n\n    result.sort((a, b) => {\n      const res = Range.compareRangesUsingStarts(a.range, b.range);\n\n      if (res === 0) {\n        if (a.id < b.id) {\n          return -1;\n        }\n\n        if (a.id > b.id) {\n          return 1;\n        }\n\n        return 0;\n      }\n\n      return res;\n    }); // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n\n    let finalResult = [],\n        finalResultLen = 0;\n    let prevDecId = null;\n\n    for (const dec of result) {\n      const decId = dec.id;\n\n      if (prevDecId === decId) {\n        // skip\n        continue;\n      }\n\n      prevDecId = decId;\n      finalResult[finalResultLen++] = dec;\n    }\n\n    return finalResult;\n  }\n\n  getInjectedTextAt(position) {\n    const viewLineNumber = this._toValidViewLineNumber(position.lineNumber);\n\n    const r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    const lineIndex = r.index;\n    const remainder = r.remainder;\n    return this.lines[lineIndex].getInjectedTextAt(remainder, position.column);\n  }\n\n  normalizePosition(position, affinity) {\n    const viewLineNumber = this._toValidViewLineNumber(position.lineNumber);\n\n    const r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    const lineIndex = r.index;\n    const remainder = r.remainder;\n    return this.lines[lineIndex].normalizePosition(this.model, lineIndex + 1, remainder, position, affinity);\n  }\n\n  getLineIndentColumn(lineNumber) {\n    const viewLineNumber = this._toValidViewLineNumber(lineNumber);\n\n    const r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    const lineIndex = r.index;\n    const remainder = r.remainder;\n\n    if (remainder === 0) {\n      return this.model.getLineIndentColumn(lineIndex + 1);\n    } // wrapped lines have no indentation.\n    // We deliberately don't handle the case that indentation is wrapped\n    // to avoid two view lines reporting indentation for the very same model line.\n\n\n    return 0;\n  }\n\n}\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\n\nclass ViewLineInfo {\n  constructor(modelLineNumber, modelLineWrappedLineIdx) {\n    this.modelLineNumber = modelLineNumber;\n    this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;\n  }\n\n  get isWrappedLineContinuation() {\n    return this.modelLineWrappedLineIdx > 0;\n  }\n\n}\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\n\n\nclass ViewLineInfoGroupedByModelRange {\n  constructor(modelRange, viewLines) {\n    this.modelRange = modelRange;\n    this.viewLines = viewLines;\n  }\n\n}\n\nclass VisibleIdentitySplitLine {\n  constructor() {}\n\n  isVisible() {\n    return true;\n  }\n\n  setVisible(isVisible) {\n    if (isVisible) {\n      return this;\n    }\n\n    return InvisibleIdentitySplitLine.INSTANCE;\n  }\n\n  getLineBreakData() {\n    return null;\n  }\n\n  getViewLineCount() {\n    return 1;\n  }\n\n  getViewLineContent(model, modelLineNumber, _outputLineIndex) {\n    return model.getLineContent(modelLineNumber);\n  }\n\n  getViewLineLength(model, modelLineNumber, _outputLineIndex) {\n    return model.getLineLength(modelLineNumber);\n  }\n\n  getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {\n    return model.getLineMinColumn(modelLineNumber);\n  }\n\n  getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {\n    return model.getLineMaxColumn(modelLineNumber);\n  }\n\n  getViewLineData(model, modelLineNumber, _outputLineIndex) {\n    let lineTokens = model.getLineTokens(modelLineNumber);\n    let lineContent = lineTokens.getLineContent();\n    return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n  }\n\n  getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\n    if (!needed[globalStartIndex]) {\n      result[globalStartIndex] = null;\n      return;\n    }\n\n    result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n  }\n\n  getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {\n    return outputColumn;\n  }\n\n  getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n    return new Position(deltaLineNumber, inputColumn);\n  }\n\n  getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {\n    return deltaLineNumber;\n  }\n\n  normalizePosition(model, modelLineNumber, outputLineIndex, outputPosition, affinity) {\n    return outputPosition;\n  }\n\n  getInjectedTextAt(_outputLineIndex, _outputColumn) {\n    return null;\n  }\n\n}\n\nVisibleIdentitySplitLine.INSTANCE = new VisibleIdentitySplitLine();\n\nclass InvisibleIdentitySplitLine {\n  constructor() {}\n\n  isVisible() {\n    return false;\n  }\n\n  setVisible(isVisible) {\n    if (!isVisible) {\n      return this;\n    }\n\n    return VisibleIdentitySplitLine.INSTANCE;\n  }\n\n  getLineBreakData() {\n    return null;\n  }\n\n  getViewLineCount() {\n    return 0;\n  }\n\n  getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  }\n\n  getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  }\n\n  getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  }\n\n  getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  }\n\n  getViewLineData(_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  }\n\n  getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\n    throw new Error('Not supported');\n  }\n\n  getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {\n    throw new Error('Not supported');\n  }\n\n  getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {\n    throw new Error('Not supported');\n  }\n\n  getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {\n    throw new Error('Not supported');\n  }\n\n  normalizePosition(model, modelLineNumber, outputLineIndex, outputPosition, affinity) {\n    throw new Error('Not supported');\n  }\n\n  getInjectedTextAt(_outputLineIndex, _outputColumn) {\n    throw new Error('Not supported');\n  }\n\n}\n\nInvisibleIdentitySplitLine.INSTANCE = new InvisibleIdentitySplitLine();\nexport class SplitLine {\n  constructor(lineBreakData, isVisible) {\n    this._lineBreakData = lineBreakData;\n    this._isVisible = isVisible;\n  }\n\n  isVisible() {\n    return this._isVisible;\n  }\n\n  setVisible(isVisible) {\n    this._isVisible = isVisible;\n    return this;\n  }\n\n  getLineBreakData() {\n    return this._lineBreakData;\n  }\n\n  getViewLineCount() {\n    if (!this._isVisible) {\n      return 0;\n    }\n\n    return this._lineBreakData.breakOffsets.length;\n  }\n\n  getInputStartOffsetOfOutputLineIndex(outputLineIndex) {\n    return this._lineBreakData.getInputOffsetOfOutputPosition(outputLineIndex, 0);\n  }\n\n  getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex) {\n    if (outputLineIndex + 1 === this._lineBreakData.breakOffsets.length) {\n      return model.getLineMaxColumn(modelLineNumber) - 1;\n    }\n\n    return this._lineBreakData.getInputOffsetOfOutputPosition(outputLineIndex + 1, 0);\n  }\n\n  getViewLineContent(model, modelLineNumber, outputLineIndex) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    } // These offsets refer to model text with injected text.\n\n\n    const startOffset = outputLineIndex > 0 ? this._lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n    const endOffset = outputLineIndex < this._lineBreakData.breakOffsets.length ? this._lineBreakData.breakOffsets[outputLineIndex] // This case might not be possible anyway, but we clamp the value to be on the safe side.\n    : this._lineBreakData.breakOffsets[this._lineBreakData.breakOffsets.length - 1];\n    let r;\n\n    if (this._lineBreakData.injectionOffsets !== null) {\n      const injectedTexts = this._lineBreakData.injectionOffsets.map((offset, idx) => new LineInjectedText(0, 0, offset + 1, this._lineBreakData.injectionOptions[idx], 0));\n\n      r = LineInjectedText.applyInjectedText(model.getLineContent(modelLineNumber), injectedTexts).substring(startOffset, endOffset);\n    } else {\n      r = model.getValueInRange({\n        startLineNumber: modelLineNumber,\n        startColumn: startOffset + 1,\n        endLineNumber: modelLineNumber,\n        endColumn: endOffset + 1\n      });\n    }\n\n    if (outputLineIndex > 0) {\n      r = spaces(this._lineBreakData.wrappedTextIndentLength) + r;\n    }\n\n    return r;\n  }\n\n  getViewLineLength(model, modelLineNumber, outputLineIndex) {\n    // TODO @hediet make this method a member of LineBreakData.\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    } // These offsets refer to model text with injected text.\n\n\n    const startOffset = outputLineIndex > 0 ? this._lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n    const endOffset = outputLineIndex < this._lineBreakData.breakOffsets.length ? this._lineBreakData.breakOffsets[outputLineIndex] // This case might not be possible anyway, but we clamp the value to be on the safe side.\n    : this._lineBreakData.breakOffsets[this._lineBreakData.breakOffsets.length - 1];\n    let r = endOffset - startOffset;\n\n    if (outputLineIndex > 0) {\n      r = this._lineBreakData.wrappedTextIndentLength + r;\n    }\n\n    return r;\n  }\n\n  getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n\n    return this._getViewLineMinColumn(outputLineIndex);\n  }\n\n  _getViewLineMinColumn(outputLineIndex) {\n    if (outputLineIndex > 0) {\n      return this._lineBreakData.wrappedTextIndentLength + 1;\n    }\n\n    return 1;\n  }\n\n  getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n\n    return this.getViewLineLength(model, modelLineNumber, outputLineIndex) + 1;\n  }\n\n  getViewLineData(model, modelLineNumber, outputLineIndex) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n\n    const lineBreakData = this._lineBreakData;\n    const deltaStartIndex = outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0;\n    const injectionOffsets = lineBreakData.injectionOffsets;\n    const injectionOptions = lineBreakData.injectionOptions;\n    let lineContent;\n    let tokens;\n    let inlineDecorations;\n\n    if (injectionOffsets) {\n      const lineTokens = model.getLineTokens(modelLineNumber).withInserted(injectionOffsets.map((offset, idx) => ({\n        offset,\n        text: injectionOptions[idx].content,\n        tokenMetadata: LineTokens.defaultTokenMetadata\n      })));\n      const lineStartOffsetInUnwrappedLine = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n      const lineEndOffsetInUnwrappedLine = lineBreakData.breakOffsets[outputLineIndex];\n      lineContent = lineTokens.getLineContent().substring(lineStartOffsetInUnwrappedLine, lineEndOffsetInUnwrappedLine);\n      tokens = lineTokens.sliceAndInflate(lineStartOffsetInUnwrappedLine, lineEndOffsetInUnwrappedLine, deltaStartIndex);\n      inlineDecorations = new Array();\n      let totalInjectedTextLengthBefore = 0;\n\n      for (let i = 0; i < injectionOffsets.length; i++) {\n        const length = injectionOptions[i].content.length;\n        const injectedTextStartOffsetInUnwrappedLine = injectionOffsets[i] + totalInjectedTextLengthBefore;\n        const injectedTextEndOffsetInUnwrappedLine = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n\n        if (injectedTextStartOffsetInUnwrappedLine > lineEndOffsetInUnwrappedLine) {\n          // Injected text only starts in later wrapped lines.\n          break;\n        }\n\n        if (lineStartOffsetInUnwrappedLine < injectedTextEndOffsetInUnwrappedLine) {\n          // Injected text ends after or in this line (but also starts in or before this line).\n          const options = injectionOptions[i];\n\n          if (options.inlineClassName) {\n            const offset = outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0;\n            const start = offset + Math.max(injectedTextStartOffsetInUnwrappedLine - lineStartOffsetInUnwrappedLine, 0);\n            const end = offset + Math.min(injectedTextEndOffsetInUnwrappedLine - lineStartOffsetInUnwrappedLine, lineEndOffsetInUnwrappedLine);\n\n            if (start !== end) {\n              inlineDecorations.push(new SingleLineInlineDecoration(start, end, options.inlineClassName, options.inlineClassNameAffectsLetterSpacing));\n            }\n          }\n        }\n\n        totalInjectedTextLengthBefore += length;\n      }\n    } else {\n      const startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n      const endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n      const lineTokens = model.getLineTokens(modelLineNumber);\n      lineContent = model.getValueInRange({\n        startLineNumber: modelLineNumber,\n        startColumn: startOffset + 1,\n        endLineNumber: modelLineNumber,\n        endColumn: endOffset + 1\n      });\n      tokens = lineTokens.sliceAndInflate(startOffset, endOffset, deltaStartIndex);\n      inlineDecorations = null;\n    }\n\n    if (outputLineIndex > 0) {\n      lineContent = spaces(lineBreakData.wrappedTextIndentLength) + lineContent;\n    }\n\n    const minColumn = outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength + 1 : 1;\n    const maxColumn = lineContent.length + 1;\n    const continuesWithWrappedLine = outputLineIndex + 1 < this.getViewLineCount();\n    const startVisibleColumn = outputLineIndex === 0 ? 0 : lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1];\n    return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations);\n  }\n\n  getViewLinesData(model, modelLineNumber, fromOuputLineIndex, toOutputLineIndex, globalStartIndex, needed, result) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n\n    for (let outputLineIndex = fromOuputLineIndex; outputLineIndex < toOutputLineIndex; outputLineIndex++) {\n      let globalIndex = globalStartIndex + outputLineIndex - fromOuputLineIndex;\n\n      if (!needed[globalIndex]) {\n        result[globalIndex] = null;\n        continue;\n      }\n\n      result[globalIndex] = this.getViewLineData(model, modelLineNumber, outputLineIndex);\n    }\n  }\n\n  getModelColumnOfViewPosition(outputLineIndex, outputColumn) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n\n    let adjustedColumn = outputColumn - 1;\n\n    if (outputLineIndex > 0) {\n      if (adjustedColumn < this._lineBreakData.wrappedTextIndentLength) {\n        adjustedColumn = 0;\n      } else {\n        adjustedColumn -= this._lineBreakData.wrappedTextIndentLength;\n      }\n    }\n\n    return this._lineBreakData.getInputOffsetOfOutputPosition(outputLineIndex, adjustedColumn) + 1;\n  }\n\n  getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n    let affinity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n\n    let r = this._lineBreakData.getOutputPositionOfInputOffset(inputColumn - 1, affinity);\n\n    let outputLineIndex = r.outputLineIndex;\n    let outputColumn = r.outputOffset + 1;\n\n    if (outputLineIndex > 0) {\n      outputColumn += this._lineBreakData.wrappedTextIndentLength;\n    } //\t\tconsole.log('in -> out ' + deltaLineNumber + ',' + inputColumn + ' ===> ' + (deltaLineNumber+outputLineIndex) + ',' + outputColumn);\n\n\n    return new Position(deltaLineNumber + outputLineIndex, outputColumn);\n  }\n\n  getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n\n    const r = this._lineBreakData.getOutputPositionOfInputOffset(inputColumn - 1);\n\n    return deltaLineNumber + r.outputLineIndex;\n  }\n\n  normalizePosition(model, modelLineNumber, outputLineIndex, outputPosition, affinity) {\n    if (this._lineBreakData.injectionOffsets !== null) {\n      const baseViewLineNumber = outputPosition.lineNumber - outputLineIndex;\n\n      const offsetInUnwrappedLine = this._lineBreakData.outputPositionToOffsetInUnwrappedLine(outputLineIndex, outputPosition.column - 1);\n\n      const normalizedOffsetInUnwrappedLine = this._lineBreakData.normalizeOffsetAroundInjections(offsetInUnwrappedLine, affinity);\n\n      if (normalizedOffsetInUnwrappedLine !== offsetInUnwrappedLine) {\n        // injected text caused a change\n        return this._lineBreakData.getOutputPositionOfOffsetInUnwrappedLine(normalizedOffsetInUnwrappedLine, affinity).toPosition(baseViewLineNumber, this._lineBreakData.wrappedTextIndentLength);\n      }\n    }\n\n    if (affinity === 0\n    /* Left */\n    ) {\n      if (outputLineIndex > 0 && outputPosition.column === this._getViewLineMinColumn(outputLineIndex)) {\n        return new Position(outputPosition.lineNumber - 1, this.getViewLineMaxColumn(model, modelLineNumber, outputLineIndex - 1));\n      }\n    } else if (affinity === 1\n    /* Right */\n    ) {\n      const maxOutputLineIndex = this.getViewLineCount() - 1;\n\n      if (outputLineIndex < maxOutputLineIndex && outputPosition.column === this.getViewLineMaxColumn(model, modelLineNumber, outputLineIndex)) {\n        return new Position(outputPosition.lineNumber + 1, this._getViewLineMinColumn(outputLineIndex + 1));\n      }\n    }\n\n    return outputPosition;\n  }\n\n  getInjectedTextAt(outputLineIndex, outputColumn) {\n    return this._lineBreakData.getInjectedText(outputLineIndex, outputColumn - 1);\n  }\n\n}\nlet _spaces = [''];\n\nfunction spaces(count) {\n  if (count >= _spaces.length) {\n    for (let i = 1; i <= count; i++) {\n      _spaces[i] = _makeSpaces(i);\n    }\n  }\n\n  return _spaces[count];\n}\n\nfunction _makeSpaces(count) {\n  return new Array(count + 1).join(' ');\n}\n\nfunction createSplitLine(lineBreakData, isVisible) {\n  if (lineBreakData === null) {\n    // No mapping needed\n    if (isVisible) {\n      return VisibleIdentitySplitLine.INSTANCE;\n    }\n\n    return InvisibleIdentitySplitLine.INSTANCE;\n  } else {\n    return new SplitLine(lineBreakData, isVisible);\n  }\n}\n\nexport class IdentityCoordinatesConverter {\n  constructor(lines) {\n    this._lines = lines;\n  }\n\n  _validPosition(pos) {\n    return this._lines.model.validatePosition(pos);\n  }\n\n  _validRange(range) {\n    return this._lines.model.validateRange(range);\n  } // View -> Model conversion and related methods\n\n\n  convertViewPositionToModelPosition(viewPosition) {\n    return this._validPosition(viewPosition);\n  }\n\n  convertViewRangeToModelRange(viewRange) {\n    return this._validRange(viewRange);\n  }\n\n  validateViewPosition(_viewPosition, expectedModelPosition) {\n    return this._validPosition(expectedModelPosition);\n  }\n\n  validateViewRange(_viewRange, expectedModelRange) {\n    return this._validRange(expectedModelRange);\n  } // Model -> View conversion and related methods\n\n\n  convertModelPositionToViewPosition(modelPosition) {\n    return this._validPosition(modelPosition);\n  }\n\n  convertModelRangeToViewRange(modelRange) {\n    return this._validRange(modelRange);\n  }\n\n  modelPositionIsVisible(modelPosition) {\n    const lineCount = this._lines.model.getLineCount();\n\n    if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n      // invalid arguments\n      return false;\n    }\n\n    return true;\n  }\n\n  getModelLineViewLineCount(modelLineNumber) {\n    return 1;\n  }\n\n  getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n    return modelLineNumber;\n  }\n\n}\nexport class IdentityLinesCollection {\n  constructor(model) {\n    this.model = model;\n  }\n\n  dispose() {}\n\n  createCoordinatesConverter() {\n    return new IdentityCoordinatesConverter(this);\n  }\n\n  getHiddenAreas() {\n    return [];\n  }\n\n  setHiddenAreas(_ranges) {\n    return false;\n  }\n\n  setTabSize(_newTabSize) {\n    return false;\n  }\n\n  setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n    return false;\n  }\n\n  createLineBreaksComputer() {\n    let result = [];\n    return {\n      addRequest: (lineText, injectedText, previousLineBreakData) => {\n        result.push(null);\n      },\n      finalize: () => {\n        return result;\n      }\n    };\n  }\n\n  onModelFlushed() {}\n\n  onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n    return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n  }\n\n  onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n    return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n  }\n\n  onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n    return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, lineNumber), null, null];\n  }\n\n  acceptVersionId(_versionId) {}\n\n  getViewLineCount() {\n    return this.model.getLineCount();\n  }\n\n  getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n    return {\n      startLineNumber: viewLineNumber,\n      endLineNumber: viewLineNumber,\n      indent: 0\n    };\n  }\n\n  getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition) {\n    return new Array(endLineNumber - startLineNumber + 1).fill([]);\n  }\n\n  getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n    const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n    let result = new Array(viewLineCount);\n\n    for (let i = 0; i < viewLineCount; i++) {\n      result[i] = 0;\n    }\n\n    return result;\n  }\n\n  getViewLineContent(viewLineNumber) {\n    return this.model.getLineContent(viewLineNumber);\n  }\n\n  getViewLineLength(viewLineNumber) {\n    return this.model.getLineLength(viewLineNumber);\n  }\n\n  getViewLineMinColumn(viewLineNumber) {\n    return this.model.getLineMinColumn(viewLineNumber);\n  }\n\n  getViewLineMaxColumn(viewLineNumber) {\n    return this.model.getLineMaxColumn(viewLineNumber);\n  }\n\n  getViewLineData(viewLineNumber) {\n    let lineTokens = this.model.getLineTokens(viewLineNumber);\n    let lineContent = lineTokens.getLineContent();\n    return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n  }\n\n  getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n    const lineCount = this.model.getLineCount();\n    viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n    viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n    let result = [];\n\n    for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n      let idx = lineNumber - viewStartLineNumber;\n\n      if (!needed[idx]) {\n        result[idx] = null;\n      }\n\n      result[idx] = this.getViewLineData(lineNumber);\n    }\n\n    return result;\n  }\n\n  getDecorationsInRange(range, ownerId, filterOutValidation) {\n    return this.model.getDecorationsInRange(range, ownerId, filterOutValidation);\n  }\n\n  normalizePosition(position, affinity) {\n    return this.model.normalizePosition(position, affinity);\n  }\n\n  getLineIndentColumn(lineNumber) {\n    return this.model.getLineIndentColumn(lineNumber);\n  }\n\n  getInjectedTextAt(position) {\n    // Identity lines collection does not support injected text.\n    return null;\n  }\n\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/common/viewModel/splitLinesCollection.js"],"names":["arrays","LineTokens","Position","Range","IndentGuide","IndentGuideHorizontalLine","ModelDecorationOptions","viewEvents","PrefixSumIndexOfResult","SingleLineInlineDecoration","ViewLineData","LineInjectedText","CoordinatesConverter","constructor","lines","_lines","convertViewPositionToModelPosition","viewPosition","lineNumber","column","convertViewRangeToModelRange","viewRange","validateViewPosition","expectedModelPosition","validateViewRange","expectedModelRange","convertModelPositionToViewPosition","modelPosition","affinity","convertModelRangeToViewRange","modelRange","modelPositionIsVisible","getModelLineViewLineCount","modelLineNumber","getViewLineNumberOfModelPosition","modelColumn","LineNumberMapper","viewLineCounts","_counts","_isValid","_validEndIndex","_modelToView","_viewToModel","_invalidate","index","Math","min","_ensureValid","i","len","length","viewLineCount","viewLinesAbove","j","changeValue","value","removeValues","start","deleteCount","splice","insertValues","insertIndex","insertArr","arrayInsert","getTotalValue","getAccumulatedValue","getIndexOf","accumulatedValue","modelLineIndex","SplitLinesCollection","editorId","model","domLineBreaksComputerFactory","monospaceLineBreaksComputerFactory","fontInfo","tabSize","wrappingStrategy","wrappingColumn","wrappingIndent","_editorId","_validModelVersionId","_domLineBreaksComputerFactory","_monospaceLineBreaksComputerFactory","_constructLines","dispose","hiddenAreasIds","deltaDecorations","createCoordinatesConverter","resetHiddenAreas","previousLineBreaks","linesContent","getLinesContent","injectedTextDecorations","getInjectedTextDecorations","lineCount","lineBreaksComputer","createLineBreaksComputer","injectedTextQueue","ArrayQueue","fromDecorations","lineInjectedText","takeWhile","t","addRequest","linesBreaks","finalize","values","hiddenAreas","map","areaId","getDecorationRange","sort","compareRangesUsingStarts","hiddenAreaStart","hiddenAreaEnd","hiddenAreaIdx","nextLineNumberToUpdateHiddenArea","startLineNumber","endLineNumber","isInHiddenArea","line","createSplitLine","getViewLineCount","getVersionId","prefixSumComputer","getHiddenAreas","decId","_reduceRanges","_ranges","ranges","r","validateRange","result","currentRangeStart","currentRangeEnd","range","push","setHiddenAreas","newRanges","oldRanges","hasDifference","equalsRange","newDecorations","newRange","options","EMPTY","hasVisibleLine","lineChanged","isVisible","setVisible","newOutputLineCount","_modelColumn","setTabSize","newTabSize","setWrappingSettings","equalFontInfo","equals","equalWrappingStrategy","equalWrappingColumn","equalWrappingIndent","onlyWrappingColumnChanged","getLineBreakData","lineBreaksComputerFactory","onModelFlushed","onModelLinesDeleted","versionId","fromLineNumber","toLineNumber","outputFromLineNumber","outputToLineNumber","ViewLinesDeletedEvent","onModelLinesInserted","_toLineNumber","lineBreaks","totalOutputLineCount","insertLines","insertPrefixSumValues","outputLineCount","slice","concat","ViewLinesInsertedEvent","onModelLineChanged","lineBreakData","lineIndex","oldOutputLineCount","lineMappingChanged","changeFrom","changeTo","insertFrom","insertTo","deleteFrom","deleteTo","viewLinesChangedEvent","ViewLinesChangedEvent","viewLinesInsertedEvent","viewLinesDeletedEvent","acceptVersionId","_toValidViewLineNumber","viewLineNumber","getActiveIndentGuide","minLineNumber","maxLineNumber","getViewLineMinColumn","modelMinPosition","modelMaxPosition","viewStartPosition","viewEndPosition","getLineMaxColumn","indent","getViewLineInfo","remainder","ViewLineInfo","getMinColumnOfViewLine","viewLineInfo","modelLineWrappedLineIdx","getModelStartPositionOfViewLine","minViewColumn","getModelColumnOfViewPosition","getModelEndPositionOfViewLine","maxViewColumn","getViewLineMaxColumn","getViewLineInfosGroupedByModelRanges","viewStartLineNumber","viewEndLineNumber","startViewLine","endViewLine","Array","lastVisibleModelPos","viewLines","curModelLine","startOffset","endOffset","lastVisibleModelPos2","fromPositions","ViewLineInfoGroupedByModelRange","getViewLinesBracketGuides","activeViewPosition","modelActivePosition","resultPerViewLine","group","modelRangeStartLineNumber","bracketGuidesPerModelLine","getLinesBracketGuides","isWrappedLineContinuation","bracketGuides","g","horizontalLine","visibleColumn","className","top","endColumn","getViewLinesIndentGuides","modelStart","modelEnd","resultRepeatCount","resultRepeatOption","modelStartLineIndex","modelEndLineIndex","reqStart","viewLineStartIndex","viewLineEndIndex","count","option","getLinesIndentGuides","viewIndents","currIndex","blockAtIndex","getViewLineContent","getViewLineLength","getViewLineData","getViewLinesData","needed","startModelLineIndex","startRemainder","getLineCount","fromViewLineIndex","remainingViewLineCount","lastLine","toViewLineIndex","viewColumn","minColumn","maxColumn","computedModelColumn","computedModelPosition","validatePosition","validViewStart","startColumn","getStartPosition","validViewEnd","getEndPosition","inputColumn","end","_modelLineNumber","validPosition","inputLineNumber","lineIndexChanged","deltaLineNumber","getViewPositionOfModelPosition","isEmpty","getDecorationsInRange","ownerId","filterOutValidation","maxLineColumn","a","b","res","id","finalResult","finalResultLen","prevDecId","dec","getInjectedTextAt","position","normalizePosition","getLineIndentColumn","VisibleIdentitySplitLine","InvisibleIdentitySplitLine","INSTANCE","_outputLineIndex","getLineContent","getLineLength","getLineMinColumn","lineTokens","getLineTokens","lineContent","inflate","_fromOuputLineIndex","_toOutputLineIndex","globalStartIndex","outputColumn","_inputColumn","outputLineIndex","outputPosition","_outputColumn","_model","Error","_globalStartIndex","_needed","_result","_deltaLineNumber","SplitLine","_lineBreakData","_isVisible","breakOffsets","getInputStartOffsetOfOutputLineIndex","getInputOffsetOfOutputPosition","getInputEndOffsetOfOutputLineIndex","injectionOffsets","injectedTexts","offset","idx","injectionOptions","applyInjectedText","substring","getValueInRange","spaces","wrappedTextIndentLength","_getViewLineMinColumn","deltaStartIndex","tokens","inlineDecorations","withInserted","text","content","tokenMetadata","defaultTokenMetadata","lineStartOffsetInUnwrappedLine","lineEndOffsetInUnwrappedLine","sliceAndInflate","totalInjectedTextLengthBefore","injectedTextStartOffsetInUnwrappedLine","injectedTextEndOffsetInUnwrappedLine","inlineClassName","max","inlineClassNameAffectsLetterSpacing","continuesWithWrappedLine","startVisibleColumn","breakOffsetsVisibleColumn","fromOuputLineIndex","toOutputLineIndex","globalIndex","adjustedColumn","getOutputPositionOfInputOffset","outputOffset","baseViewLineNumber","offsetInUnwrappedLine","outputPositionToOffsetInUnwrappedLine","normalizedOffsetInUnwrappedLine","normalizeOffsetAroundInjections","getOutputPositionOfOffsetInUnwrappedLine","toPosition","maxOutputLineIndex","getInjectedText","_spaces","_makeSpaces","join","IdentityCoordinatesConverter","_validPosition","pos","_validRange","_viewPosition","_viewRange","IdentityLinesCollection","_newTabSize","_fontInfo","_wrappingStrategy","_wrappingColumn","_wrappingIndent","lineText","injectedText","previousLineBreakData","_versionId","_minLineNumber","_maxLineNumber","activePosition","fill"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from '../core/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IndentGuide, IndentGuideHorizontalLine } from '../model.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport * as viewEvents from '../view/viewEvents.js';\nimport { PrefixSumIndexOfResult } from './prefixSumComputer.js';\nimport { SingleLineInlineDecoration, ViewLineData } from './viewModel.js';\nimport { LineInjectedText } from '../model/textModelEvents.js';\nexport class CoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._lines.convertViewRangeToModelRange(viewRange);\n    }\n    validateViewPosition(viewPosition, expectedModelPosition) {\n        return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        return this._lines.validateViewRange(viewRange, expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition, affinity) {\n        return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity);\n    }\n    convertModelRangeToViewRange(modelRange, affinity) {\n        return this._lines.convertModelRangeToViewRange(modelRange, affinity);\n    }\n    modelPositionIsVisible(modelPosition) {\n        return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return this._lines.getModelLineViewLineCount(modelLineNumber);\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n    }\n}\nclass LineNumberMapper {\n    constructor(viewLineCounts) {\n        this._counts = viewLineCounts;\n        this._isValid = false;\n        this._validEndIndex = -1;\n        this._modelToView = [];\n        this._viewToModel = [];\n    }\n    _invalidate(index) {\n        this._isValid = false;\n        this._validEndIndex = Math.min(this._validEndIndex, index - 1);\n    }\n    _ensureValid() {\n        if (this._isValid) {\n            return;\n        }\n        for (let i = this._validEndIndex + 1, len = this._counts.length; i < len; i++) {\n            const viewLineCount = this._counts[i];\n            const viewLinesAbove = (i > 0 ? this._modelToView[i - 1] : 0);\n            this._modelToView[i] = viewLinesAbove + viewLineCount;\n            for (let j = 0; j < viewLineCount; j++) {\n                this._viewToModel[viewLinesAbove + j] = i;\n            }\n        }\n        // trim things\n        this._modelToView.length = this._counts.length;\n        this._viewToModel.length = this._modelToView[this._modelToView.length - 1];\n        // mark as valid\n        this._isValid = true;\n        this._validEndIndex = this._counts.length - 1;\n    }\n    changeValue(index, value) {\n        if (this._counts[index] === value) {\n            // no change\n            return;\n        }\n        this._counts[index] = value;\n        this._invalidate(index);\n    }\n    removeValues(start, deleteCount) {\n        this._counts.splice(start, deleteCount);\n        this._invalidate(start);\n    }\n    insertValues(insertIndex, insertArr) {\n        this._counts = arrays.arrayInsert(this._counts, insertIndex, insertArr);\n        this._invalidate(insertIndex);\n    }\n    getTotalValue() {\n        this._ensureValid();\n        return this._viewToModel.length;\n    }\n    getAccumulatedValue(index) {\n        this._ensureValid();\n        return this._modelToView[index];\n    }\n    getIndexOf(accumulatedValue) {\n        this._ensureValid();\n        const modelLineIndex = this._viewToModel[accumulatedValue];\n        const viewLinesAbove = (modelLineIndex > 0 ? this._modelToView[modelLineIndex - 1] : 0);\n        return new PrefixSumIndexOfResult(modelLineIndex, accumulatedValue - viewLinesAbove);\n    }\n}\nexport class SplitLinesCollection {\n    constructor(editorId, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent) {\n        this._editorId = editorId;\n        this.model = model;\n        this._validModelVersionId = -1;\n        this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n        this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n        this.fontInfo = fontInfo;\n        this.tabSize = tabSize;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    dispose() {\n        this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, []);\n    }\n    createCoordinatesConverter() {\n        return new CoordinatesConverter(this);\n    }\n    _constructLines(resetHiddenAreas, previousLineBreaks) {\n        this.lines = [];\n        if (resetHiddenAreas) {\n            this.hiddenAreasIds = [];\n        }\n        const linesContent = this.model.getLinesContent();\n        const injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n        const lineCount = linesContent.length;\n        const lineBreaksComputer = this.createLineBreaksComputer();\n        const injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n        for (let i = 0; i < lineCount; i++) {\n            const lineInjectedText = injectedTextQueue.takeWhile(t => t.lineNumber === i + 1);\n            lineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n        }\n        const linesBreaks = lineBreaksComputer.finalize();\n        let values = [];\n        let hiddenAreas = this.hiddenAreasIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n        for (let i = 0; i < lineCount; i++) {\n            let lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n            }\n            let isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\n            let line = createSplitLine(linesBreaks[i], !isInHiddenArea);\n            values[i] = line.getViewLineCount();\n            this.lines[i] = line;\n        }\n        this._validModelVersionId = this.model.getVersionId();\n        this.prefixSumComputer = new LineNumberMapper(values);\n    }\n    getHiddenAreas() {\n        return this.hiddenAreasIds.map((decId) => {\n            return this.model.getDecorationRange(decId);\n        });\n    }\n    _reduceRanges(_ranges) {\n        if (_ranges.length === 0) {\n            return [];\n        }\n        let ranges = _ranges.map(r => this.model.validateRange(r)).sort(Range.compareRangesUsingStarts);\n        let result = [];\n        let currentRangeStart = ranges[0].startLineNumber;\n        let currentRangeEnd = ranges[0].endLineNumber;\n        for (let i = 1, len = ranges.length; i < len; i++) {\n            let range = ranges[i];\n            if (range.startLineNumber > currentRangeEnd + 1) {\n                result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n                currentRangeStart = range.startLineNumber;\n                currentRangeEnd = range.endLineNumber;\n            }\n            else if (range.endLineNumber > currentRangeEnd) {\n                currentRangeEnd = range.endLineNumber;\n            }\n        }\n        result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n        return result;\n    }\n    setHiddenAreas(_ranges) {\n        let newRanges = this._reduceRanges(_ranges);\n        // BEGIN TODO@Martin: Please stop calling this method on each model change!\n        let oldRanges = this.hiddenAreasIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        if (newRanges.length === oldRanges.length) {\n            let hasDifference = false;\n            for (let i = 0; i < newRanges.length; i++) {\n                if (!newRanges[i].equalsRange(oldRanges[i])) {\n                    hasDifference = true;\n                    break;\n                }\n            }\n            if (!hasDifference) {\n                return false;\n            }\n        }\n        // END TODO@Martin: Please stop calling this method on each model change!\n        let newDecorations = [];\n        for (const newRange of newRanges) {\n            newDecorations.push({\n                range: newRange,\n                options: ModelDecorationOptions.EMPTY\n            });\n        }\n        this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, newDecorations);\n        let hiddenAreas = newRanges;\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;\n        let hasVisibleLine = false;\n        for (let i = 0; i < this.lines.length; i++) {\n            let lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;\n            }\n            let lineChanged = false;\n            if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n                // Line should be hidden\n                if (this.lines[i].isVisible()) {\n                    this.lines[i] = this.lines[i].setVisible(false);\n                    lineChanged = true;\n                }\n            }\n            else {\n                hasVisibleLine = true;\n                // Line should be visible\n                if (!this.lines[i].isVisible()) {\n                    this.lines[i] = this.lines[i].setVisible(true);\n                    lineChanged = true;\n                }\n            }\n            if (lineChanged) {\n                let newOutputLineCount = this.lines[i].getViewLineCount();\n                this.prefixSumComputer.changeValue(i, newOutputLineCount);\n            }\n        }\n        if (!hasVisibleLine) {\n            // Cannot have everything be hidden => reveal everything!\n            this.setHiddenAreas([]);\n        }\n        return true;\n    }\n    modelPositionIsVisible(modelLineNumber, _modelColumn) {\n        if (modelLineNumber < 1 || modelLineNumber > this.lines.length) {\n            // invalid arguments\n            return false;\n        }\n        return this.lines[modelLineNumber - 1].isVisible();\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        if (modelLineNumber < 1 || modelLineNumber > this.lines.length) {\n            // invalid arguments\n            return 1;\n        }\n        return this.lines[modelLineNumber - 1].getViewLineCount();\n    }\n    setTabSize(newTabSize) {\n        if (this.tabSize === newTabSize) {\n            return false;\n        }\n        this.tabSize = newTabSize;\n        this._constructLines(/*resetHiddenAreas*/ false, null);\n        return true;\n    }\n    setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent) {\n        const equalFontInfo = this.fontInfo.equals(fontInfo);\n        const equalWrappingStrategy = (this.wrappingStrategy === wrappingStrategy);\n        const equalWrappingColumn = (this.wrappingColumn === wrappingColumn);\n        const equalWrappingIndent = (this.wrappingIndent === wrappingIndent);\n        if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent) {\n            return false;\n        }\n        const onlyWrappingColumnChanged = (equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent);\n        this.fontInfo = fontInfo;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        let previousLineBreaks = null;\n        if (onlyWrappingColumnChanged) {\n            previousLineBreaks = [];\n            for (let i = 0, len = this.lines.length; i < len; i++) {\n                previousLineBreaks[i] = this.lines[i].getLineBreakData();\n            }\n        }\n        this._constructLines(/*resetHiddenAreas*/ false, previousLineBreaks);\n        return true;\n    }\n    createLineBreaksComputer() {\n        const lineBreaksComputerFactory = (this.wrappingStrategy === 'advanced'\n            ? this._domLineBreaksComputerFactory\n            : this._monospaceLineBreaksComputerFactory);\n        return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent);\n    }\n    onModelFlushed() {\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        let outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);\n        let outputToLineNumber = this.prefixSumComputer.getAccumulatedValue(toLineNumber - 1);\n        this.lines.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        this.prefixSumComputer.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n    }\n    onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n        const isInHiddenArea = (fromLineNumber > 2 && !this.lines[fromLineNumber - 2].isVisible());\n        let outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);\n        let totalOutputLineCount = 0;\n        let insertLines = [];\n        let insertPrefixSumValues = [];\n        for (let i = 0, len = lineBreaks.length; i < len; i++) {\n            let line = createSplitLine(lineBreaks[i], !isInHiddenArea);\n            insertLines.push(line);\n            let outputLineCount = line.getViewLineCount();\n            totalOutputLineCount += outputLineCount;\n            insertPrefixSumValues[i] = outputLineCount;\n        }\n        // TODO@Alex: use arrays.arrayInsert\n        this.lines = this.lines.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.lines.slice(fromLineNumber - 1));\n        this.prefixSumComputer.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n        return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n    }\n    onModelLineChanged(versionId, lineNumber, lineBreakData) {\n        if (versionId !== null && versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return [false, null, null, null];\n        }\n        let lineIndex = lineNumber - 1;\n        let oldOutputLineCount = this.lines[lineIndex].getViewLineCount();\n        let isVisible = this.lines[lineIndex].isVisible();\n        let line = createSplitLine(lineBreakData, isVisible);\n        this.lines[lineIndex] = line;\n        let newOutputLineCount = this.lines[lineIndex].getViewLineCount();\n        let lineMappingChanged = false;\n        let changeFrom = 0;\n        let changeTo = -1;\n        let insertFrom = 0;\n        let insertTo = -1;\n        let deleteFrom = 0;\n        let deleteTo = -1;\n        if (oldOutputLineCount > newOutputLineCount) {\n            changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\n            changeTo = changeFrom + newOutputLineCount - 1;\n            deleteFrom = changeTo + 1;\n            deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else if (oldOutputLineCount < newOutputLineCount) {\n            changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\n            changeTo = changeFrom + oldOutputLineCount - 1;\n            insertFrom = changeTo + 1;\n            insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else {\n            changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\n            changeTo = changeFrom + newOutputLineCount - 1;\n        }\n        this.prefixSumComputer.changeValue(lineIndex, newOutputLineCount);\n        const viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo) : null);\n        const viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\n        const viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\n        return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n    }\n    acceptVersionId(versionId) {\n        this._validModelVersionId = versionId;\n        if (this.lines.length === 1 && !this.lines[0].isVisible()) {\n            // At least one line must be visible => reset hidden areas\n            this.setHiddenAreas([]);\n        }\n    }\n    getViewLineCount() {\n        return this.prefixSumComputer.getTotalValue();\n    }\n    _toValidViewLineNumber(viewLineNumber) {\n        if (viewLineNumber < 1) {\n            return 1;\n        }\n        const viewLineCount = this.getViewLineCount();\n        if (viewLineNumber > viewLineCount) {\n            return viewLineCount;\n        }\n        return viewLineNumber | 0;\n    }\n    getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        minLineNumber = this._toValidViewLineNumber(minLineNumber);\n        maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n        const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n        const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n        const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n        const result = this.model.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n        const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n        const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n        return {\n            startLineNumber: viewStartPosition.lineNumber,\n            endLineNumber: viewEndPosition.lineNumber,\n            indent: result.indent\n        };\n    }\n    // #region ViewLineInfo\n    getViewLineInfo(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        let lineIndex = r.index;\n        let remainder = r.remainder;\n        return new ViewLineInfo(lineIndex + 1, remainder);\n    }\n    getMinColumnOfViewLine(viewLineInfo) {\n        return this.lines[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getModelStartPositionOfViewLine(viewLineInfo) {\n        const line = this.lines[viewLineInfo.modelLineNumber - 1];\n        const minViewColumn = line.getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, minViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getModelEndPositionOfViewLine(viewLineInfo) {\n        const line = this.lines[viewLineInfo.modelLineNumber - 1];\n        const maxViewColumn = line.getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, maxViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber) {\n        const startViewLine = this.getViewLineInfo(viewStartLineNumber);\n        const endViewLine = this.getViewLineInfo(viewEndLineNumber);\n        const result = new Array();\n        let lastVisibleModelPos = this.getModelStartPositionOfViewLine(startViewLine);\n        let viewLines = new Array();\n        for (let curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n            const line = this.lines[curModelLine - 1];\n            if (line.isVisible()) {\n                let startOffset = curModelLine === startViewLine.modelLineNumber\n                    ? startViewLine.modelLineWrappedLineIdx\n                    : 0;\n                let endOffset = curModelLine === endViewLine.modelLineNumber\n                    ? endViewLine.modelLineWrappedLineIdx + 1\n                    : line.getViewLineCount();\n                for (let i = startOffset; i < endOffset; i++) {\n                    viewLines.push(new ViewLineInfo(curModelLine, i));\n                }\n            }\n            if (!line.isVisible() && lastVisibleModelPos) {\n                const lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n                const modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n                result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n                viewLines = [];\n                lastVisibleModelPos = null;\n            }\n            else if (line.isVisible() && !lastVisibleModelPos) {\n                lastVisibleModelPos = new Position(curModelLine, 1);\n            }\n        }\n        if (lastVisibleModelPos) {\n            const modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n            result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n        }\n        return result;\n    }\n    // #endregion\n    getViewLinesBracketGuides(viewStartLineNumber, viewEndLineNumber, activeViewPosition, options) {\n        const modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n        const resultPerViewLine = [];\n        for (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {\n            const modelRangeStartLineNumber = group.modelRange.startLineNumber;\n            const bracketGuidesPerModelLine = this.model.getLinesBracketGuides(modelRangeStartLineNumber, group.modelRange.endLineNumber, modelActivePosition, options);\n            for (const viewLineInfo of group.viewLines) {\n                if (viewLineInfo.isWrappedLineContinuation && this.getMinColumnOfViewLine(viewLineInfo) === 1) {\n                    // Don't add indent guides when the wrapped line continuation has no wrapping-indentation.\n                    resultPerViewLine.push([]);\n                }\n                else {\n                    let bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber];\n                    // visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n                    // model-columns must be converted to view-model columns.\n                    bracketGuides = bracketGuides.map(g => g.horizontalLine ?\n                        new IndentGuide(g.visibleColumn, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn).column)) : g);\n                    resultPerViewLine.push(bracketGuides);\n                }\n            }\n        }\n        return resultPerViewLine;\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        // TODO: Use the same code as in `getViewLinesBracketGuides`.\n        // Future TODO: Merge with `getViewLinesBracketGuides`.\n        // However, this requires more refactoring of indent guides.\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n        const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n        let result = [];\n        let resultRepeatCount = [];\n        let resultRepeatOption = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.lines[modelLineIndex];\n            if (line.isVisible()) {\n                let viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                let viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n                let count = viewLineEndIndex - viewLineStartIndex + 1;\n                let option = 0 /* BlockNone */;\n                if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n                    // wrapped lines should block indent guides\n                    option = (viewLineStartIndex === 0 ? 1 /* BlockSubsequent */ : 2 /* BlockAll */);\n                }\n                resultRepeatCount.push(count);\n                resultRepeatOption.push(option);\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, 0);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n            reqStart = null;\n        }\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        let viewIndents = new Array(viewLineCount);\n        let currIndex = 0;\n        for (let i = 0, len = result.length; i < len; i++) {\n            let value = result[i];\n            let count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n            let option = resultRepeatOption[i];\n            let blockAtIndex;\n            if (option === 2 /* BlockAll */) {\n                blockAtIndex = 0;\n            }\n            else if (option === 1 /* BlockSubsequent */) {\n                blockAtIndex = 1;\n            }\n            else {\n                blockAtIndex = count;\n            }\n            for (let j = 0; j < count; j++) {\n                if (j === blockAtIndex) {\n                    value = 0;\n                }\n                viewIndents[currIndex++] = value;\n            }\n        }\n        return viewIndents;\n    }\n    getViewLineContent(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        let lineIndex = r.index;\n        let remainder = r.remainder;\n        return this.lines[lineIndex].getViewLineContent(this.model, lineIndex + 1, remainder);\n    }\n    getViewLineLength(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        let lineIndex = r.index;\n        let remainder = r.remainder;\n        return this.lines[lineIndex].getViewLineLength(this.model, lineIndex + 1, remainder);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        let lineIndex = r.index;\n        let remainder = r.remainder;\n        return this.lines[lineIndex].getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        let lineIndex = r.index;\n        let remainder = r.remainder;\n        return this.lines[lineIndex].getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n    }\n    getViewLineData(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        let lineIndex = r.index;\n        let remainder = r.remainder;\n        return this.lines[lineIndex].getViewLineData(this.model, lineIndex + 1, remainder);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        let start = this.prefixSumComputer.getIndexOf(viewStartLineNumber - 1);\n        let viewLineNumber = viewStartLineNumber;\n        let startModelLineIndex = start.index;\n        let startRemainder = start.remainder;\n        let result = [];\n        for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n            let line = this.lines[modelLineIndex];\n            if (!line.isVisible()) {\n                continue;\n            }\n            let fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\n            let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n            let lastLine = false;\n            if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n                lastLine = true;\n                remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n            }\n            let toViewLineIndex = fromViewLineIndex + remainingViewLineCount;\n            line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, toViewLineIndex, viewLineNumber - viewStartLineNumber, needed, result);\n            viewLineNumber += remainingViewLineCount;\n            if (lastLine) {\n                break;\n            }\n        }\n        return result;\n    }\n    validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        let lineIndex = r.index;\n        let remainder = r.remainder;\n        let line = this.lines[lineIndex];\n        let minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n        let maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n        if (viewColumn < minColumn) {\n            viewColumn = minColumn;\n        }\n        if (viewColumn > maxColumn) {\n            viewColumn = maxColumn;\n        }\n        let computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n        let computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n        if (computedModelPosition.equals(expectedModelPosition)) {\n            return new Position(viewLineNumber, viewColumn);\n        }\n        return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n        const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n        return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n    }\n    convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        let lineIndex = r.index;\n        let remainder = r.remainder;\n        let inputColumn = this.lines[lineIndex].getModelColumnOfViewPosition(remainder, viewColumn);\n        // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n        return this.model.validatePosition(new Position(lineIndex + 1, inputColumn));\n    }\n    convertViewRangeToModelRange(viewRange) {\n        const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n        const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    convertModelPositionToViewPosition(_modelLineNumber, _modelColumn, affinity = 2 /* None */) {\n        const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n        const inputLineNumber = validPosition.lineNumber;\n        const inputColumn = validPosition.column;\n        let lineIndex = inputLineNumber - 1, lineIndexChanged = false;\n        while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\n            lineIndex--;\n            lineIndexChanged = true;\n        }\n        if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\n            // Could not reach a real line\n            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n            return new Position(1, 1);\n        }\n        const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n        let r;\n        if (lineIndexChanged) {\n            r = this.lines[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n        }\n        else {\n            r = this.lines[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n        }\n        // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n        return r;\n    }\n    /**\n     * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n    */\n    convertModelRangeToViewRange(modelRange, affinity = 0 /* Left */) {\n        if (modelRange.isEmpty()) {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n            return Range.fromPositions(start);\n        }\n        else {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, 1 /* Right */);\n            const end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, 0 /* Left */);\n            return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n        }\n    }\n    getViewLineNumberOfModelPosition(inputLineNumber, inputColumn) {\n        let lineIndex = inputLineNumber - 1;\n        if (this.lines[lineIndex].isVisible()) {\n            // this model line is visible\n            const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n            return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn);\n        }\n        // this model line is not visible\n        while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\n            lineIndex--;\n        }\n        if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\n            // Could not reach a real line\n            return 1;\n        }\n        const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n        return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\n        const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n        const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n        if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n            // most likely there are no hidden lines => fast path\n            // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n            return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);\n        }\n        let result = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.lines[modelLineIndex];\n            if (line.isVisible()) {\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n                    result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));\n            reqStart = null;\n        }\n        result.sort((a, b) => {\n            const res = Range.compareRangesUsingStarts(a.range, b.range);\n            if (res === 0) {\n                if (a.id < b.id) {\n                    return -1;\n                }\n                if (a.id > b.id) {\n                    return 1;\n                }\n                return 0;\n            }\n            return res;\n        });\n        // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n        let finalResult = [], finalResultLen = 0;\n        let prevDecId = null;\n        for (const dec of result) {\n            const decId = dec.id;\n            if (prevDecId === decId) {\n                // skip\n                continue;\n            }\n            prevDecId = decId;\n            finalResult[finalResultLen++] = dec;\n        }\n        return finalResult;\n    }\n    getInjectedTextAt(position) {\n        const viewLineNumber = this._toValidViewLineNumber(position.lineNumber);\n        const r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        return this.lines[lineIndex].getInjectedTextAt(remainder, position.column);\n    }\n    normalizePosition(position, affinity) {\n        const viewLineNumber = this._toValidViewLineNumber(position.lineNumber);\n        const r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        return this.lines[lineIndex].normalizePosition(this.model, lineIndex + 1, remainder, position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        const viewLineNumber = this._toValidViewLineNumber(lineNumber);\n        const r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        if (remainder === 0) {\n            return this.model.getLineIndentColumn(lineIndex + 1);\n        }\n        // wrapped lines have no indentation.\n        // We deliberately don't handle the case that indentation is wrapped\n        // to avoid two view lines reporting indentation for the very same model line.\n        return 0;\n    }\n}\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\nclass ViewLineInfo {\n    constructor(modelLineNumber, modelLineWrappedLineIdx) {\n        this.modelLineNumber = modelLineNumber;\n        this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;\n    }\n    get isWrappedLineContinuation() {\n        return this.modelLineWrappedLineIdx > 0;\n    }\n}\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\nclass ViewLineInfoGroupedByModelRange {\n    constructor(modelRange, viewLines) {\n        this.modelRange = modelRange;\n        this.viewLines = viewLines;\n    }\n}\nclass VisibleIdentitySplitLine {\n    constructor() { }\n    isVisible() {\n        return true;\n    }\n    setVisible(isVisible) {\n        if (isVisible) {\n            return this;\n        }\n        return InvisibleIdentitySplitLine.INSTANCE;\n    }\n    getLineBreakData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 1;\n    }\n    getViewLineContent(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineContent(modelLineNumber);\n    }\n    getViewLineLength(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineLength(modelLineNumber);\n    }\n    getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMinColumn(modelLineNumber);\n    }\n    getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMaxColumn(modelLineNumber);\n    }\n    getViewLineData(model, modelLineNumber, _outputLineIndex) {\n        let lineTokens = model.getLineTokens(modelLineNumber);\n        let lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\n        if (!needed[globalStartIndex]) {\n            result[globalStartIndex] = null;\n            return;\n        }\n        result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {\n        return outputColumn;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n        return new Position(deltaLineNumber, inputColumn);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {\n        return deltaLineNumber;\n    }\n    normalizePosition(model, modelLineNumber, outputLineIndex, outputPosition, affinity) {\n        return outputPosition;\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        return null;\n    }\n}\nVisibleIdentitySplitLine.INSTANCE = new VisibleIdentitySplitLine();\nclass InvisibleIdentitySplitLine {\n    constructor() { }\n    isVisible() {\n        return false;\n    }\n    setVisible(isVisible) {\n        if (!isVisible) {\n            return this;\n        }\n        return VisibleIdentitySplitLine.INSTANCE;\n    }\n    getLineBreakData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 0;\n    }\n    getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineData(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\n        throw new Error('Not supported');\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    normalizePosition(model, modelLineNumber, outputLineIndex, outputPosition, affinity) {\n        throw new Error('Not supported');\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n}\nInvisibleIdentitySplitLine.INSTANCE = new InvisibleIdentitySplitLine();\nexport class SplitLine {\n    constructor(lineBreakData, isVisible) {\n        this._lineBreakData = lineBreakData;\n        this._isVisible = isVisible;\n    }\n    isVisible() {\n        return this._isVisible;\n    }\n    setVisible(isVisible) {\n        this._isVisible = isVisible;\n        return this;\n    }\n    getLineBreakData() {\n        return this._lineBreakData;\n    }\n    getViewLineCount() {\n        if (!this._isVisible) {\n            return 0;\n        }\n        return this._lineBreakData.breakOffsets.length;\n    }\n    getInputStartOffsetOfOutputLineIndex(outputLineIndex) {\n        return this._lineBreakData.getInputOffsetOfOutputPosition(outputLineIndex, 0);\n    }\n    getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex) {\n        if (outputLineIndex + 1 === this._lineBreakData.breakOffsets.length) {\n            return model.getLineMaxColumn(modelLineNumber) - 1;\n        }\n        return this._lineBreakData.getInputOffsetOfOutputPosition(outputLineIndex + 1, 0);\n    }\n    getViewLineContent(model, modelLineNumber, outputLineIndex) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        // These offsets refer to model text with injected text.\n        const startOffset = outputLineIndex > 0 ? this._lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffset = outputLineIndex < this._lineBreakData.breakOffsets.length\n            ? this._lineBreakData.breakOffsets[outputLineIndex]\n            // This case might not be possible anyway, but we clamp the value to be on the safe side.\n            : this._lineBreakData.breakOffsets[this._lineBreakData.breakOffsets.length - 1];\n        let r;\n        if (this._lineBreakData.injectionOffsets !== null) {\n            const injectedTexts = this._lineBreakData.injectionOffsets.map((offset, idx) => new LineInjectedText(0, 0, offset + 1, this._lineBreakData.injectionOptions[idx], 0));\n            r = LineInjectedText.applyInjectedText(model.getLineContent(modelLineNumber), injectedTexts).substring(startOffset, endOffset);\n        }\n        else {\n            r = model.getValueInRange({\n                startLineNumber: modelLineNumber,\n                startColumn: startOffset + 1,\n                endLineNumber: modelLineNumber,\n                endColumn: endOffset + 1\n            });\n        }\n        if (outputLineIndex > 0) {\n            r = spaces(this._lineBreakData.wrappedTextIndentLength) + r;\n        }\n        return r;\n    }\n    getViewLineLength(model, modelLineNumber, outputLineIndex) {\n        // TODO @hediet make this method a member of LineBreakData.\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        // These offsets refer to model text with injected text.\n        const startOffset = outputLineIndex > 0 ? this._lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffset = outputLineIndex < this._lineBreakData.breakOffsets.length\n            ? this._lineBreakData.breakOffsets[outputLineIndex]\n            // This case might not be possible anyway, but we clamp the value to be on the safe side.\n            : this._lineBreakData.breakOffsets[this._lineBreakData.breakOffsets.length - 1];\n        let r = endOffset - startOffset;\n        if (outputLineIndex > 0) {\n            r = this._lineBreakData.wrappedTextIndentLength + r;\n        }\n        return r;\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        return this._getViewLineMinColumn(outputLineIndex);\n    }\n    _getViewLineMinColumn(outputLineIndex) {\n        if (outputLineIndex > 0) {\n            return this._lineBreakData.wrappedTextIndentLength + 1;\n        }\n        return 1;\n    }\n    getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        return this.getViewLineLength(model, modelLineNumber, outputLineIndex) + 1;\n    }\n    getViewLineData(model, modelLineNumber, outputLineIndex) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        const lineBreakData = this._lineBreakData;\n        const deltaStartIndex = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n        const injectionOffsets = lineBreakData.injectionOffsets;\n        const injectionOptions = lineBreakData.injectionOptions;\n        let lineContent;\n        let tokens;\n        let inlineDecorations;\n        if (injectionOffsets) {\n            const lineTokens = model.getLineTokens(modelLineNumber).withInserted(injectionOffsets.map((offset, idx) => ({\n                offset,\n                text: injectionOptions[idx].content,\n                tokenMetadata: LineTokens.defaultTokenMetadata\n            })));\n            const lineStartOffsetInUnwrappedLine = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n            const lineEndOffsetInUnwrappedLine = lineBreakData.breakOffsets[outputLineIndex];\n            lineContent = lineTokens.getLineContent().substring(lineStartOffsetInUnwrappedLine, lineEndOffsetInUnwrappedLine);\n            tokens = lineTokens.sliceAndInflate(lineStartOffsetInUnwrappedLine, lineEndOffsetInUnwrappedLine, deltaStartIndex);\n            inlineDecorations = new Array();\n            let totalInjectedTextLengthBefore = 0;\n            for (let i = 0; i < injectionOffsets.length; i++) {\n                const length = injectionOptions[i].content.length;\n                const injectedTextStartOffsetInUnwrappedLine = injectionOffsets[i] + totalInjectedTextLengthBefore;\n                const injectedTextEndOffsetInUnwrappedLine = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n                if (injectedTextStartOffsetInUnwrappedLine > lineEndOffsetInUnwrappedLine) {\n                    // Injected text only starts in later wrapped lines.\n                    break;\n                }\n                if (lineStartOffsetInUnwrappedLine < injectedTextEndOffsetInUnwrappedLine) {\n                    // Injected text ends after or in this line (but also starts in or before this line).\n                    const options = injectionOptions[i];\n                    if (options.inlineClassName) {\n                        const offset = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n                        const start = offset + Math.max(injectedTextStartOffsetInUnwrappedLine - lineStartOffsetInUnwrappedLine, 0);\n                        const end = offset + Math.min(injectedTextEndOffsetInUnwrappedLine - lineStartOffsetInUnwrappedLine, lineEndOffsetInUnwrappedLine);\n                        if (start !== end) {\n                            inlineDecorations.push(new SingleLineInlineDecoration(start, end, options.inlineClassName, options.inlineClassNameAffectsLetterSpacing));\n                        }\n                    }\n                }\n                totalInjectedTextLengthBefore += length;\n            }\n        }\n        else {\n            const startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n            const endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n            const lineTokens = model.getLineTokens(modelLineNumber);\n            lineContent = model.getValueInRange({\n                startLineNumber: modelLineNumber,\n                startColumn: startOffset + 1,\n                endLineNumber: modelLineNumber,\n                endColumn: endOffset + 1\n            });\n            tokens = lineTokens.sliceAndInflate(startOffset, endOffset, deltaStartIndex);\n            inlineDecorations = null;\n        }\n        if (outputLineIndex > 0) {\n            lineContent = spaces(lineBreakData.wrappedTextIndentLength) + lineContent;\n        }\n        const minColumn = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength + 1 : 1);\n        const maxColumn = lineContent.length + 1;\n        const continuesWithWrappedLine = (outputLineIndex + 1 < this.getViewLineCount());\n        const startVisibleColumn = (outputLineIndex === 0 ? 0 : lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1]);\n        return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations);\n    }\n    getViewLinesData(model, modelLineNumber, fromOuputLineIndex, toOutputLineIndex, globalStartIndex, needed, result) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        for (let outputLineIndex = fromOuputLineIndex; outputLineIndex < toOutputLineIndex; outputLineIndex++) {\n            let globalIndex = globalStartIndex + outputLineIndex - fromOuputLineIndex;\n            if (!needed[globalIndex]) {\n                result[globalIndex] = null;\n                continue;\n            }\n            result[globalIndex] = this.getViewLineData(model, modelLineNumber, outputLineIndex);\n        }\n    }\n    getModelColumnOfViewPosition(outputLineIndex, outputColumn) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        let adjustedColumn = outputColumn - 1;\n        if (outputLineIndex > 0) {\n            if (adjustedColumn < this._lineBreakData.wrappedTextIndentLength) {\n                adjustedColumn = 0;\n            }\n            else {\n                adjustedColumn -= this._lineBreakData.wrappedTextIndentLength;\n            }\n        }\n        return this._lineBreakData.getInputOffsetOfOutputPosition(outputLineIndex, adjustedColumn) + 1;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity = 2 /* None */) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        let r = this._lineBreakData.getOutputPositionOfInputOffset(inputColumn - 1, affinity);\n        let outputLineIndex = r.outputLineIndex;\n        let outputColumn = r.outputOffset + 1;\n        if (outputLineIndex > 0) {\n            outputColumn += this._lineBreakData.wrappedTextIndentLength;\n        }\n        //\t\tconsole.log('in -> out ' + deltaLineNumber + ',' + inputColumn + ' ===> ' + (deltaLineNumber+outputLineIndex) + ',' + outputColumn);\n        return new Position(deltaLineNumber + outputLineIndex, outputColumn);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        const r = this._lineBreakData.getOutputPositionOfInputOffset(inputColumn - 1);\n        return (deltaLineNumber + r.outputLineIndex);\n    }\n    normalizePosition(model, modelLineNumber, outputLineIndex, outputPosition, affinity) {\n        if (this._lineBreakData.injectionOffsets !== null) {\n            const baseViewLineNumber = outputPosition.lineNumber - outputLineIndex;\n            const offsetInUnwrappedLine = this._lineBreakData.outputPositionToOffsetInUnwrappedLine(outputLineIndex, outputPosition.column - 1);\n            const normalizedOffsetInUnwrappedLine = this._lineBreakData.normalizeOffsetAroundInjections(offsetInUnwrappedLine, affinity);\n            if (normalizedOffsetInUnwrappedLine !== offsetInUnwrappedLine) {\n                // injected text caused a change\n                return this._lineBreakData.getOutputPositionOfOffsetInUnwrappedLine(normalizedOffsetInUnwrappedLine, affinity).toPosition(baseViewLineNumber, this._lineBreakData.wrappedTextIndentLength);\n            }\n        }\n        if (affinity === 0 /* Left */) {\n            if (outputLineIndex > 0 && outputPosition.column === this._getViewLineMinColumn(outputLineIndex)) {\n                return new Position(outputPosition.lineNumber - 1, this.getViewLineMaxColumn(model, modelLineNumber, outputLineIndex - 1));\n            }\n        }\n        else if (affinity === 1 /* Right */) {\n            const maxOutputLineIndex = this.getViewLineCount() - 1;\n            if (outputLineIndex < maxOutputLineIndex && outputPosition.column === this.getViewLineMaxColumn(model, modelLineNumber, outputLineIndex)) {\n                return new Position(outputPosition.lineNumber + 1, this._getViewLineMinColumn(outputLineIndex + 1));\n            }\n        }\n        return outputPosition;\n    }\n    getInjectedTextAt(outputLineIndex, outputColumn) {\n        return this._lineBreakData.getInjectedText(outputLineIndex, outputColumn - 1);\n    }\n}\nlet _spaces = [''];\nfunction spaces(count) {\n    if (count >= _spaces.length) {\n        for (let i = 1; i <= count; i++) {\n            _spaces[i] = _makeSpaces(i);\n        }\n    }\n    return _spaces[count];\n}\nfunction _makeSpaces(count) {\n    return new Array(count + 1).join(' ');\n}\nfunction createSplitLine(lineBreakData, isVisible) {\n    if (lineBreakData === null) {\n        // No mapping needed\n        if (isVisible) {\n            return VisibleIdentitySplitLine.INSTANCE;\n        }\n        return InvisibleIdentitySplitLine.INSTANCE;\n    }\n    else {\n        return new SplitLine(lineBreakData, isVisible);\n    }\n}\nexport class IdentityCoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    _validPosition(pos) {\n        return this._lines.model.validatePosition(pos);\n    }\n    _validRange(range) {\n        return this._lines.model.validateRange(range);\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._validPosition(viewPosition);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._validRange(viewRange);\n    }\n    validateViewPosition(_viewPosition, expectedModelPosition) {\n        return this._validPosition(expectedModelPosition);\n    }\n    validateViewRange(_viewRange, expectedModelRange) {\n        return this._validRange(expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition) {\n        return this._validPosition(modelPosition);\n    }\n    convertModelRangeToViewRange(modelRange) {\n        return this._validRange(modelRange);\n    }\n    modelPositionIsVisible(modelPosition) {\n        const lineCount = this._lines.model.getLineCount();\n        if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n            // invalid arguments\n            return false;\n        }\n        return true;\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return 1;\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return modelLineNumber;\n    }\n}\nexport class IdentityLinesCollection {\n    constructor(model) {\n        this.model = model;\n    }\n    dispose() {\n    }\n    createCoordinatesConverter() {\n        return new IdentityCoordinatesConverter(this);\n    }\n    getHiddenAreas() {\n        return [];\n    }\n    setHiddenAreas(_ranges) {\n        return false;\n    }\n    setTabSize(_newTabSize) {\n        return false;\n    }\n    setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n        return false;\n    }\n    createLineBreaksComputer() {\n        let result = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                result.push(null);\n            },\n            finalize: () => {\n                return result;\n            }\n        };\n    }\n    onModelFlushed() {\n    }\n    onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n        return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n        return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n        return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, lineNumber), null, null];\n    }\n    acceptVersionId(_versionId) {\n    }\n    getViewLineCount() {\n        return this.model.getLineCount();\n    }\n    getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n        return {\n            startLineNumber: viewLineNumber,\n            endLineNumber: viewLineNumber,\n            indent: 0\n        };\n    }\n    getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition) {\n        return new Array(endLineNumber - startLineNumber + 1).fill([]);\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        let result = new Array(viewLineCount);\n        for (let i = 0; i < viewLineCount; i++) {\n            result[i] = 0;\n        }\n        return result;\n    }\n    getViewLineContent(viewLineNumber) {\n        return this.model.getLineContent(viewLineNumber);\n    }\n    getViewLineLength(viewLineNumber) {\n        return this.model.getLineLength(viewLineNumber);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        return this.model.getLineMinColumn(viewLineNumber);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        return this.model.getLineMaxColumn(viewLineNumber);\n    }\n    getViewLineData(viewLineNumber) {\n        let lineTokens = this.model.getLineTokens(viewLineNumber);\n        let lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        const lineCount = this.model.getLineCount();\n        viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n        viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n        let result = [];\n        for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n            let idx = lineNumber - viewStartLineNumber;\n            if (!needed[idx]) {\n                result[idx] = null;\n            }\n            result[idx] = this.getViewLineData(lineNumber);\n        }\n        return result;\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\n        return this.model.getDecorationsInRange(range, ownerId, filterOutValidation);\n    }\n    normalizePosition(position, affinity) {\n        return this.model.normalizePosition(position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        return this.model.getLineIndentColumn(lineNumber);\n    }\n    getInjectedTextAt(position) {\n        // Identity lines collection does not support injected text.\n        return null;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}