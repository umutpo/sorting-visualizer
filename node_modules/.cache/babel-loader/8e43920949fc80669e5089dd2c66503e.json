{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from './bracketPairs.js';\nimport { TextEditInfo } from './impl/beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './impl/brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThanEqual, lengthOfString, lengthsToRange, lengthZero, positionToLength, toLength } from './impl/length.js';\nimport { parseDocument } from './impl/parser.js';\nimport { DenseKeyProvider } from './impl/smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './impl/tokenizer.js';\nexport class BracketPairs extends Disposable {\n  constructor(textModel, languageConfigurationService) {\n    super();\n    this.textModel = textModel;\n    this.languageConfigurationService = languageConfigurationService;\n    this.cache = this._register(new MutableDisposable());\n    this.onDidChangeEmitter = new Emitter();\n    this.onDidChange = this.onDidChangeEmitter.event;\n    this.bracketsRequested = false;\n\n    this._register(textModel.onDidChangeOptions(e => {\n      this.cache.clear();\n      this.updateCache();\n    }));\n\n    this._register(textModel.onDidChangeLanguage(e => {\n      this.cache.clear();\n      this.updateCache();\n    }));\n\n    this._register(this.languageConfigurationService.onDidChange(e => {\n      var _a;\n\n      if (!e.languageId || ((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.object.didLanguageChange(e.languageId))) {\n        this.cache.clear();\n        this.updateCache();\n      }\n    }));\n  }\n\n  get isDocumentSupported() {\n    const maxSupportedDocumentLength =\n    /* max lines */\n    50000 *\n    /* average column count */\n    100;\n    return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n  }\n\n  updateCache() {\n    if (this.bracketsRequested && this.isDocumentSupported) {\n      if (!this.cache.value) {\n        const store = new DisposableStore();\n        this.cache.value = createDisposableRef(store.add(new ActiveBracketPairsImpl(this.textModel, languageId => {\n          return this.languageConfigurationService.getLanguageConfiguration(languageId);\n        })), store);\n        store.add(this.cache.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n        this.onDidChangeEmitter.fire();\n      }\n    } else {\n      this.cache.clear();\n      this.onDidChangeEmitter.fire();\n    }\n  }\n\n  handleContentChanged(change) {\n    var _a;\n\n    (_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.object.handleContentChanged(change);\n  }\n  /**\n   * Returns all bracket pairs that intersect the given range.\n   * The result is sorted by the start position.\n  */\n\n\n  getBracketPairsInRange(range) {\n    var _a;\n\n    this.bracketsRequested = true;\n    this.updateCache();\n    return ((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, false)) || [];\n  }\n\n  getBracketPairsInRangeWithMinIndentation(range) {\n    var _a;\n\n    this.bracketsRequested = true;\n    this.updateCache();\n    return ((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, true)) || [];\n  }\n\n  getBracketsInRange(range) {\n    var _a;\n\n    this.bracketsRequested = true;\n    this.updateCache();\n    return ((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.object.getBracketsInRange(range)) || [];\n  }\n\n}\n\nfunction createDisposableRef(object, disposable) {\n  return {\n    object,\n    dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose()\n  };\n}\n\nclass ActiveBracketPairsImpl extends Disposable {\n  constructor(textModel, getLanguageConfiguration) {\n    super();\n    this.textModel = textModel;\n    this.getLanguageConfiguration = getLanguageConfiguration;\n    this.didChangeEmitter = new Emitter();\n    this.denseKeyProvider = new DenseKeyProvider();\n    this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n    this.onDidChange = this.didChangeEmitter.event;\n\n    this._register(textModel.onBackgroundTokenizationStateChanged(() => {\n      if (textModel.backgroundTokenizationState === 2\n      /* Completed */\n      ) {\n        const wasUndefined = this.initialAstWithoutTokens === undefined; // Clear the initial tree as we can use the tree with token information now.\n\n        this.initialAstWithoutTokens = undefined;\n\n        if (!wasUndefined) {\n          this.didChangeEmitter.fire();\n        }\n      }\n    }));\n\n    this._register(textModel.onDidChangeTokens(_ref => {\n      let {\n        ranges\n      } = _ref;\n      const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n      this.astWithTokens = this.parseDocumentFromTextBuffer(edits, this.astWithTokens, false);\n\n      if (!this.initialAstWithoutTokens) {\n        this.didChangeEmitter.fire();\n      }\n    }));\n\n    if (textModel.backgroundTokenizationState === 0\n    /* Uninitialized */\n    ) {\n      // There are no token information yet\n      const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n      const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n      this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n      this.astWithTokens = this.initialAstWithoutTokens;\n    } else if (textModel.backgroundTokenizationState === 2\n    /* Completed */\n    ) {\n      // Skip the initial ast, as there is no flickering.\n      // Directly create the tree with token information.\n      this.initialAstWithoutTokens = undefined;\n      this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n    } else if (textModel.backgroundTokenizationState === 1\n    /* InProgress */\n    ) {\n      this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n      this.astWithTokens = this.initialAstWithoutTokens;\n    }\n  }\n\n  didLanguageChange(languageId) {\n    return this.brackets.didLanguageChange(languageId);\n  }\n\n  handleContentChanged(change) {\n    const edits = change.changes.map(c => {\n      const range = Range.lift(c.range);\n      return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n    }).reverse();\n    this.astWithTokens = this.parseDocumentFromTextBuffer(edits, this.astWithTokens, false);\n\n    if (this.initialAstWithoutTokens) {\n      this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(edits, this.initialAstWithoutTokens, false);\n    }\n  }\n  /**\n   * @pure (only if isPure = true)\n  */\n\n\n  parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n    // Is much faster if `isPure = false`.\n    const isPure = false;\n    const previousAstClone = isPure ? previousAst === null || previousAst === void 0 ? void 0 : previousAst.deepClone() : previousAst;\n    const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n    const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n    return result;\n  }\n\n  getBracketsInRange(range) {\n    const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n    const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n    const result = new Array();\n    const node = this.initialAstWithoutTokens || this.astWithTokens;\n    collectBrackets(node, lengthZero, node.length, startOffset, endOffset, result);\n    return result;\n  }\n\n  getBracketPairsInRange(range, includeMinIndentation) {\n    const result = new Array();\n    const startLength = positionToLength(range.getStartPosition());\n    const endLength = positionToLength(range.getEndPosition());\n    const node = this.initialAstWithoutTokens || this.astWithTokens;\n    const context = new CollectBracketPairsContext(result, includeMinIndentation, this.textModel);\n    collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context);\n    return result;\n  }\n\n}\n\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result) {\n  let level = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n\n  if (node.kind === 1\n  /* Bracket */\n  ) {\n    const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n    result.push(new BracketInfo(range, level - 1, false));\n  } else if (node.kind === 3\n  /* UnexpectedClosingBracket */\n  ) {\n    const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n    result.push(new BracketInfo(range, level - 1, true));\n  } else if (node.kind === 4\n  /* List */\n  ) {\n    for (const child of node.children) {\n      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\n      if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n        collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n      }\n\n      nodeOffsetStart = nodeOffsetEnd;\n    }\n  } else if (node.kind === 2\n  /* Pair */\n  ) {\n    // Don't use node.children here to improve performance\n    level++;\n    {\n      const child = node.openingBracket;\n      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\n      if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n        collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n      }\n\n      nodeOffsetStart = nodeOffsetEnd;\n    }\n\n    if (node.child) {\n      const child = node.child;\n      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\n      if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n        collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n      }\n\n      nodeOffsetStart = nodeOffsetEnd;\n    }\n\n    if (node.closingBracket) {\n      const child = node.closingBracket;\n      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\n      if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n        collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n      }\n\n      nodeOffsetStart = nodeOffsetEnd;\n    }\n  }\n}\n\nclass CollectBracketPairsContext {\n  constructor(result, includeMinIndentation, textModel) {\n    this.result = result;\n    this.includeMinIndentation = includeMinIndentation;\n    this.textModel = textModel;\n  }\n\n}\n\nfunction collectBracketPairs(node, nodeOffset, nodeOffsetEnd, startOffset, endOffset, context) {\n  let level = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n\n  var _a;\n\n  if (node.kind === 2\n  /* Pair */\n  ) {\n    const openingBracketEnd = lengthAdd(nodeOffset, node.openingBracket.length);\n    let minIndentation = -1;\n\n    if (context.includeMinIndentation) {\n      minIndentation = node.computeMinIndentation(nodeOffset, context.textModel);\n    }\n\n    context.result.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffset, nodeOffsetEnd), lengthsToRange(nodeOffset, openingBracketEnd), node.closingBracket ? lengthsToRange(lengthAdd(openingBracketEnd, ((_a = node.child) === null || _a === void 0 ? void 0 : _a.length) || lengthZero), nodeOffsetEnd) : undefined, level, minIndentation));\n    level++;\n  }\n\n  let curOffset = nodeOffset;\n\n  for (const child of node.children) {\n    const childOffset = curOffset;\n    curOffset = lengthAdd(curOffset, child.length);\n\n    if (lengthLessThanEqual(childOffset, endOffset) && lengthLessThanEqual(startOffset, curOffset)) {\n      collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level);\n    }\n  }\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairs/bracketPairsImpl.js"],"names":["Emitter","Disposable","DisposableStore","MutableDisposable","Range","BracketInfo","BracketPairWithMinIndentationInfo","TextEditInfo","LanguageAgnosticBracketTokens","lengthAdd","lengthGreaterThanEqual","lengthLessThanEqual","lengthOfString","lengthsToRange","lengthZero","positionToLength","toLength","parseDocument","DenseKeyProvider","FastTokenizer","TextBufferTokenizer","BracketPairs","constructor","textModel","languageConfigurationService","cache","_register","onDidChangeEmitter","onDidChange","event","bracketsRequested","onDidChangeOptions","e","clear","updateCache","onDidChangeLanguage","_a","languageId","value","object","didLanguageChange","isDocumentSupported","maxSupportedDocumentLength","getValueLength","store","createDisposableRef","add","ActiveBracketPairsImpl","getLanguageConfiguration","fire","handleContentChanged","change","getBracketPairsInRange","range","getBracketPairsInRangeWithMinIndentation","getBracketsInRange","disposable","dispose","didChangeEmitter","denseKeyProvider","brackets","onBackgroundTokenizationStateChanged","backgroundTokenizationState","wasUndefined","initialAstWithoutTokens","undefined","onDidChangeTokens","ranges","edits","map","r","fromLineNumber","toLineNumber","astWithTokens","parseDocumentFromTextBuffer","getSingleLanguageBracketTokens","getLanguageId","tokenizer","getValue","changes","c","lift","getStartPosition","getEndPosition","text","reverse","previousAst","immutable","isPure","previousAstClone","deepClone","result","startOffset","startLineNumber","startColumn","endOffset","endLineNumber","endColumn","Array","node","collectBrackets","length","includeMinIndentation","startLength","endLength","context","CollectBracketPairsContext","collectBracketPairs","nodeOffsetStart","nodeOffsetEnd","level","kind","push","child","children","openingBracket","closingBracket","nodeOffset","openingBracketEnd","minIndentation","computeMinIndentation","curOffset","childOffset"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from './bracketPairs.js';\nimport { TextEditInfo } from './impl/beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './impl/brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThanEqual, lengthOfString, lengthsToRange, lengthZero, positionToLength, toLength } from './impl/length.js';\nimport { parseDocument } from './impl/parser.js';\nimport { DenseKeyProvider } from './impl/smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './impl/tokenizer.js';\nexport class BracketPairs extends Disposable {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.cache = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n        this._register(textModel.onDidChangeOptions(e => {\n            this.cache.clear();\n            this.updateCache();\n        }));\n        this._register(textModel.onDidChangeLanguage(e => {\n            this.cache.clear();\n            this.updateCache();\n        }));\n        this._register(this.languageConfigurationService.onDidChange(e => {\n            var _a;\n            if (!e.languageId || ((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.object.didLanguageChange(e.languageId))) {\n                this.cache.clear();\n                this.updateCache();\n            }\n        }));\n    }\n    get isDocumentSupported() {\n        const maxSupportedDocumentLength = /* max lines */ 50000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    updateCache() {\n        if (this.bracketsRequested && this.isDocumentSupported) {\n            if (!this.cache.value) {\n                const store = new DisposableStore();\n                this.cache.value = createDisposableRef(store.add(new ActiveBracketPairsImpl(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.cache.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            this.cache.clear();\n            this.onDidChangeEmitter.fire();\n        }\n    }\n    handleContentChanged(change) {\n        var _a;\n        (_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.object.handleContentChanged(change);\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateCache();\n        return ((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, false)) || [];\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateCache();\n        return ((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, true)) || [];\n    }\n    getBracketsInRange(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateCache();\n        return ((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.object.getBracketsInRange(range)) || [];\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose(),\n    };\n}\nclass ActiveBracketPairsImpl extends Disposable {\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        this._register(textModel.onBackgroundTokenizationStateChanged(() => {\n            if (textModel.backgroundTokenizationState === 2 /* Completed */) {\n                const wasUndefined = this.initialAstWithoutTokens === undefined;\n                // Clear the initial tree as we can use the tree with token information now.\n                this.initialAstWithoutTokens = undefined;\n                if (!wasUndefined) {\n                    this.didChangeEmitter.fire();\n                }\n            }\n        }));\n        this._register(textModel.onDidChangeTokens(({ ranges }) => {\n            const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n            this.astWithTokens = this.parseDocumentFromTextBuffer(edits, this.astWithTokens, false);\n            if (!this.initialAstWithoutTokens) {\n                this.didChangeEmitter.fire();\n            }\n        }));\n        if (textModel.backgroundTokenizationState === 0 /* Uninitialized */) {\n            // There are no token information yet\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.backgroundTokenizationState === 2 /* Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else if (textModel.backgroundTokenizationState === 1 /* InProgress */) {\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    handleContentChanged(change) {\n        const edits = change.changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        this.astWithTokens = this.parseDocumentFromTextBuffer(edits, this.astWithTokens, false);\n        if (this.initialAstWithoutTokens) {\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(edits, this.initialAstWithoutTokens, false);\n        }\n    }\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        // Is much faster if `isPure = false`.\n        const isPure = false;\n        const previousAstClone = isPure ? previousAst === null || previousAst === void 0 ? void 0 : previousAst.deepClone() : previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range) {\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        const result = new Array();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        collectBrackets(node, lengthZero, node.length, startOffset, endOffset, result);\n        return result;\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        const result = new Array();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        const context = new CollectBracketPairsContext(result, includeMinIndentation, this.textModel);\n        collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context);\n        return result;\n    }\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level = 0) {\n    if (node.kind === 1 /* Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        result.push(new BracketInfo(range, level - 1, false));\n    }\n    else if (node.kind === 3 /* UnexpectedClosingBracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        result.push(new BracketInfo(range, level - 1, true));\n    }\n    else if (node.kind === 4 /* List */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n    }\n    else if (node.kind === 2 /* Pair */) {\n        // Don't use node.children here to improve performance\n        level++;\n        {\n            const child = node.openingBracket;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        if (node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        if (node.closingBracket) {\n            const child = node.closingBracket;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(result, includeMinIndentation, textModel) {\n        this.result = result;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffset, nodeOffsetEnd, startOffset, endOffset, context, level = 0) {\n    var _a;\n    if (node.kind === 2 /* Pair */) {\n        const openingBracketEnd = lengthAdd(nodeOffset, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffset, context.textModel);\n        }\n        context.result.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffset, nodeOffsetEnd), lengthsToRange(nodeOffset, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, ((_a = node.child) === null || _a === void 0 ? void 0 : _a.length) || lengthZero), nodeOffsetEnd)\n            : undefined, level, minIndentation));\n        level++;\n    }\n    let curOffset = nodeOffset;\n    for (const child of node.children) {\n        const childOffset = curOffset;\n        curOffset = lengthAdd(curOffset, child.length);\n        if (lengthLessThanEqual(childOffset, endOffset) && lengthLessThanEqual(startOffset, curOffset)) {\n            collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}