{"ast":null,"code":"// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n  constructor() {\n    this.listeners = [];\n\n    this.unexpectedErrorHandler = function (e) {\n      setTimeout(() => {\n        if (e.stack) {\n          throw new Error(e.message + '\\n\\n' + e.stack);\n        }\n\n        throw e;\n      }, 0);\n    };\n  }\n\n  emit(e) {\n    this.listeners.forEach(listener => {\n      listener(e);\n    });\n  }\n\n  onUnexpectedError(e) {\n    this.unexpectedErrorHandler(e);\n    this.emit(e);\n  } // For external errors, we don't want the listeners to be called\n\n\n  onUnexpectedExternalError(e) {\n    this.unexpectedErrorHandler(e);\n  }\n\n}\nexport const errorHandler = new ErrorHandler();\nexport function onUnexpectedError(e) {\n  // ignore errors from cancelled promises\n  if (!isPromiseCanceledError(e)) {\n    errorHandler.onUnexpectedError(e);\n  }\n\n  return undefined;\n}\nexport function onUnexpectedExternalError(e) {\n  // ignore errors from cancelled promises\n  if (!isPromiseCanceledError(e)) {\n    errorHandler.onUnexpectedExternalError(e);\n  }\n\n  return undefined;\n}\nexport function transformErrorForSerialization(error) {\n  if (error instanceof Error) {\n    let {\n      name,\n      message\n    } = error;\n    const stack = error.stacktrace || error.stack;\n    return {\n      $isError: true,\n      name,\n      message,\n      stack\n    };\n  } // return as is\n\n\n  return error;\n}\nconst canceledName = 'Canceled';\n/**\n * Checks if the given error is a promise in canceled state\n */\n\nexport function isPromiseCanceledError(error) {\n  return error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n/**\n * Returns an error that signals cancellation.\n */\n\nexport function canceled() {\n  const error = new Error(canceledName);\n  error.name = error.message;\n  return error;\n}\nexport function illegalArgument(name) {\n  if (name) {\n    return new Error(`Illegal argument: ${name}`);\n  } else {\n    return new Error('Illegal argument');\n  }\n}\nexport function illegalState(name) {\n  if (name) {\n    return new Error(`Illegal state: ${name}`);\n  } else {\n    return new Error('Illegal state');\n  }\n}\nexport class NotSupportedError extends Error {\n  constructor(message) {\n    super('NotSupported');\n\n    if (message) {\n      this.message = message;\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/base/common/errors.js"],"names":["ErrorHandler","constructor","listeners","unexpectedErrorHandler","e","setTimeout","stack","Error","message","emit","forEach","listener","onUnexpectedError","onUnexpectedExternalError","errorHandler","isPromiseCanceledError","undefined","transformErrorForSerialization","error","name","stacktrace","$isError","canceledName","canceled","illegalArgument","illegalState","NotSupportedError"],"mappings":"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","sourcesContent":["// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n    constructor() {\n        this.listeners = [];\n        this.unexpectedErrorHandler = function (e) {\n            setTimeout(() => {\n                if (e.stack) {\n                    throw new Error(e.message + '\\n\\n' + e.stack);\n                }\n                throw e;\n            }, 0);\n        };\n    }\n    emit(e) {\n        this.listeners.forEach((listener) => {\n            listener(e);\n        });\n    }\n    onUnexpectedError(e) {\n        this.unexpectedErrorHandler(e);\n        this.emit(e);\n    }\n    // For external errors, we don't want the listeners to be called\n    onUnexpectedExternalError(e) {\n        this.unexpectedErrorHandler(e);\n    }\n}\nexport const errorHandler = new ErrorHandler();\nexport function onUnexpectedError(e) {\n    // ignore errors from cancelled promises\n    if (!isPromiseCanceledError(e)) {\n        errorHandler.onUnexpectedError(e);\n    }\n    return undefined;\n}\nexport function onUnexpectedExternalError(e) {\n    // ignore errors from cancelled promises\n    if (!isPromiseCanceledError(e)) {\n        errorHandler.onUnexpectedExternalError(e);\n    }\n    return undefined;\n}\nexport function transformErrorForSerialization(error) {\n    if (error instanceof Error) {\n        let { name, message } = error;\n        const stack = error.stacktrace || error.stack;\n        return {\n            $isError: true,\n            name,\n            message,\n            stack\n        };\n    }\n    // return as is\n    return error;\n}\nconst canceledName = 'Canceled';\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isPromiseCanceledError(error) {\n    return error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n/**\n * Returns an error that signals cancellation.\n */\nexport function canceled() {\n    const error = new Error(canceledName);\n    error.name = error.message;\n    return error;\n}\nexport function illegalArgument(name) {\n    if (name) {\n        return new Error(`Illegal argument: ${name}`);\n    }\n    else {\n        return new Error('Illegal argument');\n    }\n}\nexport function illegalState(name) {\n    if (name) {\n        return new Error(`Illegal state: ${name}`);\n    }\n    else {\n        return new Error('Illegal state');\n    }\n}\nexport class NotSupportedError extends Error {\n    constructor(message) {\n        super('NotSupported');\n        if (message) {\n            this.message = message;\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}