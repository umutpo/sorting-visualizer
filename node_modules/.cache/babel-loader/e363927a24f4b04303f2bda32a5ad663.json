{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color } from '../../../base/common/color.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as textModelEvents from '../model/textModelEvents.js';\nimport { TokenizationRegistry } from '../modes.js';\nimport { tokenizeLineToHTML } from '../modes/textToHtmlTokenizer.js';\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\nimport * as viewEvents from '../view/viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { IdentityLinesCollection, SplitLinesCollection } from './splitLinesCollection.js';\nimport { MinimapLinesRenderingData, ViewLineRenderingData, OverviewRulerDecorationsGroup } from './viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { CursorsController } from '../controller/cursor.js';\nimport { CursorConfiguration } from '../controller/cursorCommon.js';\nimport { ViewModelEventDispatcher, FocusChangedEvent, ScrollChangedEvent, ViewZonesChangedEvent, ReadOnlyEditAttemptEvent } from './viewModelEventDispatcher.js';\nimport { PLAINTEXT_MODE_ID } from '../modes/modesRegistry.js';\nconst USE_IDENTITY_LINES_COLLECTION = true;\nexport class ViewModel extends Disposable {\n  constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame) {\n    super();\n    this._editorId = editorId;\n    this._configuration = configuration;\n    this.model = model;\n    this._eventDispatcher = new ViewModelEventDispatcher();\n    this.onEvent = this._eventDispatcher.onEvent;\n    this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration);\n    this._tokenizeViewportSoon = this._register(new RunOnceScheduler(() => this.tokenizeViewport(), 50));\n    this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\n    this._hasFocus = false;\n    this._viewportStartLine = -1;\n    this._viewportStartLineTrackedRange = null;\n    this._viewportStartLineDelta = 0;\n\n    if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n      this._lines = new IdentityLinesCollection(this.model);\n    } else {\n      const options = this._configuration.options;\n      const fontInfo = options.get(43\n      /* fontInfo */\n      );\n      const wrappingStrategy = options.get(123\n      /* wrappingStrategy */\n      );\n      const wrappingInfo = options.get(130\n      /* wrappingInfo */\n      );\n      const wrappingIndent = options.get(122\n      /* wrappingIndent */\n      );\n      this._lines = new SplitLinesCollection(this._editorId, this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent);\n    }\n\n    this.coordinatesConverter = this._lines.createCoordinatesConverter();\n    this._cursor = this._register(new CursorsController(model, this, this.coordinatesConverter, this.cursorConfig));\n    this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n\n    this._register(this.viewLayout.onDidScroll(e => {\n      if (e.scrollTopChanged) {\n        this._tokenizeViewportSoon.schedule();\n      }\n\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\n\n      this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\n    }));\n\n    this._register(this.viewLayout.onDidContentSizeChange(e => {\n      this._eventDispatcher.emitOutgoingEvent(e);\n    }));\n\n    this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\n\n    this._registerModelEvents();\n\n    this._register(this._configuration.onDidChangeFast(e => {\n      try {\n        const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n\n        this._onConfigurationChanged(eventsCollector, e);\n      } finally {\n        this._eventDispatcher.endEmitViewEvents();\n      }\n    }));\n\n    this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\n    }));\n\n    this._updateConfigurationViewLineCountNow();\n  }\n\n  dispose() {\n    // First remove listeners, as disposing the lines might end up sending\n    // model decoration changed events ... and we no longer care about them ...\n    super.dispose();\n\n    this._decorations.dispose();\n\n    this._lines.dispose();\n\n    this.invalidateMinimapColorCache();\n    this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, null, 1\n    /* NeverGrowsWhenTypingAtEdges */\n    );\n\n    this._eventDispatcher.dispose();\n  }\n\n  createLineBreaksComputer() {\n    return this._lines.createLineBreaksComputer();\n  }\n\n  addViewEventHandler(eventHandler) {\n    this._eventDispatcher.addViewEventHandler(eventHandler);\n  }\n\n  removeViewEventHandler(eventHandler) {\n    this._eventDispatcher.removeViewEventHandler(eventHandler);\n  }\n\n  _updateConfigurationViewLineCountNow() {\n    this._configuration.setViewLineCount(this._lines.getViewLineCount());\n  }\n\n  tokenizeViewport() {\n    const linesViewportData = this.viewLayout.getLinesViewportData();\n    const viewVisibleRange = new Range(linesViewportData.startLineNumber, this.getLineMinColumn(linesViewportData.startLineNumber), linesViewportData.endLineNumber, this.getLineMaxColumn(linesViewportData.endLineNumber));\n\n    const modelVisibleRanges = this._toModelVisibleRanges(viewVisibleRange);\n\n    for (const modelVisibleRange of modelVisibleRanges) {\n      this.model.tokenizeViewport(modelVisibleRange.startLineNumber, modelVisibleRange.endLineNumber);\n    }\n  }\n\n  setHasFocus(hasFocus) {\n    this._hasFocus = hasFocus;\n\n    this._cursor.setHasFocus(hasFocus);\n\n    this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\n\n    this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\n  }\n\n  onCompositionStart() {\n    this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\n  }\n\n  onCompositionEnd() {\n    this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\n  }\n\n  onDidColorThemeChange() {\n    this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent());\n  }\n\n  _onConfigurationChanged(eventsCollector, e) {\n    // We might need to restore the current centered view range, so save it (if available)\n    let previousViewportStartModelPosition = null;\n\n    if (this._viewportStartLine !== -1) {\n      let previousViewportStartViewPosition = new Position(this._viewportStartLine, this.getLineMinColumn(this._viewportStartLine));\n      previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n    }\n\n    let restorePreviousViewportStart = false;\n    const options = this._configuration.options;\n    const fontInfo = options.get(43\n    /* fontInfo */\n    );\n    const wrappingStrategy = options.get(123\n    /* wrappingStrategy */\n    );\n    const wrappingInfo = options.get(130\n    /* wrappingInfo */\n    );\n    const wrappingIndent = options.get(122\n    /* wrappingIndent */\n    );\n\n    if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent)) {\n      eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n      eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n      eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n\n      this._cursor.onLineMappingChanged(eventsCollector);\n\n      this._decorations.onLineMappingChanged();\n\n      this.viewLayout.onFlushed(this.getLineCount());\n\n      if (this.viewLayout.getCurrentScrollTop() !== 0) {\n        // Never change the scroll position from 0 to something else...\n        restorePreviousViewportStart = true;\n      }\n\n      this._updateConfigurationViewLineCount.schedule();\n    }\n\n    if (e.hasChanged(80\n    /* readOnly */\n    )) {\n      // Must read again all decorations due to readOnly filtering\n      this._decorations.reset();\n\n      eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n    }\n\n    eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\n    this.viewLayout.onConfigurationChanged(e);\n\n    if (restorePreviousViewportStart && previousViewportStartModelPosition) {\n      const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(previousViewportStartModelPosition);\n      const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n      this.viewLayout.setScrollPosition({\n        scrollTop: viewPositionTop + this._viewportStartLineDelta\n      }, 1\n      /* Immediate */\n      );\n    }\n\n    if (CursorConfiguration.shouldRecreate(e)) {\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration);\n\n      this._cursor.updateConfiguration(this.cursorConfig);\n    }\n  }\n\n  _registerModelEvents() {\n    this._register(this.model.onDidChangeContentOrInjectedText(e => {\n      try {\n        const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n\n        let hadOtherModelChange = false;\n        let hadModelLineChangeThatChangedLineMapping = false;\n        const changes = e.changes;\n        const versionId = e instanceof textModelEvents.ModelRawContentChangedEvent ? e.versionId : null; // Do a first pass to compute line mappings, and a second pass to actually interpret them\n\n        const lineBreaksComputer = this._lines.createLineBreaksComputer();\n\n        for (const change of changes) {\n          switch (change.changeType) {\n            case 4\n            /* LinesInserted */\n            :\n              {\n                for (let lineIdx = 0; lineIdx < change.detail.length; lineIdx++) {\n                  const line = change.detail[lineIdx];\n                  let injectedText = change.injectedTexts[lineIdx];\n\n                  if (injectedText) {\n                    injectedText = injectedText.filter(element => !element.ownerId || element.ownerId === this._editorId);\n                  }\n\n                  lineBreaksComputer.addRequest(line, injectedText, null);\n                }\n\n                break;\n              }\n\n            case 2\n            /* LineChanged */\n            :\n              {\n                let injectedText = null;\n\n                if (change.injectedText) {\n                  injectedText = change.injectedText.filter(element => !element.ownerId || element.ownerId === this._editorId);\n                }\n\n                lineBreaksComputer.addRequest(change.detail, injectedText, null);\n                break;\n              }\n          }\n        }\n\n        const lineBreaks = lineBreaksComputer.finalize();\n        let lineBreaksOffset = 0;\n\n        for (const change of changes) {\n          switch (change.changeType) {\n            case 1\n            /* Flush */\n            :\n              {\n                this._lines.onModelFlushed();\n\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n\n                this._decorations.reset();\n\n                this.viewLayout.onFlushed(this.getLineCount());\n                hadOtherModelChange = true;\n                break;\n              }\n\n            case 3\n            /* LinesDeleted */\n            :\n              {\n                const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n\n                if (linesDeletedEvent !== null) {\n                  eventsCollector.emitViewEvent(linesDeletedEvent);\n                  this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                }\n\n                hadOtherModelChange = true;\n                break;\n              }\n\n            case 4\n            /* LinesInserted */\n            :\n              {\n                const insertedLineBreaks = lineBreaks.slice(lineBreaksOffset, lineBreaksOffset + change.detail.length);\n                lineBreaksOffset += change.detail.length;\n\n                const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\n\n                if (linesInsertedEvent !== null) {\n                  eventsCollector.emitViewEvent(linesInsertedEvent);\n                  this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                }\n\n                hadOtherModelChange = true;\n                break;\n              }\n\n            case 2\n            /* LineChanged */\n            :\n              {\n                const changedLineBreakData = lineBreaks[lineBreaksOffset];\n                lineBreaksOffset++;\n\n                const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\n\n                hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n\n                if (linesChangedEvent) {\n                  eventsCollector.emitViewEvent(linesChangedEvent);\n                }\n\n                if (linesInsertedEvent) {\n                  eventsCollector.emitViewEvent(linesInsertedEvent);\n                  this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                }\n\n                if (linesDeletedEvent) {\n                  eventsCollector.emitViewEvent(linesDeletedEvent);\n                  this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                }\n\n                break;\n              }\n\n            case 5\n            /* EOLChanged */\n            :\n              {\n                // Nothing to do. The new version will be accepted below\n                break;\n              }\n          }\n        }\n\n        if (versionId !== null) {\n          this._lines.acceptVersionId(versionId);\n        }\n\n        this.viewLayout.onHeightMaybeChanged();\n\n        if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n          eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n          eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n\n          this._cursor.onLineMappingChanged(eventsCollector);\n\n          this._decorations.onLineMappingChanged();\n        }\n      } finally {\n        this._eventDispatcher.endEmitViewEvents();\n      } // Update the configuration and reset the centered view line\n\n\n      this._viewportStartLine = -1;\n\n      this._configuration.setMaxLineNumber(this.model.getLineCount());\n\n      this._updateConfigurationViewLineCountNow(); // Recover viewport\n\n\n      if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && this._viewportStartLineTrackedRange) {\n        const modelRange = this.model._getTrackedRange(this._viewportStartLineTrackedRange);\n\n        if (modelRange) {\n          const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n          const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n          this.viewLayout.setScrollPosition({\n            scrollTop: viewPositionTop + this._viewportStartLineDelta\n          }, 1\n          /* Immediate */\n          );\n        }\n      }\n\n      try {\n        const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n\n        this._cursor.onModelContentChanged(eventsCollector, e);\n      } finally {\n        this._eventDispatcher.endEmitViewEvents();\n      }\n    }));\n\n    this._register(this.model.onDidChangeTokens(e => {\n      let viewRanges = [];\n\n      for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n        const modelRange = e.ranges[j];\n        const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n        const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n        viewRanges[j] = {\n          fromLineNumber: viewStartLineNumber,\n          toLineNumber: viewEndLineNumber\n        };\n      }\n\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\n\n      if (e.tokenizationSupportChanged) {\n        this._tokenizeViewportSoon.schedule();\n      }\n    }));\n\n    this._register(this.model.onDidChangeLanguageConfiguration(e => {\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\n\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration);\n\n      this._cursor.updateConfiguration(this.cursorConfig);\n    }));\n\n    this._register(this.model.onDidChangeLanguage(e => {\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration);\n\n      this._cursor.updateConfiguration(this.cursorConfig);\n    }));\n\n    this._register(this.model.onDidChangeOptions(e => {\n      // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n      if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\n        try {\n          const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n\n          eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n          eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n          eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n\n          this._cursor.onLineMappingChanged(eventsCollector);\n\n          this._decorations.onLineMappingChanged();\n\n          this.viewLayout.onFlushed(this.getLineCount());\n        } finally {\n          this._eventDispatcher.endEmitViewEvents();\n        }\n\n        this._updateConfigurationViewLineCount.schedule();\n      }\n\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration);\n\n      this._cursor.updateConfiguration(this.cursorConfig);\n    }));\n\n    this._register(this.model.onDidChangeDecorations(e => {\n      this._decorations.onModelDecorationsChanged();\n\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\n    }));\n  }\n\n  setHiddenAreas(ranges) {\n    let lineMappingChanged = false;\n\n    try {\n      const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n\n      lineMappingChanged = this._lines.setHiddenAreas(ranges);\n\n      if (lineMappingChanged) {\n        eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n        eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n        eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n\n        this._cursor.onLineMappingChanged(eventsCollector);\n\n        this._decorations.onLineMappingChanged();\n\n        this.viewLayout.onFlushed(this.getLineCount());\n        this.viewLayout.onHeightMaybeChanged();\n      }\n    } finally {\n      this._eventDispatcher.endEmitViewEvents();\n    }\n\n    this._updateConfigurationViewLineCount.schedule();\n\n    if (lineMappingChanged) {\n      this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n    }\n  }\n\n  getVisibleRangesPlusViewportAboveBelow() {\n    const layoutInfo = this._configuration.options.get(129\n    /* layoutInfo */\n    );\n\n    const lineHeight = this._configuration.options.get(58\n    /* lineHeight */\n    );\n\n    const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\n    const partialData = this.viewLayout.getLinesViewportData();\n    const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\n    const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\n    return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\n  }\n\n  getVisibleRanges() {\n    const visibleViewRange = this.getCompletelyVisibleViewRange();\n    return this._toModelVisibleRanges(visibleViewRange);\n  }\n\n  _toModelVisibleRanges(visibleViewRange) {\n    const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n\n    const hiddenAreas = this._lines.getHiddenAreas();\n\n    if (hiddenAreas.length === 0) {\n      return [visibleRange];\n    }\n\n    let result = [],\n        resultLen = 0;\n    let startLineNumber = visibleRange.startLineNumber;\n    let startColumn = visibleRange.startColumn;\n    let endLineNumber = visibleRange.endLineNumber;\n    let endColumn = visibleRange.endColumn;\n\n    for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n      const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n      const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n\n      if (hiddenEndLineNumber < startLineNumber) {\n        continue;\n      }\n\n      if (hiddenStartLineNumber > endLineNumber) {\n        continue;\n      }\n\n      if (startLineNumber < hiddenStartLineNumber) {\n        result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n      }\n\n      startLineNumber = hiddenEndLineNumber + 1;\n      startColumn = 1;\n    }\n\n    if (startLineNumber < endLineNumber || startLineNumber === endLineNumber && startColumn < endColumn) {\n      result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n\n    return result;\n  }\n\n  getCompletelyVisibleViewRange() {\n    const partialData = this.viewLayout.getLinesViewportData();\n    const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n    const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n    return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n  }\n\n  getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n    const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n    const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n    const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n    return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n  }\n\n  saveState() {\n    const compatViewState = this.viewLayout.saveState();\n    const scrollTop = compatViewState.scrollTop;\n    const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n    const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n    const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n    return {\n      scrollLeft: compatViewState.scrollLeft,\n      firstPosition: firstPosition,\n      firstPositionDeltaTop: firstPositionDeltaTop\n    };\n  }\n\n  reduceRestoreState(state) {\n    if (typeof state.firstPosition === 'undefined') {\n      // This is a view state serialized by an older version\n      return this._reduceRestoreStateCompatibility(state);\n    }\n\n    const modelPosition = this.model.validatePosition(state.firstPosition);\n    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n    const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n    return {\n      scrollLeft: state.scrollLeft,\n      scrollTop: scrollTop\n    };\n  }\n\n  _reduceRestoreStateCompatibility(state) {\n    return {\n      scrollLeft: state.scrollLeft,\n      scrollTop: state.scrollTopWithoutViewZones\n    };\n  }\n\n  getTabSize() {\n    return this.model.getOptions().tabSize;\n  }\n\n  getTextModelOptions() {\n    return this.model.getOptions();\n  }\n\n  getLineCount() {\n    return this._lines.getViewLineCount();\n  }\n  /**\n   * Gives a hint that a lot of requests are about to come in for these line numbers.\n   */\n\n\n  setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n    this._viewportStartLine = startLineNumber;\n    let position = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, this.getLineMinColumn(startLineNumber)));\n    this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1\n    /* NeverGrowsWhenTypingAtEdges */\n    );\n    const viewportStartLineTop = this.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n    const scrollTop = this.viewLayout.getCurrentScrollTop();\n    this._viewportStartLineDelta = scrollTop - viewportStartLineTop;\n  }\n\n  getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n    return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n  }\n\n  getLinesIndentGuides(startLineNumber, endLineNumber) {\n    return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n  }\n\n  getBracketGuidesInRangeByLine(startLineNumber, endLineNumber, activePosition, options) {\n    return this._lines.getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options);\n  }\n\n  getLineContent(lineNumber) {\n    return this._lines.getViewLineContent(lineNumber);\n  }\n\n  getLineLength(lineNumber) {\n    return this._lines.getViewLineLength(lineNumber);\n  }\n\n  getLineMinColumn(lineNumber) {\n    return this._lines.getViewLineMinColumn(lineNumber);\n  }\n\n  getLineMaxColumn(lineNumber) {\n    return this._lines.getViewLineMaxColumn(lineNumber);\n  }\n\n  getLineFirstNonWhitespaceColumn(lineNumber) {\n    const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n\n    if (result === -1) {\n      return 0;\n    }\n\n    return result + 1;\n  }\n\n  getLineLastNonWhitespaceColumn(lineNumber) {\n    const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n\n    if (result === -1) {\n      return 0;\n    }\n\n    return result + 2;\n  }\n\n  getDecorationsInViewport(visibleRange) {\n    return this._decorations.getDecorationsViewportData(visibleRange).decorations;\n  }\n\n  getInjectedTextAt(viewPosition) {\n    return this._lines.getInjectedTextAt(viewPosition);\n  }\n\n  getViewLineRenderingData(visibleRange, lineNumber) {\n    let mightContainRTL = this.model.mightContainRTL();\n    let mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n    let tabSize = this.getTabSize();\n\n    let lineData = this._lines.getViewLineData(lineNumber);\n\n    let allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n\n    let inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n\n    if (lineData.inlineDecorations) {\n      inlineDecorations = [...inlineDecorations, ...lineData.inlineDecorations.map(d => d.toInlineDecoration(lineNumber))];\n    }\n\n    return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\n  }\n\n  getViewLineData(lineNumber) {\n    return this._lines.getViewLineData(lineNumber);\n  }\n\n  getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n    let result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n\n    return new MinimapLinesRenderingData(this.getTabSize(), result);\n  }\n\n  getAllOverviewRulerDecorations(theme) {\n    const decorations = this.model.getOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options));\n    const result = new OverviewRulerDecorations();\n\n    for (const decoration of decorations) {\n      const decorationOptions = decoration.options;\n      const opts = decorationOptions.overviewRuler;\n\n      if (!opts) {\n        continue;\n      }\n\n      const lane = opts.position;\n\n      if (lane === 0) {\n        continue;\n      }\n\n      const color = opts.getColor(theme);\n      const viewStartLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n      const viewEndLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n      result.accept(color, decorationOptions.zIndex, viewStartLineNumber, viewEndLineNumber, lane);\n    }\n\n    return result.asArray;\n  }\n\n  invalidateOverviewRulerColorCache() {\n    const decorations = this.model.getOverviewRulerDecorations();\n\n    for (const decoration of decorations) {\n      const opts = decoration.options.overviewRuler;\n\n      if (opts) {\n        opts.invalidateCachedColor();\n      }\n    }\n  }\n\n  invalidateMinimapColorCache() {\n    const decorations = this.model.getAllDecorations();\n\n    for (const decoration of decorations) {\n      const opts = decoration.options.minimap;\n\n      if (opts) {\n        opts.invalidateCachedColor();\n      }\n    }\n  }\n\n  getValueInRange(range, eol) {\n    const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n    return this.model.getValueInRange(modelRange, eol);\n  }\n\n  getModelLineMaxColumn(modelLineNumber) {\n    return this.model.getLineMaxColumn(modelLineNumber);\n  }\n\n  validateModelPosition(position) {\n    return this.model.validatePosition(position);\n  }\n\n  validateModelRange(range) {\n    return this.model.validateRange(range);\n  }\n\n  deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n    const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n\n    if (this.model.getEOL().length === 2) {\n      // This model uses CRLF, so the delta must take that into account\n      if (deltaOffset < 0) {\n        deltaOffset -= lineFeedCnt;\n      } else {\n        deltaOffset += lineFeedCnt;\n      }\n    }\n\n    const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n    const resultOffset = modelAnchorOffset + deltaOffset;\n    return this.model.getPositionAt(resultOffset);\n  }\n\n  getEOL() {\n    return this.model.getEOL();\n  }\n\n  getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\n    const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n    modelRanges = modelRanges.slice(0);\n    modelRanges.sort(Range.compareRangesUsingStarts);\n    let hasEmptyRange = false;\n    let hasNonEmptyRange = false;\n\n    for (const range of modelRanges) {\n      if (range.isEmpty()) {\n        hasEmptyRange = true;\n      } else {\n        hasNonEmptyRange = true;\n      }\n    }\n\n    if (!hasNonEmptyRange) {\n      // all ranges are empty\n      if (!emptySelectionClipboard) {\n        return '';\n      }\n\n      const modelLineNumbers = modelRanges.map(r => r.startLineNumber);\n      let result = '';\n\n      for (let i = 0; i < modelLineNumbers.length; i++) {\n        if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n          continue;\n        }\n\n        result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n      }\n\n      return result;\n    }\n\n    if (hasEmptyRange && emptySelectionClipboard) {\n      // mixed empty selections and non-empty selections\n      let result = [];\n      let prevModelLineNumber = 0;\n\n      for (const modelRange of modelRanges) {\n        const modelLineNumber = modelRange.startLineNumber;\n\n        if (modelRange.isEmpty()) {\n          if (modelLineNumber !== prevModelLineNumber) {\n            result.push(this.model.getLineContent(modelLineNumber));\n          }\n        } else {\n          result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2\n          /* CRLF */\n          : 0\n          /* TextDefined */\n          ));\n        }\n\n        prevModelLineNumber = modelLineNumber;\n      }\n\n      return result.length === 1 ? result[0] : result;\n    }\n\n    let result = [];\n\n    for (const modelRange of modelRanges) {\n      if (!modelRange.isEmpty()) {\n        result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2\n        /* CRLF */\n        : 0\n        /* TextDefined */\n        ));\n      }\n    }\n\n    return result.length === 1 ? result[0] : result;\n  }\n\n  getRichTextToCopy(modelRanges, emptySelectionClipboard) {\n    const languageId = this.model.getLanguageId();\n\n    if (languageId === PLAINTEXT_MODE_ID) {\n      return null;\n    }\n\n    if (modelRanges.length !== 1) {\n      // no multiple selection support at this time\n      return null;\n    }\n\n    let range = modelRanges[0];\n\n    if (range.isEmpty()) {\n      if (!emptySelectionClipboard) {\n        // nothing to copy\n        return null;\n      }\n\n      const lineNumber = range.startLineNumber;\n      range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n    }\n\n    const fontInfo = this._configuration.options.get(43\n    /* fontInfo */\n    );\n\n    const colorMap = this._getColorMap();\n\n    const hasBadChars = /[:;\\\\\\/<>]/.test(fontInfo.fontFamily);\n    const useDefaultFontFamily = hasBadChars || fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily;\n    let fontFamily;\n\n    if (useDefaultFontFamily) {\n      fontFamily = EDITOR_FONT_DEFAULTS.fontFamily;\n    } else {\n      fontFamily = fontInfo.fontFamily;\n      fontFamily = fontFamily.replace(/\"/g, '\\'');\n      const hasQuotesOrIsList = /[,']/.test(fontFamily);\n\n      if (!hasQuotesOrIsList) {\n        const needsQuotes = /[+ ]/.test(fontFamily);\n\n        if (needsQuotes) {\n          fontFamily = `'${fontFamily}'`;\n        }\n      }\n\n      fontFamily = `${fontFamily}, ${EDITOR_FONT_DEFAULTS.fontFamily}`;\n    }\n\n    return {\n      mode: languageId,\n      html: `<div style=\"` + `color: ${colorMap[1\n      /* DefaultForeground */\n      ]};` + `background-color: ${colorMap[2\n      /* DefaultBackground */\n      ]};` + `font-family: ${fontFamily};` + `font-weight: ${fontInfo.fontWeight};` + `font-size: ${fontInfo.fontSize}px;` + `line-height: ${fontInfo.lineHeight}px;` + `white-space: pre;` + `\">` + this._getHTMLToCopy(range, colorMap) + '</div>'\n    };\n  }\n\n  _getHTMLToCopy(modelRange, colorMap) {\n    const startLineNumber = modelRange.startLineNumber;\n    const startColumn = modelRange.startColumn;\n    const endLineNumber = modelRange.endLineNumber;\n    const endColumn = modelRange.endColumn;\n    const tabSize = this.getTabSize();\n    let result = '';\n\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const lineTokens = this.model.getLineTokens(lineNumber);\n      const lineContent = lineTokens.getLineContent();\n      const startOffset = lineNumber === startLineNumber ? startColumn - 1 : 0;\n      const endOffset = lineNumber === endLineNumber ? endColumn - 1 : lineContent.length;\n\n      if (lineContent === '') {\n        result += '<br>';\n      } else {\n        result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\n      }\n    }\n\n    return result;\n  }\n\n  _getColorMap() {\n    let colorMap = TokenizationRegistry.getColorMap();\n    let result = ['#000000'];\n\n    if (colorMap) {\n      for (let i = 1, len = colorMap.length; i < len; i++) {\n        result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n      }\n    }\n\n    return result;\n  } //#region model\n\n\n  pushStackElement() {\n    this.model.pushStackElement();\n  } //#endregion\n  //#region cursor operations\n\n\n  getPrimaryCursorState() {\n    return this._cursor.getPrimaryCursorState();\n  }\n\n  getLastAddedCursorIndex() {\n    return this._cursor.getLastAddedCursorIndex();\n  }\n\n  getCursorStates() {\n    return this._cursor.getCursorStates();\n  }\n\n  setCursorStates(source, reason, states) {\n    this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\n  }\n\n  getCursorColumnSelectData() {\n    return this._cursor.getCursorColumnSelectData();\n  }\n\n  getCursorAutoClosedCharacters() {\n    return this._cursor.getAutoClosedCharacters();\n  }\n\n  setCursorColumnSelectData(columnSelectData) {\n    this._cursor.setCursorColumnSelectData(columnSelectData);\n  }\n\n  getPrevEditOperationType() {\n    return this._cursor.getPrevEditOperationType();\n  }\n\n  setPrevEditOperationType(type) {\n    this._cursor.setPrevEditOperationType(type);\n  }\n\n  getSelection() {\n    return this._cursor.getSelection();\n  }\n\n  getSelections() {\n    return this._cursor.getSelections();\n  }\n\n  getPosition() {\n    return this._cursor.getPrimaryCursorState().modelState.position;\n  }\n\n  setSelections(source, selections) {\n    let reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\n  }\n\n  saveCursorState() {\n    return this._cursor.saveState();\n  }\n\n  restoreCursorState(states) {\n    this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\n  }\n\n  _executeCursorEdit(callback) {\n    if (this._cursor.context.cursorConfig.readOnly) {\n      // we cannot edit when read only...\n      this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\n\n      return;\n    }\n\n    this._withViewEventsCollector(callback);\n  }\n\n  executeEdits(source, edits, cursorStateComputer) {\n    this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\n  }\n\n  startComposition() {\n    this._cursor.setIsDoingComposition(true);\n\n    this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\n  }\n\n  endComposition(source) {\n    this._cursor.setIsDoingComposition(false);\n\n    this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\n  }\n\n  type(text, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\n  }\n\n  compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source));\n  }\n\n  paste(text, pasteOnNewLine, multicursorText, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\n  }\n\n  cut(source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\n  }\n\n  executeCommand(command, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\n  }\n\n  executeCommands(commands, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\n  }\n\n  revealPrimaryCursor(source, revealHorizontal) {\n    this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, revealHorizontal, 0\n    /* Smooth */\n    ));\n  }\n\n  revealTopMostCursor(source) {\n    const viewPosition = this._cursor.getTopMostViewPosition();\n\n    const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n\n    this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, viewRange, null, 0\n    /* Simple */\n    , true, 0\n    /* Smooth */\n    )));\n  }\n\n  revealBottomMostCursor(source) {\n    const viewPosition = this._cursor.getBottomMostViewPosition();\n\n    const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n\n    this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, viewRange, null, 0\n    /* Simple */\n    , true, 0\n    /* Smooth */\n    )));\n  }\n\n  revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\n    this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, viewRange, null, verticalType, revealHorizontal, scrollType)));\n  } //#endregion\n  //#region viewLayout\n\n\n  getVerticalOffsetForLineNumber(viewLineNumber) {\n    return this.viewLayout.getVerticalOffsetForLineNumber(viewLineNumber);\n  }\n\n  getScrollTop() {\n    return this.viewLayout.getCurrentScrollTop();\n  }\n\n  setScrollTop(newScrollTop, scrollType) {\n    this.viewLayout.setScrollPosition({\n      scrollTop: newScrollTop\n    }, scrollType);\n  }\n\n  setScrollPosition(position, type) {\n    this.viewLayout.setScrollPosition(position, type);\n  }\n\n  deltaScrollNow(deltaScrollLeft, deltaScrollTop) {\n    this.viewLayout.deltaScrollNow(deltaScrollLeft, deltaScrollTop);\n  }\n\n  changeWhitespace(callback) {\n    const hadAChange = this.viewLayout.changeWhitespace(callback);\n\n    if (hadAChange) {\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\n\n      this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n    }\n  }\n\n  setMaxLineWidth(maxLineWidth) {\n    this.viewLayout.setMaxLineWidth(maxLineWidth);\n  } //#endregion\n\n\n  _withViewEventsCollector(callback) {\n    try {\n      const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n\n      callback(eventsCollector);\n    } finally {\n      this._eventDispatcher.endEmitViewEvents();\n    }\n  }\n\n  normalizePosition(position, affinity) {\n    return this._lines.normalizePosition(position, affinity);\n  }\n  /**\n   * Gets the column at which indentation stops at a given line.\n   * @internal\n  */\n\n\n  getLineIndentColumn(lineNumber) {\n    return this._lines.getLineIndentColumn(lineNumber);\n  }\n\n}\n\nclass OverviewRulerDecorations {\n  constructor() {\n    this._asMap = Object.create(null);\n    this.asArray = [];\n  }\n\n  accept(color, zIndex, startLineNumber, endLineNumber, lane) {\n    const prevGroup = this._asMap[color];\n\n    if (prevGroup) {\n      const prevData = prevGroup.data;\n      const prevLane = prevData[prevData.length - 3];\n      const prevEndLineNumber = prevData[prevData.length - 1];\n\n      if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n        // merge into prev\n        if (endLineNumber > prevEndLineNumber) {\n          prevData[prevData.length - 1] = endLineNumber;\n        }\n\n        return;\n      } // push\n\n\n      prevData.push(lane, startLineNumber, endLineNumber);\n    } else {\n      const group = new OverviewRulerDecorationsGroup(color, zIndex, [lane, startLineNumber, endLineNumber]);\n      this._asMap[color] = group;\n      this.asArray.push(group);\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelImpl.js"],"names":["Color","Disposable","strings","EDITOR_FONT_DEFAULTS","filterValidationDecorations","Position","Range","textModelEvents","TokenizationRegistry","tokenizeLineToHTML","MinimapTokensColorTracker","viewEvents","ViewLayout","IdentityLinesCollection","SplitLinesCollection","MinimapLinesRenderingData","ViewLineRenderingData","OverviewRulerDecorationsGroup","ViewModelDecorations","RunOnceScheduler","platform","CursorsController","CursorConfiguration","ViewModelEventDispatcher","FocusChangedEvent","ScrollChangedEvent","ViewZonesChangedEvent","ReadOnlyEditAttemptEvent","PLAINTEXT_MODE_ID","USE_IDENTITY_LINES_COLLECTION","ViewModel","constructor","editorId","configuration","model","domLineBreaksComputerFactory","monospaceLineBreaksComputerFactory","scheduleAtNextAnimationFrame","_editorId","_configuration","_eventDispatcher","onEvent","cursorConfig","getLanguageId","getOptions","_tokenizeViewportSoon","_register","tokenizeViewport","_updateConfigurationViewLineCount","_updateConfigurationViewLineCountNow","_hasFocus","_viewportStartLine","_viewportStartLineTrackedRange","_viewportStartLineDelta","isTooLargeForTokenization","_lines","options","fontInfo","get","wrappingStrategy","wrappingInfo","wrappingIndent","tabSize","wrappingColumn","coordinatesConverter","createCoordinatesConverter","_cursor","viewLayout","getLineCount","onDidScroll","e","scrollTopChanged","schedule","emitSingleViewEvent","ViewScrollChangedEvent","emitOutgoingEvent","oldScrollWidth","oldScrollLeft","oldScrollHeight","oldScrollTop","scrollWidth","scrollLeft","scrollHeight","scrollTop","onDidContentSizeChange","_decorations","_registerModelEvents","onDidChangeFast","eventsCollector","beginEmitViewEvents","_onConfigurationChanged","endEmitViewEvents","getInstance","onDidChange","ViewTokensColorsChangedEvent","dispose","invalidateMinimapColorCache","_setTrackedRange","createLineBreaksComputer","addViewEventHandler","eventHandler","removeViewEventHandler","setViewLineCount","getViewLineCount","linesViewportData","getLinesViewportData","viewVisibleRange","startLineNumber","getLineMinColumn","endLineNumber","getLineMaxColumn","modelVisibleRanges","_toModelVisibleRanges","modelVisibleRange","setHasFocus","hasFocus","ViewFocusChangedEvent","onCompositionStart","ViewCompositionStartEvent","onCompositionEnd","ViewCompositionEndEvent","onDidColorThemeChange","ViewThemeChangedEvent","previousViewportStartModelPosition","previousViewportStartViewPosition","convertViewPositionToModelPosition","restorePreviousViewportStart","setWrappingSettings","emitViewEvent","ViewFlushedEvent","ViewLineMappingChangedEvent","ViewDecorationsChangedEvent","onLineMappingChanged","onFlushed","getCurrentScrollTop","hasChanged","reset","ViewConfigurationChangedEvent","onConfigurationChanged","viewPosition","convertModelPositionToViewPosition","viewPositionTop","getVerticalOffsetForLineNumber","lineNumber","setScrollPosition","shouldRecreate","updateConfiguration","onDidChangeContentOrInjectedText","hadOtherModelChange","hadModelLineChangeThatChangedLineMapping","changes","versionId","ModelRawContentChangedEvent","lineBreaksComputer","change","changeType","lineIdx","detail","length","line","injectedText","injectedTexts","filter","element","ownerId","addRequest","lineBreaks","finalize","lineBreaksOffset","onModelFlushed","linesDeletedEvent","onModelLinesDeleted","fromLineNumber","toLineNumber","onLinesDeleted","insertedLineBreaks","slice","linesInsertedEvent","onModelLinesInserted","onLinesInserted","changedLineBreakData","lineMappingChanged","linesChangedEvent","onModelLineChanged","acceptVersionId","onHeightMaybeChanged","setMaxLineNumber","getAttachedEditorCount","modelRange","_getTrackedRange","getStartPosition","onModelContentChanged","onDidChangeTokens","viewRanges","j","lenJ","ranges","viewStartLineNumber","viewEndLineNumber","ViewTokensChangedEvent","tokenizationSupportChanged","onDidChangeLanguageConfiguration","ViewLanguageConfigurationEvent","onDidChangeLanguage","onDidChangeOptions","setTabSize","onDidChangeDecorations","onModelDecorationsChanged","setHiddenAreas","getVisibleRangesPlusViewportAboveBelow","layoutInfo","lineHeight","linesAround","Math","max","round","height","partialData","startViewLineNumber","completelyVisibleStartLineNumber","endViewLineNumber","min","completelyVisibleEndLineNumber","getVisibleRanges","visibleViewRange","getCompletelyVisibleViewRange","visibleRange","convertViewRangeToModelRange","hiddenAreas","getHiddenAreas","result","resultLen","startColumn","endColumn","i","len","hiddenStartLineNumber","hiddenEndLineNumber","getCompletelyVisibleViewRangeAtScrollTop","getLinesViewportDataAtScrollTop","saveState","compatViewState","firstViewLineNumber","getLineNumberAtVerticalOffset","firstPosition","firstPositionDeltaTop","reduceRestoreState","state","_reduceRestoreStateCompatibility","modelPosition","validatePosition","scrollTopWithoutViewZones","getTabSize","getTextModelOptions","setViewport","centeredLineNumber","position","column","viewportStartLineTop","getActiveIndentGuide","minLineNumber","maxLineNumber","getLinesIndentGuides","getViewLinesIndentGuides","getBracketGuidesInRangeByLine","activePosition","getViewLinesBracketGuides","getLineContent","getViewLineContent","getLineLength","getViewLineLength","getViewLineMinColumn","getViewLineMaxColumn","getLineFirstNonWhitespaceColumn","firstNonWhitespaceIndex","getLineLastNonWhitespaceColumn","lastNonWhitespaceIndex","getDecorationsInViewport","getDecorationsViewportData","decorations","getInjectedTextAt","getViewLineRenderingData","mightContainRTL","mightContainNonBasicASCII","lineData","getViewLineData","allInlineDecorations","inlineDecorations","map","d","toInlineDecoration","minColumn","maxColumn","content","continuesWithWrappedLine","tokens","startVisibleColumn","getMinimapLinesRenderingData","needed","getViewLinesData","getAllOverviewRulerDecorations","theme","getOverviewRulerDecorations","OverviewRulerDecorations","decoration","decorationOptions","opts","overviewRuler","lane","color","getColor","getViewLineNumberOfModelPosition","range","accept","zIndex","asArray","invalidateOverviewRulerColorCache","invalidateCachedColor","getAllDecorations","minimap","getValueInRange","eol","getModelLineMaxColumn","modelLineNumber","validateModelPosition","validateModelRange","validateRange","deduceModelPositionRelativeToViewPosition","viewAnchorPosition","deltaOffset","lineFeedCnt","modelAnchor","getEOL","modelAnchorOffset","getOffsetAt","resultOffset","getPositionAt","getPlainTextToCopy","modelRanges","emptySelectionClipboard","forceCRLF","newLineCharacter","sort","compareRangesUsingStarts","hasEmptyRange","hasNonEmptyRange","isEmpty","modelLineNumbers","r","prevModelLineNumber","push","getRichTextToCopy","languageId","colorMap","_getColorMap","hasBadChars","test","fontFamily","useDefaultFontFamily","replace","hasQuotesOrIsList","needsQuotes","mode","html","fontWeight","fontSize","_getHTMLToCopy","lineTokens","getLineTokens","lineContent","startOffset","endOffset","inflate","isWindows","getColorMap","Format","CSS","formatHex","pushStackElement","getPrimaryCursorState","getLastAddedCursorIndex","getCursorStates","setCursorStates","source","reason","states","_withViewEventsCollector","setStates","getCursorColumnSelectData","getCursorAutoClosedCharacters","getAutoClosedCharacters","setCursorColumnSelectData","columnSelectData","getPrevEditOperationType","setPrevEditOperationType","type","getSelection","getSelections","getPosition","modelState","setSelections","selections","saveCursorState","restoreCursorState","restoreState","_executeCursorEdit","callback","context","readOnly","executeEdits","edits","cursorStateComputer","startComposition","setIsDoingComposition","endComposition","text","compositionType","replacePrevCharCnt","replaceNextCharCnt","positionDelta","paste","pasteOnNewLine","multicursorText","cut","executeCommand","command","executeCommands","commands","revealPrimaryCursor","revealHorizontal","revealPrimary","revealTopMostCursor","getTopMostViewPosition","viewRange","ViewRevealRangeRequestEvent","revealBottomMostCursor","getBottomMostViewPosition","revealRange","verticalType","scrollType","viewLineNumber","getScrollTop","setScrollTop","newScrollTop","deltaScrollNow","deltaScrollLeft","deltaScrollTop","changeWhitespace","hadAChange","setMaxLineWidth","maxLineWidth","normalizePosition","affinity","getLineIndentColumn","_asMap","Object","create","prevGroup","prevData","data","prevLane","prevEndLineNumber","group"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color } from '../../../base/common/color.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as textModelEvents from '../model/textModelEvents.js';\nimport { TokenizationRegistry } from '../modes.js';\nimport { tokenizeLineToHTML } from '../modes/textToHtmlTokenizer.js';\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\nimport * as viewEvents from '../view/viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { IdentityLinesCollection, SplitLinesCollection } from './splitLinesCollection.js';\nimport { MinimapLinesRenderingData, ViewLineRenderingData, OverviewRulerDecorationsGroup } from './viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { CursorsController } from '../controller/cursor.js';\nimport { CursorConfiguration } from '../controller/cursorCommon.js';\nimport { ViewModelEventDispatcher, FocusChangedEvent, ScrollChangedEvent, ViewZonesChangedEvent, ReadOnlyEditAttemptEvent } from './viewModelEventDispatcher.js';\nimport { PLAINTEXT_MODE_ID } from '../modes/modesRegistry.js';\nconst USE_IDENTITY_LINES_COLLECTION = true;\nexport class ViewModel extends Disposable {\n    constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame) {\n        super();\n        this._editorId = editorId;\n        this._configuration = configuration;\n        this.model = model;\n        this._eventDispatcher = new ViewModelEventDispatcher();\n        this.onEvent = this._eventDispatcher.onEvent;\n        this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration);\n        this._tokenizeViewportSoon = this._register(new RunOnceScheduler(() => this.tokenizeViewport(), 50));\n        this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\n        this._hasFocus = false;\n        this._viewportStartLine = -1;\n        this._viewportStartLineTrackedRange = null;\n        this._viewportStartLineDelta = 0;\n        if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n            this._lines = new IdentityLinesCollection(this.model);\n        }\n        else {\n            const options = this._configuration.options;\n            const fontInfo = options.get(43 /* fontInfo */);\n            const wrappingStrategy = options.get(123 /* wrappingStrategy */);\n            const wrappingInfo = options.get(130 /* wrappingInfo */);\n            const wrappingIndent = options.get(122 /* wrappingIndent */);\n            this._lines = new SplitLinesCollection(this._editorId, this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent);\n        }\n        this.coordinatesConverter = this._lines.createCoordinatesConverter();\n        this._cursor = this._register(new CursorsController(model, this, this.coordinatesConverter, this.cursorConfig));\n        this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n        this._register(this.viewLayout.onDidScroll((e) => {\n            if (e.scrollTopChanged) {\n                this._tokenizeViewportSoon.schedule();\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\n        }));\n        this._register(this.viewLayout.onDidContentSizeChange((e) => {\n            this._eventDispatcher.emitOutgoingEvent(e);\n        }));\n        this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\n        this._registerModelEvents();\n        this._register(this._configuration.onDidChangeFast((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                this._onConfigurationChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n        }));\n        this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\n        }));\n        this._updateConfigurationViewLineCountNow();\n    }\n    dispose() {\n        // First remove listeners, as disposing the lines might end up sending\n        // model decoration changed events ... and we no longer care about them ...\n        super.dispose();\n        this._decorations.dispose();\n        this._lines.dispose();\n        this.invalidateMinimapColorCache();\n        this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, null, 1 /* NeverGrowsWhenTypingAtEdges */);\n        this._eventDispatcher.dispose();\n    }\n    createLineBreaksComputer() {\n        return this._lines.createLineBreaksComputer();\n    }\n    addViewEventHandler(eventHandler) {\n        this._eventDispatcher.addViewEventHandler(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        this._eventDispatcher.removeViewEventHandler(eventHandler);\n    }\n    _updateConfigurationViewLineCountNow() {\n        this._configuration.setViewLineCount(this._lines.getViewLineCount());\n    }\n    tokenizeViewport() {\n        const linesViewportData = this.viewLayout.getLinesViewportData();\n        const viewVisibleRange = new Range(linesViewportData.startLineNumber, this.getLineMinColumn(linesViewportData.startLineNumber), linesViewportData.endLineNumber, this.getLineMaxColumn(linesViewportData.endLineNumber));\n        const modelVisibleRanges = this._toModelVisibleRanges(viewVisibleRange);\n        for (const modelVisibleRange of modelVisibleRanges) {\n            this.model.tokenizeViewport(modelVisibleRange.startLineNumber, modelVisibleRange.endLineNumber);\n        }\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n        this._cursor.setHasFocus(hasFocus);\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\n        this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\n    }\n    onCompositionStart() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\n    }\n    onCompositionEnd() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\n    }\n    onDidColorThemeChange() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent());\n    }\n    _onConfigurationChanged(eventsCollector, e) {\n        // We might need to restore the current centered view range, so save it (if available)\n        let previousViewportStartModelPosition = null;\n        if (this._viewportStartLine !== -1) {\n            let previousViewportStartViewPosition = new Position(this._viewportStartLine, this.getLineMinColumn(this._viewportStartLine));\n            previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n        }\n        let restorePreviousViewportStart = false;\n        const options = this._configuration.options;\n        const fontInfo = options.get(43 /* fontInfo */);\n        const wrappingStrategy = options.get(123 /* wrappingStrategy */);\n        const wrappingInfo = options.get(130 /* wrappingInfo */);\n        const wrappingIndent = options.get(122 /* wrappingIndent */);\n        if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent)) {\n            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n            this._cursor.onLineMappingChanged(eventsCollector);\n            this._decorations.onLineMappingChanged();\n            this.viewLayout.onFlushed(this.getLineCount());\n            if (this.viewLayout.getCurrentScrollTop() !== 0) {\n                // Never change the scroll position from 0 to something else...\n                restorePreviousViewportStart = true;\n            }\n            this._updateConfigurationViewLineCount.schedule();\n        }\n        if (e.hasChanged(80 /* readOnly */)) {\n            // Must read again all decorations due to readOnly filtering\n            this._decorations.reset();\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        }\n        eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\n        this.viewLayout.onConfigurationChanged(e);\n        if (restorePreviousViewportStart && previousViewportStartModelPosition) {\n            const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(previousViewportStartModelPosition);\n            const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n            this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStartLineDelta }, 1 /* Immediate */);\n        }\n        if (CursorConfiguration.shouldRecreate(e)) {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }\n    }\n    _registerModelEvents() {\n        this._register(this.model.onDidChangeContentOrInjectedText((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                let hadOtherModelChange = false;\n                let hadModelLineChangeThatChangedLineMapping = false;\n                const changes = e.changes;\n                const versionId = (e instanceof textModelEvents.ModelRawContentChangedEvent ? e.versionId : null);\n                // Do a first pass to compute line mappings, and a second pass to actually interpret them\n                const lineBreaksComputer = this._lines.createLineBreaksComputer();\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 4 /* LinesInserted */: {\n                            for (let lineIdx = 0; lineIdx < change.detail.length; lineIdx++) {\n                                const line = change.detail[lineIdx];\n                                let injectedText = change.injectedTexts[lineIdx];\n                                if (injectedText) {\n                                    injectedText = injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                                }\n                                lineBreaksComputer.addRequest(line, injectedText, null);\n                            }\n                            break;\n                        }\n                        case 2 /* LineChanged */: {\n                            let injectedText = null;\n                            if (change.injectedText) {\n                                injectedText = change.injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                            }\n                            lineBreaksComputer.addRequest(change.detail, injectedText, null);\n                            break;\n                        }\n                    }\n                }\n                const lineBreaks = lineBreaksComputer.finalize();\n                let lineBreaksOffset = 0;\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 1 /* Flush */: {\n                            this._lines.onModelFlushed();\n                            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                            this._decorations.reset();\n                            this.viewLayout.onFlushed(this.getLineCount());\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 3 /* LinesDeleted */: {\n                            const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n                            if (linesDeletedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 4 /* LinesInserted */: {\n                            const insertedLineBreaks = lineBreaks.slice(lineBreaksOffset, lineBreaksOffset + change.detail.length);\n                            lineBreaksOffset += change.detail.length;\n                            const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\n                            if (linesInsertedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 2 /* LineChanged */: {\n                            const changedLineBreakData = lineBreaks[lineBreaksOffset];\n                            lineBreaksOffset++;\n                            const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\n                            hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n                            if (linesChangedEvent) {\n                                eventsCollector.emitViewEvent(linesChangedEvent);\n                            }\n                            if (linesInsertedEvent) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            if (linesDeletedEvent) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            break;\n                        }\n                        case 5 /* EOLChanged */: {\n                            // Nothing to do. The new version will be accepted below\n                            break;\n                        }\n                    }\n                }\n                if (versionId !== null) {\n                    this._lines.acceptVersionId(versionId);\n                }\n                this.viewLayout.onHeightMaybeChanged();\n                if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                }\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            // Update the configuration and reset the centered view line\n            this._viewportStartLine = -1;\n            this._configuration.setMaxLineNumber(this.model.getLineCount());\n            this._updateConfigurationViewLineCountNow();\n            // Recover viewport\n            if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && this._viewportStartLineTrackedRange) {\n                const modelRange = this.model._getTrackedRange(this._viewportStartLineTrackedRange);\n                if (modelRange) {\n                    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n                    const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n                    this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStartLineDelta }, 1 /* Immediate */);\n                }\n            }\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                this._cursor.onModelContentChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n        }));\n        this._register(this.model.onDidChangeTokens((e) => {\n            let viewRanges = [];\n            for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n                const modelRange = e.ranges[j];\n                const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n                const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n                viewRanges[j] = {\n                    fromLineNumber: viewStartLineNumber,\n                    toLineNumber: viewEndLineNumber\n                };\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\n            if (e.tokenizationSupportChanged) {\n                this._tokenizeViewportSoon.schedule();\n            }\n        }));\n        this._register(this.model.onDidChangeLanguageConfiguration((e) => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }));\n        this._register(this.model.onDidChangeLanguage((e) => {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }));\n        this._register(this.model.onDidChangeOptions((e) => {\n            // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n            if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\n                try {\n                    const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                    eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                    this.viewLayout.onFlushed(this.getLineCount());\n                }\n                finally {\n                    this._eventDispatcher.endEmitViewEvents();\n                }\n                this._updateConfigurationViewLineCount.schedule();\n            }\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }));\n        this._register(this.model.onDidChangeDecorations((e) => {\n            this._decorations.onModelDecorationsChanged();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\n        }));\n    }\n    setHiddenAreas(ranges) {\n        let lineMappingChanged = false;\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            lineMappingChanged = this._lines.setHiddenAreas(ranges);\n            if (lineMappingChanged) {\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                this._cursor.onLineMappingChanged(eventsCollector);\n                this._decorations.onLineMappingChanged();\n                this.viewLayout.onFlushed(this.getLineCount());\n                this.viewLayout.onHeightMaybeChanged();\n            }\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n        this._updateConfigurationViewLineCount.schedule();\n        if (lineMappingChanged) {\n            this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n        }\n    }\n    getVisibleRangesPlusViewportAboveBelow() {\n        const layoutInfo = this._configuration.options.get(129 /* layoutInfo */);\n        const lineHeight = this._configuration.options.get(58 /* lineHeight */);\n        const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\n        const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\n        return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\n    }\n    getVisibleRanges() {\n        const visibleViewRange = this.getCompletelyVisibleViewRange();\n        return this._toModelVisibleRanges(visibleViewRange);\n    }\n    _toModelVisibleRanges(visibleViewRange) {\n        const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        const hiddenAreas = this._lines.getHiddenAreas();\n        if (hiddenAreas.length === 0) {\n            return [visibleRange];\n        }\n        let result = [], resultLen = 0;\n        let startLineNumber = visibleRange.startLineNumber;\n        let startColumn = visibleRange.startColumn;\n        let endLineNumber = visibleRange.endLineNumber;\n        let endColumn = visibleRange.endColumn;\n        for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n            const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n            const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n            if (hiddenEndLineNumber < startLineNumber) {\n                continue;\n            }\n            if (hiddenStartLineNumber > endLineNumber) {\n                continue;\n            }\n            if (startLineNumber < hiddenStartLineNumber) {\n                result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n            }\n            startLineNumber = hiddenEndLineNumber + 1;\n            startColumn = 1;\n        }\n        if (startLineNumber < endLineNumber || (startLineNumber === endLineNumber && startColumn < endColumn)) {\n            result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return result;\n    }\n    getCompletelyVisibleViewRange() {\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n        const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    saveState() {\n        const compatViewState = this.viewLayout.saveState();\n        const scrollTop = compatViewState.scrollTop;\n        const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n        const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n        const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n        return {\n            scrollLeft: compatViewState.scrollLeft,\n            firstPosition: firstPosition,\n            firstPositionDeltaTop: firstPositionDeltaTop\n        };\n    }\n    reduceRestoreState(state) {\n        if (typeof state.firstPosition === 'undefined') {\n            // This is a view state serialized by an older version\n            return this._reduceRestoreStateCompatibility(state);\n        }\n        const modelPosition = this.model.validatePosition(state.firstPosition);\n        const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: scrollTop\n        };\n    }\n    _reduceRestoreStateCompatibility(state) {\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: state.scrollTopWithoutViewZones\n        };\n    }\n    getTabSize() {\n        return this.model.getOptions().tabSize;\n    }\n    getTextModelOptions() {\n        return this.model.getOptions();\n    }\n    getLineCount() {\n        return this._lines.getViewLineCount();\n    }\n    /**\n     * Gives a hint that a lot of requests are about to come in for these line numbers.\n     */\n    setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n        this._viewportStartLine = startLineNumber;\n        let position = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, this.getLineMinColumn(startLineNumber)));\n        this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1 /* NeverGrowsWhenTypingAtEdges */);\n        const viewportStartLineTop = this.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n        const scrollTop = this.viewLayout.getCurrentScrollTop();\n        this._viewportStartLineDelta = scrollTop - viewportStartLineTop;\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n    }\n    getBracketGuidesInRangeByLine(startLineNumber, endLineNumber, activePosition, options) {\n        return this._lines.getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options);\n    }\n    getLineContent(lineNumber) {\n        return this._lines.getViewLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        return this._lines.getViewLineLength(lineNumber);\n    }\n    getLineMinColumn(lineNumber) {\n        return this._lines.getViewLineMinColumn(lineNumber);\n    }\n    getLineMaxColumn(lineNumber) {\n        return this._lines.getViewLineMaxColumn(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    getDecorationsInViewport(visibleRange) {\n        return this._decorations.getDecorationsViewportData(visibleRange).decorations;\n    }\n    getInjectedTextAt(viewPosition) {\n        return this._lines.getInjectedTextAt(viewPosition);\n    }\n    getViewLineRenderingData(visibleRange, lineNumber) {\n        let mightContainRTL = this.model.mightContainRTL();\n        let mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n        let tabSize = this.getTabSize();\n        let lineData = this._lines.getViewLineData(lineNumber);\n        let allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n        let inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n        if (lineData.inlineDecorations) {\n            inlineDecorations = [\n                ...inlineDecorations,\n                ...lineData.inlineDecorations.map(d => d.toInlineDecoration(lineNumber))\n            ];\n        }\n        return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\n    }\n    getViewLineData(lineNumber) {\n        return this._lines.getViewLineData(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        let result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n        return new MinimapLinesRenderingData(this.getTabSize(), result);\n    }\n    getAllOverviewRulerDecorations(theme) {\n        const decorations = this.model.getOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options));\n        const result = new OverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const decorationOptions = decoration.options;\n            const opts = decorationOptions.overviewRuler;\n            if (!opts) {\n                continue;\n            }\n            const lane = opts.position;\n            if (lane === 0) {\n                continue;\n            }\n            const color = opts.getColor(theme);\n            const viewStartLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n            const viewEndLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n            result.accept(color, decorationOptions.zIndex, viewStartLineNumber, viewEndLineNumber, lane);\n        }\n        return result.asArray;\n    }\n    invalidateOverviewRulerColorCache() {\n        const decorations = this.model.getOverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const opts = decoration.options.overviewRuler;\n            if (opts) {\n                opts.invalidateCachedColor();\n            }\n        }\n    }\n    invalidateMinimapColorCache() {\n        const decorations = this.model.getAllDecorations();\n        for (const decoration of decorations) {\n            const opts = decoration.options.minimap;\n            if (opts) {\n                opts.invalidateCachedColor();\n            }\n        }\n    }\n    getValueInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueInRange(modelRange, eol);\n    }\n    getModelLineMaxColumn(modelLineNumber) {\n        return this.model.getLineMaxColumn(modelLineNumber);\n    }\n    validateModelPosition(position) {\n        return this.model.validatePosition(position);\n    }\n    validateModelRange(range) {\n        return this.model.validateRange(range);\n    }\n    deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n        const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n        if (this.model.getEOL().length === 2) {\n            // This model uses CRLF, so the delta must take that into account\n            if (deltaOffset < 0) {\n                deltaOffset -= lineFeedCnt;\n            }\n            else {\n                deltaOffset += lineFeedCnt;\n            }\n        }\n        const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n        const resultOffset = modelAnchorOffset + deltaOffset;\n        return this.model.getPositionAt(resultOffset);\n    }\n    getEOL() {\n        return this.model.getEOL();\n    }\n    getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\n        const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n        modelRanges = modelRanges.slice(0);\n        modelRanges.sort(Range.compareRangesUsingStarts);\n        let hasEmptyRange = false;\n        let hasNonEmptyRange = false;\n        for (const range of modelRanges) {\n            if (range.isEmpty()) {\n                hasEmptyRange = true;\n            }\n            else {\n                hasNonEmptyRange = true;\n            }\n        }\n        if (!hasNonEmptyRange) {\n            // all ranges are empty\n            if (!emptySelectionClipboard) {\n                return '';\n            }\n            const modelLineNumbers = modelRanges.map((r) => r.startLineNumber);\n            let result = '';\n            for (let i = 0; i < modelLineNumbers.length; i++) {\n                if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n                    continue;\n                }\n                result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n            }\n            return result;\n        }\n        if (hasEmptyRange && emptySelectionClipboard) {\n            // mixed empty selections and non-empty selections\n            let result = [];\n            let prevModelLineNumber = 0;\n            for (const modelRange of modelRanges) {\n                const modelLineNumber = modelRange.startLineNumber;\n                if (modelRange.isEmpty()) {\n                    if (modelLineNumber !== prevModelLineNumber) {\n                        result.push(this.model.getLineContent(modelLineNumber));\n                    }\n                }\n                else {\n                    result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* CRLF */ : 0 /* TextDefined */));\n                }\n                prevModelLineNumber = modelLineNumber;\n            }\n            return result.length === 1 ? result[0] : result;\n        }\n        let result = [];\n        for (const modelRange of modelRanges) {\n            if (!modelRange.isEmpty()) {\n                result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* CRLF */ : 0 /* TextDefined */));\n            }\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    getRichTextToCopy(modelRanges, emptySelectionClipboard) {\n        const languageId = this.model.getLanguageId();\n        if (languageId === PLAINTEXT_MODE_ID) {\n            return null;\n        }\n        if (modelRanges.length !== 1) {\n            // no multiple selection support at this time\n            return null;\n        }\n        let range = modelRanges[0];\n        if (range.isEmpty()) {\n            if (!emptySelectionClipboard) {\n                // nothing to copy\n                return null;\n            }\n            const lineNumber = range.startLineNumber;\n            range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n        }\n        const fontInfo = this._configuration.options.get(43 /* fontInfo */);\n        const colorMap = this._getColorMap();\n        const hasBadChars = (/[:;\\\\\\/<>]/.test(fontInfo.fontFamily));\n        const useDefaultFontFamily = (hasBadChars || fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily);\n        let fontFamily;\n        if (useDefaultFontFamily) {\n            fontFamily = EDITOR_FONT_DEFAULTS.fontFamily;\n        }\n        else {\n            fontFamily = fontInfo.fontFamily;\n            fontFamily = fontFamily.replace(/\"/g, '\\'');\n            const hasQuotesOrIsList = /[,']/.test(fontFamily);\n            if (!hasQuotesOrIsList) {\n                const needsQuotes = /[+ ]/.test(fontFamily);\n                if (needsQuotes) {\n                    fontFamily = `'${fontFamily}'`;\n                }\n            }\n            fontFamily = `${fontFamily}, ${EDITOR_FONT_DEFAULTS.fontFamily}`;\n        }\n        return {\n            mode: languageId,\n            html: (`<div style=\"`\n                + `color: ${colorMap[1 /* DefaultForeground */]};`\n                + `background-color: ${colorMap[2 /* DefaultBackground */]};`\n                + `font-family: ${fontFamily};`\n                + `font-weight: ${fontInfo.fontWeight};`\n                + `font-size: ${fontInfo.fontSize}px;`\n                + `line-height: ${fontInfo.lineHeight}px;`\n                + `white-space: pre;`\n                + `\">`\n                + this._getHTMLToCopy(range, colorMap)\n                + '</div>')\n        };\n    }\n    _getHTMLToCopy(modelRange, colorMap) {\n        const startLineNumber = modelRange.startLineNumber;\n        const startColumn = modelRange.startColumn;\n        const endLineNumber = modelRange.endLineNumber;\n        const endColumn = modelRange.endColumn;\n        const tabSize = this.getTabSize();\n        let result = '';\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineTokens = this.model.getLineTokens(lineNumber);\n            const lineContent = lineTokens.getLineContent();\n            const startOffset = (lineNumber === startLineNumber ? startColumn - 1 : 0);\n            const endOffset = (lineNumber === endLineNumber ? endColumn - 1 : lineContent.length);\n            if (lineContent === '') {\n                result += '<br>';\n            }\n            else {\n                result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\n            }\n        }\n        return result;\n    }\n    _getColorMap() {\n        let colorMap = TokenizationRegistry.getColorMap();\n        let result = ['#000000'];\n        if (colorMap) {\n            for (let i = 1, len = colorMap.length; i < len; i++) {\n                result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n            }\n        }\n        return result;\n    }\n    //#region model\n    pushStackElement() {\n        this.model.pushStackElement();\n    }\n    //#endregion\n    //#region cursor operations\n    getPrimaryCursorState() {\n        return this._cursor.getPrimaryCursorState();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursor.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursor.getCursorStates();\n    }\n    setCursorStates(source, reason, states) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\n    }\n    getCursorColumnSelectData() {\n        return this._cursor.getCursorColumnSelectData();\n    }\n    getCursorAutoClosedCharacters() {\n        return this._cursor.getAutoClosedCharacters();\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._cursor.setCursorColumnSelectData(columnSelectData);\n    }\n    getPrevEditOperationType() {\n        return this._cursor.getPrevEditOperationType();\n    }\n    setPrevEditOperationType(type) {\n        this._cursor.setPrevEditOperationType(type);\n    }\n    getSelection() {\n        return this._cursor.getSelection();\n    }\n    getSelections() {\n        return this._cursor.getSelections();\n    }\n    getPosition() {\n        return this._cursor.getPrimaryCursorState().modelState.position;\n    }\n    setSelections(source, selections, reason = 0 /* NotSet */) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\n    }\n    saveCursorState() {\n        return this._cursor.saveState();\n    }\n    restoreCursorState(states) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\n    }\n    _executeCursorEdit(callback) {\n        if (this._cursor.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\n            return;\n        }\n        this._withViewEventsCollector(callback);\n    }\n    executeEdits(source, edits, cursorStateComputer) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\n    }\n    startComposition() {\n        this._cursor.setIsDoingComposition(true);\n        this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\n    }\n    endComposition(source) {\n        this._cursor.setIsDoingComposition(false);\n        this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\n    }\n    type(text, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\n    }\n    compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source));\n    }\n    paste(text, pasteOnNewLine, multicursorText, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\n    }\n    cut(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\n    }\n    executeCommand(command, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\n    }\n    executeCommands(commands, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\n    }\n    revealPrimaryCursor(source, revealHorizontal) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, revealHorizontal, 0 /* Smooth */));\n    }\n    revealTopMostCursor(source) {\n        const viewPosition = this._cursor.getTopMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, viewRange, null, 0 /* Simple */, true, 0 /* Smooth */)));\n    }\n    revealBottomMostCursor(source) {\n        const viewPosition = this._cursor.getBottomMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, viewRange, null, 0 /* Simple */, true, 0 /* Smooth */)));\n    }\n    revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, viewRange, null, verticalType, revealHorizontal, scrollType)));\n    }\n    //#endregion\n    //#region viewLayout\n    getVerticalOffsetForLineNumber(viewLineNumber) {\n        return this.viewLayout.getVerticalOffsetForLineNumber(viewLineNumber);\n    }\n    getScrollTop() {\n        return this.viewLayout.getCurrentScrollTop();\n    }\n    setScrollTop(newScrollTop, scrollType) {\n        this.viewLayout.setScrollPosition({ scrollTop: newScrollTop }, scrollType);\n    }\n    setScrollPosition(position, type) {\n        this.viewLayout.setScrollPosition(position, type);\n    }\n    deltaScrollNow(deltaScrollLeft, deltaScrollTop) {\n        this.viewLayout.deltaScrollNow(deltaScrollLeft, deltaScrollTop);\n    }\n    changeWhitespace(callback) {\n        const hadAChange = this.viewLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\n            this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n        }\n    }\n    setMaxLineWidth(maxLineWidth) {\n        this.viewLayout.setMaxLineWidth(maxLineWidth);\n    }\n    //#endregion\n    _withViewEventsCollector(callback) {\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            callback(eventsCollector);\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n    }\n    normalizePosition(position, affinity) {\n        return this._lines.normalizePosition(position, affinity);\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        return this._lines.getLineIndentColumn(lineNumber);\n    }\n}\nclass OverviewRulerDecorations {\n    constructor() {\n        this._asMap = Object.create(null);\n        this.asArray = [];\n    }\n    accept(color, zIndex, startLineNumber, endLineNumber, lane) {\n        const prevGroup = this._asMap[color];\n        if (prevGroup) {\n            const prevData = prevGroup.data;\n            const prevLane = prevData[prevData.length - 3];\n            const prevEndLineNumber = prevData[prevData.length - 1];\n            if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n                // merge into prev\n                if (endLineNumber > prevEndLineNumber) {\n                    prevData[prevData.length - 1] = endLineNumber;\n                }\n                return;\n            }\n            // push\n            prevData.push(lane, startLineNumber, endLineNumber);\n        }\n        else {\n            const group = new OverviewRulerDecorationsGroup(color, zIndex, [lane, startLineNumber, endLineNumber]);\n            this._asMap[color] = group;\n            this.asArray.push(group);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}