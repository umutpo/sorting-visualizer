{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * Common operations that work and make sense both on the model and on the view model.\n */\n\nexport class CursorColumns {\n  static visibleColumnFromColumn(lineContent, column, tabSize) {\n    const lineContentLength = lineContent.length;\n    const endOffset = column - 1 < lineContentLength ? column - 1 : lineContentLength;\n    let result = 0;\n    let i = 0;\n\n    while (i < endOffset) {\n      const codePoint = strings.getNextCodePoint(lineContent, endOffset, i);\n      i += codePoint >= 65536\n      /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */\n      ? 2 : 1;\n\n      if (codePoint === 9\n      /* Tab */\n      ) {\n        result = CursorColumns.nextRenderTabStop(result, tabSize);\n      } else {\n        let graphemeBreakType = strings.getGraphemeBreakType(codePoint);\n\n        while (i < endOffset) {\n          const nextCodePoint = strings.getNextCodePoint(lineContent, endOffset, i);\n          const nextGraphemeBreakType = strings.getGraphemeBreakType(nextCodePoint);\n\n          if (strings.breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\n            break;\n          }\n\n          i += nextCodePoint >= 65536\n          /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */\n          ? 2 : 1;\n          graphemeBreakType = nextGraphemeBreakType;\n        }\n\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n          result = result + 2;\n        } else {\n          result = result + 1;\n        }\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Returns an array that maps one based columns to one based visible columns. The entry at position 0 is -1.\n  */\n\n\n  static visibleColumnsByColumns(lineContent, tabSize) {\n    const endOffset = lineContent.length;\n    let result = new Array();\n    result.push(-1);\n    let pos = 0;\n    let i = 0;\n\n    while (i < endOffset) {\n      const codePoint = strings.getNextCodePoint(lineContent, endOffset, i);\n      i += codePoint >= 65536\n      /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */\n      ? 2 : 1;\n      result.push(pos);\n\n      if (codePoint >= 65536\n      /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */\n      ) {\n        result.push(pos);\n      }\n\n      if (codePoint === 9\n      /* Tab */\n      ) {\n        pos = CursorColumns.nextRenderTabStop(pos, tabSize);\n      } else {\n        let graphemeBreakType = strings.getGraphemeBreakType(codePoint);\n\n        while (i < endOffset) {\n          const nextCodePoint = strings.getNextCodePoint(lineContent, endOffset, i);\n          const nextGraphemeBreakType = strings.getGraphemeBreakType(nextCodePoint);\n\n          if (strings.breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\n            break;\n          }\n\n          i += nextCodePoint >= 65536\n          /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */\n          ? 2 : 1;\n          result.push(pos);\n\n          if (codePoint >= 65536\n          /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */\n          ) {\n            result.push(pos);\n          }\n\n          graphemeBreakType = nextGraphemeBreakType;\n        }\n\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n          pos = pos + 2;\n        } else {\n          pos = pos + 1;\n        }\n      }\n    }\n\n    result.push(pos);\n    return result;\n  }\n\n  static visibleColumnFromColumn2(config, model, position) {\n    return this.visibleColumnFromColumn(model.getLineContent(position.lineNumber), position.column, config.tabSize);\n  }\n\n  static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n    if (visibleColumn <= 0) {\n      return 1;\n    }\n\n    const lineLength = lineContent.length;\n    let beforeVisibleColumn = 0;\n    let beforeColumn = 1;\n    let i = 0;\n\n    while (i < lineLength) {\n      const codePoint = strings.getNextCodePoint(lineContent, lineLength, i);\n      i += codePoint >= 65536\n      /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */\n      ? 2 : 1;\n      let afterVisibleColumn;\n\n      if (codePoint === 9\n      /* Tab */\n      ) {\n        afterVisibleColumn = CursorColumns.nextRenderTabStop(beforeVisibleColumn, tabSize);\n      } else {\n        let graphemeBreakType = strings.getGraphemeBreakType(codePoint);\n\n        while (i < lineLength) {\n          const nextCodePoint = strings.getNextCodePoint(lineContent, lineLength, i);\n          const nextGraphemeBreakType = strings.getGraphemeBreakType(nextCodePoint);\n\n          if (strings.breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\n            break;\n          }\n\n          i += nextCodePoint >= 65536\n          /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */\n          ? 2 : 1;\n          graphemeBreakType = nextGraphemeBreakType;\n        }\n\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n          afterVisibleColumn = beforeVisibleColumn + 2;\n        } else {\n          afterVisibleColumn = beforeVisibleColumn + 1;\n        }\n      }\n\n      const afterColumn = i + 1;\n\n      if (afterVisibleColumn >= visibleColumn) {\n        const beforeDelta = visibleColumn - beforeVisibleColumn;\n        const afterDelta = afterVisibleColumn - visibleColumn;\n\n        if (afterDelta < beforeDelta) {\n          return afterColumn;\n        } else {\n          return beforeColumn;\n        }\n      }\n\n      beforeVisibleColumn = afterVisibleColumn;\n      beforeColumn = afterColumn;\n    } // walked the entire string\n\n\n    return lineLength + 1;\n  }\n\n  static columnFromVisibleColumn2(config, model, lineNumber, visibleColumn) {\n    let result = this.columnFromVisibleColumn(model.getLineContent(lineNumber), visibleColumn, config.tabSize);\n    let minColumn = model.getLineMinColumn(lineNumber);\n\n    if (result < minColumn) {\n      return minColumn;\n    }\n\n    let maxColumn = model.getLineMaxColumn(lineNumber);\n\n    if (result > maxColumn) {\n      return maxColumn;\n    }\n\n    return result;\n  }\n  /**\n   * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n   */\n\n\n  static nextRenderTabStop(visibleColumn, tabSize) {\n    return visibleColumn + tabSize - visibleColumn % tabSize;\n  }\n  /**\n   * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n   */\n\n\n  static nextIndentTabStop(visibleColumn, indentSize) {\n    return visibleColumn + indentSize - visibleColumn % indentSize;\n  }\n  /**\n   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n   */\n\n\n  static prevRenderTabStop(column, tabSize) {\n    return Math.max(0, column - 1 - (column - 1) % tabSize);\n  }\n  /**\n   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n   */\n\n\n  static prevIndentTabStop(column, indentSize) {\n    return Math.max(0, column - 1 - (column - 1) % indentSize);\n  }\n\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/common/controller/cursorColumns.js"],"names":["strings","CursorColumns","visibleColumnFromColumn","lineContent","column","tabSize","lineContentLength","length","endOffset","result","i","codePoint","getNextCodePoint","nextRenderTabStop","graphemeBreakType","getGraphemeBreakType","nextCodePoint","nextGraphemeBreakType","breakBetweenGraphemeBreakType","isFullWidthCharacter","isEmojiImprecise","visibleColumnsByColumns","Array","push","pos","visibleColumnFromColumn2","config","model","position","getLineContent","lineNumber","columnFromVisibleColumn","visibleColumn","lineLength","beforeVisibleColumn","beforeColumn","afterVisibleColumn","afterColumn","beforeDelta","afterDelta","columnFromVisibleColumn2","minColumn","getLineMinColumn","maxColumn","getLineMaxColumn","nextIndentTabStop","indentSize","prevRenderTabStop","Math","max","prevIndentTabStop"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * Common operations that work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const lineContentLength = lineContent.length;\n        const endOffset = column - 1 < lineContentLength ? column - 1 : lineContentLength;\n        let result = 0;\n        let i = 0;\n        while (i < endOffset) {\n            const codePoint = strings.getNextCodePoint(lineContent, endOffset, i);\n            i += (codePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\n            if (codePoint === 9 /* Tab */) {\n                result = CursorColumns.nextRenderTabStop(result, tabSize);\n            }\n            else {\n                let graphemeBreakType = strings.getGraphemeBreakType(codePoint);\n                while (i < endOffset) {\n                    const nextCodePoint = strings.getNextCodePoint(lineContent, endOffset, i);\n                    const nextGraphemeBreakType = strings.getGraphemeBreakType(nextCodePoint);\n                    if (strings.breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\n                        break;\n                    }\n                    i += (nextCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\n                    graphemeBreakType = nextGraphemeBreakType;\n                }\n                if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n                    result = result + 2;\n                }\n                else {\n                    result = result + 1;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Returns an array that maps one based columns to one based visible columns. The entry at position 0 is -1.\n    */\n    static visibleColumnsByColumns(lineContent, tabSize) {\n        const endOffset = lineContent.length;\n        let result = new Array();\n        result.push(-1);\n        let pos = 0;\n        let i = 0;\n        while (i < endOffset) {\n            const codePoint = strings.getNextCodePoint(lineContent, endOffset, i);\n            i += (codePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\n            result.push(pos);\n            if (codePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */) {\n                result.push(pos);\n            }\n            if (codePoint === 9 /* Tab */) {\n                pos = CursorColumns.nextRenderTabStop(pos, tabSize);\n            }\n            else {\n                let graphemeBreakType = strings.getGraphemeBreakType(codePoint);\n                while (i < endOffset) {\n                    const nextCodePoint = strings.getNextCodePoint(lineContent, endOffset, i);\n                    const nextGraphemeBreakType = strings.getGraphemeBreakType(nextCodePoint);\n                    if (strings.breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\n                        break;\n                    }\n                    i += (nextCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\n                    result.push(pos);\n                    if (codePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */) {\n                        result.push(pos);\n                    }\n                    graphemeBreakType = nextGraphemeBreakType;\n                }\n                if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n                    pos = pos + 2;\n                }\n                else {\n                    pos = pos + 1;\n                }\n            }\n        }\n        result.push(pos);\n        return result;\n    }\n    static visibleColumnFromColumn2(config, model, position) {\n        return this.visibleColumnFromColumn(model.getLineContent(position.lineNumber), position.column, config.tabSize);\n    }\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineLength = lineContent.length;\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        let i = 0;\n        while (i < lineLength) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineLength, i);\n            i += (codePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\n            let afterVisibleColumn;\n            if (codePoint === 9 /* Tab */) {\n                afterVisibleColumn = CursorColumns.nextRenderTabStop(beforeVisibleColumn, tabSize);\n            }\n            else {\n                let graphemeBreakType = strings.getGraphemeBreakType(codePoint);\n                while (i < lineLength) {\n                    const nextCodePoint = strings.getNextCodePoint(lineContent, lineLength, i);\n                    const nextGraphemeBreakType = strings.getGraphemeBreakType(nextCodePoint);\n                    if (strings.breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\n                        break;\n                    }\n                    i += (nextCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\n                    graphemeBreakType = nextGraphemeBreakType;\n                }\n                if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n                    afterVisibleColumn = beforeVisibleColumn + 2;\n                }\n                else {\n                    afterVisibleColumn = beforeVisibleColumn + 1;\n                }\n            }\n            const afterColumn = i + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineLength + 1;\n    }\n    static columnFromVisibleColumn2(config, model, lineNumber, visibleColumn) {\n        let result = this.columnFromVisibleColumn(model.getLineContent(lineNumber), visibleColumn, config.tabSize);\n        let minColumn = model.getLineMinColumn(lineNumber);\n        if (result < minColumn) {\n            return minColumn;\n        }\n        let maxColumn = model.getLineMaxColumn(lineNumber);\n        if (result > maxColumn) {\n            return maxColumn;\n        }\n        return result;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}