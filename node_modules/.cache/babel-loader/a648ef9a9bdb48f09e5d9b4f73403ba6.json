{"ast":null,"code":"var _a, _b;\n\nimport { compare, compareIgnoreCase, compareSubstring, compareSubstringIgnoreCase } from './strings.js';\nexport class StringIterator {\n  constructor() {\n    this._value = '';\n    this._pos = 0;\n  }\n\n  reset(key) {\n    this._value = key;\n    this._pos = 0;\n    return this;\n  }\n\n  next() {\n    this._pos += 1;\n    return this;\n  }\n\n  hasNext() {\n    return this._pos < this._value.length - 1;\n  }\n\n  cmp(a) {\n    const aCode = a.charCodeAt(0);\n\n    const thisCode = this._value.charCodeAt(this._pos);\n\n    return aCode - thisCode;\n  }\n\n  value() {\n    return this._value[this._pos];\n  }\n\n}\nexport class ConfigKeysIterator {\n  constructor() {\n    let _caseSensitive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    this._caseSensitive = _caseSensitive;\n  }\n\n  reset(key) {\n    this._value = key;\n    this._from = 0;\n    this._to = 0;\n    return this.next();\n  }\n\n  hasNext() {\n    return this._to < this._value.length;\n  }\n\n  next() {\n    // this._data = key.split(/[\\\\/]/).filter(s => !!s);\n    this._from = this._to;\n    let justSeps = true;\n\n    for (; this._to < this._value.length; this._to++) {\n      const ch = this._value.charCodeAt(this._to);\n\n      if (ch === 46\n      /* Period */\n      ) {\n        if (justSeps) {\n          this._from++;\n        } else {\n          break;\n        }\n      } else {\n        justSeps = false;\n      }\n    }\n\n    return this;\n  }\n\n  cmp(a) {\n    return this._caseSensitive ? compareSubstring(a, this._value, 0, a.length, this._from, this._to) : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n  }\n\n  value() {\n    return this._value.substring(this._from, this._to);\n  }\n\n}\nexport class PathIterator {\n  constructor() {\n    let _splitOnBackslash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    let _caseSensitive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    this._splitOnBackslash = _splitOnBackslash;\n    this._caseSensitive = _caseSensitive;\n  }\n\n  reset(key) {\n    this._value = key.replace(/\\\\$|\\/$/, '');\n    this._from = 0;\n    this._to = 0;\n    return this.next();\n  }\n\n  hasNext() {\n    return this._to < this._value.length;\n  }\n\n  next() {\n    // this._data = key.split(/[\\\\/]/).filter(s => !!s);\n    this._from = this._to;\n    let justSeps = true;\n\n    for (; this._to < this._value.length; this._to++) {\n      const ch = this._value.charCodeAt(this._to);\n\n      if (ch === 47\n      /* Slash */\n      || this._splitOnBackslash && ch === 92\n      /* Backslash */\n      ) {\n        if (justSeps) {\n          this._from++;\n        } else {\n          break;\n        }\n      } else {\n        justSeps = false;\n      }\n    }\n\n    return this;\n  }\n\n  cmp(a) {\n    return this._caseSensitive ? compareSubstring(a, this._value, 0, a.length, this._from, this._to) : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n  }\n\n  value() {\n    return this._value.substring(this._from, this._to);\n  }\n\n}\nexport class UriIterator {\n  constructor(_ignorePathCasing) {\n    this._ignorePathCasing = _ignorePathCasing;\n    this._states = [];\n    this._stateIdx = 0;\n  }\n\n  reset(key) {\n    this._value = key;\n    this._states = [];\n\n    if (this._value.scheme) {\n      this._states.push(1\n      /* Scheme */\n      );\n    }\n\n    if (this._value.authority) {\n      this._states.push(2\n      /* Authority */\n      );\n    }\n\n    if (this._value.path) {\n      this._pathIterator = new PathIterator(false, !this._ignorePathCasing(key));\n\n      this._pathIterator.reset(key.path);\n\n      if (this._pathIterator.value()) {\n        this._states.push(3\n        /* Path */\n        );\n      }\n    }\n\n    if (this._value.query) {\n      this._states.push(4\n      /* Query */\n      );\n    }\n\n    if (this._value.fragment) {\n      this._states.push(5\n      /* Fragment */\n      );\n    }\n\n    this._stateIdx = 0;\n    return this;\n  }\n\n  next() {\n    if (this._states[this._stateIdx] === 3\n    /* Path */\n    && this._pathIterator.hasNext()) {\n      this._pathIterator.next();\n    } else {\n      this._stateIdx += 1;\n    }\n\n    return this;\n  }\n\n  hasNext() {\n    return this._states[this._stateIdx] === 3\n    /* Path */\n    && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;\n  }\n\n  cmp(a) {\n    if (this._states[this._stateIdx] === 1\n    /* Scheme */\n    ) {\n      return compareIgnoreCase(a, this._value.scheme);\n    } else if (this._states[this._stateIdx] === 2\n    /* Authority */\n    ) {\n      return compareIgnoreCase(a, this._value.authority);\n    } else if (this._states[this._stateIdx] === 3\n    /* Path */\n    ) {\n      return this._pathIterator.cmp(a);\n    } else if (this._states[this._stateIdx] === 4\n    /* Query */\n    ) {\n      return compare(a, this._value.query);\n    } else if (this._states[this._stateIdx] === 5\n    /* Fragment */\n    ) {\n      return compare(a, this._value.fragment);\n    }\n\n    throw new Error();\n  }\n\n  value() {\n    if (this._states[this._stateIdx] === 1\n    /* Scheme */\n    ) {\n      return this._value.scheme;\n    } else if (this._states[this._stateIdx] === 2\n    /* Authority */\n    ) {\n      return this._value.authority;\n    } else if (this._states[this._stateIdx] === 3\n    /* Path */\n    ) {\n      return this._pathIterator.value();\n    } else if (this._states[this._stateIdx] === 4\n    /* Query */\n    ) {\n      return this._value.query;\n    } else if (this._states[this._stateIdx] === 5\n    /* Fragment */\n    ) {\n      return this._value.fragment;\n    }\n\n    throw new Error();\n  }\n\n}\n\nclass TernarySearchTreeNode {\n  constructor() {\n    this.height = 1;\n  }\n\n  rotateLeft() {\n    const tmp = this.right;\n    this.right = tmp.left;\n    tmp.left = this;\n    this.updateHeight();\n    tmp.updateHeight();\n    return tmp;\n  }\n\n  rotateRight() {\n    const tmp = this.left;\n    this.left = tmp.right;\n    tmp.right = this;\n    this.updateHeight();\n    tmp.updateHeight();\n    return tmp;\n  }\n\n  updateHeight() {\n    this.height = 1 + Math.max(this.heightLeft, this.heightRight);\n  }\n\n  balanceFactor() {\n    return this.heightRight - this.heightLeft;\n  }\n\n  get heightLeft() {\n    var _c, _d;\n\n    return (_d = (_c = this.left) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : 0;\n  }\n\n  get heightRight() {\n    var _c, _d;\n\n    return (_d = (_c = this.right) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : 0;\n  }\n\n}\n\nexport class TernarySearchTree {\n  constructor(segments) {\n    this._iter = segments;\n  }\n\n  static forUris() {\n    let ignorePathCasing = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => false;\n    return new TernarySearchTree(new UriIterator(ignorePathCasing));\n  }\n\n  static forStrings() {\n    return new TernarySearchTree(new StringIterator());\n  }\n\n  static forConfigKeys() {\n    return new TernarySearchTree(new ConfigKeysIterator());\n  }\n\n  clear() {\n    this._root = undefined;\n  }\n\n  set(key, element) {\n    const iter = this._iter.reset(key);\n\n    let node;\n\n    if (!this._root) {\n      this._root = new TernarySearchTreeNode();\n      this._root.segment = iter.value();\n    }\n\n    const stack = []; // find insert_node\n\n    node = this._root;\n\n    while (true) {\n      const val = iter.cmp(node.segment);\n\n      if (val > 0) {\n        // left\n        if (!node.left) {\n          node.left = new TernarySearchTreeNode();\n          node.left.segment = iter.value();\n        }\n\n        stack.push([-1\n        /* Left */\n        , node]);\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        if (!node.right) {\n          node.right = new TernarySearchTreeNode();\n          node.right.segment = iter.value();\n        }\n\n        stack.push([1\n        /* Right */\n        , node]);\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n\n        if (!node.mid) {\n          node.mid = new TernarySearchTreeNode();\n          node.mid.segment = iter.value();\n        }\n\n        stack.push([0\n        /* Mid */\n        , node]);\n        node = node.mid;\n      } else {\n        break;\n      }\n    } // set value\n\n\n    const oldElement = node.value;\n    node.value = element;\n    node.key = key; // balance\n\n    for (let i = stack.length - 1; i >= 0; i--) {\n      const node = stack[i][1];\n      node.updateHeight();\n      const bf = node.balanceFactor();\n\n      if (bf < -1 || bf > 1) {\n        // needs rotate\n        const d1 = stack[i][0];\n        const d2 = stack[i + 1][0];\n\n        if (d1 === 1\n        /* Right */\n        && d2 === 1\n        /* Right */\n        ) {\n          //right, right -> rotate left\n          stack[i][1] = node.rotateLeft();\n        } else if (d1 === -1\n        /* Left */\n        && d2 === -1\n        /* Left */\n        ) {\n          // left, left -> rotate right\n          stack[i][1] = node.rotateRight();\n        } else if (d1 === 1\n        /* Right */\n        && d2 === -1\n        /* Left */\n        ) {\n          // right, left -> double rotate right, left\n          node.right = stack[i + 1][1] = stack[i + 1][1].rotateRight();\n          stack[i][1] = node.rotateLeft();\n        } else if (d1 === -1\n        /* Left */\n        && d2 === 1\n        /* Right */\n        ) {\n          // left, right -> double rotate left, right\n          node.left = stack[i + 1][1] = stack[i + 1][1].rotateLeft();\n          stack[i][1] = node.rotateRight();\n        } else {\n          throw new Error();\n        } // patch path to parent\n\n\n        if (i > 0) {\n          switch (stack[i - 1][0]) {\n            case -1\n            /* Left */\n            :\n              stack[i - 1][1].left = stack[i][1];\n              break;\n\n            case 1\n            /* Right */\n            :\n              stack[i - 1][1].right = stack[i][1];\n              break;\n\n            case 0\n            /* Mid */\n            :\n              stack[i - 1][1].mid = stack[i][1];\n              break;\n          }\n        } else {\n          this._root = stack[0][1];\n        }\n      }\n    }\n\n    return oldElement;\n  }\n\n  get(key) {\n    var _c;\n\n    return (_c = this._getNode(key)) === null || _c === void 0 ? void 0 : _c.value;\n  }\n\n  _getNode(key) {\n    const iter = this._iter.reset(key);\n\n    let node = this._root;\n\n    while (node) {\n      const val = iter.cmp(node.segment);\n\n      if (val > 0) {\n        // left\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        node = node.mid;\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n\n  has(key) {\n    const node = this._getNode(key);\n\n    return !((node === null || node === void 0 ? void 0 : node.value) === undefined && (node === null || node === void 0 ? void 0 : node.mid) === undefined);\n  }\n\n  delete(key) {\n    return this._delete(key, false);\n  }\n\n  deleteSuperstr(key) {\n    return this._delete(key, true);\n  }\n\n  _delete(key, superStr) {\n    var _c;\n\n    const iter = this._iter.reset(key);\n\n    const stack = [];\n    let node = this._root; // find node\n\n    while (node) {\n      const val = iter.cmp(node.segment);\n\n      if (val > 0) {\n        // left\n        stack.push([-1\n        /* Left */\n        , node]);\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        stack.push([1\n        /* Right */\n        , node]);\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        stack.push([0\n        /* Mid */\n        , node]);\n        node = node.mid;\n      } else {\n        break;\n      }\n    }\n\n    if (!node) {\n      // node not found\n      return;\n    }\n\n    if (superStr) {\n      // removing children, reset height\n      node.left = undefined;\n      node.mid = undefined;\n      node.right = undefined;\n      node.height = 1;\n    } else {\n      // removing element\n      node.key = undefined;\n      node.value = undefined;\n    } // BST node removal\n\n\n    if (!node.mid && !node.value) {\n      if (node.left && node.right) {\n        // full node\n        const min = this._min(node.right);\n\n        const {\n          key,\n          value,\n          segment\n        } = min;\n\n        this._delete(min.key, false);\n\n        node.key = key;\n        node.value = value;\n        node.segment = segment;\n      } else {\n        // empty or half empty\n        const newChild = (_c = node.left) !== null && _c !== void 0 ? _c : node.right;\n\n        if (stack.length > 0) {\n          const [dir, parent] = stack[stack.length - 1];\n\n          switch (dir) {\n            case -1\n            /* Left */\n            :\n              parent.left = newChild;\n              break;\n\n            case 0\n            /* Mid */\n            :\n              parent.mid = newChild;\n              break;\n\n            case 1\n            /* Right */\n            :\n              parent.right = newChild;\n              break;\n          }\n        } else {\n          this._root = newChild;\n        }\n      }\n    } // AVL balance\n\n\n    for (let i = stack.length - 1; i >= 0; i--) {\n      const node = stack[i][1];\n      node.updateHeight();\n      const bf = node.balanceFactor();\n\n      if (bf > 1) {\n        // right heavy\n        if (node.right.balanceFactor() >= 0) {\n          // right, right -> rotate left\n          stack[i][1] = node.rotateLeft();\n        } else {\n          // right, left -> double rotate\n          node.right = stack[i + 1][1] = stack[i + 1][1].rotateRight();\n          stack[i][1] = node.rotateLeft();\n        }\n      } else if (bf < -1) {\n        // left heavy\n        if (node.left.balanceFactor() <= 0) {\n          // left, left -> rotate right\n          stack[i][1] = node.rotateRight();\n        } else {\n          // left, right -> double rotate\n          node.left = stack[i + 1][1] = stack[i + 1][1].rotateLeft();\n          stack[i][1] = node.rotateRight();\n        }\n      } // patch path to parent\n\n\n      if (i > 0) {\n        switch (stack[i - 1][0]) {\n          case -1\n          /* Left */\n          :\n            stack[i - 1][1].left = stack[i][1];\n            break;\n\n          case 1\n          /* Right */\n          :\n            stack[i - 1][1].right = stack[i][1];\n            break;\n\n          case 0\n          /* Mid */\n          :\n            stack[i - 1][1].mid = stack[i][1];\n            break;\n        }\n      } else {\n        this._root = stack[0][1];\n      }\n    }\n  }\n\n  _min(node) {\n    while (node.left) {\n      node = node.left;\n    }\n\n    return node;\n  }\n\n  findSubstr(key) {\n    const iter = this._iter.reset(key);\n\n    let node = this._root;\n    let candidate = undefined;\n\n    while (node) {\n      const val = iter.cmp(node.segment);\n\n      if (val > 0) {\n        // left\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        candidate = node.value || candidate;\n        node = node.mid;\n      } else {\n        break;\n      }\n    }\n\n    return node && node.value || candidate;\n  }\n\n  findSuperstr(key) {\n    const iter = this._iter.reset(key);\n\n    let node = this._root;\n\n    while (node) {\n      const val = iter.cmp(node.segment);\n\n      if (val > 0) {\n        // left\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        node = node.mid;\n      } else {\n        // collect\n        if (!node.mid) {\n          return undefined;\n        } else {\n          return this._entries(node.mid);\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  forEach(callback) {\n    for (const [key, value] of this) {\n      callback(value, key);\n    }\n  }\n\n  *[Symbol.iterator]() {\n    yield* this._entries(this._root);\n  }\n\n  *_entries(node) {\n    // DFS\n    if (!node) {\n      return;\n    }\n\n    if (node.left) {\n      yield* this._entries(node.left);\n    }\n\n    if (node.value) {\n      yield [node.key, node.value];\n    }\n\n    if (node.mid) {\n      yield* this._entries(node.mid);\n    }\n\n    if (node.right) {\n      yield* this._entries(node.right);\n    }\n  }\n\n}\n\nclass ResourceMapEntry {\n  constructor(uri, value) {\n    this.uri = uri;\n    this.value = value;\n  }\n\n}\n\nexport class ResourceMap {\n  constructor(mapOrKeyFn, toKey) {\n    this[_a] = 'ResourceMap';\n\n    if (mapOrKeyFn instanceof ResourceMap) {\n      this.map = new Map(mapOrKeyFn.map);\n      this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;\n    } else {\n      this.map = new Map();\n      this.toKey = mapOrKeyFn !== null && mapOrKeyFn !== void 0 ? mapOrKeyFn : ResourceMap.defaultToKey;\n    }\n  }\n\n  set(resource, value) {\n    this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\n    return this;\n  }\n\n  get(resource) {\n    var _c;\n\n    return (_c = this.map.get(this.toKey(resource))) === null || _c === void 0 ? void 0 : _c.value;\n  }\n\n  has(resource) {\n    return this.map.has(this.toKey(resource));\n  }\n\n  get size() {\n    return this.map.size;\n  }\n\n  clear() {\n    this.map.clear();\n  }\n\n  delete(resource) {\n    return this.map.delete(this.toKey(resource));\n  }\n\n  forEach(clb, thisArg) {\n    if (typeof thisArg !== 'undefined') {\n      clb = clb.bind(thisArg);\n    }\n\n    for (let [_, entry] of this.map) {\n      clb(entry.value, entry.uri, this);\n    }\n  }\n\n  *values() {\n    for (let entry of this.map.values()) {\n      yield entry.value;\n    }\n  }\n\n  *keys() {\n    for (let entry of this.map.values()) {\n      yield entry.uri;\n    }\n  }\n\n  *entries() {\n    for (let entry of this.map.values()) {\n      yield [entry.uri, entry.value];\n    }\n  }\n\n  *[(_a = Symbol.toStringTag, Symbol.iterator)]() {\n    for (let [, entry] of this.map) {\n      yield [entry.uri, entry.value];\n    }\n  }\n\n}\n\nResourceMap.defaultToKey = resource => resource.toString();\n\nexport class LinkedMap {\n  constructor() {\n    this[_b] = 'LinkedMap';\n    this._map = new Map();\n    this._head = undefined;\n    this._tail = undefined;\n    this._size = 0;\n    this._state = 0;\n  }\n\n  clear() {\n    this._map.clear();\n\n    this._head = undefined;\n    this._tail = undefined;\n    this._size = 0;\n    this._state++;\n  }\n\n  isEmpty() {\n    return !this._head && !this._tail;\n  }\n\n  get size() {\n    return this._size;\n  }\n\n  get first() {\n    var _c;\n\n    return (_c = this._head) === null || _c === void 0 ? void 0 : _c.value;\n  }\n\n  get last() {\n    var _c;\n\n    return (_c = this._tail) === null || _c === void 0 ? void 0 : _c.value;\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  get(key) {\n    let touch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    const item = this._map.get(key);\n\n    if (!item) {\n      return undefined;\n    }\n\n    if (touch !== 0\n    /* None */\n    ) {\n      this.touch(item, touch);\n    }\n\n    return item.value;\n  }\n\n  set(key, value) {\n    let touch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    let item = this._map.get(key);\n\n    if (item) {\n      item.value = value;\n\n      if (touch !== 0\n      /* None */\n      ) {\n        this.touch(item, touch);\n      }\n    } else {\n      item = {\n        key,\n        value,\n        next: undefined,\n        previous: undefined\n      };\n\n      switch (touch) {\n        case 0\n        /* None */\n        :\n          this.addItemLast(item);\n          break;\n\n        case 1\n        /* AsOld */\n        :\n          this.addItemFirst(item);\n          break;\n\n        case 2\n        /* AsNew */\n        :\n          this.addItemLast(item);\n          break;\n\n        default:\n          this.addItemLast(item);\n          break;\n      }\n\n      this._map.set(key, item);\n\n      this._size++;\n    }\n\n    return this;\n  }\n\n  delete(key) {\n    return !!this.remove(key);\n  }\n\n  remove(key) {\n    const item = this._map.get(key);\n\n    if (!item) {\n      return undefined;\n    }\n\n    this._map.delete(key);\n\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  }\n\n  shift() {\n    if (!this._head && !this._tail) {\n      return undefined;\n    }\n\n    if (!this._head || !this._tail) {\n      throw new Error('Invalid list');\n    }\n\n    const item = this._head;\n\n    this._map.delete(item.key);\n\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  }\n\n  forEach(callbackfn, thisArg) {\n    const state = this._state;\n    let current = this._head;\n\n    while (current) {\n      if (thisArg) {\n        callbackfn.bind(thisArg)(current.value, current.key, this);\n      } else {\n        callbackfn(current.value, current.key, this);\n      }\n\n      if (this._state !== state) {\n        throw new Error(`LinkedMap got modified during iteration.`);\n      }\n\n      current = current.next;\n    }\n  }\n\n  keys() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n\n        if (current) {\n          const result = {\n            value: current.key,\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n\n    };\n    return iterator;\n  }\n\n  values() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n\n        if (current) {\n          const result = {\n            value: current.value,\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n\n    };\n    return iterator;\n  }\n\n  entries() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n\n        if (current) {\n          const result = {\n            value: [current.key, current.value],\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n\n    };\n    return iterator;\n  }\n\n  [(_b = Symbol.toStringTag, Symbol.iterator)]() {\n    return this.entries();\n  }\n\n  trimOld(newSize) {\n    if (newSize >= this.size) {\n      return;\n    }\n\n    if (newSize === 0) {\n      this.clear();\n      return;\n    }\n\n    let current = this._head;\n    let currentSize = this.size;\n\n    while (current && currentSize > newSize) {\n      this._map.delete(current.key);\n\n      current = current.next;\n      currentSize--;\n    }\n\n    this._head = current;\n    this._size = currentSize;\n\n    if (current) {\n      current.previous = undefined;\n    }\n\n    this._state++;\n  }\n\n  addItemFirst(item) {\n    // First time Insert\n    if (!this._head && !this._tail) {\n      this._tail = item;\n    } else if (!this._head) {\n      throw new Error('Invalid list');\n    } else {\n      item.next = this._head;\n      this._head.previous = item;\n    }\n\n    this._head = item;\n    this._state++;\n  }\n\n  addItemLast(item) {\n    // First time Insert\n    if (!this._head && !this._tail) {\n      this._head = item;\n    } else if (!this._tail) {\n      throw new Error('Invalid list');\n    } else {\n      item.previous = this._tail;\n      this._tail.next = item;\n    }\n\n    this._tail = item;\n    this._state++;\n  }\n\n  removeItem(item) {\n    if (item === this._head && item === this._tail) {\n      this._head = undefined;\n      this._tail = undefined;\n    } else if (item === this._head) {\n      // This can only happen if size === 1 which is handled\n      // by the case above.\n      if (!item.next) {\n        throw new Error('Invalid list');\n      }\n\n      item.next.previous = undefined;\n      this._head = item.next;\n    } else if (item === this._tail) {\n      // This can only happen if size === 1 which is handled\n      // by the case above.\n      if (!item.previous) {\n        throw new Error('Invalid list');\n      }\n\n      item.previous.next = undefined;\n      this._tail = item.previous;\n    } else {\n      const next = item.next;\n      const previous = item.previous;\n\n      if (!next || !previous) {\n        throw new Error('Invalid list');\n      }\n\n      next.previous = previous;\n      previous.next = next;\n    }\n\n    item.next = undefined;\n    item.previous = undefined;\n    this._state++;\n  }\n\n  touch(item, touch) {\n    if (!this._head || !this._tail) {\n      throw new Error('Invalid list');\n    }\n\n    if (touch !== 1\n    /* AsOld */\n    && touch !== 2\n    /* AsNew */\n    ) {\n      return;\n    }\n\n    if (touch === 1\n    /* AsOld */\n    ) {\n      if (item === this._head) {\n        return;\n      }\n\n      const next = item.next;\n      const previous = item.previous; // Unlink the item\n\n      if (item === this._tail) {\n        // previous must be defined since item was not head but is tail\n        // So there are more than on item in the map\n        previous.next = undefined;\n        this._tail = previous;\n      } else {\n        // Both next and previous are not undefined since item was neither head nor tail.\n        next.previous = previous;\n        previous.next = next;\n      } // Insert the node at head\n\n\n      item.previous = undefined;\n      item.next = this._head;\n      this._head.previous = item;\n      this._head = item;\n      this._state++;\n    } else if (touch === 2\n    /* AsNew */\n    ) {\n      if (item === this._tail) {\n        return;\n      }\n\n      const next = item.next;\n      const previous = item.previous; // Unlink the item.\n\n      if (item === this._head) {\n        // next must be defined since item was not tail but is head\n        // So there are more than on item in the map\n        next.previous = undefined;\n        this._head = next;\n      } else {\n        // Both next and previous are not undefined since item was neither head nor tail.\n        next.previous = previous;\n        previous.next = next;\n      }\n\n      item.next = undefined;\n      item.previous = this._tail;\n      this._tail.next = item;\n      this._tail = item;\n      this._state++;\n    }\n  }\n\n  toJSON() {\n    const data = [];\n    this.forEach((value, key) => {\n      data.push([key, value]);\n    });\n    return data;\n  }\n\n  fromJSON(data) {\n    this.clear();\n\n    for (const [key, value] of data) {\n      this.set(key, value);\n    }\n  }\n\n}\nexport class LRUCache extends LinkedMap {\n  constructor(limit) {\n    let ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    super();\n    this._limit = limit;\n    this._ratio = Math.min(Math.max(0, ratio), 1);\n  }\n\n  get limit() {\n    return this._limit;\n  }\n\n  set limit(limit) {\n    this._limit = limit;\n    this.checkTrim();\n  }\n\n  get(key) {\n    let touch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    return super.get(key, touch);\n  }\n\n  peek(key) {\n    return super.get(key, 0\n    /* None */\n    );\n  }\n\n  set(key, value) {\n    super.set(key, value, 2\n    /* AsNew */\n    );\n    this.checkTrim();\n    return this;\n  }\n\n  checkTrim() {\n    if (this.size > this._limit) {\n      this.trimOld(Math.round(this._limit * this._ratio));\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/base/common/map.js"],"names":["_a","_b","compare","compareIgnoreCase","compareSubstring","compareSubstringIgnoreCase","StringIterator","constructor","_value","_pos","reset","key","next","hasNext","length","cmp","a","aCode","charCodeAt","thisCode","value","ConfigKeysIterator","_caseSensitive","_from","_to","justSeps","ch","substring","PathIterator","_splitOnBackslash","replace","UriIterator","_ignorePathCasing","_states","_stateIdx","scheme","push","authority","path","_pathIterator","query","fragment","Error","TernarySearchTreeNode","height","rotateLeft","tmp","right","left","updateHeight","rotateRight","Math","max","heightLeft","heightRight","balanceFactor","_c","_d","TernarySearchTree","segments","_iter","forUris","ignorePathCasing","forStrings","forConfigKeys","clear","_root","undefined","set","element","iter","node","segment","stack","val","mid","oldElement","i","bf","d1","d2","get","_getNode","has","delete","_delete","deleteSuperstr","superStr","min","_min","newChild","dir","parent","findSubstr","candidate","findSuperstr","_entries","forEach","callback","Symbol","iterator","ResourceMapEntry","uri","ResourceMap","mapOrKeyFn","toKey","map","Map","defaultToKey","resource","size","clb","thisArg","bind","_","entry","values","keys","entries","toStringTag","toString","LinkedMap","_map","_head","_tail","_size","_state","isEmpty","first","last","touch","item","previous","addItemLast","addItemFirst","remove","removeItem","shift","callbackfn","state","current","result","done","trimOld","newSize","currentSize","toJSON","data","fromJSON","LRUCache","limit","ratio","_limit","_ratio","checkTrim","peek","round"],"mappings":"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","sourcesContent":["var _a, _b;\nimport { compare, compareIgnoreCase, compareSubstring, compareSubstringIgnoreCase } from './strings.js';\nexport class StringIterator {\n    constructor() {\n        this._value = '';\n        this._pos = 0;\n    }\n    reset(key) {\n        this._value = key;\n        this._pos = 0;\n        return this;\n    }\n    next() {\n        this._pos += 1;\n        return this;\n    }\n    hasNext() {\n        return this._pos < this._value.length - 1;\n    }\n    cmp(a) {\n        const aCode = a.charCodeAt(0);\n        const thisCode = this._value.charCodeAt(this._pos);\n        return aCode - thisCode;\n    }\n    value() {\n        return this._value[this._pos];\n    }\n}\nexport class ConfigKeysIterator {\n    constructor(_caseSensitive = true) {\n        this._caseSensitive = _caseSensitive;\n    }\n    reset(key) {\n        this._value = key;\n        this._from = 0;\n        this._to = 0;\n        return this.next();\n    }\n    hasNext() {\n        return this._to < this._value.length;\n    }\n    next() {\n        // this._data = key.split(/[\\\\/]/).filter(s => !!s);\n        this._from = this._to;\n        let justSeps = true;\n        for (; this._to < this._value.length; this._to++) {\n            const ch = this._value.charCodeAt(this._to);\n            if (ch === 46 /* Period */) {\n                if (justSeps) {\n                    this._from++;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                justSeps = false;\n            }\n        }\n        return this;\n    }\n    cmp(a) {\n        return this._caseSensitive\n            ? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n            : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n    }\n    value() {\n        return this._value.substring(this._from, this._to);\n    }\n}\nexport class PathIterator {\n    constructor(_splitOnBackslash = true, _caseSensitive = true) {\n        this._splitOnBackslash = _splitOnBackslash;\n        this._caseSensitive = _caseSensitive;\n    }\n    reset(key) {\n        this._value = key.replace(/\\\\$|\\/$/, '');\n        this._from = 0;\n        this._to = 0;\n        return this.next();\n    }\n    hasNext() {\n        return this._to < this._value.length;\n    }\n    next() {\n        // this._data = key.split(/[\\\\/]/).filter(s => !!s);\n        this._from = this._to;\n        let justSeps = true;\n        for (; this._to < this._value.length; this._to++) {\n            const ch = this._value.charCodeAt(this._to);\n            if (ch === 47 /* Slash */ || this._splitOnBackslash && ch === 92 /* Backslash */) {\n                if (justSeps) {\n                    this._from++;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                justSeps = false;\n            }\n        }\n        return this;\n    }\n    cmp(a) {\n        return this._caseSensitive\n            ? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n            : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n    }\n    value() {\n        return this._value.substring(this._from, this._to);\n    }\n}\nexport class UriIterator {\n    constructor(_ignorePathCasing) {\n        this._ignorePathCasing = _ignorePathCasing;\n        this._states = [];\n        this._stateIdx = 0;\n    }\n    reset(key) {\n        this._value = key;\n        this._states = [];\n        if (this._value.scheme) {\n            this._states.push(1 /* Scheme */);\n        }\n        if (this._value.authority) {\n            this._states.push(2 /* Authority */);\n        }\n        if (this._value.path) {\n            this._pathIterator = new PathIterator(false, !this._ignorePathCasing(key));\n            this._pathIterator.reset(key.path);\n            if (this._pathIterator.value()) {\n                this._states.push(3 /* Path */);\n            }\n        }\n        if (this._value.query) {\n            this._states.push(4 /* Query */);\n        }\n        if (this._value.fragment) {\n            this._states.push(5 /* Fragment */);\n        }\n        this._stateIdx = 0;\n        return this;\n    }\n    next() {\n        if (this._states[this._stateIdx] === 3 /* Path */ && this._pathIterator.hasNext()) {\n            this._pathIterator.next();\n        }\n        else {\n            this._stateIdx += 1;\n        }\n        return this;\n    }\n    hasNext() {\n        return (this._states[this._stateIdx] === 3 /* Path */ && this._pathIterator.hasNext())\n            || this._stateIdx < this._states.length - 1;\n    }\n    cmp(a) {\n        if (this._states[this._stateIdx] === 1 /* Scheme */) {\n            return compareIgnoreCase(a, this._value.scheme);\n        }\n        else if (this._states[this._stateIdx] === 2 /* Authority */) {\n            return compareIgnoreCase(a, this._value.authority);\n        }\n        else if (this._states[this._stateIdx] === 3 /* Path */) {\n            return this._pathIterator.cmp(a);\n        }\n        else if (this._states[this._stateIdx] === 4 /* Query */) {\n            return compare(a, this._value.query);\n        }\n        else if (this._states[this._stateIdx] === 5 /* Fragment */) {\n            return compare(a, this._value.fragment);\n        }\n        throw new Error();\n    }\n    value() {\n        if (this._states[this._stateIdx] === 1 /* Scheme */) {\n            return this._value.scheme;\n        }\n        else if (this._states[this._stateIdx] === 2 /* Authority */) {\n            return this._value.authority;\n        }\n        else if (this._states[this._stateIdx] === 3 /* Path */) {\n            return this._pathIterator.value();\n        }\n        else if (this._states[this._stateIdx] === 4 /* Query */) {\n            return this._value.query;\n        }\n        else if (this._states[this._stateIdx] === 5 /* Fragment */) {\n            return this._value.fragment;\n        }\n        throw new Error();\n    }\n}\nclass TernarySearchTreeNode {\n    constructor() {\n        this.height = 1;\n    }\n    rotateLeft() {\n        const tmp = this.right;\n        this.right = tmp.left;\n        tmp.left = this;\n        this.updateHeight();\n        tmp.updateHeight();\n        return tmp;\n    }\n    rotateRight() {\n        const tmp = this.left;\n        this.left = tmp.right;\n        tmp.right = this;\n        this.updateHeight();\n        tmp.updateHeight();\n        return tmp;\n    }\n    updateHeight() {\n        this.height = 1 + Math.max(this.heightLeft, this.heightRight);\n    }\n    balanceFactor() {\n        return this.heightRight - this.heightLeft;\n    }\n    get heightLeft() {\n        var _c, _d;\n        return (_d = (_c = this.left) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : 0;\n    }\n    get heightRight() {\n        var _c, _d;\n        return (_d = (_c = this.right) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : 0;\n    }\n}\nexport class TernarySearchTree {\n    constructor(segments) {\n        this._iter = segments;\n    }\n    static forUris(ignorePathCasing = () => false) {\n        return new TernarySearchTree(new UriIterator(ignorePathCasing));\n    }\n    static forStrings() {\n        return new TernarySearchTree(new StringIterator());\n    }\n    static forConfigKeys() {\n        return new TernarySearchTree(new ConfigKeysIterator());\n    }\n    clear() {\n        this._root = undefined;\n    }\n    set(key, element) {\n        const iter = this._iter.reset(key);\n        let node;\n        if (!this._root) {\n            this._root = new TernarySearchTreeNode();\n            this._root.segment = iter.value();\n        }\n        const stack = [];\n        // find insert_node\n        node = this._root;\n        while (true) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                if (!node.left) {\n                    node.left = new TernarySearchTreeNode();\n                    node.left.segment = iter.value();\n                }\n                stack.push([-1 /* Left */, node]);\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                if (!node.right) {\n                    node.right = new TernarySearchTreeNode();\n                    node.right.segment = iter.value();\n                }\n                stack.push([1 /* Right */, node]);\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                if (!node.mid) {\n                    node.mid = new TernarySearchTreeNode();\n                    node.mid.segment = iter.value();\n                }\n                stack.push([0 /* Mid */, node]);\n                node = node.mid;\n            }\n            else {\n                break;\n            }\n        }\n        // set value\n        const oldElement = node.value;\n        node.value = element;\n        node.key = key;\n        // balance\n        for (let i = stack.length - 1; i >= 0; i--) {\n            const node = stack[i][1];\n            node.updateHeight();\n            const bf = node.balanceFactor();\n            if (bf < -1 || bf > 1) {\n                // needs rotate\n                const d1 = stack[i][0];\n                const d2 = stack[i + 1][0];\n                if (d1 === 1 /* Right */ && d2 === 1 /* Right */) {\n                    //right, right -> rotate left\n                    stack[i][1] = node.rotateLeft();\n                }\n                else if (d1 === -1 /* Left */ && d2 === -1 /* Left */) {\n                    // left, left -> rotate right\n                    stack[i][1] = node.rotateRight();\n                }\n                else if (d1 === 1 /* Right */ && d2 === -1 /* Left */) {\n                    // right, left -> double rotate right, left\n                    node.right = stack[i + 1][1] = stack[i + 1][1].rotateRight();\n                    stack[i][1] = node.rotateLeft();\n                }\n                else if (d1 === -1 /* Left */ && d2 === 1 /* Right */) {\n                    // left, right -> double rotate left, right\n                    node.left = stack[i + 1][1] = stack[i + 1][1].rotateLeft();\n                    stack[i][1] = node.rotateRight();\n                }\n                else {\n                    throw new Error();\n                }\n                // patch path to parent\n                if (i > 0) {\n                    switch (stack[i - 1][0]) {\n                        case -1 /* Left */:\n                            stack[i - 1][1].left = stack[i][1];\n                            break;\n                        case 1 /* Right */:\n                            stack[i - 1][1].right = stack[i][1];\n                            break;\n                        case 0 /* Mid */:\n                            stack[i - 1][1].mid = stack[i][1];\n                            break;\n                    }\n                }\n                else {\n                    this._root = stack[0][1];\n                }\n            }\n        }\n        return oldElement;\n    }\n    get(key) {\n        var _c;\n        return (_c = this._getNode(key)) === null || _c === void 0 ? void 0 : _c.value;\n    }\n    _getNode(key) {\n        const iter = this._iter.reset(key);\n        let node = this._root;\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                node = node.mid;\n            }\n            else {\n                break;\n            }\n        }\n        return node;\n    }\n    has(key) {\n        const node = this._getNode(key);\n        return !((node === null || node === void 0 ? void 0 : node.value) === undefined && (node === null || node === void 0 ? void 0 : node.mid) === undefined);\n    }\n    delete(key) {\n        return this._delete(key, false);\n    }\n    deleteSuperstr(key) {\n        return this._delete(key, true);\n    }\n    _delete(key, superStr) {\n        var _c;\n        const iter = this._iter.reset(key);\n        const stack = [];\n        let node = this._root;\n        // find node\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                stack.push([-1 /* Left */, node]);\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                stack.push([1 /* Right */, node]);\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                stack.push([0 /* Mid */, node]);\n                node = node.mid;\n            }\n            else {\n                break;\n            }\n        }\n        if (!node) {\n            // node not found\n            return;\n        }\n        if (superStr) {\n            // removing children, reset height\n            node.left = undefined;\n            node.mid = undefined;\n            node.right = undefined;\n            node.height = 1;\n        }\n        else {\n            // removing element\n            node.key = undefined;\n            node.value = undefined;\n        }\n        // BST node removal\n        if (!node.mid && !node.value) {\n            if (node.left && node.right) {\n                // full node\n                const min = this._min(node.right);\n                const { key, value, segment } = min;\n                this._delete(min.key, false);\n                node.key = key;\n                node.value = value;\n                node.segment = segment;\n            }\n            else {\n                // empty or half empty\n                const newChild = (_c = node.left) !== null && _c !== void 0 ? _c : node.right;\n                if (stack.length > 0) {\n                    const [dir, parent] = stack[stack.length - 1];\n                    switch (dir) {\n                        case -1 /* Left */:\n                            parent.left = newChild;\n                            break;\n                        case 0 /* Mid */:\n                            parent.mid = newChild;\n                            break;\n                        case 1 /* Right */:\n                            parent.right = newChild;\n                            break;\n                    }\n                }\n                else {\n                    this._root = newChild;\n                }\n            }\n        }\n        // AVL balance\n        for (let i = stack.length - 1; i >= 0; i--) {\n            const node = stack[i][1];\n            node.updateHeight();\n            const bf = node.balanceFactor();\n            if (bf > 1) {\n                // right heavy\n                if (node.right.balanceFactor() >= 0) {\n                    // right, right -> rotate left\n                    stack[i][1] = node.rotateLeft();\n                }\n                else {\n                    // right, left -> double rotate\n                    node.right = stack[i + 1][1] = stack[i + 1][1].rotateRight();\n                    stack[i][1] = node.rotateLeft();\n                }\n            }\n            else if (bf < -1) {\n                // left heavy\n                if (node.left.balanceFactor() <= 0) {\n                    // left, left -> rotate right\n                    stack[i][1] = node.rotateRight();\n                }\n                else {\n                    // left, right -> double rotate\n                    node.left = stack[i + 1][1] = stack[i + 1][1].rotateLeft();\n                    stack[i][1] = node.rotateRight();\n                }\n            }\n            // patch path to parent\n            if (i > 0) {\n                switch (stack[i - 1][0]) {\n                    case -1 /* Left */:\n                        stack[i - 1][1].left = stack[i][1];\n                        break;\n                    case 1 /* Right */:\n                        stack[i - 1][1].right = stack[i][1];\n                        break;\n                    case 0 /* Mid */:\n                        stack[i - 1][1].mid = stack[i][1];\n                        break;\n                }\n            }\n            else {\n                this._root = stack[0][1];\n            }\n        }\n    }\n    _min(node) {\n        while (node.left) {\n            node = node.left;\n        }\n        return node;\n    }\n    findSubstr(key) {\n        const iter = this._iter.reset(key);\n        let node = this._root;\n        let candidate = undefined;\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                candidate = node.value || candidate;\n                node = node.mid;\n            }\n            else {\n                break;\n            }\n        }\n        return node && node.value || candidate;\n    }\n    findSuperstr(key) {\n        const iter = this._iter.reset(key);\n        let node = this._root;\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                node = node.mid;\n            }\n            else {\n                // collect\n                if (!node.mid) {\n                    return undefined;\n                }\n                else {\n                    return this._entries(node.mid);\n                }\n            }\n        }\n        return undefined;\n    }\n    forEach(callback) {\n        for (const [key, value] of this) {\n            callback(value, key);\n        }\n    }\n    *[Symbol.iterator]() {\n        yield* this._entries(this._root);\n    }\n    *_entries(node) {\n        // DFS\n        if (!node) {\n            return;\n        }\n        if (node.left) {\n            yield* this._entries(node.left);\n        }\n        if (node.value) {\n            yield [node.key, node.value];\n        }\n        if (node.mid) {\n            yield* this._entries(node.mid);\n        }\n        if (node.right) {\n            yield* this._entries(node.right);\n        }\n    }\n}\nclass ResourceMapEntry {\n    constructor(uri, value) {\n        this.uri = uri;\n        this.value = value;\n    }\n}\nexport class ResourceMap {\n    constructor(mapOrKeyFn, toKey) {\n        this[_a] = 'ResourceMap';\n        if (mapOrKeyFn instanceof ResourceMap) {\n            this.map = new Map(mapOrKeyFn.map);\n            this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;\n        }\n        else {\n            this.map = new Map();\n            this.toKey = mapOrKeyFn !== null && mapOrKeyFn !== void 0 ? mapOrKeyFn : ResourceMap.defaultToKey;\n        }\n    }\n    set(resource, value) {\n        this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\n        return this;\n    }\n    get(resource) {\n        var _c;\n        return (_c = this.map.get(this.toKey(resource))) === null || _c === void 0 ? void 0 : _c.value;\n    }\n    has(resource) {\n        return this.map.has(this.toKey(resource));\n    }\n    get size() {\n        return this.map.size;\n    }\n    clear() {\n        this.map.clear();\n    }\n    delete(resource) {\n        return this.map.delete(this.toKey(resource));\n    }\n    forEach(clb, thisArg) {\n        if (typeof thisArg !== 'undefined') {\n            clb = clb.bind(thisArg);\n        }\n        for (let [_, entry] of this.map) {\n            clb(entry.value, entry.uri, this);\n        }\n    }\n    *values() {\n        for (let entry of this.map.values()) {\n            yield entry.value;\n        }\n    }\n    *keys() {\n        for (let entry of this.map.values()) {\n            yield entry.uri;\n        }\n    }\n    *entries() {\n        for (let entry of this.map.values()) {\n            yield [entry.uri, entry.value];\n        }\n    }\n    *[(_a = Symbol.toStringTag, Symbol.iterator)]() {\n        for (let [, entry] of this.map) {\n            yield [entry.uri, entry.value];\n        }\n    }\n}\nResourceMap.defaultToKey = (resource) => resource.toString();\nexport class LinkedMap {\n    constructor() {\n        this[_b] = 'LinkedMap';\n        this._map = new Map();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state = 0;\n    }\n    clear() {\n        this._map.clear();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state++;\n    }\n    isEmpty() {\n        return !this._head && !this._tail;\n    }\n    get size() {\n        return this._size;\n    }\n    get first() {\n        var _c;\n        return (_c = this._head) === null || _c === void 0 ? void 0 : _c.value;\n    }\n    get last() {\n        var _c;\n        return (_c = this._tail) === null || _c === void 0 ? void 0 : _c.value;\n    }\n    has(key) {\n        return this._map.has(key);\n    }\n    get(key, touch = 0 /* None */) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        if (touch !== 0 /* None */) {\n            this.touch(item, touch);\n        }\n        return item.value;\n    }\n    set(key, value, touch = 0 /* None */) {\n        let item = this._map.get(key);\n        if (item) {\n            item.value = value;\n            if (touch !== 0 /* None */) {\n                this.touch(item, touch);\n            }\n        }\n        else {\n            item = { key, value, next: undefined, previous: undefined };\n            switch (touch) {\n                case 0 /* None */:\n                    this.addItemLast(item);\n                    break;\n                case 1 /* AsOld */:\n                    this.addItemFirst(item);\n                    break;\n                case 2 /* AsNew */:\n                    this.addItemLast(item);\n                    break;\n                default:\n                    this.addItemLast(item);\n                    break;\n            }\n            this._map.set(key, item);\n            this._size++;\n        }\n        return this;\n    }\n    delete(key) {\n        return !!this.remove(key);\n    }\n    remove(key) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        this._map.delete(key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    shift() {\n        if (!this._head && !this._tail) {\n            return undefined;\n        }\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        const item = this._head;\n        this._map.delete(item.key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    forEach(callbackfn, thisArg) {\n        const state = this._state;\n        let current = this._head;\n        while (current) {\n            if (thisArg) {\n                callbackfn.bind(thisArg)(current.value, current.key, this);\n            }\n            else {\n                callbackfn(current.value, current.key, this);\n            }\n            if (this._state !== state) {\n                throw new Error(`LinkedMap got modified during iteration.`);\n            }\n            current = current.next;\n        }\n    }\n    keys() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.key, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    values() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.value, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    entries() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: [current.key, current.value], done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    [(_b = Symbol.toStringTag, Symbol.iterator)]() {\n        return this.entries();\n    }\n    trimOld(newSize) {\n        if (newSize >= this.size) {\n            return;\n        }\n        if (newSize === 0) {\n            this.clear();\n            return;\n        }\n        let current = this._head;\n        let currentSize = this.size;\n        while (current && currentSize > newSize) {\n            this._map.delete(current.key);\n            current = current.next;\n            currentSize--;\n        }\n        this._head = current;\n        this._size = currentSize;\n        if (current) {\n            current.previous = undefined;\n        }\n        this._state++;\n    }\n    addItemFirst(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._tail = item;\n        }\n        else if (!this._head) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.next = this._head;\n            this._head.previous = item;\n        }\n        this._head = item;\n        this._state++;\n    }\n    addItemLast(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._head = item;\n        }\n        else if (!this._tail) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.previous = this._tail;\n            this._tail.next = item;\n        }\n        this._tail = item;\n        this._state++;\n    }\n    removeItem(item) {\n        if (item === this._head && item === this._tail) {\n            this._head = undefined;\n            this._tail = undefined;\n        }\n        else if (item === this._head) {\n            // This can only happen if size === 1 which is handled\n            // by the case above.\n            if (!item.next) {\n                throw new Error('Invalid list');\n            }\n            item.next.previous = undefined;\n            this._head = item.next;\n        }\n        else if (item === this._tail) {\n            // This can only happen if size === 1 which is handled\n            // by the case above.\n            if (!item.previous) {\n                throw new Error('Invalid list');\n            }\n            item.previous.next = undefined;\n            this._tail = item.previous;\n        }\n        else {\n            const next = item.next;\n            const previous = item.previous;\n            if (!next || !previous) {\n                throw new Error('Invalid list');\n            }\n            next.previous = previous;\n            previous.next = next;\n        }\n        item.next = undefined;\n        item.previous = undefined;\n        this._state++;\n    }\n    touch(item, touch) {\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        if ((touch !== 1 /* AsOld */ && touch !== 2 /* AsNew */)) {\n            return;\n        }\n        if (touch === 1 /* AsOld */) {\n            if (item === this._head) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item\n            if (item === this._tail) {\n                // previous must be defined since item was not head but is tail\n                // So there are more than on item in the map\n                previous.next = undefined;\n                this._tail = previous;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            // Insert the node at head\n            item.previous = undefined;\n            item.next = this._head;\n            this._head.previous = item;\n            this._head = item;\n            this._state++;\n        }\n        else if (touch === 2 /* AsNew */) {\n            if (item === this._tail) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item.\n            if (item === this._head) {\n                // next must be defined since item was not tail but is head\n                // So there are more than on item in the map\n                next.previous = undefined;\n                this._head = next;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            item.next = undefined;\n            item.previous = this._tail;\n            this._tail.next = item;\n            this._tail = item;\n            this._state++;\n        }\n    }\n    toJSON() {\n        const data = [];\n        this.forEach((value, key) => {\n            data.push([key, value]);\n        });\n        return data;\n    }\n    fromJSON(data) {\n        this.clear();\n        for (const [key, value] of data) {\n            this.set(key, value);\n        }\n    }\n}\nexport class LRUCache extends LinkedMap {\n    constructor(limit, ratio = 1) {\n        super();\n        this._limit = limit;\n        this._ratio = Math.min(Math.max(0, ratio), 1);\n    }\n    get limit() {\n        return this._limit;\n    }\n    set limit(limit) {\n        this._limit = limit;\n        this.checkTrim();\n    }\n    get(key, touch = 2 /* AsNew */) {\n        return super.get(key, touch);\n    }\n    peek(key) {\n        return super.get(key, 0 /* None */);\n    }\n    set(key, value) {\n        super.set(key, value, 2 /* AsNew */);\n        this.checkTrim();\n        return this;\n    }\n    checkTrim() {\n        if (this.size > this._limit) {\n            this.trimOld(Math.round(this._limit * this._ratio));\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}