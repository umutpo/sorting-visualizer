{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { DocumentSemanticTokensProviderRegistry, DocumentRangeSemanticTokensProviderRegistry } from '../modes.js';\nimport { IModelService } from './modelService.js';\nimport { CommandsRegistry, ICommandService } from '../../../platform/commands/common/commands.js';\nimport { assertType } from '../../../base/common/types.js';\nimport { encodeSemanticTokensDto } from './semanticTokensDto.js';\nimport { Range } from '../core/range.js';\nexport function isSemanticTokens(v) {\n  return v && !!v.data;\n}\nexport function isSemanticTokensEdits(v) {\n  return v && Array.isArray(v.edits);\n}\nexport class DocumentSemanticTokensResult {\n  constructor(provider, tokens) {\n    this.provider = provider;\n    this.tokens = tokens;\n  }\n\n}\nexport function hasDocumentSemanticTokensProvider(model) {\n  return DocumentSemanticTokensProviderRegistry.has(model);\n}\n\nfunction getDocumentSemanticTokensProviders(model) {\n  const groups = DocumentSemanticTokensProviderRegistry.orderedGroups(model);\n  return groups.length > 0 ? groups[0] : [];\n}\n\nexport function getDocumentSemanticTokens(model, lastProvider, lastResultId, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const providers = getDocumentSemanticTokensProviders(model); // Get tokens from all providers at the same time.\n\n    const results = yield Promise.all(providers.map(provider => __awaiter(this, void 0, void 0, function* () {\n      let result;\n\n      try {\n        result = yield provider.provideDocumentSemanticTokens(model, provider === lastProvider ? lastResultId : null, token);\n      } catch (err) {\n        onUnexpectedExternalError(err);\n        result = null;\n      }\n\n      if (!result || !isSemanticTokens(result) && !isSemanticTokensEdits(result)) {\n        result = null;\n      }\n\n      return new DocumentSemanticTokensResult(provider, result);\n    }))); // Try to return the first result with actual tokens\n\n    for (const result of results) {\n      if (result.tokens) {\n        return result;\n      }\n    } // Return the first result, even if it doesn't have tokens\n\n\n    if (results.length > 0) {\n      return results[0];\n    }\n\n    return null;\n  });\n}\n\nfunction _getDocumentSemanticTokensProviderHighestGroup(model) {\n  const result = DocumentSemanticTokensProviderRegistry.orderedGroups(model);\n  return result.length > 0 ? result[0] : null;\n}\n\nclass DocumentRangeSemanticTokensResult {\n  constructor(provider, tokens) {\n    this.provider = provider;\n    this.tokens = tokens;\n  }\n\n}\n\nexport function hasDocumentRangeSemanticTokensProvider(model) {\n  return DocumentRangeSemanticTokensProviderRegistry.has(model);\n}\n\nfunction getDocumentRangeSemanticTokensProviders(model) {\n  const groups = DocumentRangeSemanticTokensProviderRegistry.orderedGroups(model);\n  return groups.length > 0 ? groups[0] : [];\n}\n\nexport function getDocumentRangeSemanticTokens(model, range, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const providers = getDocumentRangeSemanticTokensProviders(model); // Get tokens from all providers at the same time.\n\n    const results = yield Promise.all(providers.map(provider => __awaiter(this, void 0, void 0, function* () {\n      let result;\n\n      try {\n        result = yield provider.provideDocumentRangeSemanticTokens(model, range, token);\n      } catch (err) {\n        onUnexpectedExternalError(err);\n        result = null;\n      }\n\n      if (!result || !isSemanticTokens(result)) {\n        result = null;\n      }\n\n      return new DocumentRangeSemanticTokensResult(provider, result);\n    }))); // Try to return the first result with actual tokens\n\n    for (const result of results) {\n      if (result.tokens) {\n        return result;\n      }\n    } // Return the first result, even if it doesn't have tokens\n\n\n    if (results.length > 0) {\n      return results[0];\n    }\n\n    return null;\n  });\n}\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokensLegend', function (accessor) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n\n    if (!model) {\n      return undefined;\n    }\n\n    const providers = _getDocumentSemanticTokensProviderHighestGroup(model);\n\n    if (!providers) {\n      // there is no provider => fall back to a document range semantic tokens provider\n      return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokensLegend', uri);\n    }\n\n    return providers[0].getLegend();\n  });\n});\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokens', function (accessor) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n\n    if (!model) {\n      return undefined;\n    }\n\n    if (!hasDocumentSemanticTokensProvider(model)) {\n      // there is no provider => fall back to a document range semantic tokens provider\n      return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokens', uri, model.getFullModelRange());\n    }\n\n    const r = yield getDocumentSemanticTokens(model, null, null, CancellationToken.None);\n\n    if (!r) {\n      return undefined;\n    }\n\n    const {\n      provider,\n      tokens\n    } = r;\n\n    if (!tokens || !isSemanticTokens(tokens)) {\n      return undefined;\n    }\n\n    const buff = encodeSemanticTokensDto({\n      id: 0,\n      type: 'full',\n      data: tokens.data\n    });\n\n    if (tokens.resultId) {\n      provider.releaseDocumentSemanticTokens(tokens.resultId);\n    }\n\n    return buff;\n  });\n});\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokensLegend', function (accessor) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const [uri, range] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n\n    if (!model) {\n      return undefined;\n    }\n\n    const providers = getDocumentRangeSemanticTokensProviders(model);\n\n    if (providers.length === 0) {\n      // no providers\n      return undefined;\n    }\n\n    if (providers.length === 1) {\n      // straight forward case, just a single provider\n      return providers[0].getLegend();\n    }\n\n    if (!range || !Range.isIRange(range)) {\n      // if no range is provided, we cannot support multiple providers\n      // as we cannot fall back to the one which would give results\n      // => return the first legend for backwards compatibility and print a warning\n      console.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);\n      return providers[0].getLegend();\n    }\n\n    const result = yield getDocumentRangeSemanticTokens(model, Range.lift(range), CancellationToken.None);\n\n    if (!result) {\n      return undefined;\n    }\n\n    return result.provider.getLegend();\n  });\n});\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokens', function (accessor) {\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const [uri, range] = args;\n    assertType(uri instanceof URI);\n    assertType(Range.isIRange(range));\n    const model = accessor.get(IModelService).getModel(uri);\n\n    if (!model) {\n      return undefined;\n    }\n\n    const result = yield getDocumentRangeSemanticTokens(model, Range.lift(range), CancellationToken.None);\n\n    if (!result || !result.tokens) {\n      // there is no provider or it didn't return tokens\n      return undefined;\n    }\n\n    return encodeSemanticTokensDto({\n      id: 0,\n      type: 'full',\n      data: result.tokens.data\n    });\n  });\n});","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/common/services/getSemanticTokens.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","CancellationToken","onUnexpectedExternalError","URI","DocumentSemanticTokensProviderRegistry","DocumentRangeSemanticTokensProviderRegistry","IModelService","CommandsRegistry","ICommandService","assertType","encodeSemanticTokensDto","Range","isSemanticTokens","v","data","isSemanticTokensEdits","Array","isArray","edits","DocumentSemanticTokensResult","constructor","provider","tokens","hasDocumentSemanticTokensProvider","model","has","getDocumentSemanticTokensProviders","groups","orderedGroups","length","getDocumentSemanticTokens","lastProvider","lastResultId","token","providers","results","all","map","provideDocumentSemanticTokens","err","_getDocumentSemanticTokensProviderHighestGroup","DocumentRangeSemanticTokensResult","hasDocumentRangeSemanticTokensProvider","getDocumentRangeSemanticTokensProviders","getDocumentRangeSemanticTokens","range","provideDocumentRangeSemanticTokens","registerCommand","accessor","args","uri","get","getModel","undefined","executeCommand","getLegend","getFullModelRange","r","None","buff","id","type","resultId","releaseDocumentSemanticTokens","isIRange","console","warn","lift"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { DocumentSemanticTokensProviderRegistry, DocumentRangeSemanticTokensProviderRegistry } from '../modes.js';\nimport { IModelService } from './modelService.js';\nimport { CommandsRegistry, ICommandService } from '../../../platform/commands/common/commands.js';\nimport { assertType } from '../../../base/common/types.js';\nimport { encodeSemanticTokensDto } from './semanticTokensDto.js';\nimport { Range } from '../core/range.js';\nexport function isSemanticTokens(v) {\n    return v && !!(v.data);\n}\nexport function isSemanticTokensEdits(v) {\n    return v && Array.isArray(v.edits);\n}\nexport class DocumentSemanticTokensResult {\n    constructor(provider, tokens) {\n        this.provider = provider;\n        this.tokens = tokens;\n    }\n}\nexport function hasDocumentSemanticTokensProvider(model) {\n    return DocumentSemanticTokensProviderRegistry.has(model);\n}\nfunction getDocumentSemanticTokensProviders(model) {\n    const groups = DocumentSemanticTokensProviderRegistry.orderedGroups(model);\n    return (groups.length > 0 ? groups[0] : []);\n}\nexport function getDocumentSemanticTokens(model, lastProvider, lastResultId, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const providers = getDocumentSemanticTokensProviders(model);\n        // Get tokens from all providers at the same time.\n        const results = yield Promise.all(providers.map((provider) => __awaiter(this, void 0, void 0, function* () {\n            let result;\n            try {\n                result = yield provider.provideDocumentSemanticTokens(model, (provider === lastProvider ? lastResultId : null), token);\n            }\n            catch (err) {\n                onUnexpectedExternalError(err);\n                result = null;\n            }\n            if (!result || (!isSemanticTokens(result) && !isSemanticTokensEdits(result))) {\n                result = null;\n            }\n            return new DocumentSemanticTokensResult(provider, result);\n        })));\n        // Try to return the first result with actual tokens\n        for (const result of results) {\n            if (result.tokens) {\n                return result;\n            }\n        }\n        // Return the first result, even if it doesn't have tokens\n        if (results.length > 0) {\n            return results[0];\n        }\n        return null;\n    });\n}\nfunction _getDocumentSemanticTokensProviderHighestGroup(model) {\n    const result = DocumentSemanticTokensProviderRegistry.orderedGroups(model);\n    return (result.length > 0 ? result[0] : null);\n}\nclass DocumentRangeSemanticTokensResult {\n    constructor(provider, tokens) {\n        this.provider = provider;\n        this.tokens = tokens;\n    }\n}\nexport function hasDocumentRangeSemanticTokensProvider(model) {\n    return DocumentRangeSemanticTokensProviderRegistry.has(model);\n}\nfunction getDocumentRangeSemanticTokensProviders(model) {\n    const groups = DocumentRangeSemanticTokensProviderRegistry.orderedGroups(model);\n    return (groups.length > 0 ? groups[0] : []);\n}\nexport function getDocumentRangeSemanticTokens(model, range, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const providers = getDocumentRangeSemanticTokensProviders(model);\n        // Get tokens from all providers at the same time.\n        const results = yield Promise.all(providers.map((provider) => __awaiter(this, void 0, void 0, function* () {\n            let result;\n            try {\n                result = yield provider.provideDocumentRangeSemanticTokens(model, range, token);\n            }\n            catch (err) {\n                onUnexpectedExternalError(err);\n                result = null;\n            }\n            if (!result || !isSemanticTokens(result)) {\n                result = null;\n            }\n            return new DocumentRangeSemanticTokensResult(provider, result);\n        })));\n        // Try to return the first result with actual tokens\n        for (const result of results) {\n            if (result.tokens) {\n                return result;\n            }\n        }\n        // Return the first result, even if it doesn't have tokens\n        if (results.length > 0) {\n            return results[0];\n        }\n        return null;\n    });\n}\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokensLegend', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const providers = _getDocumentSemanticTokensProviderHighestGroup(model);\n    if (!providers) {\n        // there is no provider => fall back to a document range semantic tokens provider\n        return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokensLegend', uri);\n    }\n    return providers[0].getLegend();\n}));\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokens', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    if (!hasDocumentSemanticTokensProvider(model)) {\n        // there is no provider => fall back to a document range semantic tokens provider\n        return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokens', uri, model.getFullModelRange());\n    }\n    const r = yield getDocumentSemanticTokens(model, null, null, CancellationToken.None);\n    if (!r) {\n        return undefined;\n    }\n    const { provider, tokens } = r;\n    if (!tokens || !isSemanticTokens(tokens)) {\n        return undefined;\n    }\n    const buff = encodeSemanticTokensDto({\n        id: 0,\n        type: 'full',\n        data: tokens.data\n    });\n    if (tokens.resultId) {\n        provider.releaseDocumentSemanticTokens(tokens.resultId);\n    }\n    return buff;\n}));\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokensLegend', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri, range] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const providers = getDocumentRangeSemanticTokensProviders(model);\n    if (providers.length === 0) {\n        // no providers\n        return undefined;\n    }\n    if (providers.length === 1) {\n        // straight forward case, just a single provider\n        return providers[0].getLegend();\n    }\n    if (!range || !Range.isIRange(range)) {\n        // if no range is provided, we cannot support multiple providers\n        // as we cannot fall back to the one which would give results\n        // => return the first legend for backwards compatibility and print a warning\n        console.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);\n        return providers[0].getLegend();\n    }\n    const result = yield getDocumentRangeSemanticTokens(model, Range.lift(range), CancellationToken.None);\n    if (!result) {\n        return undefined;\n    }\n    return result.provider.getLegend();\n}));\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokens', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri, range] = args;\n    assertType(uri instanceof URI);\n    assertType(Range.isIRange(range));\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const result = yield getDocumentRangeSemanticTokens(model, Range.lift(range), CancellationToken.None);\n    if (!result || !result.tokens) {\n        // there is no provider or it didn't return tokens\n        return undefined;\n    }\n    return encodeSemanticTokensDto({\n        id: 0,\n        type: 'full',\n        data: result.tokens.data\n    });\n}));\n"]},"metadata":{},"sourceType":"module"}