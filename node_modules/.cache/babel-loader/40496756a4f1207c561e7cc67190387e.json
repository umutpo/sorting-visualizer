{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, TokenizationResult2 } from '../../../common/core/token.js';\nimport * as modes from '../../../common/modes.js';\nimport { NULL_MODE_ID, NULL_STATE } from '../../../common/modes/nullMode.js';\nimport * as monarchCommon from './monarchCommon.js';\nconst CACHE_STACK_DEPTH = 5;\n/**\n * Reuse the same stack elements up to a certain depth.\n */\n\nclass MonarchStackElementFactory {\n  constructor(maxCacheDepth) {\n    this._maxCacheDepth = maxCacheDepth;\n    this._entries = Object.create(null);\n  }\n\n  static create(parent, state) {\n    return this._INSTANCE.create(parent, state);\n  }\n\n  create(parent, state) {\n    if (parent !== null && parent.depth >= this._maxCacheDepth) {\n      // no caching above a certain depth\n      return new MonarchStackElement(parent, state);\n    }\n\n    let stackElementId = MonarchStackElement.getStackElementId(parent);\n\n    if (stackElementId.length > 0) {\n      stackElementId += '|';\n    }\n\n    stackElementId += state;\n    let result = this._entries[stackElementId];\n\n    if (result) {\n      return result;\n    }\n\n    result = new MonarchStackElement(parent, state);\n    this._entries[stackElementId] = result;\n    return result;\n  }\n\n}\n\nMonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);\n\nclass MonarchStackElement {\n  constructor(parent, state) {\n    this.parent = parent;\n    this.state = state;\n    this.depth = (this.parent ? this.parent.depth : 0) + 1;\n  }\n\n  static getStackElementId(element) {\n    let result = '';\n\n    while (element !== null) {\n      if (result.length > 0) {\n        result += '|';\n      }\n\n      result += element.state;\n      element = element.parent;\n    }\n\n    return result;\n  }\n\n  static _equals(a, b) {\n    while (a !== null && b !== null) {\n      if (a === b) {\n        return true;\n      }\n\n      if (a.state !== b.state) {\n        return false;\n      }\n\n      a = a.parent;\n      b = b.parent;\n    }\n\n    if (a === null && b === null) {\n      return true;\n    }\n\n    return false;\n  }\n\n  equals(other) {\n    return MonarchStackElement._equals(this, other);\n  }\n\n  push(state) {\n    return MonarchStackElementFactory.create(this, state);\n  }\n\n  pop() {\n    return this.parent;\n  }\n\n  popall() {\n    let result = this;\n\n    while (result.parent) {\n      result = result.parent;\n    }\n\n    return result;\n  }\n\n  switchTo(state) {\n    return MonarchStackElementFactory.create(this.parent, state);\n  }\n\n}\n\nclass EmbeddedModeData {\n  constructor(languageId, state) {\n    this.languageId = languageId;\n    this.state = state;\n  }\n\n  equals(other) {\n    return this.languageId === other.languageId && this.state.equals(other.state);\n  }\n\n  clone() {\n    let stateClone = this.state.clone(); // save an object\n\n    if (stateClone === this.state) {\n      return this;\n    }\n\n    return new EmbeddedModeData(this.languageId, this.state);\n  }\n\n}\n/**\n * Reuse the same line states up to a certain depth.\n */\n\n\nclass MonarchLineStateFactory {\n  constructor(maxCacheDepth) {\n    this._maxCacheDepth = maxCacheDepth;\n    this._entries = Object.create(null);\n  }\n\n  static create(stack, embeddedModeData) {\n    return this._INSTANCE.create(stack, embeddedModeData);\n  }\n\n  create(stack, embeddedModeData) {\n    if (embeddedModeData !== null) {\n      // no caching when embedding\n      return new MonarchLineState(stack, embeddedModeData);\n    }\n\n    if (stack !== null && stack.depth >= this._maxCacheDepth) {\n      // no caching above a certain depth\n      return new MonarchLineState(stack, embeddedModeData);\n    }\n\n    let stackElementId = MonarchStackElement.getStackElementId(stack);\n    let result = this._entries[stackElementId];\n\n    if (result) {\n      return result;\n    }\n\n    result = new MonarchLineState(stack, null);\n    this._entries[stackElementId] = result;\n    return result;\n  }\n\n}\n\nMonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);\n\nclass MonarchLineState {\n  constructor(stack, embeddedModeData) {\n    this.stack = stack;\n    this.embeddedModeData = embeddedModeData;\n  }\n\n  clone() {\n    let embeddedModeDataClone = this.embeddedModeData ? this.embeddedModeData.clone() : null; // save an object\n\n    if (embeddedModeDataClone === this.embeddedModeData) {\n      return this;\n    }\n\n    return MonarchLineStateFactory.create(this.stack, this.embeddedModeData);\n  }\n\n  equals(other) {\n    if (!(other instanceof MonarchLineState)) {\n      return false;\n    }\n\n    if (!this.stack.equals(other.stack)) {\n      return false;\n    }\n\n    if (this.embeddedModeData === null && other.embeddedModeData === null) {\n      return true;\n    }\n\n    if (this.embeddedModeData === null || other.embeddedModeData === null) {\n      return false;\n    }\n\n    return this.embeddedModeData.equals(other.embeddedModeData);\n  }\n\n}\n\nclass MonarchClassicTokensCollector {\n  constructor() {\n    this._tokens = [];\n    this._languageId = null;\n    this._lastTokenType = null;\n    this._lastTokenLanguage = null;\n  }\n\n  enterMode(startOffset, languageId) {\n    this._languageId = languageId;\n  }\n\n  emit(startOffset, type) {\n    if (this._lastTokenType === type && this._lastTokenLanguage === this._languageId) {\n      return;\n    }\n\n    this._lastTokenType = type;\n    this._lastTokenLanguage = this._languageId;\n\n    this._tokens.push(new Token(startOffset, type, this._languageId));\n  }\n\n  nestedModeTokenize(embeddedModeLine, hasEOL, embeddedModeData, offsetDelta) {\n    const nestedModeId = embeddedModeData.languageId;\n    const embeddedModeState = embeddedModeData.state;\n    const nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n\n    if (!nestedModeTokenizationSupport) {\n      this.enterMode(offsetDelta, nestedModeId);\n      this.emit(offsetDelta, '');\n      return embeddedModeState;\n    }\n\n    let nestedResult = nestedModeTokenizationSupport.tokenize(embeddedModeLine, hasEOL, embeddedModeState, offsetDelta);\n    this._tokens = this._tokens.concat(nestedResult.tokens);\n    this._lastTokenType = null;\n    this._lastTokenLanguage = null;\n    this._languageId = null;\n    return nestedResult.endState;\n  }\n\n  finalize(endState) {\n    return new TokenizationResult(this._tokens, endState);\n  }\n\n}\n\nclass MonarchModernTokensCollector {\n  constructor(modeService, theme) {\n    this._modeService = modeService;\n    this._theme = theme;\n    this._prependTokens = null;\n    this._tokens = [];\n    this._currentLanguageId = 0\n    /* Null */\n    ;\n    this._lastTokenMetadata = 0;\n  }\n\n  enterMode(startOffset, languageId) {\n    this._currentLanguageId = this._modeService.languageIdCodec.encodeLanguageId(languageId);\n  }\n\n  emit(startOffset, type) {\n    let metadata = this._theme.match(this._currentLanguageId, type);\n\n    if (this._lastTokenMetadata === metadata) {\n      return;\n    }\n\n    this._lastTokenMetadata = metadata;\n\n    this._tokens.push(startOffset);\n\n    this._tokens.push(metadata);\n  }\n\n  static _merge(a, b, c) {\n    let aLen = a !== null ? a.length : 0;\n    let bLen = b.length;\n    let cLen = c !== null ? c.length : 0;\n\n    if (aLen === 0 && bLen === 0 && cLen === 0) {\n      return new Uint32Array(0);\n    }\n\n    if (aLen === 0 && bLen === 0) {\n      return c;\n    }\n\n    if (bLen === 0 && cLen === 0) {\n      return a;\n    }\n\n    let result = new Uint32Array(aLen + bLen + cLen);\n\n    if (a !== null) {\n      result.set(a);\n    }\n\n    for (let i = 0; i < bLen; i++) {\n      result[aLen + i] = b[i];\n    }\n\n    if (c !== null) {\n      result.set(c, aLen + bLen);\n    }\n\n    return result;\n  }\n\n  nestedModeTokenize(embeddedModeLine, hasEOL, embeddedModeData, offsetDelta) {\n    const nestedModeId = embeddedModeData.languageId;\n    const embeddedModeState = embeddedModeData.state;\n    const nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n\n    if (!nestedModeTokenizationSupport) {\n      this.enterMode(offsetDelta, nestedModeId);\n      this.emit(offsetDelta, '');\n      return embeddedModeState;\n    }\n\n    let nestedResult = nestedModeTokenizationSupport.tokenize2(embeddedModeLine, hasEOL, embeddedModeState, offsetDelta);\n    this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\n    this._tokens = [];\n    this._currentLanguageId = 0;\n    this._lastTokenMetadata = 0;\n    return nestedResult.endState;\n  }\n\n  finalize(endState) {\n    return new TokenizationResult2(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\n  }\n\n}\n\nexport class MonarchTokenizer {\n  constructor(modeService, standaloneThemeService, languageId, lexer) {\n    this._modeService = modeService;\n    this._standaloneThemeService = standaloneThemeService;\n    this._languageId = languageId;\n    this._lexer = lexer;\n    this._embeddedModes = Object.create(null);\n    this.embeddedLoaded = Promise.resolve(undefined); // Set up listening for embedded modes\n\n    let emitting = false;\n    this._tokenizationRegistryListener = modes.TokenizationRegistry.onDidChange(e => {\n      if (emitting) {\n        return;\n      }\n\n      let isOneOfMyEmbeddedModes = false;\n\n      for (let i = 0, len = e.changedLanguages.length; i < len; i++) {\n        let language = e.changedLanguages[i];\n\n        if (this._embeddedModes[language]) {\n          isOneOfMyEmbeddedModes = true;\n          break;\n        }\n      }\n\n      if (isOneOfMyEmbeddedModes) {\n        emitting = true;\n        modes.TokenizationRegistry.fire([this._languageId]);\n        emitting = false;\n      }\n    });\n  }\n\n  dispose() {\n    this._tokenizationRegistryListener.dispose();\n  }\n\n  getLoadStatus() {\n    let promises = [];\n\n    for (let nestedModeId in this._embeddedModes) {\n      const tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n\n      if (tokenizationSupport) {\n        // The nested mode is already loaded\n        if (tokenizationSupport instanceof MonarchTokenizer) {\n          const nestedModeStatus = tokenizationSupport.getLoadStatus();\n\n          if (nestedModeStatus.loaded === false) {\n            promises.push(nestedModeStatus.promise);\n          }\n        }\n\n        continue;\n      }\n\n      const tokenizationSupportPromise = modes.TokenizationRegistry.getPromise(nestedModeId);\n\n      if (tokenizationSupportPromise) {\n        // The nested mode is in the process of being loaded\n        promises.push(tokenizationSupportPromise);\n      }\n    }\n\n    if (promises.length === 0) {\n      return {\n        loaded: true\n      };\n    }\n\n    return {\n      loaded: false,\n      promise: Promise.all(promises).then(_ => undefined)\n    };\n  }\n\n  getInitialState() {\n    let rootState = MonarchStackElementFactory.create(null, this._lexer.start);\n    return MonarchLineStateFactory.create(rootState, null);\n  }\n\n  tokenize(line, hasEOL, lineState, offsetDelta) {\n    let tokensCollector = new MonarchClassicTokensCollector();\n\n    let endLineState = this._tokenize(line, hasEOL, lineState, offsetDelta, tokensCollector);\n\n    return tokensCollector.finalize(endLineState);\n  }\n\n  tokenize2(line, hasEOL, lineState, offsetDelta) {\n    let tokensCollector = new MonarchModernTokensCollector(this._modeService, this._standaloneThemeService.getColorTheme().tokenTheme);\n\n    let endLineState = this._tokenize(line, hasEOL, lineState, offsetDelta, tokensCollector);\n\n    return tokensCollector.finalize(endLineState);\n  }\n\n  _tokenize(line, hasEOL, lineState, offsetDelta, collector) {\n    if (lineState.embeddedModeData) {\n      return this._nestedTokenize(line, hasEOL, lineState, offsetDelta, collector);\n    } else {\n      return this._myTokenize(line, hasEOL, lineState, offsetDelta, collector);\n    }\n  }\n\n  _findLeavingNestedModeOffset(line, state) {\n    let rules = this._lexer.tokenizer[state.stack.state];\n\n    if (!rules) {\n      rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\n\n      if (!rules) {\n        throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\n      }\n    }\n\n    let popOffset = -1;\n    let hasEmbeddedPopRule = false;\n\n    for (const rule of rules) {\n      if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\n        continue;\n      }\n\n      hasEmbeddedPopRule = true;\n      let regex = rule.regex;\n      let regexSource = rule.regex.source;\n\n      if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\n        let flags = (regex.ignoreCase ? 'i' : '') + (regex.unicode ? 'u' : '');\n        regex = new RegExp(regexSource.substr(4, regexSource.length - 5), flags);\n      }\n\n      let result = line.search(regex);\n\n      if (result === -1 || result !== 0 && rule.matchOnlyAtLineStart) {\n        continue;\n      }\n\n      if (popOffset === -1 || result < popOffset) {\n        popOffset = result;\n      }\n    }\n\n    if (!hasEmbeddedPopRule) {\n      throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\n    }\n\n    return popOffset;\n  }\n\n  _nestedTokenize(line, hasEOL, lineState, offsetDelta, tokensCollector) {\n    let popOffset = this._findLeavingNestedModeOffset(line, lineState);\n\n    if (popOffset === -1) {\n      // tokenization will not leave nested mode\n      let nestedEndState = tokensCollector.nestedModeTokenize(line, hasEOL, lineState.embeddedModeData, offsetDelta);\n      return MonarchLineStateFactory.create(lineState.stack, new EmbeddedModeData(lineState.embeddedModeData.languageId, nestedEndState));\n    }\n\n    let nestedModeLine = line.substring(0, popOffset);\n\n    if (nestedModeLine.length > 0) {\n      // tokenize with the nested mode\n      tokensCollector.nestedModeTokenize(nestedModeLine, false, lineState.embeddedModeData, offsetDelta);\n    }\n\n    let restOfTheLine = line.substring(popOffset);\n    return this._myTokenize(restOfTheLine, hasEOL, lineState, offsetDelta + popOffset, tokensCollector);\n  }\n\n  _safeRuleName(rule) {\n    if (rule) {\n      return rule.name;\n    }\n\n    return '(unknown)';\n  }\n\n  _myTokenize(lineWithoutLF, hasEOL, lineState, offsetDelta, tokensCollector) {\n    tokensCollector.enterMode(offsetDelta, this._languageId);\n    const lineWithoutLFLength = lineWithoutLF.length;\n    const line = hasEOL && this._lexer.includeLF ? lineWithoutLF + '\\n' : lineWithoutLF;\n    const lineLength = line.length;\n    let embeddedModeData = lineState.embeddedModeData;\n    let stack = lineState.stack;\n    let pos = 0;\n    let groupMatching = null; // See https://github.com/microsoft/monaco-editor/issues/1235\n    // Evaluate rules at least once for an empty line\n\n    let forceEvaluation = true;\n\n    while (forceEvaluation || pos < lineLength) {\n      const pos0 = pos;\n      const stackLen0 = stack.depth;\n      const groupLen0 = groupMatching ? groupMatching.groups.length : 0;\n      const state = stack.state;\n      let matches = null;\n      let matched = null;\n      let action = null;\n      let rule = null;\n      let enteringEmbeddedMode = null; // check if we need to process group matches first\n\n      if (groupMatching) {\n        matches = groupMatching.matches;\n        const groupEntry = groupMatching.groups.shift();\n        matched = groupEntry.matched;\n        action = groupEntry.action;\n        rule = groupMatching.rule; // cleanup if necessary\n\n        if (groupMatching.groups.length === 0) {\n          groupMatching = null;\n        }\n      } else {\n        // otherwise we match on the token stream\n        if (!forceEvaluation && pos >= lineLength) {\n          // nothing to do\n          break;\n        }\n\n        forceEvaluation = false; // get the rules for this state\n\n        let rules = this._lexer.tokenizer[state];\n\n        if (!rules) {\n          rules = monarchCommon.findRules(this._lexer, state); // do parent matching\n\n          if (!rules) {\n            throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\n          }\n        } // try each rule until we match\n\n\n        let restOfLine = line.substr(pos);\n\n        for (const rule of rules) {\n          if (pos === 0 || !rule.matchOnlyAtLineStart) {\n            matches = restOfLine.match(rule.regex);\n\n            if (matches) {\n              matched = matches[0];\n              action = rule.action;\n              break;\n            }\n          }\n        }\n      } // We matched 'rule' with 'matches' and 'action'\n\n\n      if (!matches) {\n        matches = [''];\n        matched = '';\n      }\n\n      if (!action) {\n        // bad: we didn't match anything, and there is no action to take\n        // we need to advance the stream or we get progress trouble\n        if (pos < lineLength) {\n          matches = [line.charAt(pos)];\n          matched = matches[0];\n        }\n\n        action = this._lexer.defaultToken;\n      }\n\n      if (matched === null) {\n        // should never happen, needed for strict null checking\n        break;\n      } // advance stream\n\n\n      pos += matched.length; // maybe call action function (used for 'cases')\n\n      while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\n        action = action.test(matched, matches, state, pos === lineLength);\n      }\n\n      let result = null; // set the result: either a string or an array of actions\n\n      if (typeof action === 'string' || Array.isArray(action)) {\n        result = action;\n      } else if (action.group) {\n        result = action.group;\n      } else if (action.token !== null && action.token !== undefined) {\n        // do $n replacements?\n        if (action.tokenSubst) {\n          result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\n        } else {\n          result = action.token;\n        } // enter embedded mode?\n\n\n        if (action.nextEmbedded) {\n          if (action.nextEmbedded === '@pop') {\n            if (!embeddedModeData) {\n              throw monarchCommon.createError(this._lexer, 'cannot pop embedded mode if not inside one');\n            }\n\n            embeddedModeData = null;\n          } else if (embeddedModeData) {\n            throw monarchCommon.createError(this._lexer, 'cannot enter embedded mode from within an embedded mode');\n          } else {\n            enteringEmbeddedMode = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\n          }\n        } // state transformations\n\n\n        if (action.goBack) {\n          // back up the stream..\n          pos = Math.max(0, pos - action.goBack);\n        }\n\n        if (action.switchTo && typeof action.switchTo === 'string') {\n          let nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\n\n          if (nextState[0] === '@') {\n            nextState = nextState.substr(1); // peel off starting '@'\n          }\n\n          if (!monarchCommon.findRules(this._lexer, nextState)) {\n            throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n          } else {\n            stack = stack.switchTo(nextState);\n          }\n        } else if (action.transform && typeof action.transform === 'function') {\n          throw monarchCommon.createError(this._lexer, 'action.transform not supported');\n        } else if (action.next) {\n          if (action.next === '@push') {\n            if (stack.depth >= this._lexer.maxStack) {\n              throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' + stack.state + ',' + stack.parent.state + ',...]');\n            } else {\n              stack = stack.push(state);\n            }\n          } else if (action.next === '@pop') {\n            if (stack.depth <= 1) {\n              throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\n            } else {\n              stack = stack.pop();\n            }\n          } else if (action.next === '@popall') {\n            stack = stack.popall();\n          } else {\n            let nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\n\n            if (nextState[0] === '@') {\n              nextState = nextState.substr(1); // peel off starting '@'\n            }\n\n            if (!monarchCommon.findRules(this._lexer, nextState)) {\n              throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n            } else {\n              stack = stack.push(nextState);\n            }\n          }\n        }\n\n        if (action.log && typeof action.log === 'string') {\n          monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\n        }\n      } // check result\n\n\n      if (result === null) {\n        throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\n      }\n\n      const computeNewStateForEmbeddedMode = enteringEmbeddedMode => {\n        // substitute language alias to known modes to support syntax highlighting\n        let enteringEmbeddedModeId = this._modeService.getModeIdForLanguageName(enteringEmbeddedMode);\n\n        if (enteringEmbeddedModeId) {\n          enteringEmbeddedMode = enteringEmbeddedModeId;\n        }\n\n        const embeddedModeData = this._getNestedEmbeddedModeData(enteringEmbeddedMode);\n\n        if (pos < lineLength) {\n          // there is content from the embedded mode on this line\n          const restOfLine = lineWithoutLF.substr(pos);\n          return this._nestedTokenize(restOfLine, hasEOL, MonarchLineStateFactory.create(stack, embeddedModeData), offsetDelta + pos, tokensCollector);\n        } else {\n          return MonarchLineStateFactory.create(stack, embeddedModeData);\n        }\n      }; // is the result a group match?\n\n\n      if (Array.isArray(result)) {\n        if (groupMatching && groupMatching.groups.length > 0) {\n          throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\n        }\n\n        if (matches.length !== result.length + 1) {\n          throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\n        }\n\n        let totalLen = 0;\n\n        for (let i = 1; i < matches.length; i++) {\n          totalLen += matches[i].length;\n        }\n\n        if (totalLen !== matched.length) {\n          throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\n        }\n\n        groupMatching = {\n          rule: rule,\n          matches: matches,\n          groups: []\n        };\n\n        for (let i = 0; i < result.length; i++) {\n          groupMatching.groups[i] = {\n            action: result[i],\n            matched: matches[i + 1]\n          };\n        }\n\n        pos -= matched.length; // call recursively to initiate first result match\n\n        continue;\n      } else {\n        // regular result\n        // check for '@rematch'\n        if (result === '@rematch') {\n          pos -= matched.length;\n          matched = ''; // better set the next state too..\n\n          matches = null;\n          result = ''; // Even though `@rematch` was specified, if `nextEmbedded` also specified,\n          // a state transition should occur.\n\n          if (enteringEmbeddedMode !== null) {\n            return computeNewStateForEmbeddedMode(enteringEmbeddedMode);\n          }\n        } // check progress\n\n\n        if (matched.length === 0) {\n          if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\n            continue;\n          } else {\n            throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\n          }\n        } // return the result (and check for brace matching)\n        // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\n\n\n        let tokenType = null;\n\n        if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\n          let rest = result.substr('@brackets'.length);\n          let bracket = findBracket(this._lexer, matched);\n\n          if (!bracket) {\n            throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\n          }\n\n          tokenType = monarchCommon.sanitize(bracket.token + rest);\n        } else {\n          let token = result === '' ? '' : result + this._lexer.tokenPostfix;\n          tokenType = monarchCommon.sanitize(token);\n        }\n\n        if (pos0 < lineWithoutLFLength) {\n          tokensCollector.emit(pos0 + offsetDelta, tokenType);\n        }\n      }\n\n      if (enteringEmbeddedMode !== null) {\n        return computeNewStateForEmbeddedMode(enteringEmbeddedMode);\n      }\n    }\n\n    return MonarchLineStateFactory.create(stack, embeddedModeData);\n  }\n\n  _getNestedEmbeddedModeData(mimetypeOrModeId) {\n    let nestedModeId = this._locateMode(mimetypeOrModeId);\n\n    if (nestedModeId) {\n      let tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n\n      if (tokenizationSupport) {\n        return new EmbeddedModeData(nestedModeId, tokenizationSupport.getInitialState());\n      }\n    }\n\n    return new EmbeddedModeData(nestedModeId || NULL_MODE_ID, NULL_STATE);\n  }\n\n  _locateMode(mimetypeOrModeId) {\n    if (!mimetypeOrModeId || !this._modeService.isRegisteredMode(mimetypeOrModeId)) {\n      return null;\n    }\n\n    if (mimetypeOrModeId === this._languageId) {\n      // embedding myself...\n      return mimetypeOrModeId;\n    }\n\n    const languageId = this._modeService.getModeId(mimetypeOrModeId);\n\n    if (languageId) {\n      // Fire mode loading event\n      this._modeService.triggerMode(languageId);\n\n      this._embeddedModes[languageId] = true;\n    }\n\n    return languageId;\n  }\n\n}\n/**\n * Searches for a bracket in the 'brackets' attribute that matches the input.\n */\n\nfunction findBracket(lexer, matched) {\n  if (!matched) {\n    return null;\n  }\n\n  matched = monarchCommon.fixCase(lexer, matched);\n  let brackets = lexer.brackets;\n\n  for (const bracket of brackets) {\n    if (bracket.open === matched) {\n      return {\n        token: bracket.token,\n        bracketType: 1\n        /* Open */\n\n      };\n    } else if (bracket.close === matched) {\n      return {\n        token: bracket.token,\n        bracketType: -1\n        /* Close */\n\n      };\n    }\n  }\n\n  return null;\n}\n\nexport function createTokenizationSupport(modeService, standaloneThemeService, languageId, lexer) {\n  return new MonarchTokenizer(modeService, standaloneThemeService, languageId, lexer);\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchLexer.js"],"names":["Token","TokenizationResult","TokenizationResult2","modes","NULL_MODE_ID","NULL_STATE","monarchCommon","CACHE_STACK_DEPTH","MonarchStackElementFactory","constructor","maxCacheDepth","_maxCacheDepth","_entries","Object","create","parent","state","_INSTANCE","depth","MonarchStackElement","stackElementId","getStackElementId","length","result","element","_equals","a","b","equals","other","push","pop","popall","switchTo","EmbeddedModeData","languageId","clone","stateClone","MonarchLineStateFactory","stack","embeddedModeData","MonarchLineState","embeddedModeDataClone","MonarchClassicTokensCollector","_tokens","_languageId","_lastTokenType","_lastTokenLanguage","enterMode","startOffset","emit","type","nestedModeTokenize","embeddedModeLine","hasEOL","offsetDelta","nestedModeId","embeddedModeState","nestedModeTokenizationSupport","TokenizationRegistry","get","nestedResult","tokenize","concat","tokens","endState","finalize","MonarchModernTokensCollector","modeService","theme","_modeService","_theme","_prependTokens","_currentLanguageId","_lastTokenMetadata","languageIdCodec","encodeLanguageId","metadata","match","_merge","c","aLen","bLen","cLen","Uint32Array","set","i","tokenize2","MonarchTokenizer","standaloneThemeService","lexer","_standaloneThemeService","_lexer","_embeddedModes","embeddedLoaded","Promise","resolve","undefined","emitting","_tokenizationRegistryListener","onDidChange","e","isOneOfMyEmbeddedModes","len","changedLanguages","language","fire","dispose","getLoadStatus","promises","tokenizationSupport","nestedModeStatus","loaded","promise","tokenizationSupportPromise","getPromise","all","then","_","getInitialState","rootState","start","line","lineState","tokensCollector","endLineState","_tokenize","getColorTheme","tokenTheme","collector","_nestedTokenize","_myTokenize","_findLeavingNestedModeOffset","rules","tokenizer","findRules","createError","popOffset","hasEmbeddedPopRule","rule","isIAction","action","nextEmbedded","regex","regexSource","source","substr","flags","ignoreCase","unicode","RegExp","search","matchOnlyAtLineStart","nestedEndState","nestedModeLine","substring","restOfTheLine","_safeRuleName","name","lineWithoutLF","lineWithoutLFLength","includeLF","lineLength","pos","groupMatching","forceEvaluation","pos0","stackLen0","groupLen0","groups","matches","matched","enteringEmbeddedMode","groupEntry","shift","restOfLine","charAt","defaultToken","isFuzzyAction","test","Array","isArray","group","token","tokenSubst","substituteMatches","goBack","Math","max","nextState","transform","next","maxStack","log","computeNewStateForEmbeddedMode","enteringEmbeddedModeId","getModeIdForLanguageName","_getNestedEmbeddedModeData","totalLen","tokenType","isString","indexOf","rest","bracket","findBracket","sanitize","tokenPostfix","mimetypeOrModeId","_locateMode","isRegisteredMode","getModeId","triggerMode","fixCase","brackets","open","bracketType","close","createTokenizationSupport"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, TokenizationResult2 } from '../../../common/core/token.js';\nimport * as modes from '../../../common/modes.js';\nimport { NULL_MODE_ID, NULL_STATE } from '../../../common/modes/nullMode.js';\nimport * as monarchCommon from './monarchCommon.js';\nconst CACHE_STACK_DEPTH = 5;\n/**\n * Reuse the same stack elements up to a certain depth.\n */\nclass MonarchStackElementFactory {\n    constructor(maxCacheDepth) {\n        this._maxCacheDepth = maxCacheDepth;\n        this._entries = Object.create(null);\n    }\n    static create(parent, state) {\n        return this._INSTANCE.create(parent, state);\n    }\n    create(parent, state) {\n        if (parent !== null && parent.depth >= this._maxCacheDepth) {\n            // no caching above a certain depth\n            return new MonarchStackElement(parent, state);\n        }\n        let stackElementId = MonarchStackElement.getStackElementId(parent);\n        if (stackElementId.length > 0) {\n            stackElementId += '|';\n        }\n        stackElementId += state;\n        let result = this._entries[stackElementId];\n        if (result) {\n            return result;\n        }\n        result = new MonarchStackElement(parent, state);\n        this._entries[stackElementId] = result;\n        return result;\n    }\n}\nMonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);\nclass MonarchStackElement {\n    constructor(parent, state) {\n        this.parent = parent;\n        this.state = state;\n        this.depth = (this.parent ? this.parent.depth : 0) + 1;\n    }\n    static getStackElementId(element) {\n        let result = '';\n        while (element !== null) {\n            if (result.length > 0) {\n                result += '|';\n            }\n            result += element.state;\n            element = element.parent;\n        }\n        return result;\n    }\n    static _equals(a, b) {\n        while (a !== null && b !== null) {\n            if (a === b) {\n                return true;\n            }\n            if (a.state !== b.state) {\n                return false;\n            }\n            a = a.parent;\n            b = b.parent;\n        }\n        if (a === null && b === null) {\n            return true;\n        }\n        return false;\n    }\n    equals(other) {\n        return MonarchStackElement._equals(this, other);\n    }\n    push(state) {\n        return MonarchStackElementFactory.create(this, state);\n    }\n    pop() {\n        return this.parent;\n    }\n    popall() {\n        let result = this;\n        while (result.parent) {\n            result = result.parent;\n        }\n        return result;\n    }\n    switchTo(state) {\n        return MonarchStackElementFactory.create(this.parent, state);\n    }\n}\nclass EmbeddedModeData {\n    constructor(languageId, state) {\n        this.languageId = languageId;\n        this.state = state;\n    }\n    equals(other) {\n        return (this.languageId === other.languageId\n            && this.state.equals(other.state));\n    }\n    clone() {\n        let stateClone = this.state.clone();\n        // save an object\n        if (stateClone === this.state) {\n            return this;\n        }\n        return new EmbeddedModeData(this.languageId, this.state);\n    }\n}\n/**\n * Reuse the same line states up to a certain depth.\n */\nclass MonarchLineStateFactory {\n    constructor(maxCacheDepth) {\n        this._maxCacheDepth = maxCacheDepth;\n        this._entries = Object.create(null);\n    }\n    static create(stack, embeddedModeData) {\n        return this._INSTANCE.create(stack, embeddedModeData);\n    }\n    create(stack, embeddedModeData) {\n        if (embeddedModeData !== null) {\n            // no caching when embedding\n            return new MonarchLineState(stack, embeddedModeData);\n        }\n        if (stack !== null && stack.depth >= this._maxCacheDepth) {\n            // no caching above a certain depth\n            return new MonarchLineState(stack, embeddedModeData);\n        }\n        let stackElementId = MonarchStackElement.getStackElementId(stack);\n        let result = this._entries[stackElementId];\n        if (result) {\n            return result;\n        }\n        result = new MonarchLineState(stack, null);\n        this._entries[stackElementId] = result;\n        return result;\n    }\n}\nMonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);\nclass MonarchLineState {\n    constructor(stack, embeddedModeData) {\n        this.stack = stack;\n        this.embeddedModeData = embeddedModeData;\n    }\n    clone() {\n        let embeddedModeDataClone = this.embeddedModeData ? this.embeddedModeData.clone() : null;\n        // save an object\n        if (embeddedModeDataClone === this.embeddedModeData) {\n            return this;\n        }\n        return MonarchLineStateFactory.create(this.stack, this.embeddedModeData);\n    }\n    equals(other) {\n        if (!(other instanceof MonarchLineState)) {\n            return false;\n        }\n        if (!this.stack.equals(other.stack)) {\n            return false;\n        }\n        if (this.embeddedModeData === null && other.embeddedModeData === null) {\n            return true;\n        }\n        if (this.embeddedModeData === null || other.embeddedModeData === null) {\n            return false;\n        }\n        return this.embeddedModeData.equals(other.embeddedModeData);\n    }\n}\nclass MonarchClassicTokensCollector {\n    constructor() {\n        this._tokens = [];\n        this._languageId = null;\n        this._lastTokenType = null;\n        this._lastTokenLanguage = null;\n    }\n    enterMode(startOffset, languageId) {\n        this._languageId = languageId;\n    }\n    emit(startOffset, type) {\n        if (this._lastTokenType === type && this._lastTokenLanguage === this._languageId) {\n            return;\n        }\n        this._lastTokenType = type;\n        this._lastTokenLanguage = this._languageId;\n        this._tokens.push(new Token(startOffset, type, this._languageId));\n    }\n    nestedModeTokenize(embeddedModeLine, hasEOL, embeddedModeData, offsetDelta) {\n        const nestedModeId = embeddedModeData.languageId;\n        const embeddedModeState = embeddedModeData.state;\n        const nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n        if (!nestedModeTokenizationSupport) {\n            this.enterMode(offsetDelta, nestedModeId);\n            this.emit(offsetDelta, '');\n            return embeddedModeState;\n        }\n        let nestedResult = nestedModeTokenizationSupport.tokenize(embeddedModeLine, hasEOL, embeddedModeState, offsetDelta);\n        this._tokens = this._tokens.concat(nestedResult.tokens);\n        this._lastTokenType = null;\n        this._lastTokenLanguage = null;\n        this._languageId = null;\n        return nestedResult.endState;\n    }\n    finalize(endState) {\n        return new TokenizationResult(this._tokens, endState);\n    }\n}\nclass MonarchModernTokensCollector {\n    constructor(modeService, theme) {\n        this._modeService = modeService;\n        this._theme = theme;\n        this._prependTokens = null;\n        this._tokens = [];\n        this._currentLanguageId = 0 /* Null */;\n        this._lastTokenMetadata = 0;\n    }\n    enterMode(startOffset, languageId) {\n        this._currentLanguageId = this._modeService.languageIdCodec.encodeLanguageId(languageId);\n    }\n    emit(startOffset, type) {\n        let metadata = this._theme.match(this._currentLanguageId, type);\n        if (this._lastTokenMetadata === metadata) {\n            return;\n        }\n        this._lastTokenMetadata = metadata;\n        this._tokens.push(startOffset);\n        this._tokens.push(metadata);\n    }\n    static _merge(a, b, c) {\n        let aLen = (a !== null ? a.length : 0);\n        let bLen = b.length;\n        let cLen = (c !== null ? c.length : 0);\n        if (aLen === 0 && bLen === 0 && cLen === 0) {\n            return new Uint32Array(0);\n        }\n        if (aLen === 0 && bLen === 0) {\n            return c;\n        }\n        if (bLen === 0 && cLen === 0) {\n            return a;\n        }\n        let result = new Uint32Array(aLen + bLen + cLen);\n        if (a !== null) {\n            result.set(a);\n        }\n        for (let i = 0; i < bLen; i++) {\n            result[aLen + i] = b[i];\n        }\n        if (c !== null) {\n            result.set(c, aLen + bLen);\n        }\n        return result;\n    }\n    nestedModeTokenize(embeddedModeLine, hasEOL, embeddedModeData, offsetDelta) {\n        const nestedModeId = embeddedModeData.languageId;\n        const embeddedModeState = embeddedModeData.state;\n        const nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n        if (!nestedModeTokenizationSupport) {\n            this.enterMode(offsetDelta, nestedModeId);\n            this.emit(offsetDelta, '');\n            return embeddedModeState;\n        }\n        let nestedResult = nestedModeTokenizationSupport.tokenize2(embeddedModeLine, hasEOL, embeddedModeState, offsetDelta);\n        this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\n        this._tokens = [];\n        this._currentLanguageId = 0;\n        this._lastTokenMetadata = 0;\n        return nestedResult.endState;\n    }\n    finalize(endState) {\n        return new TokenizationResult2(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\n    }\n}\nexport class MonarchTokenizer {\n    constructor(modeService, standaloneThemeService, languageId, lexer) {\n        this._modeService = modeService;\n        this._standaloneThemeService = standaloneThemeService;\n        this._languageId = languageId;\n        this._lexer = lexer;\n        this._embeddedModes = Object.create(null);\n        this.embeddedLoaded = Promise.resolve(undefined);\n        // Set up listening for embedded modes\n        let emitting = false;\n        this._tokenizationRegistryListener = modes.TokenizationRegistry.onDidChange((e) => {\n            if (emitting) {\n                return;\n            }\n            let isOneOfMyEmbeddedModes = false;\n            for (let i = 0, len = e.changedLanguages.length; i < len; i++) {\n                let language = e.changedLanguages[i];\n                if (this._embeddedModes[language]) {\n                    isOneOfMyEmbeddedModes = true;\n                    break;\n                }\n            }\n            if (isOneOfMyEmbeddedModes) {\n                emitting = true;\n                modes.TokenizationRegistry.fire([this._languageId]);\n                emitting = false;\n            }\n        });\n    }\n    dispose() {\n        this._tokenizationRegistryListener.dispose();\n    }\n    getLoadStatus() {\n        let promises = [];\n        for (let nestedModeId in this._embeddedModes) {\n            const tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n            if (tokenizationSupport) {\n                // The nested mode is already loaded\n                if (tokenizationSupport instanceof MonarchTokenizer) {\n                    const nestedModeStatus = tokenizationSupport.getLoadStatus();\n                    if (nestedModeStatus.loaded === false) {\n                        promises.push(nestedModeStatus.promise);\n                    }\n                }\n                continue;\n            }\n            const tokenizationSupportPromise = modes.TokenizationRegistry.getPromise(nestedModeId);\n            if (tokenizationSupportPromise) {\n                // The nested mode is in the process of being loaded\n                promises.push(tokenizationSupportPromise);\n            }\n        }\n        if (promises.length === 0) {\n            return {\n                loaded: true\n            };\n        }\n        return {\n            loaded: false,\n            promise: Promise.all(promises).then(_ => undefined)\n        };\n    }\n    getInitialState() {\n        let rootState = MonarchStackElementFactory.create(null, this._lexer.start);\n        return MonarchLineStateFactory.create(rootState, null);\n    }\n    tokenize(line, hasEOL, lineState, offsetDelta) {\n        let tokensCollector = new MonarchClassicTokensCollector();\n        let endLineState = this._tokenize(line, hasEOL, lineState, offsetDelta, tokensCollector);\n        return tokensCollector.finalize(endLineState);\n    }\n    tokenize2(line, hasEOL, lineState, offsetDelta) {\n        let tokensCollector = new MonarchModernTokensCollector(this._modeService, this._standaloneThemeService.getColorTheme().tokenTheme);\n        let endLineState = this._tokenize(line, hasEOL, lineState, offsetDelta, tokensCollector);\n        return tokensCollector.finalize(endLineState);\n    }\n    _tokenize(line, hasEOL, lineState, offsetDelta, collector) {\n        if (lineState.embeddedModeData) {\n            return this._nestedTokenize(line, hasEOL, lineState, offsetDelta, collector);\n        }\n        else {\n            return this._myTokenize(line, hasEOL, lineState, offsetDelta, collector);\n        }\n    }\n    _findLeavingNestedModeOffset(line, state) {\n        let rules = this._lexer.tokenizer[state.stack.state];\n        if (!rules) {\n            rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\n            if (!rules) {\n                throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\n            }\n        }\n        let popOffset = -1;\n        let hasEmbeddedPopRule = false;\n        for (const rule of rules) {\n            if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\n                continue;\n            }\n            hasEmbeddedPopRule = true;\n            let regex = rule.regex;\n            let regexSource = rule.regex.source;\n            if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\n                let flags = (regex.ignoreCase ? 'i' : '') + (regex.unicode ? 'u' : '');\n                regex = new RegExp(regexSource.substr(4, regexSource.length - 5), flags);\n            }\n            let result = line.search(regex);\n            if (result === -1 || (result !== 0 && rule.matchOnlyAtLineStart)) {\n                continue;\n            }\n            if (popOffset === -1 || result < popOffset) {\n                popOffset = result;\n            }\n        }\n        if (!hasEmbeddedPopRule) {\n            throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\n        }\n        return popOffset;\n    }\n    _nestedTokenize(line, hasEOL, lineState, offsetDelta, tokensCollector) {\n        let popOffset = this._findLeavingNestedModeOffset(line, lineState);\n        if (popOffset === -1) {\n            // tokenization will not leave nested mode\n            let nestedEndState = tokensCollector.nestedModeTokenize(line, hasEOL, lineState.embeddedModeData, offsetDelta);\n            return MonarchLineStateFactory.create(lineState.stack, new EmbeddedModeData(lineState.embeddedModeData.languageId, nestedEndState));\n        }\n        let nestedModeLine = line.substring(0, popOffset);\n        if (nestedModeLine.length > 0) {\n            // tokenize with the nested mode\n            tokensCollector.nestedModeTokenize(nestedModeLine, false, lineState.embeddedModeData, offsetDelta);\n        }\n        let restOfTheLine = line.substring(popOffset);\n        return this._myTokenize(restOfTheLine, hasEOL, lineState, offsetDelta + popOffset, tokensCollector);\n    }\n    _safeRuleName(rule) {\n        if (rule) {\n            return rule.name;\n        }\n        return '(unknown)';\n    }\n    _myTokenize(lineWithoutLF, hasEOL, lineState, offsetDelta, tokensCollector) {\n        tokensCollector.enterMode(offsetDelta, this._languageId);\n        const lineWithoutLFLength = lineWithoutLF.length;\n        const line = (hasEOL && this._lexer.includeLF ? lineWithoutLF + '\\n' : lineWithoutLF);\n        const lineLength = line.length;\n        let embeddedModeData = lineState.embeddedModeData;\n        let stack = lineState.stack;\n        let pos = 0;\n        let groupMatching = null;\n        // See https://github.com/microsoft/monaco-editor/issues/1235\n        // Evaluate rules at least once for an empty line\n        let forceEvaluation = true;\n        while (forceEvaluation || pos < lineLength) {\n            const pos0 = pos;\n            const stackLen0 = stack.depth;\n            const groupLen0 = groupMatching ? groupMatching.groups.length : 0;\n            const state = stack.state;\n            let matches = null;\n            let matched = null;\n            let action = null;\n            let rule = null;\n            let enteringEmbeddedMode = null;\n            // check if we need to process group matches first\n            if (groupMatching) {\n                matches = groupMatching.matches;\n                const groupEntry = groupMatching.groups.shift();\n                matched = groupEntry.matched;\n                action = groupEntry.action;\n                rule = groupMatching.rule;\n                // cleanup if necessary\n                if (groupMatching.groups.length === 0) {\n                    groupMatching = null;\n                }\n            }\n            else {\n                // otherwise we match on the token stream\n                if (!forceEvaluation && pos >= lineLength) {\n                    // nothing to do\n                    break;\n                }\n                forceEvaluation = false;\n                // get the rules for this state\n                let rules = this._lexer.tokenizer[state];\n                if (!rules) {\n                    rules = monarchCommon.findRules(this._lexer, state); // do parent matching\n                    if (!rules) {\n                        throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\n                    }\n                }\n                // try each rule until we match\n                let restOfLine = line.substr(pos);\n                for (const rule of rules) {\n                    if (pos === 0 || !rule.matchOnlyAtLineStart) {\n                        matches = restOfLine.match(rule.regex);\n                        if (matches) {\n                            matched = matches[0];\n                            action = rule.action;\n                            break;\n                        }\n                    }\n                }\n            }\n            // We matched 'rule' with 'matches' and 'action'\n            if (!matches) {\n                matches = [''];\n                matched = '';\n            }\n            if (!action) {\n                // bad: we didn't match anything, and there is no action to take\n                // we need to advance the stream or we get progress trouble\n                if (pos < lineLength) {\n                    matches = [line.charAt(pos)];\n                    matched = matches[0];\n                }\n                action = this._lexer.defaultToken;\n            }\n            if (matched === null) {\n                // should never happen, needed for strict null checking\n                break;\n            }\n            // advance stream\n            pos += matched.length;\n            // maybe call action function (used for 'cases')\n            while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\n                action = action.test(matched, matches, state, pos === lineLength);\n            }\n            let result = null;\n            // set the result: either a string or an array of actions\n            if (typeof action === 'string' || Array.isArray(action)) {\n                result = action;\n            }\n            else if (action.group) {\n                result = action.group;\n            }\n            else if (action.token !== null && action.token !== undefined) {\n                // do $n replacements?\n                if (action.tokenSubst) {\n                    result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\n                }\n                else {\n                    result = action.token;\n                }\n                // enter embedded mode?\n                if (action.nextEmbedded) {\n                    if (action.nextEmbedded === '@pop') {\n                        if (!embeddedModeData) {\n                            throw monarchCommon.createError(this._lexer, 'cannot pop embedded mode if not inside one');\n                        }\n                        embeddedModeData = null;\n                    }\n                    else if (embeddedModeData) {\n                        throw monarchCommon.createError(this._lexer, 'cannot enter embedded mode from within an embedded mode');\n                    }\n                    else {\n                        enteringEmbeddedMode = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\n                    }\n                }\n                // state transformations\n                if (action.goBack) { // back up the stream..\n                    pos = Math.max(0, pos - action.goBack);\n                }\n                if (action.switchTo && typeof action.switchTo === 'string') {\n                    let nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\n                    if (nextState[0] === '@') {\n                        nextState = nextState.substr(1); // peel off starting '@'\n                    }\n                    if (!monarchCommon.findRules(this._lexer, nextState)) {\n                        throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n                    }\n                    else {\n                        stack = stack.switchTo(nextState);\n                    }\n                }\n                else if (action.transform && typeof action.transform === 'function') {\n                    throw monarchCommon.createError(this._lexer, 'action.transform not supported');\n                }\n                else if (action.next) {\n                    if (action.next === '@push') {\n                        if (stack.depth >= this._lexer.maxStack) {\n                            throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' +\n                                stack.state + ',' + stack.parent.state + ',...]');\n                        }\n                        else {\n                            stack = stack.push(state);\n                        }\n                    }\n                    else if (action.next === '@pop') {\n                        if (stack.depth <= 1) {\n                            throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\n                        }\n                        else {\n                            stack = stack.pop();\n                        }\n                    }\n                    else if (action.next === '@popall') {\n                        stack = stack.popall();\n                    }\n                    else {\n                        let nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\n                        if (nextState[0] === '@') {\n                            nextState = nextState.substr(1); // peel off starting '@'\n                        }\n                        if (!monarchCommon.findRules(this._lexer, nextState)) {\n                            throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n                        }\n                        else {\n                            stack = stack.push(nextState);\n                        }\n                    }\n                }\n                if (action.log && typeof (action.log) === 'string') {\n                    monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\n                }\n            }\n            // check result\n            if (result === null) {\n                throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\n            }\n            const computeNewStateForEmbeddedMode = (enteringEmbeddedMode) => {\n                // substitute language alias to known modes to support syntax highlighting\n                let enteringEmbeddedModeId = this._modeService.getModeIdForLanguageName(enteringEmbeddedMode);\n                if (enteringEmbeddedModeId) {\n                    enteringEmbeddedMode = enteringEmbeddedModeId;\n                }\n                const embeddedModeData = this._getNestedEmbeddedModeData(enteringEmbeddedMode);\n                if (pos < lineLength) {\n                    // there is content from the embedded mode on this line\n                    const restOfLine = lineWithoutLF.substr(pos);\n                    return this._nestedTokenize(restOfLine, hasEOL, MonarchLineStateFactory.create(stack, embeddedModeData), offsetDelta + pos, tokensCollector);\n                }\n                else {\n                    return MonarchLineStateFactory.create(stack, embeddedModeData);\n                }\n            };\n            // is the result a group match?\n            if (Array.isArray(result)) {\n                if (groupMatching && groupMatching.groups.length > 0) {\n                    throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\n                }\n                if (matches.length !== result.length + 1) {\n                    throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\n                }\n                let totalLen = 0;\n                for (let i = 1; i < matches.length; i++) {\n                    totalLen += matches[i].length;\n                }\n                if (totalLen !== matched.length) {\n                    throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\n                }\n                groupMatching = {\n                    rule: rule,\n                    matches: matches,\n                    groups: []\n                };\n                for (let i = 0; i < result.length; i++) {\n                    groupMatching.groups[i] = {\n                        action: result[i],\n                        matched: matches[i + 1]\n                    };\n                }\n                pos -= matched.length;\n                // call recursively to initiate first result match\n                continue;\n            }\n            else {\n                // regular result\n                // check for '@rematch'\n                if (result === '@rematch') {\n                    pos -= matched.length;\n                    matched = ''; // better set the next state too..\n                    matches = null;\n                    result = '';\n                    // Even though `@rematch` was specified, if `nextEmbedded` also specified,\n                    // a state transition should occur.\n                    if (enteringEmbeddedMode !== null) {\n                        return computeNewStateForEmbeddedMode(enteringEmbeddedMode);\n                    }\n                }\n                // check progress\n                if (matched.length === 0) {\n                    if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\n                        continue;\n                    }\n                    else {\n                        throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\n                    }\n                }\n                // return the result (and check for brace matching)\n                // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\n                let tokenType = null;\n                if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\n                    let rest = result.substr('@brackets'.length);\n                    let bracket = findBracket(this._lexer, matched);\n                    if (!bracket) {\n                        throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\n                    }\n                    tokenType = monarchCommon.sanitize(bracket.token + rest);\n                }\n                else {\n                    let token = (result === '' ? '' : result + this._lexer.tokenPostfix);\n                    tokenType = monarchCommon.sanitize(token);\n                }\n                if (pos0 < lineWithoutLFLength) {\n                    tokensCollector.emit(pos0 + offsetDelta, tokenType);\n                }\n            }\n            if (enteringEmbeddedMode !== null) {\n                return computeNewStateForEmbeddedMode(enteringEmbeddedMode);\n            }\n        }\n        return MonarchLineStateFactory.create(stack, embeddedModeData);\n    }\n    _getNestedEmbeddedModeData(mimetypeOrModeId) {\n        let nestedModeId = this._locateMode(mimetypeOrModeId);\n        if (nestedModeId) {\n            let tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n            if (tokenizationSupport) {\n                return new EmbeddedModeData(nestedModeId, tokenizationSupport.getInitialState());\n            }\n        }\n        return new EmbeddedModeData(nestedModeId || NULL_MODE_ID, NULL_STATE);\n    }\n    _locateMode(mimetypeOrModeId) {\n        if (!mimetypeOrModeId || !this._modeService.isRegisteredMode(mimetypeOrModeId)) {\n            return null;\n        }\n        if (mimetypeOrModeId === this._languageId) {\n            // embedding myself...\n            return mimetypeOrModeId;\n        }\n        const languageId = this._modeService.getModeId(mimetypeOrModeId);\n        if (languageId) {\n            // Fire mode loading event\n            this._modeService.triggerMode(languageId);\n            this._embeddedModes[languageId] = true;\n        }\n        return languageId;\n    }\n}\n/**\n * Searches for a bracket in the 'brackets' attribute that matches the input.\n */\nfunction findBracket(lexer, matched) {\n    if (!matched) {\n        return null;\n    }\n    matched = monarchCommon.fixCase(lexer, matched);\n    let brackets = lexer.brackets;\n    for (const bracket of brackets) {\n        if (bracket.open === matched) {\n            return { token: bracket.token, bracketType: 1 /* Open */ };\n        }\n        else if (bracket.close === matched) {\n            return { token: bracket.token, bracketType: -1 /* Close */ };\n        }\n    }\n    return null;\n}\nexport function createTokenizationSupport(modeService, standaloneThemeService, languageId, lexer) {\n    return new MonarchTokenizer(modeService, standaloneThemeService, languageId, lexer);\n}\n"]},"metadata":{},"sourceType":"module"}