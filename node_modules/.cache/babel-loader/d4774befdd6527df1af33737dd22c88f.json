{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as extpath from './extpath.js';\nimport { Schemas } from './network.js';\nimport * as paths from './path.js';\nimport { compare as strCompare } from './strings.js';\nimport { URI, uriToFsPath } from './uri.js';\nexport function originalFSPath(uri) {\n  return uriToFsPath(uri, true);\n}\nexport class ExtUri {\n  constructor(_ignorePathCasing) {\n    this._ignorePathCasing = _ignorePathCasing;\n  }\n\n  compare(uri1, uri2) {\n    let ignoreFragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (uri1 === uri2) {\n      return 0;\n    }\n\n    return strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n  }\n\n  isEqual(uri1, uri2) {\n    let ignoreFragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (uri1 === uri2) {\n      return true;\n    }\n\n    if (!uri1 || !uri2) {\n      return false;\n    }\n\n    return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n  }\n\n  getComparisonKey(uri) {\n    let ignoreFragment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return uri.with({\n      path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n      fragment: ignoreFragment ? null : undefined\n    }).toString();\n  } // --- path math\n\n\n  joinPath(resource) {\n    for (var _len = arguments.length, pathFragment = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      pathFragment[_key - 1] = arguments[_key];\n    }\n\n    return URI.joinPath(resource, ...pathFragment);\n  }\n\n  basenameOrAuthority(resource) {\n    return basename(resource) || resource.authority;\n  }\n\n  basename(resource) {\n    return paths.posix.basename(resource.path);\n  }\n\n  dirname(resource) {\n    if (resource.path.length === 0) {\n      return resource;\n    }\n\n    let dirname;\n\n    if (resource.scheme === Schemas.file) {\n      dirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n    } else {\n      dirname = paths.posix.dirname(resource.path);\n\n      if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47\n      /* Slash */\n      ) {\n        console.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n        dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n      }\n    }\n\n    return resource.with({\n      path: dirname\n    });\n  }\n\n  normalizePath(resource) {\n    if (!resource.path.length) {\n      return resource;\n    }\n\n    let normalizedPath;\n\n    if (resource.scheme === Schemas.file) {\n      normalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n    } else {\n      normalizedPath = paths.posix.normalize(resource.path);\n    }\n\n    return resource.with({\n      path: normalizedPath\n    });\n  }\n\n  resolvePath(base, path) {\n    if (base.scheme === Schemas.file) {\n      const newURI = URI.file(paths.resolve(originalFSPath(base), path));\n      return base.with({\n        authority: newURI.authority,\n        path: newURI.path\n      });\n    }\n\n    path = extpath.toPosixPath(path); // we allow path to be a windows path\n\n    return base.with({\n      path: paths.posix.resolve(base.path, path)\n    });\n  }\n\n}\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\n\nexport const extUri = new ExtUri(() => false);\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\n/**\n * Data URI related helpers.\n */\n\nexport var DataUri;\n\n(function (DataUri) {\n  DataUri.META_DATA_LABEL = 'label';\n  DataUri.META_DATA_DESCRIPTION = 'description';\n  DataUri.META_DATA_SIZE = 'size';\n  DataUri.META_DATA_MIME = 'mime';\n\n  function parseMetaData(dataUri) {\n    const metadata = new Map(); // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n    // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\n    const meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n    meta.split(';').forEach(property => {\n      const [key, value] = property.split(':');\n\n      if (key && value) {\n        metadata.set(key, value);\n      }\n    }); // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n    // the mime is: image/png\n\n    const mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\n    if (mime) {\n      metadata.set(DataUri.META_DATA_MIME, mime);\n    }\n\n    return metadata;\n  }\n\n  DataUri.parseMetaData = parseMetaData;\n})(DataUri || (DataUri = {}));","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/base/common/resources.js"],"names":["extpath","Schemas","paths","compare","strCompare","URI","uriToFsPath","originalFSPath","uri","ExtUri","constructor","_ignorePathCasing","uri1","uri2","ignoreFragment","getComparisonKey","isEqual","with","path","toLowerCase","undefined","fragment","toString","joinPath","resource","pathFragment","basenameOrAuthority","basename","authority","posix","dirname","length","scheme","file","charCodeAt","console","error","normalizePath","normalizedPath","normalize","resolvePath","base","newURI","resolve","toPosixPath","extUri","bind","DataUri","META_DATA_LABEL","META_DATA_DESCRIPTION","META_DATA_SIZE","META_DATA_MIME","parseMetaData","dataUri","metadata","Map","meta","substring","indexOf","lastIndexOf","split","forEach","property","key","value","set","mime"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as extpath from './extpath.js';\nimport { Schemas } from './network.js';\nimport * as paths from './path.js';\nimport { compare as strCompare } from './strings.js';\nimport { URI, uriToFsPath } from './uri.js';\nexport function originalFSPath(uri) {\n    return uriToFsPath(uri, true);\n}\nexport class ExtUri {\n    constructor(_ignorePathCasing) {\n        this._ignorePathCasing = _ignorePathCasing;\n    }\n    compare(uri1, uri2, ignoreFragment = false) {\n        if (uri1 === uri2) {\n            return 0;\n        }\n        return strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n    }\n    isEqual(uri1, uri2, ignoreFragment = false) {\n        if (uri1 === uri2) {\n            return true;\n        }\n        if (!uri1 || !uri2) {\n            return false;\n        }\n        return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n    }\n    getComparisonKey(uri, ignoreFragment = false) {\n        return uri.with({\n            path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n            fragment: ignoreFragment ? null : undefined\n        }).toString();\n    }\n    // --- path math\n    joinPath(resource, ...pathFragment) {\n        return URI.joinPath(resource, ...pathFragment);\n    }\n    basenameOrAuthority(resource) {\n        return basename(resource) || resource.authority;\n    }\n    basename(resource) {\n        return paths.posix.basename(resource.path);\n    }\n    dirname(resource) {\n        if (resource.path.length === 0) {\n            return resource;\n        }\n        let dirname;\n        if (resource.scheme === Schemas.file) {\n            dirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n        }\n        else {\n            dirname = paths.posix.dirname(resource.path);\n            if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47 /* Slash */) {\n                console.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n                dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n            }\n        }\n        return resource.with({\n            path: dirname\n        });\n    }\n    normalizePath(resource) {\n        if (!resource.path.length) {\n            return resource;\n        }\n        let normalizedPath;\n        if (resource.scheme === Schemas.file) {\n            normalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n        }\n        else {\n            normalizedPath = paths.posix.normalize(resource.path);\n        }\n        return resource.with({\n            path: normalizedPath\n        });\n    }\n    resolvePath(base, path) {\n        if (base.scheme === Schemas.file) {\n            const newURI = URI.file(paths.resolve(originalFSPath(base), path));\n            return base.with({\n                authority: newURI.authority,\n                path: newURI.path\n            });\n        }\n        path = extpath.toPosixPath(path); // we allow path to be a windows path\n        return base.with({\n            path: paths.posix.resolve(base.path, path)\n        });\n    }\n}\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\n/**\n * Data URI related helpers.\n */\nexport var DataUri;\n(function (DataUri) {\n    DataUri.META_DATA_LABEL = 'label';\n    DataUri.META_DATA_DESCRIPTION = 'description';\n    DataUri.META_DATA_SIZE = 'size';\n    DataUri.META_DATA_MIME = 'mime';\n    function parseMetaData(dataUri) {\n        const metadata = new Map();\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n        // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n        const meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n        meta.split(';').forEach(property => {\n            const [key, value] = property.split(':');\n            if (key && value) {\n                metadata.set(key, value);\n            }\n        });\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n        // the mime is: image/png\n        const mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n        if (mime) {\n            metadata.set(DataUri.META_DATA_MIME, mime);\n        }\n        return metadata;\n    }\n    DataUri.parseMetaData = parseMetaData;\n})(DataUri || (DataUri = {}));\n"]},"metadata":{},"sourceType":"module"}