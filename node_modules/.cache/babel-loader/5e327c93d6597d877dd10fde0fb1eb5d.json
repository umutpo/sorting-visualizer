{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { CancellationTokenSource } from './cancellation.js';\nimport { canceled } from './errors.js';\nimport { toDisposable } from './lifecycle.js';\nexport function isThenable(obj) {\n  return !!obj && typeof obj.then === 'function';\n}\nexport function createCancelablePromise(callback) {\n  const source = new CancellationTokenSource();\n  const thenable = callback(source.token);\n  const promise = new Promise((resolve, reject) => {\n    const subscription = source.token.onCancellationRequested(() => {\n      subscription.dispose();\n      source.dispose();\n      reject(canceled());\n    });\n    Promise.resolve(thenable).then(value => {\n      subscription.dispose();\n      source.dispose();\n      resolve(value);\n    }, err => {\n      subscription.dispose();\n      source.dispose();\n      reject(err);\n    });\n  });\n  return new class {\n    cancel() {\n      source.cancel();\n    }\n\n    then(resolve, reject) {\n      return promise.then(resolve, reject);\n    }\n\n    catch(reject) {\n      return this.then(undefined, reject);\n    }\n\n    finally(onfinally) {\n      return promise.finally(onfinally);\n    }\n\n  }();\n}\nexport function raceCancellation(promise, token, defaultValue) {\n  return Promise.race([promise, new Promise(resolve => token.onCancellationRequested(() => resolve(defaultValue)))]);\n}\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\n\nexport class Throttler {\n  constructor() {\n    this.activePromise = null;\n    this.queuedPromise = null;\n    this.queuedPromiseFactory = null;\n  }\n\n  queue(promiseFactory) {\n    if (this.activePromise) {\n      this.queuedPromiseFactory = promiseFactory;\n\n      if (!this.queuedPromise) {\n        const onComplete = () => {\n          this.queuedPromise = null;\n          const result = this.queue(this.queuedPromiseFactory);\n          this.queuedPromiseFactory = null;\n          return result;\n        };\n\n        this.queuedPromise = new Promise(resolve => {\n          this.activePromise.then(onComplete, onComplete).then(resolve);\n        });\n      }\n\n      return new Promise((resolve, reject) => {\n        this.queuedPromise.then(resolve, reject);\n      });\n    }\n\n    this.activePromise = promiseFactory();\n    return new Promise((resolve, reject) => {\n      this.activePromise.then(result => {\n        this.activePromise = null;\n        resolve(result);\n      }, err => {\n        this.activePromise = null;\n        reject(err);\n      });\n    });\n  }\n\n}\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\n\nexport class Delayer {\n  constructor(defaultDelay) {\n    this.defaultDelay = defaultDelay;\n    this.timeout = null;\n    this.completionPromise = null;\n    this.doResolve = null;\n    this.doReject = null;\n    this.task = null;\n  }\n\n  trigger(task) {\n    let delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.defaultDelay;\n    this.task = task;\n    this.cancelTimeout();\n\n    if (!this.completionPromise) {\n      this.completionPromise = new Promise((resolve, reject) => {\n        this.doResolve = resolve;\n        this.doReject = reject;\n      }).then(() => {\n        this.completionPromise = null;\n        this.doResolve = null;\n\n        if (this.task) {\n          const task = this.task;\n          this.task = null;\n          return task();\n        }\n\n        return undefined;\n      });\n    }\n\n    this.timeout = setTimeout(() => {\n      this.timeout = null;\n\n      if (this.doResolve) {\n        this.doResolve(null);\n      }\n    }, delay);\n    return this.completionPromise;\n  }\n\n  isTriggered() {\n    return this.timeout !== null;\n  }\n\n  cancel() {\n    this.cancelTimeout();\n\n    if (this.completionPromise) {\n      if (this.doReject) {\n        this.doReject(canceled());\n      }\n\n      this.completionPromise = null;\n    }\n  }\n\n  cancelTimeout() {\n    if (this.timeout !== null) {\n      clearTimeout(this.timeout);\n      this.timeout = null;\n    }\n  }\n\n  dispose() {\n    this.cancel();\n  }\n\n}\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\n\nexport class ThrottledDelayer {\n  constructor(defaultDelay) {\n    this.delayer = new Delayer(defaultDelay);\n    this.throttler = new Throttler();\n  }\n\n  trigger(promiseFactory, delay) {\n    return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);\n  }\n\n  dispose() {\n    this.delayer.dispose();\n  }\n\n}\nexport function timeout(millis, token) {\n  if (!token) {\n    return createCancelablePromise(token => timeout(millis, token));\n  }\n\n  return new Promise((resolve, reject) => {\n    const handle = setTimeout(() => {\n      disposable.dispose();\n      resolve();\n    }, millis);\n    const disposable = token.onCancellationRequested(() => {\n      clearTimeout(handle);\n      disposable.dispose();\n      reject(canceled());\n    });\n  });\n}\nexport function disposableTimeout(handler) {\n  let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const timer = setTimeout(handler, timeout);\n  return toDisposable(() => clearTimeout(timer));\n}\nexport function first(promiseFactories) {\n  let shouldStop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : t => !!t;\n  let defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let index = 0;\n  const len = promiseFactories.length;\n\n  const loop = () => {\n    if (index >= len) {\n      return Promise.resolve(defaultValue);\n    }\n\n    const factory = promiseFactories[index++];\n    const promise = Promise.resolve(factory());\n    return promise.then(result => {\n      if (shouldStop(result)) {\n        return Promise.resolve(result);\n      }\n\n      return loop();\n    });\n  };\n\n  return loop();\n}\nexport class TimeoutTimer {\n  constructor(runner, timeout) {\n    this._token = -1;\n\n    if (typeof runner === 'function' && typeof timeout === 'number') {\n      this.setIfNotSet(runner, timeout);\n    }\n  }\n\n  dispose() {\n    this.cancel();\n  }\n\n  cancel() {\n    if (this._token !== -1) {\n      clearTimeout(this._token);\n      this._token = -1;\n    }\n  }\n\n  cancelAndSet(runner, timeout) {\n    this.cancel();\n    this._token = setTimeout(() => {\n      this._token = -1;\n      runner();\n    }, timeout);\n  }\n\n  setIfNotSet(runner, timeout) {\n    if (this._token !== -1) {\n      // timer is already set\n      return;\n    }\n\n    this._token = setTimeout(() => {\n      this._token = -1;\n      runner();\n    }, timeout);\n  }\n\n}\nexport class IntervalTimer {\n  constructor() {\n    this._token = -1;\n  }\n\n  dispose() {\n    this.cancel();\n  }\n\n  cancel() {\n    if (this._token !== -1) {\n      clearInterval(this._token);\n      this._token = -1;\n    }\n  }\n\n  cancelAndSet(runner, interval) {\n    this.cancel();\n    this._token = setInterval(() => {\n      runner();\n    }, interval);\n  }\n\n}\nexport class RunOnceScheduler {\n  constructor(runner, delay) {\n    this.timeoutToken = -1;\n    this.runner = runner;\n    this.timeout = delay;\n    this.timeoutHandler = this.onTimeout.bind(this);\n  }\n  /**\n   * Dispose RunOnceScheduler\n   */\n\n\n  dispose() {\n    this.cancel();\n    this.runner = null;\n  }\n  /**\n   * Cancel current scheduled runner (if any).\n   */\n\n\n  cancel() {\n    if (this.isScheduled()) {\n      clearTimeout(this.timeoutToken);\n      this.timeoutToken = -1;\n    }\n  }\n  /**\n   * Cancel previous runner (if any) & schedule a new runner.\n   */\n\n\n  schedule() {\n    let delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n    this.cancel();\n    this.timeoutToken = setTimeout(this.timeoutHandler, delay);\n  }\n\n  get delay() {\n    return this.timeout;\n  }\n\n  set delay(value) {\n    this.timeout = value;\n  }\n  /**\n   * Returns true if scheduled.\n   */\n\n\n  isScheduled() {\n    return this.timeoutToken !== -1;\n  }\n\n  onTimeout() {\n    this.timeoutToken = -1;\n\n    if (this.runner) {\n      this.doRun();\n    }\n  }\n\n  doRun() {\n    if (this.runner) {\n      this.runner();\n    }\n  }\n\n}\n/**\n * Execute the callback the next time the browser is idle\n */\n\nexport let runWhenIdle;\n\n(function () {\n  if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n    runWhenIdle = runner => {\n      const handle = setTimeout(() => {\n        const end = Date.now() + 15; // one frame at 64fps\n\n        runner(Object.freeze({\n          didTimeout: true,\n\n          timeRemaining() {\n            return Math.max(0, end - Date.now());\n          }\n\n        }));\n      });\n      let disposed = false;\n      return {\n        dispose() {\n          if (disposed) {\n            return;\n          }\n\n          disposed = true;\n          clearTimeout(handle);\n        }\n\n      };\n    };\n  } else {\n    runWhenIdle = (runner, timeout) => {\n      const handle = requestIdleCallback(runner, typeof timeout === 'number' ? {\n        timeout\n      } : undefined);\n      let disposed = false;\n      return {\n        dispose() {\n          if (disposed) {\n            return;\n          }\n\n          disposed = true;\n          cancelIdleCallback(handle);\n        }\n\n      };\n    };\n  }\n})();\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\n\n\nexport class IdleValue {\n  constructor(executor) {\n    this._didRun = false;\n\n    this._executor = () => {\n      try {\n        this._value = executor();\n      } catch (err) {\n        this._error = err;\n      } finally {\n        this._didRun = true;\n      }\n    };\n\n    this._handle = runWhenIdle(() => this._executor());\n  }\n\n  dispose() {\n    this._handle.dispose();\n  }\n\n  get value() {\n    if (!this._didRun) {\n      this._handle.dispose();\n\n      this._executor();\n    }\n\n    if (this._error) {\n      throw this._error;\n    }\n\n    return this._value;\n  }\n\n  get isInitialized() {\n    return this._didRun;\n  }\n\n} //#endregion\n//#region Promises\n\nexport var Promises;\n\n(function (Promises) {\n  /**\n   * A drop-in replacement for `Promise.all` with the only difference\n   * that the method awaits every promise to either fulfill or reject.\n   *\n   * Similar to `Promise.all`, only the first error will be returned\n   * if any.\n   */\n  function settled(promises) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let firstError = undefined;\n      const result = yield Promise.all(promises.map(promise => promise.then(value => value, error => {\n        if (!firstError) {\n          firstError = error;\n        }\n\n        return undefined; // do not rethrow so that other promises can settle\n      })));\n\n      if (typeof firstError !== 'undefined') {\n        throw firstError;\n      }\n\n      return result; // cast is needed and protected by the `throw` above\n    });\n  }\n\n  Promises.settled = settled;\n  /**\n   * A helper to create a new `Promise<T>` with a body that is a promise\n   * itself. By default, an error that raises from the async body will\n   * end up as a unhandled rejection, so this utility properly awaits the\n   * body and rejects the promise as a normal promise does without async\n   * body.\n   *\n   * This method should only be used in rare cases where otherwise `async`\n   * cannot be used (e.g. when callbacks are involved that require this).\n   */\n\n  function withAsyncBody(bodyFn) {\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield bodyFn(resolve, reject);\n      } catch (error) {\n        reject(error);\n      }\n    }));\n  }\n\n  Promises.withAsyncBody = withAsyncBody;\n})(Promises || (Promises = {})); //#endregion","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/base/common/async.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","CancellationTokenSource","canceled","toDisposable","isThenable","obj","createCancelablePromise","callback","source","thenable","token","promise","subscription","onCancellationRequested","dispose","err","cancel","catch","undefined","finally","onfinally","raceCancellation","defaultValue","race","Throttler","constructor","activePromise","queuedPromise","queuedPromiseFactory","queue","promiseFactory","onComplete","Delayer","defaultDelay","timeout","completionPromise","doResolve","doReject","task","trigger","delay","cancelTimeout","setTimeout","isTriggered","clearTimeout","ThrottledDelayer","delayer","throttler","millis","handle","disposable","disposableTimeout","handler","timer","first","promiseFactories","shouldStop","t","index","len","length","loop","factory","TimeoutTimer","runner","_token","setIfNotSet","cancelAndSet","IntervalTimer","clearInterval","interval","setInterval","RunOnceScheduler","timeoutToken","timeoutHandler","onTimeout","bind","isScheduled","schedule","doRun","runWhenIdle","requestIdleCallback","cancelIdleCallback","end","Date","now","Object","freeze","didTimeout","timeRemaining","Math","max","disposed","IdleValue","executor","_didRun","_executor","_value","_error","_handle","isInitialized","Promises","settled","promises","firstError","all","map","error","withAsyncBody","bodyFn"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CancellationTokenSource } from './cancellation.js';\nimport { canceled } from './errors.js';\nimport { toDisposable } from './lifecycle.js';\nexport function isThenable(obj) {\n    return !!obj && typeof obj.then === 'function';\n}\nexport function createCancelablePromise(callback) {\n    const source = new CancellationTokenSource();\n    const thenable = callback(source.token);\n    const promise = new Promise((resolve, reject) => {\n        const subscription = source.token.onCancellationRequested(() => {\n            subscription.dispose();\n            source.dispose();\n            reject(canceled());\n        });\n        Promise.resolve(thenable).then(value => {\n            subscription.dispose();\n            source.dispose();\n            resolve(value);\n        }, err => {\n            subscription.dispose();\n            source.dispose();\n            reject(err);\n        });\n    });\n    return new class {\n        cancel() {\n            source.cancel();\n        }\n        then(resolve, reject) {\n            return promise.then(resolve, reject);\n        }\n        catch(reject) {\n            return this.then(undefined, reject);\n        }\n        finally(onfinally) {\n            return promise.finally(onfinally);\n        }\n    };\n}\nexport function raceCancellation(promise, token, defaultValue) {\n    return Promise.race([promise, new Promise(resolve => token.onCancellationRequested(() => resolve(defaultValue)))]);\n}\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n    constructor() {\n        this.activePromise = null;\n        this.queuedPromise = null;\n        this.queuedPromiseFactory = null;\n    }\n    queue(promiseFactory) {\n        if (this.activePromise) {\n            this.queuedPromiseFactory = promiseFactory;\n            if (!this.queuedPromise) {\n                const onComplete = () => {\n                    this.queuedPromise = null;\n                    const result = this.queue(this.queuedPromiseFactory);\n                    this.queuedPromiseFactory = null;\n                    return result;\n                };\n                this.queuedPromise = new Promise(resolve => {\n                    this.activePromise.then(onComplete, onComplete).then(resolve);\n                });\n            }\n            return new Promise((resolve, reject) => {\n                this.queuedPromise.then(resolve, reject);\n            });\n        }\n        this.activePromise = promiseFactory();\n        return new Promise((resolve, reject) => {\n            this.activePromise.then((result) => {\n                this.activePromise = null;\n                resolve(result);\n            }, (err) => {\n                this.activePromise = null;\n                reject(err);\n            });\n        });\n    }\n}\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer {\n    constructor(defaultDelay) {\n        this.defaultDelay = defaultDelay;\n        this.timeout = null;\n        this.completionPromise = null;\n        this.doResolve = null;\n        this.doReject = null;\n        this.task = null;\n    }\n    trigger(task, delay = this.defaultDelay) {\n        this.task = task;\n        this.cancelTimeout();\n        if (!this.completionPromise) {\n            this.completionPromise = new Promise((resolve, reject) => {\n                this.doResolve = resolve;\n                this.doReject = reject;\n            }).then(() => {\n                this.completionPromise = null;\n                this.doResolve = null;\n                if (this.task) {\n                    const task = this.task;\n                    this.task = null;\n                    return task();\n                }\n                return undefined;\n            });\n        }\n        this.timeout = setTimeout(() => {\n            this.timeout = null;\n            if (this.doResolve) {\n                this.doResolve(null);\n            }\n        }, delay);\n        return this.completionPromise;\n    }\n    isTriggered() {\n        return this.timeout !== null;\n    }\n    cancel() {\n        this.cancelTimeout();\n        if (this.completionPromise) {\n            if (this.doReject) {\n                this.doReject(canceled());\n            }\n            this.completionPromise = null;\n        }\n    }\n    cancelTimeout() {\n        if (this.timeout !== null) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n    }\n    dispose() {\n        this.cancel();\n    }\n}\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer {\n    constructor(defaultDelay) {\n        this.delayer = new Delayer(defaultDelay);\n        this.throttler = new Throttler();\n    }\n    trigger(promiseFactory, delay) {\n        return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);\n    }\n    dispose() {\n        this.delayer.dispose();\n    }\n}\nexport function timeout(millis, token) {\n    if (!token) {\n        return createCancelablePromise(token => timeout(millis, token));\n    }\n    return new Promise((resolve, reject) => {\n        const handle = setTimeout(() => {\n            disposable.dispose();\n            resolve();\n        }, millis);\n        const disposable = token.onCancellationRequested(() => {\n            clearTimeout(handle);\n            disposable.dispose();\n            reject(canceled());\n        });\n    });\n}\nexport function disposableTimeout(handler, timeout = 0) {\n    const timer = setTimeout(handler, timeout);\n    return toDisposable(() => clearTimeout(timer));\n}\nexport function first(promiseFactories, shouldStop = t => !!t, defaultValue = null) {\n    let index = 0;\n    const len = promiseFactories.length;\n    const loop = () => {\n        if (index >= len) {\n            return Promise.resolve(defaultValue);\n        }\n        const factory = promiseFactories[index++];\n        const promise = Promise.resolve(factory());\n        return promise.then(result => {\n            if (shouldStop(result)) {\n                return Promise.resolve(result);\n            }\n            return loop();\n        });\n    };\n    return loop();\n}\nexport class TimeoutTimer {\n    constructor(runner, timeout) {\n        this._token = -1;\n        if (typeof runner === 'function' && typeof timeout === 'number') {\n            this.setIfNotSet(runner, timeout);\n        }\n    }\n    dispose() {\n        this.cancel();\n    }\n    cancel() {\n        if (this._token !== -1) {\n            clearTimeout(this._token);\n            this._token = -1;\n        }\n    }\n    cancelAndSet(runner, timeout) {\n        this.cancel();\n        this._token = setTimeout(() => {\n            this._token = -1;\n            runner();\n        }, timeout);\n    }\n    setIfNotSet(runner, timeout) {\n        if (this._token !== -1) {\n            // timer is already set\n            return;\n        }\n        this._token = setTimeout(() => {\n            this._token = -1;\n            runner();\n        }, timeout);\n    }\n}\nexport class IntervalTimer {\n    constructor() {\n        this._token = -1;\n    }\n    dispose() {\n        this.cancel();\n    }\n    cancel() {\n        if (this._token !== -1) {\n            clearInterval(this._token);\n            this._token = -1;\n        }\n    }\n    cancelAndSet(runner, interval) {\n        this.cancel();\n        this._token = setInterval(() => {\n            runner();\n        }, interval);\n    }\n}\nexport class RunOnceScheduler {\n    constructor(runner, delay) {\n        this.timeoutToken = -1;\n        this.runner = runner;\n        this.timeout = delay;\n        this.timeoutHandler = this.onTimeout.bind(this);\n    }\n    /**\n     * Dispose RunOnceScheduler\n     */\n    dispose() {\n        this.cancel();\n        this.runner = null;\n    }\n    /**\n     * Cancel current scheduled runner (if any).\n     */\n    cancel() {\n        if (this.isScheduled()) {\n            clearTimeout(this.timeoutToken);\n            this.timeoutToken = -1;\n        }\n    }\n    /**\n     * Cancel previous runner (if any) & schedule a new runner.\n     */\n    schedule(delay = this.timeout) {\n        this.cancel();\n        this.timeoutToken = setTimeout(this.timeoutHandler, delay);\n    }\n    get delay() {\n        return this.timeout;\n    }\n    set delay(value) {\n        this.timeout = value;\n    }\n    /**\n     * Returns true if scheduled.\n     */\n    isScheduled() {\n        return this.timeoutToken !== -1;\n    }\n    onTimeout() {\n        this.timeoutToken = -1;\n        if (this.runner) {\n            this.doRun();\n        }\n    }\n    doRun() {\n        if (this.runner) {\n            this.runner();\n        }\n    }\n}\n/**\n * Execute the callback the next time the browser is idle\n */\nexport let runWhenIdle;\n(function () {\n    if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n        runWhenIdle = (runner) => {\n            const handle = setTimeout(() => {\n                const end = Date.now() + 15; // one frame at 64fps\n                runner(Object.freeze({\n                    didTimeout: true,\n                    timeRemaining() {\n                        return Math.max(0, end - Date.now());\n                    }\n                }));\n            });\n            let disposed = false;\n            return {\n                dispose() {\n                    if (disposed) {\n                        return;\n                    }\n                    disposed = true;\n                    clearTimeout(handle);\n                }\n            };\n        };\n    }\n    else {\n        runWhenIdle = (runner, timeout) => {\n            const handle = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n            let disposed = false;\n            return {\n                dispose() {\n                    if (disposed) {\n                        return;\n                    }\n                    disposed = true;\n                    cancelIdleCallback(handle);\n                }\n            };\n        };\n    }\n})();\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue {\n    constructor(executor) {\n        this._didRun = false;\n        this._executor = () => {\n            try {\n                this._value = executor();\n            }\n            catch (err) {\n                this._error = err;\n            }\n            finally {\n                this._didRun = true;\n            }\n        };\n        this._handle = runWhenIdle(() => this._executor());\n    }\n    dispose() {\n        this._handle.dispose();\n    }\n    get value() {\n        if (!this._didRun) {\n            this._handle.dispose();\n            this._executor();\n        }\n        if (this._error) {\n            throw this._error;\n        }\n        return this._value;\n    }\n    get isInitialized() {\n        return this._didRun;\n    }\n}\n//#endregion\n//#region Promises\nexport var Promises;\n(function (Promises) {\n    /**\n     * A drop-in replacement for `Promise.all` with the only difference\n     * that the method awaits every promise to either fulfill or reject.\n     *\n     * Similar to `Promise.all`, only the first error will be returned\n     * if any.\n     */\n    function settled(promises) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let firstError = undefined;\n            const result = yield Promise.all(promises.map(promise => promise.then(value => value, error => {\n                if (!firstError) {\n                    firstError = error;\n                }\n                return undefined; // do not rethrow so that other promises can settle\n            })));\n            if (typeof firstError !== 'undefined') {\n                throw firstError;\n            }\n            return result; // cast is needed and protected by the `throw` above\n        });\n    }\n    Promises.settled = settled;\n    /**\n     * A helper to create a new `Promise<T>` with a body that is a promise\n     * itself. By default, an error that raises from the async body will\n     * end up as a unhandled rejection, so this utility properly awaits the\n     * body and rejects the promise as a normal promise does without async\n     * body.\n     *\n     * This method should only be used in rare cases where otherwise `async`\n     * cannot be used (e.g. when callbacks are involved that require this).\n     */\n    function withAsyncBody(bodyFn) {\n        // eslint-disable-next-line no-async-promise-executor\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield bodyFn(resolve, reject);\n            }\n            catch (error) {\n                reject(error);\n            }\n        }));\n    }\n    Promises.withAsyncBody = withAsyncBody;\n})(Promises || (Promises = {}));\n//#endregion\n"]},"metadata":{},"sourceType":"module"}