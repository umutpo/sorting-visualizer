{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { normalize, posix, sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { startsWithIgnoreCase } from './strings.js';\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\n\nexport function toSlashes(osPath) {\n  return osPath.replace(/[\\\\/]/g, posix.sep);\n}\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\n\nexport function toPosixPath(osPath) {\n  if (osPath.indexOf('/') === -1) {\n    osPath = toSlashes(osPath);\n  }\n\n  if (/^[a-zA-Z]:(\\/|$)/.test(osPath)) {\n    // starts with a drive letter\n    osPath = '/' + osPath;\n  }\n\n  return osPath;\n}\nexport function isEqualOrParent(base, parentCandidate, ignoreCase) {\n  let separator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sep;\n\n  if (base === parentCandidate) {\n    return true;\n  }\n\n  if (!base || !parentCandidate) {\n    return false;\n  }\n\n  if (parentCandidate.length > base.length) {\n    return false;\n  }\n\n  if (ignoreCase) {\n    const beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\n    if (!beginsWith) {\n      return false;\n    }\n\n    if (parentCandidate.length === base.length) {\n      return true; // same path, different casing\n    }\n\n    let sepOffset = parentCandidate.length;\n\n    if (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n      sepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n    }\n\n    return base.charAt(sepOffset) === separator;\n  }\n\n  if (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n    parentCandidate += separator;\n  }\n\n  return base.indexOf(parentCandidate) === 0;\n}\nexport function isWindowsDriveLetter(char0) {\n  return char0 >= 65\n  /* A */\n  && char0 <= 90\n  /* Z */\n  || char0 >= 97\n  /* a */\n  && char0 <= 122\n  /* z */\n  ;\n}\nexport function isRootOrDriveLetter(path) {\n  const pathNormalized = normalize(path);\n\n  if (isWindows) {\n    if (path.length > 3) {\n      return false;\n    }\n\n    return hasDriveLetter(pathNormalized) && (path.length === 2 || pathNormalized.charCodeAt(2) === 92\n    /* Backslash */\n    );\n  }\n\n  return pathNormalized === posix.sep;\n}\nexport function hasDriveLetter(path) {\n  if (isWindows) {\n    return isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === 58\n    /* Colon */\n    ;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/base/common/extpath.js"],"names":["normalize","posix","sep","isWindows","startsWithIgnoreCase","toSlashes","osPath","replace","toPosixPath","indexOf","test","isEqualOrParent","base","parentCandidate","ignoreCase","separator","length","beginsWith","sepOffset","charAt","isWindowsDriveLetter","char0","isRootOrDriveLetter","path","pathNormalized","hasDriveLetter","charCodeAt"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { normalize, posix, sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { startsWithIgnoreCase } from './strings.js';\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath) {\n    return osPath.replace(/[\\\\/]/g, posix.sep);\n}\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath) {\n    if (osPath.indexOf('/') === -1) {\n        osPath = toSlashes(osPath);\n    }\n    if (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n        osPath = '/' + osPath;\n    }\n    return osPath;\n}\nexport function isEqualOrParent(base, parentCandidate, ignoreCase, separator = sep) {\n    if (base === parentCandidate) {\n        return true;\n    }\n    if (!base || !parentCandidate) {\n        return false;\n    }\n    if (parentCandidate.length > base.length) {\n        return false;\n    }\n    if (ignoreCase) {\n        const beginsWith = startsWithIgnoreCase(base, parentCandidate);\n        if (!beginsWith) {\n            return false;\n        }\n        if (parentCandidate.length === base.length) {\n            return true; // same path, different casing\n        }\n        let sepOffset = parentCandidate.length;\n        if (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n            sepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n        }\n        return base.charAt(sepOffset) === separator;\n    }\n    if (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n        parentCandidate += separator;\n    }\n    return base.indexOf(parentCandidate) === 0;\n}\nexport function isWindowsDriveLetter(char0) {\n    return char0 >= 65 /* A */ && char0 <= 90 /* Z */ || char0 >= 97 /* a */ && char0 <= 122 /* z */;\n}\nexport function isRootOrDriveLetter(path) {\n    const pathNormalized = normalize(path);\n    if (isWindows) {\n        if (path.length > 3) {\n            return false;\n        }\n        return hasDriveLetter(pathNormalized) &&\n            (path.length === 2 || pathNormalized.charCodeAt(2) === 92 /* Backslash */);\n    }\n    return pathNormalized === posix.sep;\n}\nexport function hasDriveLetter(path) {\n    if (isWindows) {\n        return isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === 58 /* Colon */;\n    }\n    return false;\n}\n"]},"metadata":{},"sourceType":"module"}