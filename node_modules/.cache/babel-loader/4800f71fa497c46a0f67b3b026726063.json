{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ObjectTreeModel } from './objectTreeModel.js';\nimport { TreeError, WeakMapper } from './tree.js';\nimport { Event } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\n\nfunction noCompress(element) {\n  const elements = [element.element];\n  const incompressible = element.incompressible || false;\n  return {\n    element: {\n      elements,\n      incompressible\n    },\n    children: Iterable.map(Iterable.from(element.children), noCompress),\n    collapsible: element.collapsible,\n    collapsed: element.collapsed\n  };\n} // Exported only for test reasons, do not use directly\n\n\nexport function compress(element) {\n  const elements = [element.element];\n  const incompressible = element.incompressible || false;\n  let childrenIterator;\n  let children;\n\n  while (true) {\n    [children, childrenIterator] = Iterable.consume(Iterable.from(element.children), 2);\n\n    if (children.length !== 1) {\n      break;\n    }\n\n    if (children[0].incompressible) {\n      break;\n    }\n\n    element = children[0];\n    elements.push(element.element);\n  }\n\n  return {\n    element: {\n      elements,\n      incompressible\n    },\n    children: Iterable.map(Iterable.concat(children, childrenIterator), compress),\n    collapsible: element.collapsible,\n    collapsed: element.collapsed\n  };\n}\n\nfunction _decompress(element) {\n  let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let children;\n\n  if (index < element.element.elements.length - 1) {\n    children = [_decompress(element, index + 1)];\n  } else {\n    children = Iterable.map(Iterable.from(element.children), el => _decompress(el, 0));\n  }\n\n  if (index === 0 && element.element.incompressible) {\n    return {\n      element: element.element.elements[index],\n      children,\n      incompressible: true,\n      collapsible: element.collapsible,\n      collapsed: element.collapsed\n    };\n  }\n\n  return {\n    element: element.element.elements[index],\n    children,\n    collapsible: element.collapsible,\n    collapsed: element.collapsed\n  };\n} // Exported only for test reasons, do not use directly\n\n\nexport function decompress(element) {\n  return _decompress(element, 0);\n}\n\nfunction splice(treeElement, element, children) {\n  if (treeElement.element === element) {\n    return Object.assign(Object.assign({}, treeElement), {\n      children\n    });\n  }\n\n  return Object.assign(Object.assign({}, treeElement), {\n    children: Iterable.map(Iterable.from(treeElement.children), e => splice(e, element, children))\n  });\n}\n\nconst wrapIdentityProvider = base => ({\n  getId(node) {\n    return node.elements.map(e => base.getId(e).toString()).join('\\0');\n  }\n\n}); // Exported only for test reasons, do not use directly\n\n\nexport class CompressedObjectTreeModel {\n  constructor(user, list) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.user = user;\n    this.rootRef = null;\n    this.nodes = new Map();\n    this.model = new ObjectTreeModel(user, list, options);\n    this.enabled = typeof options.compressionEnabled === 'undefined' ? true : options.compressionEnabled;\n    this.identityProvider = options.identityProvider;\n  }\n\n  get onDidSplice() {\n    return this.model.onDidSplice;\n  }\n\n  get onDidChangeCollapseState() {\n    return this.model.onDidChangeCollapseState;\n  }\n\n  get onDidChangeRenderNodeCount() {\n    return this.model.onDidChangeRenderNodeCount;\n  }\n\n  setChildren(element) {\n    let children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Iterable.empty();\n    let options = arguments.length > 2 ? arguments[2] : undefined;\n    // Diffs must be deem, since the compression can affect nested elements.\n    // @see https://github.com/microsoft/vscode/pull/114237#issuecomment-759425034\n    const diffIdentityProvider = options.diffIdentityProvider && wrapIdentityProvider(options.diffIdentityProvider);\n\n    if (element === null) {\n      const compressedChildren = Iterable.map(children, this.enabled ? compress : noCompress);\n\n      this._setChildren(null, compressedChildren, {\n        diffIdentityProvider,\n        diffDepth: Infinity\n      });\n\n      return;\n    }\n\n    const compressedNode = this.nodes.get(element);\n\n    if (!compressedNode) {\n      throw new Error('Unknown compressed tree node');\n    }\n\n    const node = this.model.getNode(compressedNode);\n    const compressedParentNode = this.model.getParentNodeLocation(compressedNode);\n    const parent = this.model.getNode(compressedParentNode);\n    const decompressedElement = decompress(node);\n    const splicedElement = splice(decompressedElement, element, children);\n    const recompressedElement = (this.enabled ? compress : noCompress)(splicedElement);\n    const parentChildren = parent.children.map(child => child === node ? recompressedElement : child);\n\n    this._setChildren(parent.element, parentChildren, {\n      diffIdentityProvider,\n      diffDepth: node.depth - parent.depth\n    });\n  }\n\n  setCompressionEnabled(enabled) {\n    if (enabled === this.enabled) {\n      return;\n    }\n\n    this.enabled = enabled;\n    const root = this.model.getNode();\n    const rootChildren = root.children;\n    const decompressedRootChildren = Iterable.map(rootChildren, decompress);\n    const recompressedRootChildren = Iterable.map(decompressedRootChildren, enabled ? compress : noCompress); // it should be safe to always use deep diff mode here if an identity\n    // provider is available, since we know the raw nodes are unchanged.\n\n    this._setChildren(null, recompressedRootChildren, {\n      diffIdentityProvider: this.identityProvider,\n      diffDepth: Infinity\n    });\n  }\n\n  _setChildren(node, children, options) {\n    const insertedElements = new Set();\n\n    const onDidCreateNode = node => {\n      for (const element of node.element.elements) {\n        insertedElements.add(element);\n        this.nodes.set(element, node.element);\n      }\n    };\n\n    const onDidDeleteNode = node => {\n      for (const element of node.element.elements) {\n        if (!insertedElements.has(element)) {\n          this.nodes.delete(element);\n        }\n      }\n    };\n\n    this.model.setChildren(node, children, Object.assign(Object.assign({}, options), {\n      onDidCreateNode,\n      onDidDeleteNode\n    }));\n  }\n\n  has(element) {\n    return this.nodes.has(element);\n  }\n\n  getListIndex(location) {\n    const node = this.getCompressedNode(location);\n    return this.model.getListIndex(node);\n  }\n\n  getListRenderCount(location) {\n    const node = this.getCompressedNode(location);\n    return this.model.getListRenderCount(node);\n  }\n\n  getNode(location) {\n    if (typeof location === 'undefined') {\n      return this.model.getNode();\n    }\n\n    const node = this.getCompressedNode(location);\n    return this.model.getNode(node);\n  } // TODO: review this\n\n\n  getNodeLocation(node) {\n    const compressedNode = this.model.getNodeLocation(node);\n\n    if (compressedNode === null) {\n      return null;\n    }\n\n    return compressedNode.elements[compressedNode.elements.length - 1];\n  } // TODO: review this\n\n\n  getParentNodeLocation(location) {\n    const compressedNode = this.getCompressedNode(location);\n    const parentNode = this.model.getParentNodeLocation(compressedNode);\n\n    if (parentNode === null) {\n      return null;\n    }\n\n    return parentNode.elements[parentNode.elements.length - 1];\n  }\n\n  isCollapsible(location) {\n    const compressedNode = this.getCompressedNode(location);\n    return this.model.isCollapsible(compressedNode);\n  }\n\n  setCollapsible(location, collapsible) {\n    const compressedNode = this.getCompressedNode(location);\n    return this.model.setCollapsible(compressedNode, collapsible);\n  }\n\n  isCollapsed(location) {\n    const compressedNode = this.getCompressedNode(location);\n    return this.model.isCollapsed(compressedNode);\n  }\n\n  setCollapsed(location, collapsed, recursive) {\n    const compressedNode = this.getCompressedNode(location);\n    return this.model.setCollapsed(compressedNode, collapsed, recursive);\n  }\n\n  expandTo(location) {\n    const compressedNode = this.getCompressedNode(location);\n    this.model.expandTo(compressedNode);\n  }\n\n  rerender(location) {\n    const compressedNode = this.getCompressedNode(location);\n    this.model.rerender(compressedNode);\n  }\n\n  refilter() {\n    this.model.refilter();\n  }\n\n  getCompressedNode(element) {\n    if (element === null) {\n      return null;\n    }\n\n    const node = this.nodes.get(element);\n\n    if (!node) {\n      throw new TreeError(this.user, `Tree element not found: ${element}`);\n    }\n\n    return node;\n  }\n\n}\nexport const DefaultElementMapper = elements => elements[elements.length - 1];\n\nclass CompressedTreeNodeWrapper {\n  constructor(unwrapper, node) {\n    this.unwrapper = unwrapper;\n    this.node = node;\n  }\n\n  get element() {\n    return this.node.element === null ? null : this.unwrapper(this.node.element);\n  }\n\n  get children() {\n    return this.node.children.map(node => new CompressedTreeNodeWrapper(this.unwrapper, node));\n  }\n\n  get depth() {\n    return this.node.depth;\n  }\n\n  get visibleChildrenCount() {\n    return this.node.visibleChildrenCount;\n  }\n\n  get visibleChildIndex() {\n    return this.node.visibleChildIndex;\n  }\n\n  get collapsible() {\n    return this.node.collapsible;\n  }\n\n  get collapsed() {\n    return this.node.collapsed;\n  }\n\n  get visible() {\n    return this.node.visible;\n  }\n\n  get filterData() {\n    return this.node.filterData;\n  }\n\n}\n\nfunction mapList(nodeMapper, list) {\n  return {\n    splice(start, deleteCount, toInsert) {\n      list.splice(start, deleteCount, toInsert.map(node => nodeMapper.map(node)));\n    },\n\n    updateElementHeight(index, height) {\n      list.updateElementHeight(index, height);\n    }\n\n  };\n}\n\nfunction mapOptions(compressedNodeUnwrapper, options) {\n  return Object.assign(Object.assign({}, options), {\n    identityProvider: options.identityProvider && {\n      getId(node) {\n        return options.identityProvider.getId(compressedNodeUnwrapper(node));\n      }\n\n    },\n    sorter: options.sorter && {\n      compare(node, otherNode) {\n        return options.sorter.compare(node.elements[0], otherNode.elements[0]);\n      }\n\n    },\n    filter: options.filter && {\n      filter(node, parentVisibility) {\n        return options.filter.filter(compressedNodeUnwrapper(node), parentVisibility);\n      }\n\n    }\n  });\n}\n\nexport class CompressibleObjectTreeModel {\n  constructor(user, list) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.rootRef = null;\n    this.elementMapper = options.elementMapper || DefaultElementMapper;\n\n    const compressedNodeUnwrapper = node => this.elementMapper(node.elements);\n\n    this.nodeMapper = new WeakMapper(node => new CompressedTreeNodeWrapper(compressedNodeUnwrapper, node));\n    this.model = new CompressedObjectTreeModel(user, mapList(this.nodeMapper, list), mapOptions(compressedNodeUnwrapper, options));\n  }\n\n  get onDidSplice() {\n    return Event.map(this.model.onDidSplice, _ref => {\n      let {\n        insertedNodes,\n        deletedNodes\n      } = _ref;\n      return {\n        insertedNodes: insertedNodes.map(node => this.nodeMapper.map(node)),\n        deletedNodes: deletedNodes.map(node => this.nodeMapper.map(node))\n      };\n    });\n  }\n\n  get onDidChangeCollapseState() {\n    return Event.map(this.model.onDidChangeCollapseState, _ref2 => {\n      let {\n        node,\n        deep\n      } = _ref2;\n      return {\n        node: this.nodeMapper.map(node),\n        deep\n      };\n    });\n  }\n\n  get onDidChangeRenderNodeCount() {\n    return Event.map(this.model.onDidChangeRenderNodeCount, node => this.nodeMapper.map(node));\n  }\n\n  setChildren(element) {\n    let children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Iterable.empty();\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.model.setChildren(element, children, options);\n  }\n\n  setCompressionEnabled(enabled) {\n    this.model.setCompressionEnabled(enabled);\n  }\n\n  has(location) {\n    return this.model.has(location);\n  }\n\n  getListIndex(location) {\n    return this.model.getListIndex(location);\n  }\n\n  getListRenderCount(location) {\n    return this.model.getListRenderCount(location);\n  }\n\n  getNode(location) {\n    return this.nodeMapper.map(this.model.getNode(location));\n  }\n\n  getNodeLocation(node) {\n    return node.element;\n  }\n\n  getParentNodeLocation(location) {\n    return this.model.getParentNodeLocation(location);\n  }\n\n  isCollapsible(location) {\n    return this.model.isCollapsible(location);\n  }\n\n  setCollapsible(location, collapsed) {\n    return this.model.setCollapsible(location, collapsed);\n  }\n\n  isCollapsed(location) {\n    return this.model.isCollapsed(location);\n  }\n\n  setCollapsed(location, collapsed, recursive) {\n    return this.model.setCollapsed(location, collapsed, recursive);\n  }\n\n  expandTo(location) {\n    return this.model.expandTo(location);\n  }\n\n  rerender(location) {\n    return this.model.rerender(location);\n  }\n\n  refilter() {\n    return this.model.refilter();\n  }\n\n  getCompressedTreeNode() {\n    let location = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    return this.model.getNode(location);\n  }\n\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/base/browser/ui/tree/compressedObjectTreeModel.js"],"names":["ObjectTreeModel","TreeError","WeakMapper","Event","Iterable","noCompress","element","elements","incompressible","children","map","from","collapsible","collapsed","compress","childrenIterator","consume","length","push","concat","_decompress","index","el","decompress","splice","treeElement","Object","assign","e","wrapIdentityProvider","base","getId","node","toString","join","CompressedObjectTreeModel","constructor","user","list","options","rootRef","nodes","Map","model","enabled","compressionEnabled","identityProvider","onDidSplice","onDidChangeCollapseState","onDidChangeRenderNodeCount","setChildren","empty","diffIdentityProvider","compressedChildren","_setChildren","diffDepth","Infinity","compressedNode","get","Error","getNode","compressedParentNode","getParentNodeLocation","parent","decompressedElement","splicedElement","recompressedElement","parentChildren","child","depth","setCompressionEnabled","root","rootChildren","decompressedRootChildren","recompressedRootChildren","insertedElements","Set","onDidCreateNode","add","set","onDidDeleteNode","has","delete","getListIndex","location","getCompressedNode","getListRenderCount","getNodeLocation","parentNode","isCollapsible","setCollapsible","isCollapsed","setCollapsed","recursive","expandTo","rerender","refilter","DefaultElementMapper","CompressedTreeNodeWrapper","unwrapper","visibleChildrenCount","visibleChildIndex","visible","filterData","mapList","nodeMapper","start","deleteCount","toInsert","updateElementHeight","height","mapOptions","compressedNodeUnwrapper","sorter","compare","otherNode","filter","parentVisibility","CompressibleObjectTreeModel","elementMapper","insertedNodes","deletedNodes","deep","getCompressedTreeNode"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ObjectTreeModel } from './objectTreeModel.js';\nimport { TreeError, WeakMapper } from './tree.js';\nimport { Event } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nfunction noCompress(element) {\n    const elements = [element.element];\n    const incompressible = element.incompressible || false;\n    return {\n        element: { elements, incompressible },\n        children: Iterable.map(Iterable.from(element.children), noCompress),\n        collapsible: element.collapsible,\n        collapsed: element.collapsed\n    };\n}\n// Exported only for test reasons, do not use directly\nexport function compress(element) {\n    const elements = [element.element];\n    const incompressible = element.incompressible || false;\n    let childrenIterator;\n    let children;\n    while (true) {\n        [children, childrenIterator] = Iterable.consume(Iterable.from(element.children), 2);\n        if (children.length !== 1) {\n            break;\n        }\n        if (children[0].incompressible) {\n            break;\n        }\n        element = children[0];\n        elements.push(element.element);\n    }\n    return {\n        element: { elements, incompressible },\n        children: Iterable.map(Iterable.concat(children, childrenIterator), compress),\n        collapsible: element.collapsible,\n        collapsed: element.collapsed\n    };\n}\nfunction _decompress(element, index = 0) {\n    let children;\n    if (index < element.element.elements.length - 1) {\n        children = [_decompress(element, index + 1)];\n    }\n    else {\n        children = Iterable.map(Iterable.from(element.children), el => _decompress(el, 0));\n    }\n    if (index === 0 && element.element.incompressible) {\n        return {\n            element: element.element.elements[index],\n            children,\n            incompressible: true,\n            collapsible: element.collapsible,\n            collapsed: element.collapsed\n        };\n    }\n    return {\n        element: element.element.elements[index],\n        children,\n        collapsible: element.collapsible,\n        collapsed: element.collapsed\n    };\n}\n// Exported only for test reasons, do not use directly\nexport function decompress(element) {\n    return _decompress(element, 0);\n}\nfunction splice(treeElement, element, children) {\n    if (treeElement.element === element) {\n        return Object.assign(Object.assign({}, treeElement), { children });\n    }\n    return Object.assign(Object.assign({}, treeElement), { children: Iterable.map(Iterable.from(treeElement.children), e => splice(e, element, children)) });\n}\nconst wrapIdentityProvider = (base) => ({\n    getId(node) {\n        return node.elements.map(e => base.getId(e).toString()).join('\\0');\n    }\n});\n// Exported only for test reasons, do not use directly\nexport class CompressedObjectTreeModel {\n    constructor(user, list, options = {}) {\n        this.user = user;\n        this.rootRef = null;\n        this.nodes = new Map();\n        this.model = new ObjectTreeModel(user, list, options);\n        this.enabled = typeof options.compressionEnabled === 'undefined' ? true : options.compressionEnabled;\n        this.identityProvider = options.identityProvider;\n    }\n    get onDidSplice() { return this.model.onDidSplice; }\n    get onDidChangeCollapseState() { return this.model.onDidChangeCollapseState; }\n    get onDidChangeRenderNodeCount() { return this.model.onDidChangeRenderNodeCount; }\n    setChildren(element, children = Iterable.empty(), options) {\n        // Diffs must be deem, since the compression can affect nested elements.\n        // @see https://github.com/microsoft/vscode/pull/114237#issuecomment-759425034\n        const diffIdentityProvider = options.diffIdentityProvider && wrapIdentityProvider(options.diffIdentityProvider);\n        if (element === null) {\n            const compressedChildren = Iterable.map(children, this.enabled ? compress : noCompress);\n            this._setChildren(null, compressedChildren, { diffIdentityProvider, diffDepth: Infinity });\n            return;\n        }\n        const compressedNode = this.nodes.get(element);\n        if (!compressedNode) {\n            throw new Error('Unknown compressed tree node');\n        }\n        const node = this.model.getNode(compressedNode);\n        const compressedParentNode = this.model.getParentNodeLocation(compressedNode);\n        const parent = this.model.getNode(compressedParentNode);\n        const decompressedElement = decompress(node);\n        const splicedElement = splice(decompressedElement, element, children);\n        const recompressedElement = (this.enabled ? compress : noCompress)(splicedElement);\n        const parentChildren = parent.children\n            .map(child => child === node ? recompressedElement : child);\n        this._setChildren(parent.element, parentChildren, {\n            diffIdentityProvider,\n            diffDepth: node.depth - parent.depth,\n        });\n    }\n    setCompressionEnabled(enabled) {\n        if (enabled === this.enabled) {\n            return;\n        }\n        this.enabled = enabled;\n        const root = this.model.getNode();\n        const rootChildren = root.children;\n        const decompressedRootChildren = Iterable.map(rootChildren, decompress);\n        const recompressedRootChildren = Iterable.map(decompressedRootChildren, enabled ? compress : noCompress);\n        // it should be safe to always use deep diff mode here if an identity\n        // provider is available, since we know the raw nodes are unchanged.\n        this._setChildren(null, recompressedRootChildren, {\n            diffIdentityProvider: this.identityProvider,\n            diffDepth: Infinity,\n        });\n    }\n    _setChildren(node, children, options) {\n        const insertedElements = new Set();\n        const onDidCreateNode = (node) => {\n            for (const element of node.element.elements) {\n                insertedElements.add(element);\n                this.nodes.set(element, node.element);\n            }\n        };\n        const onDidDeleteNode = (node) => {\n            for (const element of node.element.elements) {\n                if (!insertedElements.has(element)) {\n                    this.nodes.delete(element);\n                }\n            }\n        };\n        this.model.setChildren(node, children, Object.assign(Object.assign({}, options), { onDidCreateNode, onDidDeleteNode }));\n    }\n    has(element) {\n        return this.nodes.has(element);\n    }\n    getListIndex(location) {\n        const node = this.getCompressedNode(location);\n        return this.model.getListIndex(node);\n    }\n    getListRenderCount(location) {\n        const node = this.getCompressedNode(location);\n        return this.model.getListRenderCount(node);\n    }\n    getNode(location) {\n        if (typeof location === 'undefined') {\n            return this.model.getNode();\n        }\n        const node = this.getCompressedNode(location);\n        return this.model.getNode(node);\n    }\n    // TODO: review this\n    getNodeLocation(node) {\n        const compressedNode = this.model.getNodeLocation(node);\n        if (compressedNode === null) {\n            return null;\n        }\n        return compressedNode.elements[compressedNode.elements.length - 1];\n    }\n    // TODO: review this\n    getParentNodeLocation(location) {\n        const compressedNode = this.getCompressedNode(location);\n        const parentNode = this.model.getParentNodeLocation(compressedNode);\n        if (parentNode === null) {\n            return null;\n        }\n        return parentNode.elements[parentNode.elements.length - 1];\n    }\n    isCollapsible(location) {\n        const compressedNode = this.getCompressedNode(location);\n        return this.model.isCollapsible(compressedNode);\n    }\n    setCollapsible(location, collapsible) {\n        const compressedNode = this.getCompressedNode(location);\n        return this.model.setCollapsible(compressedNode, collapsible);\n    }\n    isCollapsed(location) {\n        const compressedNode = this.getCompressedNode(location);\n        return this.model.isCollapsed(compressedNode);\n    }\n    setCollapsed(location, collapsed, recursive) {\n        const compressedNode = this.getCompressedNode(location);\n        return this.model.setCollapsed(compressedNode, collapsed, recursive);\n    }\n    expandTo(location) {\n        const compressedNode = this.getCompressedNode(location);\n        this.model.expandTo(compressedNode);\n    }\n    rerender(location) {\n        const compressedNode = this.getCompressedNode(location);\n        this.model.rerender(compressedNode);\n    }\n    refilter() {\n        this.model.refilter();\n    }\n    getCompressedNode(element) {\n        if (element === null) {\n            return null;\n        }\n        const node = this.nodes.get(element);\n        if (!node) {\n            throw new TreeError(this.user, `Tree element not found: ${element}`);\n        }\n        return node;\n    }\n}\nexport const DefaultElementMapper = elements => elements[elements.length - 1];\nclass CompressedTreeNodeWrapper {\n    constructor(unwrapper, node) {\n        this.unwrapper = unwrapper;\n        this.node = node;\n    }\n    get element() { return this.node.element === null ? null : this.unwrapper(this.node.element); }\n    get children() { return this.node.children.map(node => new CompressedTreeNodeWrapper(this.unwrapper, node)); }\n    get depth() { return this.node.depth; }\n    get visibleChildrenCount() { return this.node.visibleChildrenCount; }\n    get visibleChildIndex() { return this.node.visibleChildIndex; }\n    get collapsible() { return this.node.collapsible; }\n    get collapsed() { return this.node.collapsed; }\n    get visible() { return this.node.visible; }\n    get filterData() { return this.node.filterData; }\n}\nfunction mapList(nodeMapper, list) {\n    return {\n        splice(start, deleteCount, toInsert) {\n            list.splice(start, deleteCount, toInsert.map(node => nodeMapper.map(node)));\n        },\n        updateElementHeight(index, height) {\n            list.updateElementHeight(index, height);\n        }\n    };\n}\nfunction mapOptions(compressedNodeUnwrapper, options) {\n    return Object.assign(Object.assign({}, options), { identityProvider: options.identityProvider && {\n            getId(node) {\n                return options.identityProvider.getId(compressedNodeUnwrapper(node));\n            }\n        }, sorter: options.sorter && {\n            compare(node, otherNode) {\n                return options.sorter.compare(node.elements[0], otherNode.elements[0]);\n            }\n        }, filter: options.filter && {\n            filter(node, parentVisibility) {\n                return options.filter.filter(compressedNodeUnwrapper(node), parentVisibility);\n            }\n        } });\n}\nexport class CompressibleObjectTreeModel {\n    constructor(user, list, options = {}) {\n        this.rootRef = null;\n        this.elementMapper = options.elementMapper || DefaultElementMapper;\n        const compressedNodeUnwrapper = node => this.elementMapper(node.elements);\n        this.nodeMapper = new WeakMapper(node => new CompressedTreeNodeWrapper(compressedNodeUnwrapper, node));\n        this.model = new CompressedObjectTreeModel(user, mapList(this.nodeMapper, list), mapOptions(compressedNodeUnwrapper, options));\n    }\n    get onDidSplice() {\n        return Event.map(this.model.onDidSplice, ({ insertedNodes, deletedNodes }) => ({\n            insertedNodes: insertedNodes.map(node => this.nodeMapper.map(node)),\n            deletedNodes: deletedNodes.map(node => this.nodeMapper.map(node)),\n        }));\n    }\n    get onDidChangeCollapseState() {\n        return Event.map(this.model.onDidChangeCollapseState, ({ node, deep }) => ({\n            node: this.nodeMapper.map(node),\n            deep\n        }));\n    }\n    get onDidChangeRenderNodeCount() {\n        return Event.map(this.model.onDidChangeRenderNodeCount, node => this.nodeMapper.map(node));\n    }\n    setChildren(element, children = Iterable.empty(), options = {}) {\n        this.model.setChildren(element, children, options);\n    }\n    setCompressionEnabled(enabled) {\n        this.model.setCompressionEnabled(enabled);\n    }\n    has(location) {\n        return this.model.has(location);\n    }\n    getListIndex(location) {\n        return this.model.getListIndex(location);\n    }\n    getListRenderCount(location) {\n        return this.model.getListRenderCount(location);\n    }\n    getNode(location) {\n        return this.nodeMapper.map(this.model.getNode(location));\n    }\n    getNodeLocation(node) {\n        return node.element;\n    }\n    getParentNodeLocation(location) {\n        return this.model.getParentNodeLocation(location);\n    }\n    isCollapsible(location) {\n        return this.model.isCollapsible(location);\n    }\n    setCollapsible(location, collapsed) {\n        return this.model.setCollapsible(location, collapsed);\n    }\n    isCollapsed(location) {\n        return this.model.isCollapsed(location);\n    }\n    setCollapsed(location, collapsed, recursive) {\n        return this.model.setCollapsed(location, collapsed, recursive);\n    }\n    expandTo(location) {\n        return this.model.expandTo(location);\n    }\n    rerender(location) {\n        return this.model.rerender(location);\n    }\n    refilter() {\n        return this.model.refilter();\n    }\n    getCompressedTreeNode(location = null) {\n        return this.model.getNode(location);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}