{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\nimport { BlockCommentCommand } from './blockCommentCommand.js';\nexport class LineCommentCommand {\n  constructor(selection, tabSize, type, insertSpace, ignoreEmptyLines, ignoreFirstLine) {\n    this._selection = selection;\n    this._tabSize = tabSize;\n    this._type = type;\n    this._insertSpace = insertSpace;\n    this._selectionId = null;\n    this._deltaColumn = 0;\n    this._moveEndPositionDown = false;\n    this._ignoreEmptyLines = ignoreEmptyLines;\n    this._ignoreFirstLine = ignoreFirstLine || false;\n  }\n  /**\n   * Do an initial pass over the lines and gather info about the line comment string.\n   * Returns null if any of the lines doesn't support a line comment string.\n   */\n\n\n  static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber) {\n    model.tokenizeIfCheap(startLineNumber);\n    const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n    const config = LanguageConfigurationRegistry.getComments(languageId);\n    const commentStr = config ? config.lineCommentToken : null;\n\n    if (!commentStr) {\n      // Mode does not support line comments\n      return null;\n    }\n\n    let lines = [];\n\n    for (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n      lines[i] = {\n        ignore: false,\n        commentStr: commentStr,\n        commentStrOffset: 0,\n        commentStrLength: commentStr.length\n      };\n    }\n\n    return lines;\n  }\n  /**\n   * Analyze lines and decide which lines are relevant and what the toggle should do.\n   * Also, build up several offsets and lengths useful in the generation of editor operations.\n   */\n\n\n  static _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine) {\n    let onlyWhitespaceLines = true;\n    let shouldRemoveComments;\n\n    if (type === 0\n    /* Toggle */\n    ) {\n      shouldRemoveComments = true;\n    } else if (type === 1\n    /* ForceAdd */\n    ) {\n      shouldRemoveComments = false;\n    } else {\n      shouldRemoveComments = true;\n    }\n\n    for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n      const lineData = lines[i];\n      const lineNumber = startLineNumber + i;\n\n      if (lineNumber === startLineNumber && ignoreFirstLine) {\n        // first line ignored\n        lineData.ignore = true;\n        continue;\n      }\n\n      const lineContent = model.getLineContent(lineNumber);\n      const lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n\n      if (lineContentStartOffset === -1) {\n        // Empty or whitespace only line\n        lineData.ignore = ignoreEmptyLines;\n        lineData.commentStrOffset = lineContent.length;\n        continue;\n      }\n\n      onlyWhitespaceLines = false;\n      lineData.ignore = false;\n      lineData.commentStrOffset = lineContentStartOffset;\n\n      if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\n        if (type === 0\n        /* Toggle */\n        ) {\n          // Every line so far has been a line comment, but this one is not\n          shouldRemoveComments = false;\n        } else if (type === 1\n        /* ForceAdd */\n        ) {// Will not happen\n        } else {\n          lineData.ignore = true;\n        }\n      }\n\n      if (shouldRemoveComments && insertSpace) {\n        // Remove a following space if present\n        const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n\n        if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32\n        /* Space */\n        ) {\n          lineData.commentStrLength += 1;\n        }\n      }\n    }\n\n    if (type === 0\n    /* Toggle */\n    && onlyWhitespaceLines) {\n      // For only whitespace lines, we insert comments\n      shouldRemoveComments = false; // Also, no longer ignore them\n\n      for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n        lines[i].ignore = false;\n      }\n    }\n\n    return {\n      supported: true,\n      shouldRemoveComments: shouldRemoveComments,\n      lines: lines\n    };\n  }\n  /**\n   * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\n   */\n\n\n  static _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines, ignoreFirstLine) {\n    const lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber);\n\n    if (lines === null) {\n      return {\n        supported: false\n      };\n    }\n\n    return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine);\n  }\n  /**\n   * Given a successful analysis, execute either insert line comments, either remove line comments\n   */\n\n\n  _executeLineComments(model, builder, data, s) {\n    let ops;\n\n    if (data.shouldRemoveComments) {\n      ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n    } else {\n      LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);\n\n      ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n    }\n\n    const cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\n\n    for (let i = 0, len = ops.length; i < len; i++) {\n      builder.addEditOperation(ops[i].range, ops[i].text);\n\n      if (Range.isEmpty(ops[i].range) && Range.getStartPosition(ops[i].range).equals(cursorPosition)) {\n        const lineContent = model.getLineContent(cursorPosition.lineNumber);\n\n        if (lineContent.length + 1 === cursorPosition.column) {\n          this._deltaColumn = (ops[i].text || '').length;\n        }\n      }\n    }\n\n    this._selectionId = builder.trackSelection(s);\n  }\n\n  _attemptRemoveBlockComment(model, s, startToken, endToken) {\n    let startLineNumber = s.startLineNumber;\n    let endLineNumber = s.endLineNumber;\n    let startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);\n    let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n    let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n\n    if (startTokenIndex !== -1 && endTokenIndex === -1) {\n      endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n      endLineNumber = startLineNumber;\n    }\n\n    if (startTokenIndex === -1 && endTokenIndex !== -1) {\n      startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n      startLineNumber = endLineNumber;\n    }\n\n    if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n      startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n\n      if (startTokenIndex !== -1) {\n        endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n      }\n    } // We have to adjust to possible inner white space.\n    // For Space after startToken, add Space to startToken - range math will work out.\n\n\n    if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32\n    /* Space */\n    ) {\n      startToken += ' ';\n    } // For Space before endToken, add Space before endToken and shift index one left.\n\n\n    if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32\n    /* Space */\n    ) {\n      endToken = ' ' + endToken;\n      endTokenIndex -= 1;\n    }\n\n    if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n      return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n    }\n\n    return null;\n  }\n  /**\n   * Given an unsuccessful analysis, delegate to the block comment command\n   */\n\n\n  _executeBlockComment(model, builder, s) {\n    model.tokenizeIfCheap(s.startLineNumber);\n    let languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n    let config = LanguageConfigurationRegistry.getComments(languageId);\n\n    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n      // Mode does not support block comments\n      return;\n    }\n\n    const startToken = config.blockCommentStartToken;\n    const endToken = config.blockCommentEndToken;\n\n    let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n\n    if (!ops) {\n      if (s.isEmpty()) {\n        const lineContent = model.getLineContent(s.startLineNumber);\n        let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n\n        if (firstNonWhitespaceIndex === -1) {\n          // Line is empty or contains only whitespace\n          firstNonWhitespaceIndex = lineContent.length;\n        }\n\n        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);\n      } else {\n        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);\n      }\n\n      if (ops.length === 1) {\n        // Leave cursor after token and Space\n        this._deltaColumn = startToken.length + 1;\n      }\n    }\n\n    this._selectionId = builder.trackSelection(s);\n\n    for (const op of ops) {\n      builder.addEditOperation(op.range, op.text);\n    }\n  }\n\n  getEditOperations(model, builder) {\n    let s = this._selection;\n    this._moveEndPositionDown = false;\n\n    if (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {\n      builder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? '' : '\\n');\n      this._selectionId = builder.trackSelection(s);\n      return;\n    }\n\n    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n      this._moveEndPositionDown = true;\n      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n    }\n\n    const data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine);\n\n    if (data.supported) {\n      return this._executeLineComments(model, builder, data, s);\n    }\n\n    return this._executeBlockComment(model, builder, s);\n  }\n\n  computeCursorState(model, helper) {\n    let result = helper.getTrackedSelection(this._selectionId);\n\n    if (this._moveEndPositionDown) {\n      result = result.setEndPosition(result.endLineNumber + 1, 1);\n    }\n\n    return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);\n  }\n  /**\n   * Generate edit operations in the remove line comment case\n   */\n\n\n  static _createRemoveLineCommentsOperations(lines, startLineNumber) {\n    let res = [];\n\n    for (let i = 0, len = lines.length; i < len; i++) {\n      const lineData = lines[i];\n\n      if (lineData.ignore) {\n        continue;\n      }\n\n      res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));\n    }\n\n    return res;\n  }\n  /**\n   * Generate edit operations in the add line comment case\n   */\n\n\n  _createAddLineCommentsOperations(lines, startLineNumber) {\n    let res = [];\n    const afterCommentStr = this._insertSpace ? ' ' : '';\n\n    for (let i = 0, len = lines.length; i < len; i++) {\n      const lineData = lines[i];\n\n      if (lineData.ignore) {\n        continue;\n      }\n\n      res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));\n    }\n\n    return res;\n  }\n\n  static nextVisibleColumn(currentVisibleColumn, tabSize, isTab, columnSize) {\n    if (isTab) {\n      return currentVisibleColumn + (tabSize - currentVisibleColumn % tabSize);\n    }\n\n    return currentVisibleColumn + columnSize;\n  }\n  /**\n   * Adjust insertion points to have them vertically aligned in the add line comment case\n   */\n\n\n  static _normalizeInsertionPoint(model, lines, startLineNumber, tabSize) {\n    let minVisibleColumn = 1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    ;\n    let j;\n    let lenJ;\n\n    for (let i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].ignore) {\n        continue;\n      }\n\n      const lineContent = model.getLineContent(startLineNumber + i);\n      let currentVisibleColumn = 0;\n\n      for (let j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9\n        /* Tab */\n        , 1);\n      }\n\n      if (currentVisibleColumn < minVisibleColumn) {\n        minVisibleColumn = currentVisibleColumn;\n      }\n    }\n\n    minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;\n\n    for (let i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].ignore) {\n        continue;\n      }\n\n      const lineContent = model.getLineContent(startLineNumber + i);\n      let currentVisibleColumn = 0;\n\n      for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9\n        /* Tab */\n        , 1);\n      }\n\n      if (currentVisibleColumn > minVisibleColumn) {\n        lines[i].commentStrOffset = j - 1;\n      } else {\n        lines[i].commentStrOffset = j;\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/contrib/comment/lineCommentCommand.js"],"names":["strings","EditOperation","Position","Range","Selection","LanguageConfigurationRegistry","BlockCommentCommand","LineCommentCommand","constructor","selection","tabSize","type","insertSpace","ignoreEmptyLines","ignoreFirstLine","_selection","_tabSize","_type","_insertSpace","_selectionId","_deltaColumn","_moveEndPositionDown","_ignoreEmptyLines","_ignoreFirstLine","_gatherPreflightCommentStrings","model","startLineNumber","endLineNumber","tokenizeIfCheap","languageId","getLanguageIdAtPosition","config","getComments","commentStr","lineCommentToken","lines","i","lineCount","ignore","commentStrOffset","commentStrLength","length","_analyzeLines","onlyWhitespaceLines","shouldRemoveComments","lineData","lineNumber","lineContent","getLineContent","lineContentStartOffset","firstNonWhitespaceIndex","_haystackHasNeedleAtOffset","commentStrEndOffset","charCodeAt","supported","_gatherPreflightData","_executeLineComments","builder","data","s","ops","_createRemoveLineCommentsOperations","_normalizeInsertionPoint","_createAddLineCommentsOperations","cursorPosition","positionLineNumber","positionColumn","len","addEditOperation","range","text","isEmpty","getStartPosition","equals","column","trackSelection","_attemptRemoveBlockComment","startToken","endToken","startTokenAllowedBeforeColumn","Math","max","getLineFirstNonWhitespaceColumn","startColumn","startTokenIndex","lastIndexOf","endTokenIndex","indexOf","endColumn","_createRemoveBlockCommentOperations","_executeBlockComment","blockCommentStartToken","blockCommentEndToken","_createAddBlockCommentOperations","getLineMaxColumn","op","getEditOperations","getLineCount","setEndPosition","computeCursorState","helper","result","getTrackedSelection","selectionStartLineNumber","selectionStartColumn","res","push","delete","afterCommentStr","insert","nextVisibleColumn","currentVisibleColumn","isTab","columnSize","minVisibleColumn","j","lenJ","floor"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\nimport { BlockCommentCommand } from './blockCommentCommand.js';\nexport class LineCommentCommand {\n    constructor(selection, tabSize, type, insertSpace, ignoreEmptyLines, ignoreFirstLine) {\n        this._selection = selection;\n        this._tabSize = tabSize;\n        this._type = type;\n        this._insertSpace = insertSpace;\n        this._selectionId = null;\n        this._deltaColumn = 0;\n        this._moveEndPositionDown = false;\n        this._ignoreEmptyLines = ignoreEmptyLines;\n        this._ignoreFirstLine = ignoreFirstLine || false;\n    }\n    /**\n     * Do an initial pass over the lines and gather info about the line comment string.\n     * Returns null if any of the lines doesn't support a line comment string.\n     */\n    static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber) {\n        model.tokenizeIfCheap(startLineNumber);\n        const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n        const config = LanguageConfigurationRegistry.getComments(languageId);\n        const commentStr = (config ? config.lineCommentToken : null);\n        if (!commentStr) {\n            // Mode does not support line comments\n            return null;\n        }\n        let lines = [];\n        for (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n            lines[i] = {\n                ignore: false,\n                commentStr: commentStr,\n                commentStrOffset: 0,\n                commentStrLength: commentStr.length\n            };\n        }\n        return lines;\n    }\n    /**\n     * Analyze lines and decide which lines are relevant and what the toggle should do.\n     * Also, build up several offsets and lengths useful in the generation of editor operations.\n     */\n    static _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine) {\n        let onlyWhitespaceLines = true;\n        let shouldRemoveComments;\n        if (type === 0 /* Toggle */) {\n            shouldRemoveComments = true;\n        }\n        else if (type === 1 /* ForceAdd */) {\n            shouldRemoveComments = false;\n        }\n        else {\n            shouldRemoveComments = true;\n        }\n        for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n            const lineData = lines[i];\n            const lineNumber = startLineNumber + i;\n            if (lineNumber === startLineNumber && ignoreFirstLine) {\n                // first line ignored\n                lineData.ignore = true;\n                continue;\n            }\n            const lineContent = model.getLineContent(lineNumber);\n            const lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n            if (lineContentStartOffset === -1) {\n                // Empty or whitespace only line\n                lineData.ignore = ignoreEmptyLines;\n                lineData.commentStrOffset = lineContent.length;\n                continue;\n            }\n            onlyWhitespaceLines = false;\n            lineData.ignore = false;\n            lineData.commentStrOffset = lineContentStartOffset;\n            if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\n                if (type === 0 /* Toggle */) {\n                    // Every line so far has been a line comment, but this one is not\n                    shouldRemoveComments = false;\n                }\n                else if (type === 1 /* ForceAdd */) {\n                    // Will not happen\n                }\n                else {\n                    lineData.ignore = true;\n                }\n            }\n            if (shouldRemoveComments && insertSpace) {\n                // Remove a following space if present\n                const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n                if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32 /* Space */) {\n                    lineData.commentStrLength += 1;\n                }\n            }\n        }\n        if (type === 0 /* Toggle */ && onlyWhitespaceLines) {\n            // For only whitespace lines, we insert comments\n            shouldRemoveComments = false;\n            // Also, no longer ignore them\n            for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n                lines[i].ignore = false;\n            }\n        }\n        return {\n            supported: true,\n            shouldRemoveComments: shouldRemoveComments,\n            lines: lines\n        };\n    }\n    /**\n     * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\n     */\n    static _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines, ignoreFirstLine) {\n        const lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber);\n        if (lines === null) {\n            return {\n                supported: false\n            };\n        }\n        return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine);\n    }\n    /**\n     * Given a successful analysis, execute either insert line comments, either remove line comments\n     */\n    _executeLineComments(model, builder, data, s) {\n        let ops;\n        if (data.shouldRemoveComments) {\n            ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n        }\n        else {\n            LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);\n            ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n        }\n        const cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\n        for (let i = 0, len = ops.length; i < len; i++) {\n            builder.addEditOperation(ops[i].range, ops[i].text);\n            if (Range.isEmpty(ops[i].range) && Range.getStartPosition(ops[i].range).equals(cursorPosition)) {\n                const lineContent = model.getLineContent(cursorPosition.lineNumber);\n                if (lineContent.length + 1 === cursorPosition.column) {\n                    this._deltaColumn = (ops[i].text || '').length;\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n    }\n    _attemptRemoveBlockComment(model, s, startToken, endToken) {\n        let startLineNumber = s.startLineNumber;\n        let endLineNumber = s.endLineNumber;\n        let startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);\n        let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n        let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n        if (startTokenIndex !== -1 && endTokenIndex === -1) {\n            endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n            endLineNumber = startLineNumber;\n        }\n        if (startTokenIndex === -1 && endTokenIndex !== -1) {\n            startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n            startLineNumber = endLineNumber;\n        }\n        if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n            startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n            if (startTokenIndex !== -1) {\n                endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n            }\n        }\n        // We have to adjust to possible inner white space.\n        // For Space after startToken, add Space to startToken - range math will work out.\n        if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32 /* Space */) {\n            startToken += ' ';\n        }\n        // For Space before endToken, add Space before endToken and shift index one left.\n        if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32 /* Space */) {\n            endToken = ' ' + endToken;\n            endTokenIndex -= 1;\n        }\n        if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n            return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n        }\n        return null;\n    }\n    /**\n     * Given an unsuccessful analysis, delegate to the block comment command\n     */\n    _executeBlockComment(model, builder, s) {\n        model.tokenizeIfCheap(s.startLineNumber);\n        let languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n        let config = LanguageConfigurationRegistry.getComments(languageId);\n        if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n            // Mode does not support block comments\n            return;\n        }\n        const startToken = config.blockCommentStartToken;\n        const endToken = config.blockCommentEndToken;\n        let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n        if (!ops) {\n            if (s.isEmpty()) {\n                const lineContent = model.getLineContent(s.startLineNumber);\n                let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n                if (firstNonWhitespaceIndex === -1) {\n                    // Line is empty or contains only whitespace\n                    firstNonWhitespaceIndex = lineContent.length;\n                }\n                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);\n            }\n            else {\n                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);\n            }\n            if (ops.length === 1) {\n                // Leave cursor after token and Space\n                this._deltaColumn = startToken.length + 1;\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n        for (const op of ops) {\n            builder.addEditOperation(op.range, op.text);\n        }\n    }\n    getEditOperations(model, builder) {\n        let s = this._selection;\n        this._moveEndPositionDown = false;\n        if (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {\n            builder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? '' : '\\n');\n            this._selectionId = builder.trackSelection(s);\n            return;\n        }\n        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n            this._moveEndPositionDown = true;\n            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n        }\n        const data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine);\n        if (data.supported) {\n            return this._executeLineComments(model, builder, data, s);\n        }\n        return this._executeBlockComment(model, builder, s);\n    }\n    computeCursorState(model, helper) {\n        let result = helper.getTrackedSelection(this._selectionId);\n        if (this._moveEndPositionDown) {\n            result = result.setEndPosition(result.endLineNumber + 1, 1);\n        }\n        return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);\n    }\n    /**\n     * Generate edit operations in the remove line comment case\n     */\n    static _createRemoveLineCommentsOperations(lines, startLineNumber) {\n        let res = [];\n        for (let i = 0, len = lines.length; i < len; i++) {\n            const lineData = lines[i];\n            if (lineData.ignore) {\n                continue;\n            }\n            res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));\n        }\n        return res;\n    }\n    /**\n     * Generate edit operations in the add line comment case\n     */\n    _createAddLineCommentsOperations(lines, startLineNumber) {\n        let res = [];\n        const afterCommentStr = this._insertSpace ? ' ' : '';\n        for (let i = 0, len = lines.length; i < len; i++) {\n            const lineData = lines[i];\n            if (lineData.ignore) {\n                continue;\n            }\n            res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));\n        }\n        return res;\n    }\n    static nextVisibleColumn(currentVisibleColumn, tabSize, isTab, columnSize) {\n        if (isTab) {\n            return currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));\n        }\n        return currentVisibleColumn + columnSize;\n    }\n    /**\n     * Adjust insertion points to have them vertically aligned in the add line comment case\n     */\n    static _normalizeInsertionPoint(model, lines, startLineNumber, tabSize) {\n        let minVisibleColumn = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n        let j;\n        let lenJ;\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].ignore) {\n                continue;\n            }\n            const lineContent = model.getLineContent(startLineNumber + i);\n            let currentVisibleColumn = 0;\n            for (let j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* Tab */, 1);\n            }\n            if (currentVisibleColumn < minVisibleColumn) {\n                minVisibleColumn = currentVisibleColumn;\n            }\n        }\n        minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].ignore) {\n                continue;\n            }\n            const lineContent = model.getLineContent(startLineNumber + i);\n            let currentVisibleColumn = 0;\n            for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* Tab */, 1);\n            }\n            if (currentVisibleColumn > minVisibleColumn) {\n                lines[i].commentStrOffset = j - 1;\n            }\n            else {\n                lines[i].commentStrOffset = j;\n            }\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}