{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { createCancelablePromise, RunOnceScheduler } from '../../../base/common/async.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { onUnexpectedError, onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { commonPrefixLength, commonSuffixLength } from '../../../base/common/strings.js';\nimport { CoreEditingCommands } from '../../browser/controller/coreCommands.js';\nimport { RedoCommand, UndoCommand } from '../../browser/editorExtensions.js';\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Range } from '../../common/core/range.js';\nimport { InlineCompletionsProviderRegistry, InlineCompletionTriggerKind } from '../../common/modes.js';\nimport { BaseGhostTextWidgetModel } from './ghostText.js';\nimport { ICommandService } from '../../../platform/commands/common/commands.js';\nimport { inlineSuggestCommitId } from './consts.js';\nimport { inlineCompletionToGhostText } from './inlineCompletionToGhostText.js';\nlet InlineCompletionsModel = class InlineCompletionsModel extends Disposable {\n  constructor(editor, cache, commandService) {\n    super();\n    this.editor = editor;\n    this.cache = cache;\n    this.commandService = commandService;\n    this.onDidChangeEmitter = new Emitter();\n    this.onDidChange = this.onDidChangeEmitter.event;\n    this.completionSession = this._register(new MutableDisposable());\n    this.active = false;\n    this.disposed = false;\n\n    this._register(commandService.onDidExecuteCommand(e => {\n      // These commands don't trigger onDidType.\n      const commands = new Set([UndoCommand.id, RedoCommand.id, CoreEditingCommands.Tab.id, CoreEditingCommands.DeleteLeft.id, CoreEditingCommands.DeleteRight.id, inlineSuggestCommitId, 'acceptSelectedSuggestion']);\n\n      if (commands.has(e.commandId) && editor.hasTextFocus()) {\n        this.handleUserInput();\n      }\n    }));\n\n    this._register(this.editor.onDidType(e => {\n      this.handleUserInput();\n    }));\n\n    this._register(this.editor.onDidChangeCursorPosition(e => {\n      if (this.session && !this.session.isValid) {\n        this.hide();\n      }\n    }));\n\n    this._register(toDisposable(() => {\n      this.disposed = true;\n    }));\n\n    this._register(this.editor.onDidBlurEditorWidget(() => {\n      this.hide();\n    }));\n  }\n\n  handleUserInput() {\n    if (this.session && !this.session.isValid) {\n      this.hide();\n    }\n\n    setTimeout(() => {\n      if (this.disposed) {\n        return;\n      } // Wait for the cursor update that happens in the same iteration loop iteration\n\n\n      this.startSessionIfTriggered();\n    }, 0);\n  }\n\n  get session() {\n    return this.completionSession.value;\n  }\n\n  get ghostText() {\n    var _a;\n\n    return (_a = this.session) === null || _a === void 0 ? void 0 : _a.ghostText;\n  }\n\n  get minReservedLineCount() {\n    return this.session ? this.session.minReservedLineCount : 0;\n  }\n\n  setExpanded(expanded) {\n    var _a;\n\n    (_a = this.session) === null || _a === void 0 ? void 0 : _a.setExpanded(expanded);\n  }\n\n  setActive(active) {\n    var _a;\n\n    this.active = active;\n\n    if (active) {\n      (_a = this.session) === null || _a === void 0 ? void 0 : _a.scheduleAutomaticUpdate();\n    }\n  }\n\n  startSessionIfTriggered() {\n    const suggestOptions = this.editor.getOption(54\n    /* inlineSuggest */\n    );\n\n    if (!suggestOptions.enabled) {\n      return;\n    }\n\n    if (this.session && this.session.isValid) {\n      return;\n    }\n\n    this.trigger(InlineCompletionTriggerKind.Automatic);\n  }\n\n  trigger(triggerKind) {\n    if (this.completionSession.value) {\n      if (triggerKind === InlineCompletionTriggerKind.Explicit) {\n        void this.completionSession.value.ensureUpdateWithExplicitContext();\n      }\n\n      return;\n    }\n\n    this.completionSession.value = new InlineCompletionsSession(this.editor, this.editor.getPosition(), () => this.active, this.commandService, this.cache, triggerKind);\n    this.completionSession.value.takeOwnership(this.completionSession.value.onDidChange(() => {\n      this.onDidChangeEmitter.fire();\n    }));\n  }\n\n  hide() {\n    this.completionSession.clear();\n    this.onDidChangeEmitter.fire();\n  }\n\n  commitCurrentSuggestion() {\n    var _a; // Don't dispose the session, so that after committing, more suggestions are shown.\n\n\n    (_a = this.session) === null || _a === void 0 ? void 0 : _a.commitCurrentCompletion();\n  }\n\n  showNext() {\n    var _a;\n\n    (_a = this.session) === null || _a === void 0 ? void 0 : _a.showNextInlineCompletion();\n  }\n\n  showPrevious() {\n    var _a;\n\n    (_a = this.session) === null || _a === void 0 ? void 0 : _a.showPreviousInlineCompletion();\n  }\n\n  hasMultipleInlineCompletions() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = yield (_a = this.session) === null || _a === void 0 ? void 0 : _a.hasMultipleInlineCompletions();\n      return result !== undefined ? result : false;\n    });\n  }\n\n};\nInlineCompletionsModel = __decorate([__param(2, ICommandService)], InlineCompletionsModel);\nexport { InlineCompletionsModel };\nexport class InlineCompletionsSession extends BaseGhostTextWidgetModel {\n  constructor(editor, triggerPosition, shouldUpdate, commandService, cache, initialTriggerKind) {\n    super(editor);\n    this.triggerPosition = triggerPosition;\n    this.shouldUpdate = shouldUpdate;\n    this.commandService = commandService;\n    this.cache = cache;\n    this.initialTriggerKind = initialTriggerKind;\n    this.minReservedLineCount = 0;\n    this.updateOperation = this._register(new MutableDisposable());\n    this.updateSoon = this._register(new RunOnceScheduler(() => {\n      let triggerKind = this.initialTriggerKind; // All subsequent triggers are automatic.\n\n      this.initialTriggerKind = InlineCompletionTriggerKind.Automatic;\n      return this.update(triggerKind);\n    }, 50)); //#region Selection\n    // We use a semantic id to track the selection even if the cache changes.\n\n    this.currentlySelectedCompletionId = undefined;\n    let lastCompletionItem = undefined;\n\n    this._register(this.onDidChange(() => {\n      const currentCompletion = this.currentCompletion;\n\n      if (currentCompletion && currentCompletion.sourceInlineCompletion !== lastCompletionItem) {\n        lastCompletionItem = currentCompletion.sourceInlineCompletion;\n        const provider = currentCompletion.sourceProvider;\n\n        if (provider.handleItemDidShow) {\n          provider.handleItemDidShow(currentCompletion.sourceInlineCompletions, lastCompletionItem);\n        }\n      }\n    }));\n\n    this._register(toDisposable(() => {\n      this.cache.clear();\n    }));\n\n    this._register(this.editor.onDidChangeCursorPosition(e => {\n      if (this.cache.value) {\n        this.onDidChangeEmitter.fire();\n      }\n    }));\n\n    this._register(this.editor.onDidChangeModelContent(e => {\n      this.scheduleAutomaticUpdate();\n    }));\n\n    this._register(InlineCompletionsProviderRegistry.onDidChange(() => {\n      this.updateSoon.schedule();\n    }));\n\n    this.scheduleAutomaticUpdate();\n  }\n\n  fixAndGetIndexOfCurrentSelection() {\n    if (!this.currentlySelectedCompletionId || !this.cache.value) {\n      return 0;\n    }\n\n    if (this.cache.value.completions.length === 0) {\n      // don't reset the selection in this case\n      return 0;\n    }\n\n    const idx = this.cache.value.completions.findIndex(v => v.semanticId === this.currentlySelectedCompletionId);\n\n    if (idx === -1) {\n      // Reset the selection so that the selection does not jump back when it appears again\n      this.currentlySelectedCompletionId = undefined;\n      return 0;\n    }\n\n    return idx;\n  }\n\n  get currentCachedCompletion() {\n    if (!this.cache.value) {\n      return undefined;\n    }\n\n    return this.cache.value.completions[this.fixAndGetIndexOfCurrentSelection()];\n  }\n\n  showNextInlineCompletion() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.ensureUpdateWithExplicitContext();\n      const completions = ((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.completions) || [];\n\n      if (completions.length > 0) {\n        const newIdx = (this.fixAndGetIndexOfCurrentSelection() + 1) % completions.length;\n        this.currentlySelectedCompletionId = completions[newIdx].semanticId;\n      } else {\n        this.currentlySelectedCompletionId = undefined;\n      }\n\n      this.onDidChangeEmitter.fire();\n    });\n  }\n\n  showPreviousInlineCompletion() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.ensureUpdateWithExplicitContext();\n      const completions = ((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.completions) || [];\n\n      if (completions.length > 0) {\n        const newIdx = (this.fixAndGetIndexOfCurrentSelection() + completions.length - 1) % completions.length;\n        this.currentlySelectedCompletionId = completions[newIdx].semanticId;\n      } else {\n        this.currentlySelectedCompletionId = undefined;\n      }\n\n      this.onDidChangeEmitter.fire();\n    });\n  }\n\n  ensureUpdateWithExplicitContext() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.updateOperation.value) {\n        // Restart or wait for current update operation\n        if (this.updateOperation.value.triggerKind === InlineCompletionTriggerKind.Explicit) {\n          yield this.updateOperation.value.promise;\n        } else {\n          yield this.update(InlineCompletionTriggerKind.Explicit);\n        }\n      } else if (((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.triggerKind) !== InlineCompletionTriggerKind.Explicit) {\n        // Refresh cache\n        yield this.update(InlineCompletionTriggerKind.Explicit);\n      }\n    });\n  }\n\n  hasMultipleInlineCompletions() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.ensureUpdateWithExplicitContext();\n      return (((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.completions.length) || 0) > 1;\n    });\n  } //#endregion\n\n\n  get ghostText() {\n    const currentCompletion = this.currentCompletion;\n    const mode = this.editor.getOptions().get(54\n    /* inlineSuggest */\n    ).mode;\n    return currentCompletion ? inlineCompletionToGhostText(currentCompletion, this.editor.getModel(), mode, this.editor.getPosition()) : undefined;\n  }\n\n  get currentCompletion() {\n    const completion = this.currentCachedCompletion;\n\n    if (!completion) {\n      return undefined;\n    }\n\n    return completion.toLiveInlineCompletion();\n  }\n\n  get isValid() {\n    return this.editor.getPosition().lineNumber === this.triggerPosition.lineNumber;\n  }\n\n  scheduleAutomaticUpdate() {\n    // Since updateSoon debounces, starvation can happen.\n    // To prevent stale cache, we clear the current update operation.\n    this.updateOperation.clear();\n    this.updateSoon.schedule();\n  }\n\n  update(triggerKind) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.shouldUpdate()) {\n        return;\n      }\n\n      const position = this.editor.getPosition();\n      const promise = createCancelablePromise(token => __awaiter(this, void 0, void 0, function* () {\n        let result;\n\n        try {\n          result = yield provideInlineCompletions(position, this.editor.getModel(), {\n            triggerKind,\n            selectedSuggestionInfo: undefined\n          }, token);\n        } catch (e) {\n          onUnexpectedError(e);\n          return;\n        }\n\n        if (token.isCancellationRequested) {\n          return;\n        }\n\n        this.cache.setValue(this.editor, result, triggerKind);\n        this.onDidChangeEmitter.fire();\n      }));\n      const operation = new UpdateOperation(promise, triggerKind);\n      this.updateOperation.value = operation;\n      yield promise;\n\n      if (this.updateOperation.value === operation) {\n        this.updateOperation.clear();\n      }\n    });\n  }\n\n  takeOwnership(disposable) {\n    this._register(disposable);\n  }\n\n  commitCurrentCompletion() {\n    if (!this.ghostText) {\n      // No ghost text was shown for this completion.\n      // Thus, we don't want to commit anything.\n      return;\n    }\n\n    const completion = this.currentCompletion;\n\n    if (completion) {\n      this.commit(completion);\n    }\n  }\n\n  commit(completion) {\n    // Mark the cache as stale, but don't dispose it yet,\n    // otherwise command args might get disposed.\n    const cache = this.cache.clearAndLeak();\n    this.editor.executeEdits('inlineSuggestion.accept', [EditOperation.replaceMove(completion.range, completion.text)]);\n\n    if (completion.command) {\n      this.commandService.executeCommand(completion.command.id, ...(completion.command.arguments || [])).finally(() => {\n        cache === null || cache === void 0 ? void 0 : cache.dispose();\n      }).then(undefined, onUnexpectedExternalError);\n    } else {\n      cache === null || cache === void 0 ? void 0 : cache.dispose();\n    }\n\n    this.onDidChangeEmitter.fire();\n  }\n\n}\nexport class UpdateOperation {\n  constructor(promise, triggerKind) {\n    this.promise = promise;\n    this.triggerKind = triggerKind;\n  }\n\n  dispose() {\n    this.promise.cancel();\n  }\n\n}\n/**\n * The cache keeps itself in sync with the editor.\n * It also owns the completions result and disposes it when the cache is diposed.\n*/\n\nexport class SynchronizedInlineCompletionsCache extends Disposable {\n  constructor(editor, completionsSource, onChange, triggerKind) {\n    super();\n    this.triggerKind = triggerKind;\n    const decorationIds = editor.deltaDecorations([], completionsSource.items.map(i => ({\n      range: i.range,\n      options: {\n        description: 'inline-completion-tracking-range'\n      }\n    })));\n\n    this._register(toDisposable(() => {\n      editor.deltaDecorations(decorationIds, []);\n    }));\n\n    this.completions = completionsSource.items.map((c, idx) => new CachedInlineCompletion(c, decorationIds[idx]));\n\n    this._register(editor.onDidChangeModelContent(() => {\n      let hasChanged = false;\n      const model = editor.getModel();\n\n      for (const c of this.completions) {\n        const newRange = model.getDecorationRange(c.decorationId);\n\n        if (!newRange) {\n          onUnexpectedError(new Error('Decoration has no range'));\n          continue;\n        }\n\n        if (!c.synchronizedRange.equalsRange(newRange)) {\n          hasChanged = true;\n          c.synchronizedRange = newRange;\n        }\n      }\n\n      if (hasChanged) {\n        onChange();\n      }\n    }));\n\n    this._register(completionsSource);\n  }\n\n}\n\nclass CachedInlineCompletion {\n  constructor(inlineCompletion, decorationId) {\n    this.inlineCompletion = inlineCompletion;\n    this.decorationId = decorationId;\n    this.semanticId = JSON.stringify({\n      text: this.inlineCompletion.text,\n      startLine: this.inlineCompletion.range.startLineNumber,\n      startColumn: this.inlineCompletion.range.startColumn,\n      command: this.inlineCompletion.command\n    });\n    this.synchronizedRange = inlineCompletion.range;\n  }\n\n  toLiveInlineCompletion() {\n    return {\n      text: this.inlineCompletion.text,\n      range: this.synchronizedRange,\n      command: this.inlineCompletion.command,\n      sourceProvider: this.inlineCompletion.sourceProvider,\n      sourceInlineCompletions: this.inlineCompletion.sourceInlineCompletions,\n      sourceInlineCompletion: this.inlineCompletion.sourceInlineCompletion\n    };\n  }\n\n}\n\nfunction getDefaultRange(position, model) {\n  const word = model.getWordAtPosition(position);\n  const maxColumn = model.getLineMaxColumn(position.lineNumber); // By default, always replace up until the end of the current line.\n  // This default might be subject to change!\n\n  return word ? new Range(position.lineNumber, word.startColumn, position.lineNumber, maxColumn) : Range.fromPositions(position, position.with(undefined, maxColumn));\n}\n\nexport function provideInlineCompletions(position, model, context) {\n  let token = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : CancellationToken.None;\n  return __awaiter(this, void 0, void 0, function* () {\n    const defaultReplaceRange = getDefaultRange(position, model);\n    const providers = InlineCompletionsProviderRegistry.all(model);\n    const results = yield Promise.all(providers.map(provider => __awaiter(this, void 0, void 0, function* () {\n      const completions = yield provider.provideInlineCompletions(model, position, context, token);\n      return {\n        completions,\n        provider,\n        dispose: () => {\n          if (completions) {\n            provider.freeInlineCompletions(completions);\n          }\n        }\n      };\n    })));\n    const itemsByHash = new Map();\n\n    for (const result of results) {\n      const completions = result.completions;\n\n      if (completions) {\n        for (const item of completions.items.map(item => ({\n          text: item.text,\n          range: item.range ? Range.lift(item.range) : defaultReplaceRange,\n          command: item.command,\n          sourceProvider: result.provider,\n          sourceInlineCompletions: completions,\n          sourceInlineCompletion: item\n        }))) {\n          if (item.range.startLineNumber !== item.range.endLineNumber) {\n            // Ignore invalid ranges.\n            continue;\n          }\n\n          itemsByHash.set(JSON.stringify({\n            text: item.text,\n            range: item.range\n          }), item);\n        }\n      }\n    }\n\n    return {\n      items: [...itemsByHash.values()],\n      dispose: () => {\n        for (const result of results) {\n          result.dispose();\n        }\n      }\n    };\n  });\n}\nexport function minimizeInlineCompletion(model, inlineCompletion) {\n  if (!inlineCompletion) {\n    return inlineCompletion;\n  }\n\n  const valueToReplace = model.getValueInRange(inlineCompletion.range);\n  const commonPrefixLen = commonPrefixLength(valueToReplace, inlineCompletion.text);\n  const startOffset = model.getOffsetAt(inlineCompletion.range.getStartPosition()) + commonPrefixLen;\n  const start = model.getPositionAt(startOffset);\n  const remainingValueToReplace = valueToReplace.substr(commonPrefixLen);\n  const commonSuffixLen = commonSuffixLength(remainingValueToReplace, inlineCompletion.text);\n  const end = model.getPositionAt(Math.max(startOffset, model.getOffsetAt(inlineCompletion.range.getEndPosition()) - commonSuffixLen));\n  return {\n    range: Range.fromPositions(start, end),\n    text: inlineCompletion.text.substr(commonPrefixLen, inlineCompletion.text.length - commonPrefixLen - commonSuffixLen)\n  };\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/inlineCompletionsModel.js"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","createCancelablePromise","RunOnceScheduler","CancellationToken","onUnexpectedError","onUnexpectedExternalError","Emitter","Disposable","MutableDisposable","toDisposable","commonPrefixLength","commonSuffixLength","CoreEditingCommands","RedoCommand","UndoCommand","EditOperation","Range","InlineCompletionsProviderRegistry","InlineCompletionTriggerKind","BaseGhostTextWidgetModel","ICommandService","inlineSuggestCommitId","inlineCompletionToGhostText","InlineCompletionsModel","constructor","editor","cache","commandService","onDidChangeEmitter","onDidChange","event","completionSession","_register","active","disposed","onDidExecuteCommand","commands","Set","id","Tab","DeleteLeft","DeleteRight","has","commandId","hasTextFocus","handleUserInput","onDidType","onDidChangeCursorPosition","session","isValid","hide","onDidBlurEditorWidget","setTimeout","startSessionIfTriggered","ghostText","_a","minReservedLineCount","setExpanded","expanded","setActive","scheduleAutomaticUpdate","suggestOptions","getOption","enabled","trigger","Automatic","triggerKind","Explicit","ensureUpdateWithExplicitContext","InlineCompletionsSession","getPosition","takeOwnership","fire","clear","commitCurrentSuggestion","commitCurrentCompletion","showNext","showNextInlineCompletion","showPrevious","showPreviousInlineCompletion","hasMultipleInlineCompletions","undefined","triggerPosition","shouldUpdate","initialTriggerKind","updateOperation","updateSoon","update","currentlySelectedCompletionId","lastCompletionItem","currentCompletion","sourceInlineCompletion","provider","sourceProvider","handleItemDidShow","sourceInlineCompletions","onDidChangeModelContent","schedule","fixAndGetIndexOfCurrentSelection","completions","idx","findIndex","v","semanticId","currentCachedCompletion","newIdx","promise","mode","getOptions","get","getModel","completion","toLiveInlineCompletion","lineNumber","position","token","provideInlineCompletions","selectedSuggestionInfo","isCancellationRequested","setValue","operation","UpdateOperation","disposable","commit","clearAndLeak","executeEdits","replaceMove","range","text","command","executeCommand","finally","dispose","cancel","SynchronizedInlineCompletionsCache","completionsSource","onChange","decorationIds","deltaDecorations","items","map","options","description","CachedInlineCompletion","hasChanged","model","newRange","getDecorationRange","decorationId","Error","synchronizedRange","equalsRange","inlineCompletion","JSON","stringify","startLine","startLineNumber","startColumn","getDefaultRange","word","getWordAtPosition","maxColumn","getLineMaxColumn","fromPositions","with","context","None","defaultReplaceRange","providers","all","results","freeInlineCompletions","itemsByHash","Map","item","lift","endLineNumber","set","values","minimizeInlineCompletion","valueToReplace","getValueInRange","commonPrefixLen","startOffset","getOffsetAt","getStartPosition","start","getPositionAt","remainingValueToReplace","substr","commonSuffixLen","end","Math","max","getEndPosition"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { createCancelablePromise, RunOnceScheduler } from '../../../base/common/async.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { onUnexpectedError, onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { commonPrefixLength, commonSuffixLength } from '../../../base/common/strings.js';\nimport { CoreEditingCommands } from '../../browser/controller/coreCommands.js';\nimport { RedoCommand, UndoCommand } from '../../browser/editorExtensions.js';\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Range } from '../../common/core/range.js';\nimport { InlineCompletionsProviderRegistry, InlineCompletionTriggerKind } from '../../common/modes.js';\nimport { BaseGhostTextWidgetModel } from './ghostText.js';\nimport { ICommandService } from '../../../platform/commands/common/commands.js';\nimport { inlineSuggestCommitId } from './consts.js';\nimport { inlineCompletionToGhostText } from './inlineCompletionToGhostText.js';\nlet InlineCompletionsModel = class InlineCompletionsModel extends Disposable {\n    constructor(editor, cache, commandService) {\n        super();\n        this.editor = editor;\n        this.cache = cache;\n        this.commandService = commandService;\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.completionSession = this._register(new MutableDisposable());\n        this.active = false;\n        this.disposed = false;\n        this._register(commandService.onDidExecuteCommand(e => {\n            // These commands don't trigger onDidType.\n            const commands = new Set([\n                UndoCommand.id,\n                RedoCommand.id,\n                CoreEditingCommands.Tab.id,\n                CoreEditingCommands.DeleteLeft.id,\n                CoreEditingCommands.DeleteRight.id,\n                inlineSuggestCommitId,\n                'acceptSelectedSuggestion'\n            ]);\n            if (commands.has(e.commandId) && editor.hasTextFocus()) {\n                this.handleUserInput();\n            }\n        }));\n        this._register(this.editor.onDidType((e) => {\n            this.handleUserInput();\n        }));\n        this._register(this.editor.onDidChangeCursorPosition((e) => {\n            if (this.session && !this.session.isValid) {\n                this.hide();\n            }\n        }));\n        this._register(toDisposable(() => {\n            this.disposed = true;\n        }));\n        this._register(this.editor.onDidBlurEditorWidget(() => {\n            this.hide();\n        }));\n    }\n    handleUserInput() {\n        if (this.session && !this.session.isValid) {\n            this.hide();\n        }\n        setTimeout(() => {\n            if (this.disposed) {\n                return;\n            }\n            // Wait for the cursor update that happens in the same iteration loop iteration\n            this.startSessionIfTriggered();\n        }, 0);\n    }\n    get session() {\n        return this.completionSession.value;\n    }\n    get ghostText() {\n        var _a;\n        return (_a = this.session) === null || _a === void 0 ? void 0 : _a.ghostText;\n    }\n    get minReservedLineCount() {\n        return this.session ? this.session.minReservedLineCount : 0;\n    }\n    setExpanded(expanded) {\n        var _a;\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.setExpanded(expanded);\n    }\n    setActive(active) {\n        var _a;\n        this.active = active;\n        if (active) {\n            (_a = this.session) === null || _a === void 0 ? void 0 : _a.scheduleAutomaticUpdate();\n        }\n    }\n    startSessionIfTriggered() {\n        const suggestOptions = this.editor.getOption(54 /* inlineSuggest */);\n        if (!suggestOptions.enabled) {\n            return;\n        }\n        if (this.session && this.session.isValid) {\n            return;\n        }\n        this.trigger(InlineCompletionTriggerKind.Automatic);\n    }\n    trigger(triggerKind) {\n        if (this.completionSession.value) {\n            if (triggerKind === InlineCompletionTriggerKind.Explicit) {\n                void this.completionSession.value.ensureUpdateWithExplicitContext();\n            }\n            return;\n        }\n        this.completionSession.value = new InlineCompletionsSession(this.editor, this.editor.getPosition(), () => this.active, this.commandService, this.cache, triggerKind);\n        this.completionSession.value.takeOwnership(this.completionSession.value.onDidChange(() => {\n            this.onDidChangeEmitter.fire();\n        }));\n    }\n    hide() {\n        this.completionSession.clear();\n        this.onDidChangeEmitter.fire();\n    }\n    commitCurrentSuggestion() {\n        var _a;\n        // Don't dispose the session, so that after committing, more suggestions are shown.\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.commitCurrentCompletion();\n    }\n    showNext() {\n        var _a;\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.showNextInlineCompletion();\n    }\n    showPrevious() {\n        var _a;\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.showPreviousInlineCompletion();\n    }\n    hasMultipleInlineCompletions() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield ((_a = this.session) === null || _a === void 0 ? void 0 : _a.hasMultipleInlineCompletions());\n            return result !== undefined ? result : false;\n        });\n    }\n};\nInlineCompletionsModel = __decorate([\n    __param(2, ICommandService)\n], InlineCompletionsModel);\nexport { InlineCompletionsModel };\nexport class InlineCompletionsSession extends BaseGhostTextWidgetModel {\n    constructor(editor, triggerPosition, shouldUpdate, commandService, cache, initialTriggerKind) {\n        super(editor);\n        this.triggerPosition = triggerPosition;\n        this.shouldUpdate = shouldUpdate;\n        this.commandService = commandService;\n        this.cache = cache;\n        this.initialTriggerKind = initialTriggerKind;\n        this.minReservedLineCount = 0;\n        this.updateOperation = this._register(new MutableDisposable());\n        this.updateSoon = this._register(new RunOnceScheduler(() => {\n            let triggerKind = this.initialTriggerKind;\n            // All subsequent triggers are automatic.\n            this.initialTriggerKind = InlineCompletionTriggerKind.Automatic;\n            return this.update(triggerKind);\n        }, 50));\n        //#region Selection\n        // We use a semantic id to track the selection even if the cache changes.\n        this.currentlySelectedCompletionId = undefined;\n        let lastCompletionItem = undefined;\n        this._register(this.onDidChange(() => {\n            const currentCompletion = this.currentCompletion;\n            if (currentCompletion && currentCompletion.sourceInlineCompletion !== lastCompletionItem) {\n                lastCompletionItem = currentCompletion.sourceInlineCompletion;\n                const provider = currentCompletion.sourceProvider;\n                if (provider.handleItemDidShow) {\n                    provider.handleItemDidShow(currentCompletion.sourceInlineCompletions, lastCompletionItem);\n                }\n            }\n        }));\n        this._register(toDisposable(() => {\n            this.cache.clear();\n        }));\n        this._register(this.editor.onDidChangeCursorPosition((e) => {\n            if (this.cache.value) {\n                this.onDidChangeEmitter.fire();\n            }\n        }));\n        this._register(this.editor.onDidChangeModelContent((e) => {\n            this.scheduleAutomaticUpdate();\n        }));\n        this._register(InlineCompletionsProviderRegistry.onDidChange(() => {\n            this.updateSoon.schedule();\n        }));\n        this.scheduleAutomaticUpdate();\n    }\n    fixAndGetIndexOfCurrentSelection() {\n        if (!this.currentlySelectedCompletionId || !this.cache.value) {\n            return 0;\n        }\n        if (this.cache.value.completions.length === 0) {\n            // don't reset the selection in this case\n            return 0;\n        }\n        const idx = this.cache.value.completions.findIndex(v => v.semanticId === this.currentlySelectedCompletionId);\n        if (idx === -1) {\n            // Reset the selection so that the selection does not jump back when it appears again\n            this.currentlySelectedCompletionId = undefined;\n            return 0;\n        }\n        return idx;\n    }\n    get currentCachedCompletion() {\n        if (!this.cache.value) {\n            return undefined;\n        }\n        return this.cache.value.completions[this.fixAndGetIndexOfCurrentSelection()];\n    }\n    showNextInlineCompletion() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.ensureUpdateWithExplicitContext();\n            const completions = ((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.completions) || [];\n            if (completions.length > 0) {\n                const newIdx = (this.fixAndGetIndexOfCurrentSelection() + 1) % completions.length;\n                this.currentlySelectedCompletionId = completions[newIdx].semanticId;\n            }\n            else {\n                this.currentlySelectedCompletionId = undefined;\n            }\n            this.onDidChangeEmitter.fire();\n        });\n    }\n    showPreviousInlineCompletion() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.ensureUpdateWithExplicitContext();\n            const completions = ((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.completions) || [];\n            if (completions.length > 0) {\n                const newIdx = (this.fixAndGetIndexOfCurrentSelection() + completions.length - 1) % completions.length;\n                this.currentlySelectedCompletionId = completions[newIdx].semanticId;\n            }\n            else {\n                this.currentlySelectedCompletionId = undefined;\n            }\n            this.onDidChangeEmitter.fire();\n        });\n    }\n    ensureUpdateWithExplicitContext() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.updateOperation.value) {\n                // Restart or wait for current update operation\n                if (this.updateOperation.value.triggerKind === InlineCompletionTriggerKind.Explicit) {\n                    yield this.updateOperation.value.promise;\n                }\n                else {\n                    yield this.update(InlineCompletionTriggerKind.Explicit);\n                }\n            }\n            else if (((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.triggerKind) !== InlineCompletionTriggerKind.Explicit) {\n                // Refresh cache\n                yield this.update(InlineCompletionTriggerKind.Explicit);\n            }\n        });\n    }\n    hasMultipleInlineCompletions() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.ensureUpdateWithExplicitContext();\n            return (((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.completions.length) || 0) > 1;\n        });\n    }\n    //#endregion\n    get ghostText() {\n        const currentCompletion = this.currentCompletion;\n        const mode = this.editor.getOptions().get(54 /* inlineSuggest */).mode;\n        return currentCompletion ? inlineCompletionToGhostText(currentCompletion, this.editor.getModel(), mode, this.editor.getPosition()) : undefined;\n    }\n    get currentCompletion() {\n        const completion = this.currentCachedCompletion;\n        if (!completion) {\n            return undefined;\n        }\n        return completion.toLiveInlineCompletion();\n    }\n    get isValid() {\n        return this.editor.getPosition().lineNumber === this.triggerPosition.lineNumber;\n    }\n    scheduleAutomaticUpdate() {\n        // Since updateSoon debounces, starvation can happen.\n        // To prevent stale cache, we clear the current update operation.\n        this.updateOperation.clear();\n        this.updateSoon.schedule();\n    }\n    update(triggerKind) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.shouldUpdate()) {\n                return;\n            }\n            const position = this.editor.getPosition();\n            const promise = createCancelablePromise((token) => __awaiter(this, void 0, void 0, function* () {\n                let result;\n                try {\n                    result = yield provideInlineCompletions(position, this.editor.getModel(), { triggerKind, selectedSuggestionInfo: undefined }, token);\n                }\n                catch (e) {\n                    onUnexpectedError(e);\n                    return;\n                }\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                this.cache.setValue(this.editor, result, triggerKind);\n                this.onDidChangeEmitter.fire();\n            }));\n            const operation = new UpdateOperation(promise, triggerKind);\n            this.updateOperation.value = operation;\n            yield promise;\n            if (this.updateOperation.value === operation) {\n                this.updateOperation.clear();\n            }\n        });\n    }\n    takeOwnership(disposable) {\n        this._register(disposable);\n    }\n    commitCurrentCompletion() {\n        if (!this.ghostText) {\n            // No ghost text was shown for this completion.\n            // Thus, we don't want to commit anything.\n            return;\n        }\n        const completion = this.currentCompletion;\n        if (completion) {\n            this.commit(completion);\n        }\n    }\n    commit(completion) {\n        // Mark the cache as stale, but don't dispose it yet,\n        // otherwise command args might get disposed.\n        const cache = this.cache.clearAndLeak();\n        this.editor.executeEdits('inlineSuggestion.accept', [\n            EditOperation.replaceMove(completion.range, completion.text)\n        ]);\n        if (completion.command) {\n            this.commandService\n                .executeCommand(completion.command.id, ...(completion.command.arguments || []))\n                .finally(() => {\n                cache === null || cache === void 0 ? void 0 : cache.dispose();\n            })\n                .then(undefined, onUnexpectedExternalError);\n        }\n        else {\n            cache === null || cache === void 0 ? void 0 : cache.dispose();\n        }\n        this.onDidChangeEmitter.fire();\n    }\n}\nexport class UpdateOperation {\n    constructor(promise, triggerKind) {\n        this.promise = promise;\n        this.triggerKind = triggerKind;\n    }\n    dispose() {\n        this.promise.cancel();\n    }\n}\n/**\n * The cache keeps itself in sync with the editor.\n * It also owns the completions result and disposes it when the cache is diposed.\n*/\nexport class SynchronizedInlineCompletionsCache extends Disposable {\n    constructor(editor, completionsSource, onChange, triggerKind) {\n        super();\n        this.triggerKind = triggerKind;\n        const decorationIds = editor.deltaDecorations([], completionsSource.items.map(i => ({\n            range: i.range,\n            options: {\n                description: 'inline-completion-tracking-range'\n            },\n        })));\n        this._register(toDisposable(() => {\n            editor.deltaDecorations(decorationIds, []);\n        }));\n        this.completions = completionsSource.items.map((c, idx) => new CachedInlineCompletion(c, decorationIds[idx]));\n        this._register(editor.onDidChangeModelContent(() => {\n            let hasChanged = false;\n            const model = editor.getModel();\n            for (const c of this.completions) {\n                const newRange = model.getDecorationRange(c.decorationId);\n                if (!newRange) {\n                    onUnexpectedError(new Error('Decoration has no range'));\n                    continue;\n                }\n                if (!c.synchronizedRange.equalsRange(newRange)) {\n                    hasChanged = true;\n                    c.synchronizedRange = newRange;\n                }\n            }\n            if (hasChanged) {\n                onChange();\n            }\n        }));\n        this._register(completionsSource);\n    }\n}\nclass CachedInlineCompletion {\n    constructor(inlineCompletion, decorationId) {\n        this.inlineCompletion = inlineCompletion;\n        this.decorationId = decorationId;\n        this.semanticId = JSON.stringify({\n            text: this.inlineCompletion.text,\n            startLine: this.inlineCompletion.range.startLineNumber,\n            startColumn: this.inlineCompletion.range.startColumn,\n            command: this.inlineCompletion.command\n        });\n        this.synchronizedRange = inlineCompletion.range;\n    }\n    toLiveInlineCompletion() {\n        return {\n            text: this.inlineCompletion.text,\n            range: this.synchronizedRange,\n            command: this.inlineCompletion.command,\n            sourceProvider: this.inlineCompletion.sourceProvider,\n            sourceInlineCompletions: this.inlineCompletion.sourceInlineCompletions,\n            sourceInlineCompletion: this.inlineCompletion.sourceInlineCompletion,\n        };\n    }\n}\nfunction getDefaultRange(position, model) {\n    const word = model.getWordAtPosition(position);\n    const maxColumn = model.getLineMaxColumn(position.lineNumber);\n    // By default, always replace up until the end of the current line.\n    // This default might be subject to change!\n    return word\n        ? new Range(position.lineNumber, word.startColumn, position.lineNumber, maxColumn)\n        : Range.fromPositions(position, position.with(undefined, maxColumn));\n}\nexport function provideInlineCompletions(position, model, context, token = CancellationToken.None) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const defaultReplaceRange = getDefaultRange(position, model);\n        const providers = InlineCompletionsProviderRegistry.all(model);\n        const results = yield Promise.all(providers.map((provider) => __awaiter(this, void 0, void 0, function* () {\n            const completions = yield provider.provideInlineCompletions(model, position, context, token);\n            return ({\n                completions,\n                provider,\n                dispose: () => {\n                    if (completions) {\n                        provider.freeInlineCompletions(completions);\n                    }\n                }\n            });\n        })));\n        const itemsByHash = new Map();\n        for (const result of results) {\n            const completions = result.completions;\n            if (completions) {\n                for (const item of completions.items.map(item => ({\n                    text: item.text,\n                    range: item.range ? Range.lift(item.range) : defaultReplaceRange,\n                    command: item.command,\n                    sourceProvider: result.provider,\n                    sourceInlineCompletions: completions,\n                    sourceInlineCompletion: item\n                }))) {\n                    if (item.range.startLineNumber !== item.range.endLineNumber) {\n                        // Ignore invalid ranges.\n                        continue;\n                    }\n                    itemsByHash.set(JSON.stringify({ text: item.text, range: item.range }), item);\n                }\n            }\n        }\n        return {\n            items: [...itemsByHash.values()],\n            dispose: () => {\n                for (const result of results) {\n                    result.dispose();\n                }\n            },\n        };\n    });\n}\nexport function minimizeInlineCompletion(model, inlineCompletion) {\n    if (!inlineCompletion) {\n        return inlineCompletion;\n    }\n    const valueToReplace = model.getValueInRange(inlineCompletion.range);\n    const commonPrefixLen = commonPrefixLength(valueToReplace, inlineCompletion.text);\n    const startOffset = model.getOffsetAt(inlineCompletion.range.getStartPosition()) + commonPrefixLen;\n    const start = model.getPositionAt(startOffset);\n    const remainingValueToReplace = valueToReplace.substr(commonPrefixLen);\n    const commonSuffixLen = commonSuffixLength(remainingValueToReplace, inlineCompletion.text);\n    const end = model.getPositionAt(Math.max(startOffset, model.getOffsetAt(inlineCompletion.range.getEndPosition()) - commonSuffixLen));\n    return {\n        range: Range.fromPositions(start, end),\n        text: inlineCompletion.text.substr(commonPrefixLen, inlineCompletion.text.length - commonPrefixLen - commonSuffixLen),\n    };\n}\n"]},"metadata":{},"sourceType":"module"}