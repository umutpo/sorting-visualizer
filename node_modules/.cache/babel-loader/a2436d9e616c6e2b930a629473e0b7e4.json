{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns, SingleCursorState } from './cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { AtomicTabMoveOperations } from './cursorAtomicMoveOperations.js';\nexport class CursorPosition {\n  constructor(lineNumber, column, leftoverVisibleColumns) {\n    this._cursorPositionBrand = undefined;\n    this.lineNumber = lineNumber;\n    this.column = column;\n    this.leftoverVisibleColumns = leftoverVisibleColumns;\n  }\n\n}\nexport class MoveOperations {\n  static leftPosition(model, position) {\n    if (position.column > model.getLineMinColumn(position.lineNumber)) {\n      return position.delta(undefined, -strings.prevCharLength(model.getLineContent(position.lineNumber), position.column - 1));\n    } else if (position.lineNumber > 1) {\n      const newLineNumber = position.lineNumber - 1;\n      return new Position(newLineNumber, model.getLineMaxColumn(newLineNumber));\n    } else {\n      return position;\n    }\n  }\n\n  static leftPositionAtomicSoftTabs(model, position, tabSize) {\n    if (position.column <= model.getLineIndentColumn(position.lineNumber)) {\n      const minColumn = model.getLineMinColumn(position.lineNumber);\n      const lineContent = model.getLineContent(position.lineNumber);\n      const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 0\n      /* Left */\n      );\n\n      if (newPosition !== -1 && newPosition + 1 >= minColumn) {\n        return new Position(position.lineNumber, newPosition + 1);\n      }\n    }\n\n    return this.leftPosition(model, position);\n  }\n\n  static left(config, model, position) {\n    const pos = config.stickyTabStops ? MoveOperations.leftPositionAtomicSoftTabs(model, position, config.tabSize) : MoveOperations.leftPosition(model, position);\n    return new CursorPosition(pos.lineNumber, pos.column, 0);\n  }\n  /**\n   * @param noOfColumns Must be either `1`\n   * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).\n  */\n\n\n  static moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {\n    let lineNumber, column;\n\n    if (cursor.hasSelection() && !inSelectionMode) {\n      // If the user has a selection and does not want to extend it,\n      // put the cursor at the beginning of the selection.\n      lineNumber = cursor.selection.startLineNumber;\n      column = cursor.selection.startColumn;\n    } else {\n      // This has no effect if noOfColumns === 1.\n      // It is ok to do so in the half-line scenario.\n      const pos = cursor.position.delta(undefined, -(noOfColumns - 1)); // We clip the position before normalization, as normalization is not defined\n      // for possibly negative columns.\n\n      const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 0\n      /* Left */\n      );\n      const p = MoveOperations.left(config, model, normalizedPos);\n      lineNumber = p.lineNumber;\n      column = p.column;\n    }\n\n    return cursor.move(inSelectionMode, lineNumber, column, 0);\n  }\n  /**\n   * Adjusts the column so that it is within min/max of the line.\n  */\n\n\n  static clipPositionColumn(position, model) {\n    return new Position(position.lineNumber, MoveOperations.clipRange(position.column, model.getLineMinColumn(position.lineNumber), model.getLineMaxColumn(position.lineNumber)));\n  }\n\n  static clipRange(value, min, max) {\n    if (value < min) {\n      return min;\n    }\n\n    if (value > max) {\n      return max;\n    }\n\n    return value;\n  }\n\n  static rightPosition(model, lineNumber, column) {\n    if (column < model.getLineMaxColumn(lineNumber)) {\n      column = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n    } else if (lineNumber < model.getLineCount()) {\n      lineNumber = lineNumber + 1;\n      column = model.getLineMinColumn(lineNumber);\n    }\n\n    return new Position(lineNumber, column);\n  }\n\n  static rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {\n    if (column < model.getLineIndentColumn(lineNumber)) {\n      const lineContent = model.getLineContent(lineNumber);\n      const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 1\n      /* Right */\n      );\n\n      if (newPosition !== -1) {\n        return new Position(lineNumber, newPosition + 1);\n      }\n    }\n\n    return this.rightPosition(model, lineNumber, column);\n  }\n\n  static right(config, model, position) {\n    const pos = config.stickyTabStops ? MoveOperations.rightPositionAtomicSoftTabs(model, position.lineNumber, position.column, config.tabSize, config.indentSize) : MoveOperations.rightPosition(model, position.lineNumber, position.column);\n    return new CursorPosition(pos.lineNumber, pos.column, 0);\n  }\n\n  static moveRight(config, model, cursor, inSelectionMode, noOfColumns) {\n    let lineNumber, column;\n\n    if (cursor.hasSelection() && !inSelectionMode) {\n      // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n      lineNumber = cursor.selection.endLineNumber;\n      column = cursor.selection.endColumn;\n    } else {\n      const pos = cursor.position.delta(undefined, noOfColumns - 1);\n      const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 1\n      /* Right */\n      );\n      const r = MoveOperations.right(config, model, normalizedPos);\n      lineNumber = r.lineNumber;\n      column = r.column;\n    }\n\n    return cursor.move(inSelectionMode, lineNumber, column, 0);\n  }\n\n  static vertical(config, model, lineNumber, column, leftoverVisibleColumns, newLineNumber, allowMoveOnEdgeLine) {\n    const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n    const lineCount = model.getLineCount();\n    const wasOnFirstPosition = lineNumber === 1 && column === 1;\n    const wasOnLastPosition = lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber);\n    const wasAtEdgePosition = newLineNumber < lineNumber ? wasOnFirstPosition : wasOnLastPosition;\n    lineNumber = newLineNumber;\n\n    if (lineNumber < 1) {\n      lineNumber = 1;\n\n      if (allowMoveOnEdgeLine) {\n        column = model.getLineMinColumn(lineNumber);\n      } else {\n        column = Math.min(model.getLineMaxColumn(lineNumber), column);\n      }\n    } else if (lineNumber > lineCount) {\n      lineNumber = lineCount;\n\n      if (allowMoveOnEdgeLine) {\n        column = model.getLineMaxColumn(lineNumber);\n      } else {\n        column = Math.min(model.getLineMaxColumn(lineNumber), column);\n      }\n    } else {\n      column = CursorColumns.columnFromVisibleColumn2(config, model, lineNumber, currentVisibleColumn);\n    }\n\n    if (wasAtEdgePosition) {\n      leftoverVisibleColumns = 0;\n    } else {\n      leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n    }\n\n    return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n  }\n\n  static down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {\n    return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber + count, allowMoveOnLastLine);\n  }\n\n  static moveDown(config, model, cursor, inSelectionMode, linesCount) {\n    let lineNumber, column;\n\n    if (cursor.hasSelection() && !inSelectionMode) {\n      // If we are in selection mode, move down acts relative to the end of selection\n      lineNumber = cursor.selection.endLineNumber;\n      column = cursor.selection.endColumn;\n    } else {\n      lineNumber = cursor.position.lineNumber;\n      column = cursor.position.column;\n    }\n\n    let r = MoveOperations.down(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n    return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n  }\n\n  static translateDown(config, model, cursor) {\n    let selection = cursor.selection;\n    let selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n    let position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n    return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n  }\n\n  static up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {\n    return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber - count, allowMoveOnFirstLine);\n  }\n\n  static moveUp(config, model, cursor, inSelectionMode, linesCount) {\n    let lineNumber, column;\n\n    if (cursor.hasSelection() && !inSelectionMode) {\n      // If we are in selection mode, move up acts relative to the beginning of selection\n      lineNumber = cursor.selection.startLineNumber;\n      column = cursor.selection.startColumn;\n    } else {\n      lineNumber = cursor.position.lineNumber;\n      column = cursor.position.column;\n    }\n\n    let r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n    return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n  }\n\n  static translateUp(config, model, cursor) {\n    let selection = cursor.selection;\n    let selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n    let position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n    return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n  }\n\n  static _isBlankLine(model, lineNumber) {\n    if (model.getLineFirstNonWhitespaceColumn(lineNumber) === 0) {\n      // empty or contains only whitespace\n      return true;\n    }\n\n    return false;\n  }\n\n  static moveToPrevBlankLine(config, model, cursor, inSelectionMode) {\n    let lineNumber = cursor.position.lineNumber; // If our current line is blank, move to the previous non-blank line\n\n    while (lineNumber > 1 && this._isBlankLine(model, lineNumber)) {\n      lineNumber--;\n    } // Find the previous blank line\n\n\n    while (lineNumber > 1 && !this._isBlankLine(model, lineNumber)) {\n      lineNumber--;\n    }\n\n    return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n  }\n\n  static moveToNextBlankLine(config, model, cursor, inSelectionMode) {\n    const lineCount = model.getLineCount();\n    let lineNumber = cursor.position.lineNumber; // If our current line is blank, move to the next non-blank line\n\n    while (lineNumber < lineCount && this._isBlankLine(model, lineNumber)) {\n      lineNumber++;\n    } // Find the next blank line\n\n\n    while (lineNumber < lineCount && !this._isBlankLine(model, lineNumber)) {\n      lineNumber++;\n    }\n\n    return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n  }\n\n  static moveToBeginningOfLine(config, model, cursor, inSelectionMode) {\n    let lineNumber = cursor.position.lineNumber;\n    let minColumn = model.getLineMinColumn(lineNumber);\n    let firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n    let column;\n    let relevantColumnNumber = cursor.position.column;\n\n    if (relevantColumnNumber === firstNonBlankColumn) {\n      column = minColumn;\n    } else {\n      column = firstNonBlankColumn;\n    }\n\n    return cursor.move(inSelectionMode, lineNumber, column, 0);\n  }\n\n  static moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {\n    let lineNumber = cursor.position.lineNumber;\n    let maxColumn = model.getLineMaxColumn(lineNumber);\n    return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    - maxColumn : 0);\n  }\n\n  static moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {\n    return cursor.move(inSelectionMode, 1, 1, 0);\n  }\n\n  static moveToEndOfBuffer(config, model, cursor, inSelectionMode) {\n    let lastLineNumber = model.getLineCount();\n    let lastColumn = model.getLineMaxColumn(lastLineNumber);\n    return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n  }\n\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/common/controller/cursorMoveOperations.js"],"names":["CursorColumns","SingleCursorState","Position","Range","strings","AtomicTabMoveOperations","CursorPosition","constructor","lineNumber","column","leftoverVisibleColumns","_cursorPositionBrand","undefined","MoveOperations","leftPosition","model","position","getLineMinColumn","delta","prevCharLength","getLineContent","newLineNumber","getLineMaxColumn","leftPositionAtomicSoftTabs","tabSize","getLineIndentColumn","minColumn","lineContent","newPosition","atomicPosition","left","config","pos","stickyTabStops","moveLeft","cursor","inSelectionMode","noOfColumns","hasSelection","selection","startLineNumber","startColumn","normalizedPos","normalizePosition","clipPositionColumn","p","move","clipRange","value","min","max","rightPosition","nextCharLength","getLineCount","rightPositionAtomicSoftTabs","indentSize","right","moveRight","endLineNumber","endColumn","r","vertical","allowMoveOnEdgeLine","currentVisibleColumn","visibleColumnFromColumn","lineCount","wasOnFirstPosition","wasOnLastPosition","wasAtEdgePosition","Math","columnFromVisibleColumn2","down","count","allowMoveOnLastLine","moveDown","linesCount","translateDown","selectionStart","selectionStartLineNumber","selectionStartColumn","selectionStartLeftoverVisibleColumns","positionLineNumber","positionColumn","up","allowMoveOnFirstLine","moveUp","translateUp","_isBlankLine","getLineFirstNonWhitespaceColumn","moveToPrevBlankLine","moveToNextBlankLine","moveToBeginningOfLine","firstNonBlankColumn","relevantColumnNumber","moveToEndOfLine","sticky","maxColumn","moveToBeginningOfBuffer","moveToEndOfBuffer","lastLineNumber","lastColumn"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns, SingleCursorState } from './cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { AtomicTabMoveOperations } from './cursorAtomicMoveOperations.js';\nexport class CursorPosition {\n    constructor(lineNumber, column, leftoverVisibleColumns) {\n        this._cursorPositionBrand = undefined;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n    }\n}\nexport class MoveOperations {\n    static leftPosition(model, position) {\n        if (position.column > model.getLineMinColumn(position.lineNumber)) {\n            return position.delta(undefined, -strings.prevCharLength(model.getLineContent(position.lineNumber), position.column - 1));\n        }\n        else if (position.lineNumber > 1) {\n            const newLineNumber = position.lineNumber - 1;\n            return new Position(newLineNumber, model.getLineMaxColumn(newLineNumber));\n        }\n        else {\n            return position;\n        }\n    }\n    static leftPositionAtomicSoftTabs(model, position, tabSize) {\n        if (position.column <= model.getLineIndentColumn(position.lineNumber)) {\n            const minColumn = model.getLineMinColumn(position.lineNumber);\n            const lineContent = model.getLineContent(position.lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 0 /* Left */);\n            if (newPosition !== -1 && newPosition + 1 >= minColumn) {\n                return new Position(position.lineNumber, newPosition + 1);\n            }\n        }\n        return this.leftPosition(model, position);\n    }\n    static left(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.leftPositionAtomicSoftTabs(model, position, config.tabSize)\n            : MoveOperations.leftPosition(model, position);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    /**\n     * @param noOfColumns Must be either `1`\n     * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).\n    */\n    static moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If the user has a selection and does not want to extend it,\n            // put the cursor at the beginning of the selection.\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            // This has no effect if noOfColumns === 1.\n            // It is ok to do so in the half-line scenario.\n            const pos = cursor.position.delta(undefined, -(noOfColumns - 1));\n            // We clip the position before normalization, as normalization is not defined\n            // for possibly negative columns.\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 0 /* Left */);\n            const p = MoveOperations.left(config, model, normalizedPos);\n            lineNumber = p.lineNumber;\n            column = p.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    /**\n     * Adjusts the column so that it is within min/max of the line.\n    */\n    static clipPositionColumn(position, model) {\n        return new Position(position.lineNumber, MoveOperations.clipRange(position.column, model.getLineMinColumn(position.lineNumber), model.getLineMaxColumn(position.lineNumber)));\n    }\n    static clipRange(value, min, max) {\n        if (value < min) {\n            return min;\n        }\n        if (value > max) {\n            return max;\n        }\n        return value;\n    }\n    static rightPosition(model, lineNumber, column) {\n        if (column < model.getLineMaxColumn(lineNumber)) {\n            column = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n        }\n        else if (lineNumber < model.getLineCount()) {\n            lineNumber = lineNumber + 1;\n            column = model.getLineMinColumn(lineNumber);\n        }\n        return new Position(lineNumber, column);\n    }\n    static rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {\n        if (column < model.getLineIndentColumn(lineNumber)) {\n            const lineContent = model.getLineContent(lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 1 /* Right */);\n            if (newPosition !== -1) {\n                return new Position(lineNumber, newPosition + 1);\n            }\n        }\n        return this.rightPosition(model, lineNumber, column);\n    }\n    static right(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.rightPositionAtomicSoftTabs(model, position.lineNumber, position.column, config.tabSize, config.indentSize)\n            : MoveOperations.rightPosition(model, position.lineNumber, position.column);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    static moveRight(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            const pos = cursor.position.delta(undefined, noOfColumns - 1);\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 1 /* Right */);\n            const r = MoveOperations.right(config, model, normalizedPos);\n            lineNumber = r.lineNumber;\n            column = r.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static vertical(config, model, lineNumber, column, leftoverVisibleColumns, newLineNumber, allowMoveOnEdgeLine) {\n        const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n        const lineCount = model.getLineCount();\n        const wasOnFirstPosition = (lineNumber === 1 && column === 1);\n        const wasOnLastPosition = (lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber));\n        const wasAtEdgePosition = (newLineNumber < lineNumber ? wasOnFirstPosition : wasOnLastPosition);\n        lineNumber = newLineNumber;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMinColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else if (lineNumber > lineCount) {\n            lineNumber = lineCount;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else {\n            column = CursorColumns.columnFromVisibleColumn2(config, model, lineNumber, currentVisibleColumn);\n        }\n        if (wasAtEdgePosition) {\n            leftoverVisibleColumns = 0;\n        }\n        else {\n            leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n        }\n        return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n    }\n    static down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber + count, allowMoveOnLastLine);\n    }\n    static moveDown(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move down acts relative to the end of selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        let r = MoveOperations.down(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateDown(config, model, cursor) {\n        let selection = cursor.selection;\n        let selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        let position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber - count, allowMoveOnFirstLine);\n    }\n    static moveUp(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move up acts relative to the beginning of selection\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        let r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateUp(config, model, cursor) {\n        let selection = cursor.selection;\n        let selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        let position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static _isBlankLine(model, lineNumber) {\n        if (model.getLineFirstNonWhitespaceColumn(lineNumber) === 0) {\n            // empty or contains only whitespace\n            return true;\n        }\n        return false;\n    }\n    static moveToPrevBlankLine(config, model, cursor, inSelectionMode) {\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the previous non-blank line\n        while (lineNumber > 1 && this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        // Find the previous blank line\n        while (lineNumber > 1 && !this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToNextBlankLine(config, model, cursor, inSelectionMode) {\n        const lineCount = model.getLineCount();\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the next non-blank line\n        while (lineNumber < lineCount && this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        // Find the next blank line\n        while (lineNumber < lineCount && !this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToBeginningOfLine(config, model, cursor, inSelectionMode) {\n        let lineNumber = cursor.position.lineNumber;\n        let minColumn = model.getLineMinColumn(lineNumber);\n        let firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n        let column;\n        let relevantColumnNumber = cursor.position.column;\n        if (relevantColumnNumber === firstNonBlankColumn) {\n            column = minColumn;\n        }\n        else {\n            column = firstNonBlankColumn;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {\n        let lineNumber = cursor.position.lineNumber;\n        let maxColumn = model.getLineMaxColumn(lineNumber);\n        return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824 /* MAX_SAFE_SMALL_INTEGER */ - maxColumn : 0);\n    }\n    static moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {\n        return cursor.move(inSelectionMode, 1, 1, 0);\n    }\n    static moveToEndOfBuffer(config, model, cursor, inSelectionMode) {\n        let lastLineNumber = model.getLineCount();\n        let lastColumn = model.getLineMaxColumn(lastLineNumber);\n        return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}