{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../base/browser/browser.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { TextAreaState, _debugComposition } from './textAreaState.js';\nimport { Position } from '../../common/core/position.js';\nimport { Selection } from '../../common/core/selection.js';\nexport var TextAreaSyntethicEvents;\n\n(function (TextAreaSyntethicEvents) {\n  TextAreaSyntethicEvents.Tap = '-monaco-textarea-synthetic-tap';\n})(TextAreaSyntethicEvents || (TextAreaSyntethicEvents = {}));\n\nexport const CopyOptions = {\n  forceCopyWithSyntaxHighlighting: false\n};\n/**\n * Every time we write to the clipboard, we record a bit of extra metadata here.\n * Every time we read from the cipboard, if the text matches our last written text,\n * we can fetch the previous metadata.\n */\n\nexport class InMemoryClipboardMetadataManager {\n  constructor() {\n    this._lastState = null;\n  }\n\n  set(lastCopiedValue, data) {\n    this._lastState = {\n      lastCopiedValue,\n      data\n    };\n  }\n\n  get(pastedText) {\n    if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\n      // match!\n      return this._lastState.data;\n    }\n\n    this._lastState = null;\n    return null;\n  }\n\n}\nInMemoryClipboardMetadataManager.INSTANCE = new InMemoryClipboardMetadataManager();\n/**\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\n *  - onCut\n *  - onPaste\n *  - onType\n *\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\n */\n\nexport class TextAreaInput extends Disposable {\n  constructor(host, textArea) {\n    super();\n    this.textArea = textArea;\n    this._onFocus = this._register(new Emitter());\n    this.onFocus = this._onFocus.event;\n    this._onBlur = this._register(new Emitter());\n    this.onBlur = this._onBlur.event;\n    this._onKeyDown = this._register(new Emitter());\n    this.onKeyDown = this._onKeyDown.event;\n    this._onKeyUp = this._register(new Emitter());\n    this.onKeyUp = this._onKeyUp.event;\n    this._onCut = this._register(new Emitter());\n    this.onCut = this._onCut.event;\n    this._onPaste = this._register(new Emitter());\n    this.onPaste = this._onPaste.event;\n    this._onType = this._register(new Emitter());\n    this.onType = this._onType.event;\n    this._onCompositionStart = this._register(new Emitter());\n    this.onCompositionStart = this._onCompositionStart.event;\n    this._onCompositionUpdate = this._register(new Emitter());\n    this.onCompositionUpdate = this._onCompositionUpdate.event;\n    this._onCompositionEnd = this._register(new Emitter());\n    this.onCompositionEnd = this._onCompositionEnd.event;\n    this._onSelectionChangeRequest = this._register(new Emitter());\n    this.onSelectionChangeRequest = this._onSelectionChangeRequest.event;\n    this._host = host;\n    this._textArea = this._register(new TextAreaWrapper(textArea));\n    this._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));\n    this._asyncFocusGainWriteScreenReaderContent = this._register(new RunOnceScheduler(() => this.writeScreenReaderContent('asyncFocusGain'), 0));\n    this._textAreaState = TextAreaState.EMPTY;\n    this._selectionChangeListener = null;\n    this.writeScreenReaderContent('ctor');\n    this._hasFocus = false;\n    this._isDoingComposition = false;\n    this._nextCommand = 0\n    /* Type */\n    ;\n    let lastKeyDown = null;\n\n    this._register(dom.addStandardDisposableListener(textArea.domNode, 'keydown', e => {\n      if (e.keyCode === 109\n      /* KEY_IN_COMPOSITION */\n      || this._isDoingComposition && e.keyCode === 1\n      /* Backspace */\n      ) {\n        // Stop propagation for keyDown events if the IME is processing key input\n        e.stopPropagation();\n      }\n\n      if (e.equals(9\n      /* Escape */\n      )) {\n        // Prevent default always for `Esc`, otherwise it will generate a keypress\n        // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n        e.preventDefault();\n      }\n\n      lastKeyDown = e;\n\n      this._onKeyDown.fire(e);\n    }));\n\n    this._register(dom.addStandardDisposableListener(textArea.domNode, 'keyup', e => {\n      this._onKeyUp.fire(e);\n    }));\n\n    this._register(dom.addDisposableListener(textArea.domNode, 'compositionstart', e => {\n      if (_debugComposition) {\n        console.log(`[compositionstart]`, e);\n      }\n\n      if (this._isDoingComposition) {\n        return;\n      }\n\n      this._isDoingComposition = true;\n\n      if (platform.isMacintosh && this._textAreaState.selectionStart === this._textAreaState.selectionEnd && this._textAreaState.selectionStart > 0 && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === e.data) {\n        const isArrowKey = lastKeyDown && lastKeyDown.equals(109\n        /* KEY_IN_COMPOSITION */\n        ) && (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft');\n\n        if (isArrowKey || browser.isFirefox) {\n          // Handling long press case on Chromium/Safari macOS + arrow key => pretend the character was selected\n          // or long press case on Firefox on macOS\n          if (_debugComposition) {\n            console.log(`[compositionstart] Handling long press case on macOS + arrow key or Firefox`, e);\n          }\n\n          this._textAreaState = new TextAreaState(this._textAreaState.value, this._textAreaState.selectionStart - 1, this._textAreaState.selectionEnd, this._textAreaState.selectionStartPosition ? new Position(this._textAreaState.selectionStartPosition.lineNumber, this._textAreaState.selectionStartPosition.column - 1) : null, this._textAreaState.selectionEndPosition);\n\n          this._onCompositionStart.fire({\n            revealDeltaColumns: -1\n          });\n\n          return;\n        }\n      }\n\n      if (browser.isAndroid) {\n        // when tapping on the editor, Android enters composition mode to edit the current word\n        // so we cannot clear the textarea on Android and we must pretend the current word was selected\n        this._onCompositionStart.fire({\n          revealDeltaColumns: -this._textAreaState.selectionStart\n        });\n\n        return;\n      }\n\n      this._setAndWriteTextAreaState('compositionstart', TextAreaState.EMPTY);\n\n      this._onCompositionStart.fire({\n        revealDeltaColumns: 0\n      });\n    }));\n    /**\n     * Deduce the typed input from a text area's value and the last observed state.\n     */\n\n\n    const deduceInputFromTextAreaValue = couldBeEmojiInput => {\n      const oldState = this._textAreaState;\n      const newState = TextAreaState.readFromTextArea(this._textArea);\n      return [newState, TextAreaState.deduceInput(oldState, newState, couldBeEmojiInput)];\n    };\n\n    const deduceAndroidCompositionInput = () => {\n      const oldState = this._textAreaState;\n      const newState = TextAreaState.readFromTextArea(this._textArea);\n      return [newState, TextAreaState.deduceAndroidCompositionInput(oldState, newState)];\n    };\n    /**\n     * Deduce the composition input from a string.\n     */\n\n\n    const deduceComposition = text => {\n      const oldState = this._textAreaState;\n      const newState = TextAreaState.selectedText(text);\n      const typeInput = {\n        text: newState.value,\n        replacePrevCharCnt: oldState.selectionEnd - oldState.selectionStart,\n        replaceNextCharCnt: 0,\n        positionDelta: 0\n      };\n      return [newState, typeInput];\n    };\n\n    this._register(dom.addDisposableListener(textArea.domNode, 'compositionupdate', e => {\n      if (_debugComposition) {\n        console.log(`[compositionupdate]`, e);\n      }\n\n      if (browser.isAndroid) {\n        // On Android, the data sent with the composition update event is unusable.\n        // For example, if the cursor is in the middle of a word like Mic|osoft\n        // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n        // This is not really usable because it doesn't tell us where the edit began and where it ended.\n        const [newState, typeInput] = deduceAndroidCompositionInput();\n        this._textAreaState = newState;\n\n        this._onType.fire(typeInput);\n\n        this._onCompositionUpdate.fire(e);\n\n        return;\n      }\n\n      const [newState, typeInput] = deduceComposition(e.data || '');\n      this._textAreaState = newState;\n\n      this._onType.fire(typeInput);\n\n      this._onCompositionUpdate.fire(e);\n    }));\n\n    this._register(dom.addDisposableListener(textArea.domNode, 'compositionend', e => {\n      if (_debugComposition) {\n        console.log(`[compositionend]`, e);\n      } // https://github.com/microsoft/monaco-editor/issues/1663\n      // On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\n\n\n      if (!this._isDoingComposition) {\n        return;\n      }\n\n      this._isDoingComposition = false;\n\n      if (browser.isAndroid) {\n        // On Android, the data sent with the composition update event is unusable.\n        // For example, if the cursor is in the middle of a word like Mic|osoft\n        // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n        // This is not really usable because it doesn't tell us where the edit began and where it ended.\n        const [newState, typeInput] = deduceAndroidCompositionInput();\n        this._textAreaState = newState;\n\n        this._onType.fire(typeInput);\n\n        this._onCompositionEnd.fire();\n\n        return;\n      }\n\n      const [newState, typeInput] = deduceComposition(e.data || '');\n      this._textAreaState = newState;\n\n      this._onType.fire(typeInput); // isChrome: the textarea is not updated correctly when composition ends\n      // isFirefox: the textarea is not updated correctly after inserting emojis\n      // => we cannot assume the text at the end consists only of the composited text\n\n\n      if (browser.isChrome || browser.isFirefox) {\n        this._textAreaState = TextAreaState.readFromTextArea(this._textArea);\n      }\n\n      this._onCompositionEnd.fire();\n    }));\n\n    this._register(dom.addDisposableListener(textArea.domNode, 'input', () => {\n      // Pretend here we touched the text area, as the `input` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      this._textArea.setIgnoreSelectionChangeTime('received input event');\n\n      if (this._isDoingComposition) {\n        return;\n      }\n\n      const [newState, typeInput] = deduceInputFromTextAreaValue(\n      /*couldBeEmojiInput*/\n      platform.isMacintosh);\n\n      if (typeInput.replacePrevCharCnt === 0 && typeInput.text.length === 1 && strings.isHighSurrogate(typeInput.text.charCodeAt(0))) {\n        // Ignore invalid input but keep it around for next time\n        return;\n      }\n\n      this._textAreaState = newState;\n\n      if (this._nextCommand === 0\n      /* Type */\n      ) {\n        if (typeInput.text !== '' || typeInput.replacePrevCharCnt !== 0) {\n          this._onType.fire(typeInput);\n        }\n      } else {\n        if (typeInput.text !== '' || typeInput.replacePrevCharCnt !== 0) {\n          this._firePaste(typeInput.text, null);\n        }\n\n        this._nextCommand = 0\n        /* Type */\n        ;\n      }\n    })); // --- Clipboard operations\n\n\n    this._register(dom.addDisposableListener(textArea.domNode, 'cut', e => {\n      // Pretend here we touched the text area, as the `cut` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      this._textArea.setIgnoreSelectionChangeTime('received cut event');\n\n      this._ensureClipboardGetsEditorSelection(e);\n\n      this._asyncTriggerCut.schedule();\n    }));\n\n    this._register(dom.addDisposableListener(textArea.domNode, 'copy', e => {\n      this._ensureClipboardGetsEditorSelection(e);\n    }));\n\n    this._register(dom.addDisposableListener(textArea.domNode, 'paste', e => {\n      // Pretend here we touched the text area, as the `paste` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      this._textArea.setIgnoreSelectionChangeTime('received paste event');\n\n      if (ClipboardEventUtils.canUseTextData(e)) {\n        const [pastePlainText, metadata] = ClipboardEventUtils.getTextData(e);\n\n        if (pastePlainText !== '') {\n          this._firePaste(pastePlainText, metadata);\n        }\n      } else {\n        if (this._textArea.getSelectionStart() !== this._textArea.getSelectionEnd()) {\n          // Clean up the textarea, to get a clean paste\n          this._setAndWriteTextAreaState('paste', TextAreaState.EMPTY);\n        }\n\n        this._nextCommand = 1\n        /* Paste */\n        ;\n      }\n    }));\n\n    this._register(dom.addDisposableListener(textArea.domNode, 'focus', () => {\n      const hadFocus = this._hasFocus;\n\n      this._setHasFocus(true);\n\n      if (browser.isSafari && !hadFocus && this._hasFocus) {\n        // When \"tabbing into\" the textarea, immediately after dispatching the 'focus' event,\n        // Safari will always move the selection at offset 0 in the textarea\n        this._asyncFocusGainWriteScreenReaderContent.schedule();\n      }\n    }));\n\n    this._register(dom.addDisposableListener(textArea.domNode, 'blur', () => {\n      if (this._isDoingComposition) {\n        // See https://github.com/microsoft/vscode/issues/112621\n        // where compositionend is not triggered when the editor\n        // is taken off-dom during a composition\n        // Clear the flag to be able to write to the textarea\n        this._isDoingComposition = false; // Clear the textarea to avoid an unwanted cursor type\n\n        this.writeScreenReaderContent('blurWithoutCompositionEnd'); // Fire artificial composition end\n\n        this._onCompositionEnd.fire();\n      }\n\n      this._setHasFocus(false);\n    }));\n\n    this._register(dom.addDisposableListener(textArea.domNode, TextAreaSyntethicEvents.Tap, () => {\n      if (browser.isAndroid && this._isDoingComposition) {\n        // on Android, tapping does not cancel the current composition, so the\n        // textarea is stuck showing the old composition\n        // Clear the flag to be able to write to the textarea\n        this._isDoingComposition = false; // Clear the textarea to avoid an unwanted cursor type\n\n        this.writeScreenReaderContent('tapWithoutCompositionEnd'); // Fire artificial composition end\n\n        this._onCompositionEnd.fire();\n      }\n    }));\n  }\n\n  _installSelectionChangeListener() {\n    // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\n    // When using a Braille display, it is possible for users to reposition the\n    // system caret. This is reflected in Chrome as a `selectionchange` event.\n    //\n    // The `selectionchange` event appears to be emitted under numerous other circumstances,\n    // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n    // using a Braille display from all the other cases.\n    //\n    // The problems with the `selectionchange` event are:\n    //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n    //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\n    //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n    //  * the event is emitted when tabbing into the textarea\n    //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n    //  * the event sometimes comes in bursts for a single logical textarea operation\n    // `selectionchange` events often come multiple times for a single logical change\n    // so throttle multiple `selectionchange` events that burst in a short period of time.\n    let previousSelectionChangeEventTime = 0;\n    return dom.addDisposableListener(document, 'selectionchange', e => {\n      if (!this._hasFocus) {\n        return;\n      }\n\n      if (this._isDoingComposition) {\n        return;\n      }\n\n      if (!browser.isChrome) {\n        // Support only for Chrome until testing happens on other browsers\n        return;\n      }\n\n      const now = Date.now();\n      const delta1 = now - previousSelectionChangeEventTime;\n      previousSelectionChangeEventTime = now;\n\n      if (delta1 < 5) {\n        // received another `selectionchange` event within 5ms of the previous `selectionchange` event\n        // => ignore it\n        return;\n      }\n\n      const delta2 = now - this._textArea.getIgnoreSelectionChangeTime();\n\n      this._textArea.resetSelectionChangeTime();\n\n      if (delta2 < 100) {\n        // received a `selectionchange` event within 100ms since we touched the textarea\n        // => ignore it, since we caused it\n        return;\n      }\n\n      if (!this._textAreaState.selectionStartPosition || !this._textAreaState.selectionEndPosition) {\n        // Cannot correlate a position in the textarea with a position in the editor...\n        return;\n      }\n\n      const newValue = this._textArea.getValue();\n\n      if (this._textAreaState.value !== newValue) {\n        // Cannot correlate a position in the textarea with a position in the editor...\n        return;\n      }\n\n      const newSelectionStart = this._textArea.getSelectionStart();\n\n      const newSelectionEnd = this._textArea.getSelectionEnd();\n\n      if (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {\n        // Nothing to do...\n        return;\n      }\n\n      const _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);\n\n      const newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n\n      const _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);\n\n      const newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n\n      const newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\n\n      this._onSelectionChangeRequest.fire(newSelection);\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    if (this._selectionChangeListener) {\n      this._selectionChangeListener.dispose();\n\n      this._selectionChangeListener = null;\n    }\n  }\n\n  focusTextArea() {\n    // Setting this._hasFocus and writing the screen reader content\n    // will result in a focus() and setSelectionRange() in the textarea\n    this._setHasFocus(true); // If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\n\n\n    this.refreshFocusState();\n  }\n\n  isFocused() {\n    return this._hasFocus;\n  }\n\n  refreshFocusState() {\n    const shadowRoot = dom.getShadowRoot(this.textArea.domNode);\n\n    if (shadowRoot) {\n      this._setHasFocus(shadowRoot.activeElement === this.textArea.domNode);\n    } else if (dom.isInDOM(this.textArea.domNode)) {\n      this._setHasFocus(document.activeElement === this.textArea.domNode);\n    } else {\n      this._setHasFocus(false);\n    }\n  }\n\n  _setHasFocus(newHasFocus) {\n    if (this._hasFocus === newHasFocus) {\n      // no change\n      return;\n    }\n\n    this._hasFocus = newHasFocus;\n\n    if (this._selectionChangeListener) {\n      this._selectionChangeListener.dispose();\n\n      this._selectionChangeListener = null;\n    }\n\n    if (this._hasFocus) {\n      this._selectionChangeListener = this._installSelectionChangeListener();\n    }\n\n    if (this._hasFocus) {\n      this.writeScreenReaderContent('focusgain');\n    }\n\n    if (this._hasFocus) {\n      this._onFocus.fire();\n    } else {\n      this._onBlur.fire();\n    }\n  }\n\n  _setAndWriteTextAreaState(reason, textAreaState) {\n    if (!this._hasFocus) {\n      textAreaState = textAreaState.collapseSelection();\n    }\n\n    textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n    this._textAreaState = textAreaState;\n  }\n\n  writeScreenReaderContent(reason) {\n    if (this._isDoingComposition) {\n      // Do not write to the text area when doing composition\n      return;\n    }\n\n    this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent(this._textAreaState));\n  }\n\n  _ensureClipboardGetsEditorSelection(e) {\n    const dataToCopy = this._host.getDataToCopy(ClipboardEventUtils.canUseTextData(e));\n\n    const storedMetadata = {\n      version: 1,\n      isFromEmptySelection: dataToCopy.isFromEmptySelection,\n      multicursorText: dataToCopy.multicursorText,\n      mode: dataToCopy.mode\n    };\n    InMemoryClipboardMetadataManager.INSTANCE.set( // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\n    // Firefox pastes \"LINE\\n\", so let's work around this quirk\n    browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text, storedMetadata);\n\n    if (!ClipboardEventUtils.canUseTextData(e)) {\n      // Looks like an old browser. The strategy is to place the text\n      // we'd like to be copied to the clipboard in the textarea and select it.\n      this._setAndWriteTextAreaState('copy or cut', TextAreaState.selectedText(dataToCopy.text));\n\n      return;\n    }\n\n    ClipboardEventUtils.setTextData(e, dataToCopy.text, dataToCopy.html, storedMetadata);\n  }\n\n  _firePaste(text, metadata) {\n    if (!metadata) {\n      // try the in-memory store\n      metadata = InMemoryClipboardMetadataManager.INSTANCE.get(text);\n    }\n\n    this._onPaste.fire({\n      text: text,\n      metadata: metadata\n    });\n  }\n\n}\n\nclass ClipboardEventUtils {\n  static canUseTextData(e) {\n    if (e.clipboardData) {\n      return true;\n    }\n\n    return false;\n  }\n\n  static getTextData(e) {\n    if (e.clipboardData) {\n      e.preventDefault();\n      const text = e.clipboardData.getData(Mimes.text);\n      let metadata = null;\n      const rawmetadata = e.clipboardData.getData('vscode-editor-data');\n\n      if (typeof rawmetadata === 'string') {\n        try {\n          metadata = JSON.parse(rawmetadata);\n\n          if (metadata.version !== 1) {\n            metadata = null;\n          }\n        } catch (err) {// no problem!\n        }\n      }\n\n      return [text, metadata];\n    }\n\n    throw new Error('ClipboardEventUtils.getTextData: Cannot use text data!');\n  }\n\n  static setTextData(e, text, html, metadata) {\n    if (e.clipboardData) {\n      e.clipboardData.setData(Mimes.text, text);\n\n      if (typeof html === 'string') {\n        e.clipboardData.setData('text/html', html);\n      }\n\n      e.clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\n      e.preventDefault();\n      return;\n    }\n\n    throw new Error('ClipboardEventUtils.setTextData: Cannot use text data!');\n  }\n\n}\n\nclass TextAreaWrapper extends Disposable {\n  constructor(_textArea) {\n    super();\n    this._actual = _textArea;\n    this._ignoreSelectionChangeTime = 0;\n  }\n\n  setIgnoreSelectionChangeTime(reason) {\n    this._ignoreSelectionChangeTime = Date.now();\n  }\n\n  getIgnoreSelectionChangeTime() {\n    return this._ignoreSelectionChangeTime;\n  }\n\n  resetSelectionChangeTime() {\n    this._ignoreSelectionChangeTime = 0;\n  }\n\n  getValue() {\n    // console.log('current value: ' + this._textArea.value);\n    return this._actual.domNode.value;\n  }\n\n  setValue(reason, value) {\n    const textArea = this._actual.domNode;\n\n    if (textArea.value === value) {\n      // No change\n      return;\n    } // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n\n\n    this.setIgnoreSelectionChangeTime('setValue');\n    textArea.value = value;\n  }\n\n  getSelectionStart() {\n    return this._actual.domNode.selectionDirection === 'backward' ? this._actual.domNode.selectionEnd : this._actual.domNode.selectionStart;\n  }\n\n  getSelectionEnd() {\n    return this._actual.domNode.selectionDirection === 'backward' ? this._actual.domNode.selectionStart : this._actual.domNode.selectionEnd;\n  }\n\n  setSelectionRange(reason, selectionStart, selectionEnd) {\n    const textArea = this._actual.domNode;\n    let activeElement = null;\n    const shadowRoot = dom.getShadowRoot(textArea);\n\n    if (shadowRoot) {\n      activeElement = shadowRoot.activeElement;\n    } else {\n      activeElement = document.activeElement;\n    }\n\n    const currentIsFocused = activeElement === textArea;\n    const currentSelectionStart = textArea.selectionStart;\n    const currentSelectionEnd = textArea.selectionEnd;\n\n    if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n      // No change\n      // Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\n      if (browser.isFirefox && window.parent !== window) {\n        textArea.focus();\n      }\n\n      return;\n    } // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n\n\n    if (currentIsFocused) {\n      // No need to focus, only need to change the selection range\n      this.setIgnoreSelectionChangeTime('setSelectionRange');\n      textArea.setSelectionRange(selectionStart, selectionEnd);\n\n      if (browser.isFirefox && window.parent !== window) {\n        textArea.focus();\n      }\n\n      return;\n    } // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n    // Here, we try to undo the browser's desperate reveal.\n\n\n    try {\n      const scrollState = dom.saveParentsScrollTop(textArea);\n      this.setIgnoreSelectionChangeTime('setSelectionRange');\n      textArea.focus();\n      textArea.setSelectionRange(selectionStart, selectionEnd);\n      dom.restoreParentsScrollTop(textArea, scrollState);\n    } catch (e) {// Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaInput.js"],"names":["browser","dom","RunOnceScheduler","Emitter","Disposable","Mimes","platform","strings","TextAreaState","_debugComposition","Position","Selection","TextAreaSyntethicEvents","Tap","CopyOptions","forceCopyWithSyntaxHighlighting","InMemoryClipboardMetadataManager","constructor","_lastState","set","lastCopiedValue","data","get","pastedText","INSTANCE","TextAreaInput","host","textArea","_onFocus","_register","onFocus","event","_onBlur","onBlur","_onKeyDown","onKeyDown","_onKeyUp","onKeyUp","_onCut","onCut","_onPaste","onPaste","_onType","onType","_onCompositionStart","onCompositionStart","_onCompositionUpdate","onCompositionUpdate","_onCompositionEnd","onCompositionEnd","_onSelectionChangeRequest","onSelectionChangeRequest","_host","_textArea","TextAreaWrapper","_asyncTriggerCut","fire","_asyncFocusGainWriteScreenReaderContent","writeScreenReaderContent","_textAreaState","EMPTY","_selectionChangeListener","_hasFocus","_isDoingComposition","_nextCommand","lastKeyDown","addStandardDisposableListener","domNode","e","keyCode","stopPropagation","equals","preventDefault","addDisposableListener","console","log","isMacintosh","selectionStart","selectionEnd","value","substr","isArrowKey","code","isFirefox","selectionStartPosition","lineNumber","column","selectionEndPosition","revealDeltaColumns","isAndroid","_setAndWriteTextAreaState","deduceInputFromTextAreaValue","couldBeEmojiInput","oldState","newState","readFromTextArea","deduceInput","deduceAndroidCompositionInput","deduceComposition","text","selectedText","typeInput","replacePrevCharCnt","replaceNextCharCnt","positionDelta","isChrome","setIgnoreSelectionChangeTime","length","isHighSurrogate","charCodeAt","_firePaste","_ensureClipboardGetsEditorSelection","schedule","ClipboardEventUtils","canUseTextData","pastePlainText","metadata","getTextData","getSelectionStart","getSelectionEnd","hadFocus","_setHasFocus","isSafari","_installSelectionChangeListener","previousSelectionChangeEventTime","document","now","Date","delta1","delta2","getIgnoreSelectionChangeTime","resetSelectionChangeTime","newValue","getValue","newSelectionStart","newSelectionEnd","_newSelectionStartPosition","deduceEditorPosition","newSelectionStartPosition","deduceModelPosition","_newSelectionEndPosition","newSelectionEndPosition","newSelection","dispose","focusTextArea","refreshFocusState","isFocused","shadowRoot","getShadowRoot","activeElement","isInDOM","newHasFocus","reason","textAreaState","collapseSelection","writeToTextArea","getScreenReaderContent","dataToCopy","getDataToCopy","storedMetadata","version","isFromEmptySelection","multicursorText","mode","replace","setTextData","html","clipboardData","getData","rawmetadata","JSON","parse","err","Error","setData","stringify","_actual","_ignoreSelectionChangeTime","setValue","selectionDirection","setSelectionRange","currentIsFocused","currentSelectionStart","currentSelectionEnd","window","parent","focus","scrollState","saveParentsScrollTop","restoreParentsScrollTop"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../base/browser/browser.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { TextAreaState, _debugComposition } from './textAreaState.js';\nimport { Position } from '../../common/core/position.js';\nimport { Selection } from '../../common/core/selection.js';\nexport var TextAreaSyntethicEvents;\n(function (TextAreaSyntethicEvents) {\n    TextAreaSyntethicEvents.Tap = '-monaco-textarea-synthetic-tap';\n})(TextAreaSyntethicEvents || (TextAreaSyntethicEvents = {}));\nexport const CopyOptions = {\n    forceCopyWithSyntaxHighlighting: false\n};\n/**\n * Every time we write to the clipboard, we record a bit of extra metadata here.\n * Every time we read from the cipboard, if the text matches our last written text,\n * we can fetch the previous metadata.\n */\nexport class InMemoryClipboardMetadataManager {\n    constructor() {\n        this._lastState = null;\n    }\n    set(lastCopiedValue, data) {\n        this._lastState = { lastCopiedValue, data };\n    }\n    get(pastedText) {\n        if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\n            // match!\n            return this._lastState.data;\n        }\n        this._lastState = null;\n        return null;\n    }\n}\nInMemoryClipboardMetadataManager.INSTANCE = new InMemoryClipboardMetadataManager();\n/**\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\n *  - onCut\n *  - onPaste\n *  - onType\n *\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\n */\nexport class TextAreaInput extends Disposable {\n    constructor(host, textArea) {\n        super();\n        this.textArea = textArea;\n        this._onFocus = this._register(new Emitter());\n        this.onFocus = this._onFocus.event;\n        this._onBlur = this._register(new Emitter());\n        this.onBlur = this._onBlur.event;\n        this._onKeyDown = this._register(new Emitter());\n        this.onKeyDown = this._onKeyDown.event;\n        this._onKeyUp = this._register(new Emitter());\n        this.onKeyUp = this._onKeyUp.event;\n        this._onCut = this._register(new Emitter());\n        this.onCut = this._onCut.event;\n        this._onPaste = this._register(new Emitter());\n        this.onPaste = this._onPaste.event;\n        this._onType = this._register(new Emitter());\n        this.onType = this._onType.event;\n        this._onCompositionStart = this._register(new Emitter());\n        this.onCompositionStart = this._onCompositionStart.event;\n        this._onCompositionUpdate = this._register(new Emitter());\n        this.onCompositionUpdate = this._onCompositionUpdate.event;\n        this._onCompositionEnd = this._register(new Emitter());\n        this.onCompositionEnd = this._onCompositionEnd.event;\n        this._onSelectionChangeRequest = this._register(new Emitter());\n        this.onSelectionChangeRequest = this._onSelectionChangeRequest.event;\n        this._host = host;\n        this._textArea = this._register(new TextAreaWrapper(textArea));\n        this._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));\n        this._asyncFocusGainWriteScreenReaderContent = this._register(new RunOnceScheduler(() => this.writeScreenReaderContent('asyncFocusGain'), 0));\n        this._textAreaState = TextAreaState.EMPTY;\n        this._selectionChangeListener = null;\n        this.writeScreenReaderContent('ctor');\n        this._hasFocus = false;\n        this._isDoingComposition = false;\n        this._nextCommand = 0 /* Type */;\n        let lastKeyDown = null;\n        this._register(dom.addStandardDisposableListener(textArea.domNode, 'keydown', (e) => {\n            if (e.keyCode === 109 /* KEY_IN_COMPOSITION */\n                || (this._isDoingComposition && e.keyCode === 1 /* Backspace */)) {\n                // Stop propagation for keyDown events if the IME is processing key input\n                e.stopPropagation();\n            }\n            if (e.equals(9 /* Escape */)) {\n                // Prevent default always for `Esc`, otherwise it will generate a keypress\n                // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n                e.preventDefault();\n            }\n            lastKeyDown = e;\n            this._onKeyDown.fire(e);\n        }));\n        this._register(dom.addStandardDisposableListener(textArea.domNode, 'keyup', (e) => {\n            this._onKeyUp.fire(e);\n        }));\n        this._register(dom.addDisposableListener(textArea.domNode, 'compositionstart', (e) => {\n            if (_debugComposition) {\n                console.log(`[compositionstart]`, e);\n            }\n            if (this._isDoingComposition) {\n                return;\n            }\n            this._isDoingComposition = true;\n            if (platform.isMacintosh\n                && this._textAreaState.selectionStart === this._textAreaState.selectionEnd\n                && this._textAreaState.selectionStart > 0\n                && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === e.data) {\n                const isArrowKey = (lastKeyDown && lastKeyDown.equals(109 /* KEY_IN_COMPOSITION */)\n                    && (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft'));\n                if (isArrowKey || browser.isFirefox) {\n                    // Handling long press case on Chromium/Safari macOS + arrow key => pretend the character was selected\n                    // or long press case on Firefox on macOS\n                    if (_debugComposition) {\n                        console.log(`[compositionstart] Handling long press case on macOS + arrow key or Firefox`, e);\n                    }\n                    this._textAreaState = new TextAreaState(this._textAreaState.value, this._textAreaState.selectionStart - 1, this._textAreaState.selectionEnd, this._textAreaState.selectionStartPosition ? new Position(this._textAreaState.selectionStartPosition.lineNumber, this._textAreaState.selectionStartPosition.column - 1) : null, this._textAreaState.selectionEndPosition);\n                    this._onCompositionStart.fire({ revealDeltaColumns: -1 });\n                    return;\n                }\n            }\n            if (browser.isAndroid) {\n                // when tapping on the editor, Android enters composition mode to edit the current word\n                // so we cannot clear the textarea on Android and we must pretend the current word was selected\n                this._onCompositionStart.fire({ revealDeltaColumns: -this._textAreaState.selectionStart });\n                return;\n            }\n            this._setAndWriteTextAreaState('compositionstart', TextAreaState.EMPTY);\n            this._onCompositionStart.fire({ revealDeltaColumns: 0 });\n        }));\n        /**\n         * Deduce the typed input from a text area's value and the last observed state.\n         */\n        const deduceInputFromTextAreaValue = (couldBeEmojiInput) => {\n            const oldState = this._textAreaState;\n            const newState = TextAreaState.readFromTextArea(this._textArea);\n            return [newState, TextAreaState.deduceInput(oldState, newState, couldBeEmojiInput)];\n        };\n        const deduceAndroidCompositionInput = () => {\n            const oldState = this._textAreaState;\n            const newState = TextAreaState.readFromTextArea(this._textArea);\n            return [newState, TextAreaState.deduceAndroidCompositionInput(oldState, newState)];\n        };\n        /**\n         * Deduce the composition input from a string.\n         */\n        const deduceComposition = (text) => {\n            const oldState = this._textAreaState;\n            const newState = TextAreaState.selectedText(text);\n            const typeInput = {\n                text: newState.value,\n                replacePrevCharCnt: oldState.selectionEnd - oldState.selectionStart,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n            return [newState, typeInput];\n        };\n        this._register(dom.addDisposableListener(textArea.domNode, 'compositionupdate', (e) => {\n            if (_debugComposition) {\n                console.log(`[compositionupdate]`, e);\n            }\n            if (browser.isAndroid) {\n                // On Android, the data sent with the composition update event is unusable.\n                // For example, if the cursor is in the middle of a word like Mic|osoft\n                // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n                // This is not really usable because it doesn't tell us where the edit began and where it ended.\n                const [newState, typeInput] = deduceAndroidCompositionInput();\n                this._textAreaState = newState;\n                this._onType.fire(typeInput);\n                this._onCompositionUpdate.fire(e);\n                return;\n            }\n            const [newState, typeInput] = deduceComposition(e.data || '');\n            this._textAreaState = newState;\n            this._onType.fire(typeInput);\n            this._onCompositionUpdate.fire(e);\n        }));\n        this._register(dom.addDisposableListener(textArea.domNode, 'compositionend', (e) => {\n            if (_debugComposition) {\n                console.log(`[compositionend]`, e);\n            }\n            // https://github.com/microsoft/monaco-editor/issues/1663\n            // On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\n            if (!this._isDoingComposition) {\n                return;\n            }\n            this._isDoingComposition = false;\n            if (browser.isAndroid) {\n                // On Android, the data sent with the composition update event is unusable.\n                // For example, if the cursor is in the middle of a word like Mic|osoft\n                // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n                // This is not really usable because it doesn't tell us where the edit began and where it ended.\n                const [newState, typeInput] = deduceAndroidCompositionInput();\n                this._textAreaState = newState;\n                this._onType.fire(typeInput);\n                this._onCompositionEnd.fire();\n                return;\n            }\n            const [newState, typeInput] = deduceComposition(e.data || '');\n            this._textAreaState = newState;\n            this._onType.fire(typeInput);\n            // isChrome: the textarea is not updated correctly when composition ends\n            // isFirefox: the textarea is not updated correctly after inserting emojis\n            // => we cannot assume the text at the end consists only of the composited text\n            if (browser.isChrome || browser.isFirefox) {\n                this._textAreaState = TextAreaState.readFromTextArea(this._textArea);\n            }\n            this._onCompositionEnd.fire();\n        }));\n        this._register(dom.addDisposableListener(textArea.domNode, 'input', () => {\n            // Pretend here we touched the text area, as the `input` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received input event');\n            if (this._isDoingComposition) {\n                return;\n            }\n            const [newState, typeInput] = deduceInputFromTextAreaValue(/*couldBeEmojiInput*/ platform.isMacintosh);\n            if (typeInput.replacePrevCharCnt === 0 && typeInput.text.length === 1 && strings.isHighSurrogate(typeInput.text.charCodeAt(0))) {\n                // Ignore invalid input but keep it around for next time\n                return;\n            }\n            this._textAreaState = newState;\n            if (this._nextCommand === 0 /* Type */) {\n                if (typeInput.text !== '' || typeInput.replacePrevCharCnt !== 0) {\n                    this._onType.fire(typeInput);\n                }\n            }\n            else {\n                if (typeInput.text !== '' || typeInput.replacePrevCharCnt !== 0) {\n                    this._firePaste(typeInput.text, null);\n                }\n                this._nextCommand = 0 /* Type */;\n            }\n        }));\n        // --- Clipboard operations\n        this._register(dom.addDisposableListener(textArea.domNode, 'cut', (e) => {\n            // Pretend here we touched the text area, as the `cut` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received cut event');\n            this._ensureClipboardGetsEditorSelection(e);\n            this._asyncTriggerCut.schedule();\n        }));\n        this._register(dom.addDisposableListener(textArea.domNode, 'copy', (e) => {\n            this._ensureClipboardGetsEditorSelection(e);\n        }));\n        this._register(dom.addDisposableListener(textArea.domNode, 'paste', (e) => {\n            // Pretend here we touched the text area, as the `paste` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received paste event');\n            if (ClipboardEventUtils.canUseTextData(e)) {\n                const [pastePlainText, metadata] = ClipboardEventUtils.getTextData(e);\n                if (pastePlainText !== '') {\n                    this._firePaste(pastePlainText, metadata);\n                }\n            }\n            else {\n                if (this._textArea.getSelectionStart() !== this._textArea.getSelectionEnd()) {\n                    // Clean up the textarea, to get a clean paste\n                    this._setAndWriteTextAreaState('paste', TextAreaState.EMPTY);\n                }\n                this._nextCommand = 1 /* Paste */;\n            }\n        }));\n        this._register(dom.addDisposableListener(textArea.domNode, 'focus', () => {\n            const hadFocus = this._hasFocus;\n            this._setHasFocus(true);\n            if (browser.isSafari && !hadFocus && this._hasFocus) {\n                // When \"tabbing into\" the textarea, immediately after dispatching the 'focus' event,\n                // Safari will always move the selection at offset 0 in the textarea\n                this._asyncFocusGainWriteScreenReaderContent.schedule();\n            }\n        }));\n        this._register(dom.addDisposableListener(textArea.domNode, 'blur', () => {\n            if (this._isDoingComposition) {\n                // See https://github.com/microsoft/vscode/issues/112621\n                // where compositionend is not triggered when the editor\n                // is taken off-dom during a composition\n                // Clear the flag to be able to write to the textarea\n                this._isDoingComposition = false;\n                // Clear the textarea to avoid an unwanted cursor type\n                this.writeScreenReaderContent('blurWithoutCompositionEnd');\n                // Fire artificial composition end\n                this._onCompositionEnd.fire();\n            }\n            this._setHasFocus(false);\n        }));\n        this._register(dom.addDisposableListener(textArea.domNode, TextAreaSyntethicEvents.Tap, () => {\n            if (browser.isAndroid && this._isDoingComposition) {\n                // on Android, tapping does not cancel the current composition, so the\n                // textarea is stuck showing the old composition\n                // Clear the flag to be able to write to the textarea\n                this._isDoingComposition = false;\n                // Clear the textarea to avoid an unwanted cursor type\n                this.writeScreenReaderContent('tapWithoutCompositionEnd');\n                // Fire artificial composition end\n                this._onCompositionEnd.fire();\n            }\n        }));\n    }\n    _installSelectionChangeListener() {\n        // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\n        // When using a Braille display, it is possible for users to reposition the\n        // system caret. This is reflected in Chrome as a `selectionchange` event.\n        //\n        // The `selectionchange` event appears to be emitted under numerous other circumstances,\n        // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n        // using a Braille display from all the other cases.\n        //\n        // The problems with the `selectionchange` event are:\n        //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n        //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\n        //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n        //  * the event is emitted when tabbing into the textarea\n        //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n        //  * the event sometimes comes in bursts for a single logical textarea operation\n        // `selectionchange` events often come multiple times for a single logical change\n        // so throttle multiple `selectionchange` events that burst in a short period of time.\n        let previousSelectionChangeEventTime = 0;\n        return dom.addDisposableListener(document, 'selectionchange', (e) => {\n            if (!this._hasFocus) {\n                return;\n            }\n            if (this._isDoingComposition) {\n                return;\n            }\n            if (!browser.isChrome) {\n                // Support only for Chrome until testing happens on other browsers\n                return;\n            }\n            const now = Date.now();\n            const delta1 = now - previousSelectionChangeEventTime;\n            previousSelectionChangeEventTime = now;\n            if (delta1 < 5) {\n                // received another `selectionchange` event within 5ms of the previous `selectionchange` event\n                // => ignore it\n                return;\n            }\n            const delta2 = now - this._textArea.getIgnoreSelectionChangeTime();\n            this._textArea.resetSelectionChangeTime();\n            if (delta2 < 100) {\n                // received a `selectionchange` event within 100ms since we touched the textarea\n                // => ignore it, since we caused it\n                return;\n            }\n            if (!this._textAreaState.selectionStartPosition || !this._textAreaState.selectionEndPosition) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            const newValue = this._textArea.getValue();\n            if (this._textAreaState.value !== newValue) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            const newSelectionStart = this._textArea.getSelectionStart();\n            const newSelectionEnd = this._textArea.getSelectionEnd();\n            if (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {\n                // Nothing to do...\n                return;\n            }\n            const _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);\n            const newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n            const _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);\n            const newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n            const newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\n            this._onSelectionChangeRequest.fire(newSelection);\n        });\n    }\n    dispose() {\n        super.dispose();\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n    }\n    focusTextArea() {\n        // Setting this._hasFocus and writing the screen reader content\n        // will result in a focus() and setSelectionRange() in the textarea\n        this._setHasFocus(true);\n        // If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\n        this.refreshFocusState();\n    }\n    isFocused() {\n        return this._hasFocus;\n    }\n    refreshFocusState() {\n        const shadowRoot = dom.getShadowRoot(this.textArea.domNode);\n        if (shadowRoot) {\n            this._setHasFocus(shadowRoot.activeElement === this.textArea.domNode);\n        }\n        else if (dom.isInDOM(this.textArea.domNode)) {\n            this._setHasFocus(document.activeElement === this.textArea.domNode);\n        }\n        else {\n            this._setHasFocus(false);\n        }\n    }\n    _setHasFocus(newHasFocus) {\n        if (this._hasFocus === newHasFocus) {\n            // no change\n            return;\n        }\n        this._hasFocus = newHasFocus;\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n        if (this._hasFocus) {\n            this._selectionChangeListener = this._installSelectionChangeListener();\n        }\n        if (this._hasFocus) {\n            this.writeScreenReaderContent('focusgain');\n        }\n        if (this._hasFocus) {\n            this._onFocus.fire();\n        }\n        else {\n            this._onBlur.fire();\n        }\n    }\n    _setAndWriteTextAreaState(reason, textAreaState) {\n        if (!this._hasFocus) {\n            textAreaState = textAreaState.collapseSelection();\n        }\n        textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n        this._textAreaState = textAreaState;\n    }\n    writeScreenReaderContent(reason) {\n        if (this._isDoingComposition) {\n            // Do not write to the text area when doing composition\n            return;\n        }\n        this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent(this._textAreaState));\n    }\n    _ensureClipboardGetsEditorSelection(e) {\n        const dataToCopy = this._host.getDataToCopy(ClipboardEventUtils.canUseTextData(e));\n        const storedMetadata = {\n            version: 1,\n            isFromEmptySelection: dataToCopy.isFromEmptySelection,\n            multicursorText: dataToCopy.multicursorText,\n            mode: dataToCopy.mode\n        };\n        InMemoryClipboardMetadataManager.INSTANCE.set(\n        // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\n        // Firefox pastes \"LINE\\n\", so let's work around this quirk\n        (browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text), storedMetadata);\n        if (!ClipboardEventUtils.canUseTextData(e)) {\n            // Looks like an old browser. The strategy is to place the text\n            // we'd like to be copied to the clipboard in the textarea and select it.\n            this._setAndWriteTextAreaState('copy or cut', TextAreaState.selectedText(dataToCopy.text));\n            return;\n        }\n        ClipboardEventUtils.setTextData(e, dataToCopy.text, dataToCopy.html, storedMetadata);\n    }\n    _firePaste(text, metadata) {\n        if (!metadata) {\n            // try the in-memory store\n            metadata = InMemoryClipboardMetadataManager.INSTANCE.get(text);\n        }\n        this._onPaste.fire({\n            text: text,\n            metadata: metadata\n        });\n    }\n}\nclass ClipboardEventUtils {\n    static canUseTextData(e) {\n        if (e.clipboardData) {\n            return true;\n        }\n        return false;\n    }\n    static getTextData(e) {\n        if (e.clipboardData) {\n            e.preventDefault();\n            const text = e.clipboardData.getData(Mimes.text);\n            let metadata = null;\n            const rawmetadata = e.clipboardData.getData('vscode-editor-data');\n            if (typeof rawmetadata === 'string') {\n                try {\n                    metadata = JSON.parse(rawmetadata);\n                    if (metadata.version !== 1) {\n                        metadata = null;\n                    }\n                }\n                catch (err) {\n                    // no problem!\n                }\n            }\n            return [text, metadata];\n        }\n        throw new Error('ClipboardEventUtils.getTextData: Cannot use text data!');\n    }\n    static setTextData(e, text, html, metadata) {\n        if (e.clipboardData) {\n            e.clipboardData.setData(Mimes.text, text);\n            if (typeof html === 'string') {\n                e.clipboardData.setData('text/html', html);\n            }\n            e.clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\n            e.preventDefault();\n            return;\n        }\n        throw new Error('ClipboardEventUtils.setTextData: Cannot use text data!');\n    }\n}\nclass TextAreaWrapper extends Disposable {\n    constructor(_textArea) {\n        super();\n        this._actual = _textArea;\n        this._ignoreSelectionChangeTime = 0;\n    }\n    setIgnoreSelectionChangeTime(reason) {\n        this._ignoreSelectionChangeTime = Date.now();\n    }\n    getIgnoreSelectionChangeTime() {\n        return this._ignoreSelectionChangeTime;\n    }\n    resetSelectionChangeTime() {\n        this._ignoreSelectionChangeTime = 0;\n    }\n    getValue() {\n        // console.log('current value: ' + this._textArea.value);\n        return this._actual.domNode.value;\n    }\n    setValue(reason, value) {\n        const textArea = this._actual.domNode;\n        if (textArea.value === value) {\n            // No change\n            return;\n        }\n        // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n        this.setIgnoreSelectionChangeTime('setValue');\n        textArea.value = value;\n    }\n    getSelectionStart() {\n        return this._actual.domNode.selectionDirection === 'backward' ? this._actual.domNode.selectionEnd : this._actual.domNode.selectionStart;\n    }\n    getSelectionEnd() {\n        return this._actual.domNode.selectionDirection === 'backward' ? this._actual.domNode.selectionStart : this._actual.domNode.selectionEnd;\n    }\n    setSelectionRange(reason, selectionStart, selectionEnd) {\n        const textArea = this._actual.domNode;\n        let activeElement = null;\n        const shadowRoot = dom.getShadowRoot(textArea);\n        if (shadowRoot) {\n            activeElement = shadowRoot.activeElement;\n        }\n        else {\n            activeElement = document.activeElement;\n        }\n        const currentIsFocused = (activeElement === textArea);\n        const currentSelectionStart = textArea.selectionStart;\n        const currentSelectionEnd = textArea.selectionEnd;\n        if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n            // No change\n            // Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\n            if (browser.isFirefox && window.parent !== window) {\n                textArea.focus();\n            }\n            return;\n        }\n        // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n        if (currentIsFocused) {\n            // No need to focus, only need to change the selection range\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            if (browser.isFirefox && window.parent !== window) {\n                textArea.focus();\n            }\n            return;\n        }\n        // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n        // Here, we try to undo the browser's desperate reveal.\n        try {\n            const scrollState = dom.saveParentsScrollTop(textArea);\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.focus();\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            dom.restoreParentsScrollTop(textArea, scrollState);\n        }\n        catch (e) {\n            // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}