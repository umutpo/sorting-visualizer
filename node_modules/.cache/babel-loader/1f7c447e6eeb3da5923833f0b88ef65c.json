{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../config/editorOptions.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport * as model from '../model.js';\nimport { EditStack } from './editStack.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from './textModelEvents.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TextModelTokenization } from './textModelTokens.js';\nimport { getWordAtText } from './wordHelper.js';\nimport { ILanguageConfigurationService } from '../modes/languageConfigurationRegistry.js';\nimport { NULL_MODE_ID } from '../modes/nullMode.js';\nimport { ignoreBracketsInToken } from '../modes/supports.js';\nimport { BracketsUtils } from '../modes/supports/richEditBrackets.js';\nimport { TokensStore, countEOL, TokensStore2 } from './tokensStore.js';\nimport { Color } from '../../../base/common/color.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { ArrayQueue, findLast } from '../../../base/common/arrays.js';\nimport { BracketPairs } from './bracketPairs/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairs/colorizedBracketPairsDecorationProvider.js';\nimport { CursorColumns } from '../controller/cursorColumns.js';\nimport { IModeService } from '../services/modeService.js';\n\nfunction createTextBufferBuilder() {\n  return new PieceTreeTextBufferBuilder();\n}\n\nexport function createTextBufferFactory(text) {\n  const builder = createTextBufferBuilder();\n  builder.acceptChunk(text);\n  return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n  const factory = typeof value === 'string' ? createTextBufferFactory(value) : value;\n  return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nexport const LONG_LINE_BOUNDARY = 10000;\n\nclass TextModelSnapshot {\n  constructor(source) {\n    this._source = source;\n    this._eos = false;\n  }\n\n  read() {\n    if (this._eos) {\n      return null;\n    }\n\n    let result = [],\n        resultCnt = 0,\n        resultLength = 0;\n\n    do {\n      let tmp = this._source.read();\n\n      if (tmp === null) {\n        // end-of-stream\n        this._eos = true;\n\n        if (resultCnt === 0) {\n          return null;\n        } else {\n          return result.join('');\n        }\n      }\n\n      if (tmp.length > 0) {\n        result[resultCnt++] = tmp;\n        resultLength += tmp.length;\n      }\n\n      if (resultLength >= 64 * 1024) {\n        return result.join('');\n      }\n    } while (true);\n  }\n\n}\n\nconst invalidFunc = () => {\n  throw new Error(`Invalid change accessor`);\n};\n\nclass BracketSearchCanceled {\n  constructor() {\n    this._searchCanceledBrand = undefined;\n  }\n\n}\n\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\n\nfunction stripBracketSearchCanceled(result) {\n  if (result instanceof BracketSearchCanceled) {\n    return null;\n  }\n\n  return result;\n}\n\nlet TextModel = class TextModel extends Disposable {\n  constructor(source, creationOptions, languageId) {\n    let associatedResource = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    let _undoRedoService = arguments.length > 4 ? arguments[4] : undefined;\n\n    let _modeService = arguments.length > 5 ? arguments[5] : undefined;\n\n    let _languageConfigurationService = arguments.length > 6 ? arguments[6] : undefined;\n\n    super();\n    this._undoRedoService = _undoRedoService;\n    this._modeService = _modeService;\n    this._languageConfigurationService = _languageConfigurationService; //#region Events\n\n    this._onWillDispose = this._register(new Emitter());\n    this.onWillDispose = this._onWillDispose.event;\n    this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n    this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n    this._onDidChangeLanguage = this._register(new Emitter());\n    this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n    this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n    this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n    this._onDidChangeTokens = this._register(new Emitter());\n    this.onDidChangeTokens = this._onDidChangeTokens.event;\n    this._onDidChangeOptions = this._register(new Emitter());\n    this.onDidChangeOptions = this._onDidChangeOptions.event;\n    this._onDidChangeAttached = this._register(new Emitter());\n    this.onDidChangeAttached = this._onDidChangeAttached.event;\n    this._onDidChangeContentOrInjectedText = this._register(new Emitter());\n    this.onDidChangeContentOrInjectedText = this._onDidChangeContentOrInjectedText.event;\n    this._eventEmitter = this._register(new DidChangeContentEmitter());\n    this._backgroundTokenizationState = 0\n    /* Uninitialized */\n    ;\n    this._onBackgroundTokenizationStateChanged = this._register(new Emitter());\n    this.onBackgroundTokenizationStateChanged = this._onBackgroundTokenizationStateChanged.event;\n\n    this._register(this._eventEmitter.fastEvent(e => {\n      this._onDidChangeContentOrInjectedText.fire(e.rawContentChangedEvent);\n    })); // Generate a new unique model id\n\n\n    MODEL_ID++;\n    this.id = '$model' + MODEL_ID;\n    this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n\n    if (typeof associatedResource === 'undefined' || associatedResource === null) {\n      this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n    } else {\n      this._associatedResource = associatedResource;\n    }\n\n    this._attachedEditorCount = 0;\n    const {\n      textBuffer,\n      disposable\n    } = createTextBuffer(source, creationOptions.defaultEOL);\n    this._buffer = textBuffer;\n    this._bufferDisposable = disposable;\n    this._options = TextModel.resolveOptions(this._buffer, creationOptions);\n\n    const bufferLineCount = this._buffer.getLineCount();\n\n    const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0\n    /* TextDefined */\n    ); // !!! Make a decision in the ctor and permanently respect this decision !!!\n    // If a model is too large at construction time, it will never get tokenized,\n    // under no circumstances.\n\n\n    if (creationOptions.largeFileOptimizations) {\n      this._isTooLargeForTokenization = bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD || bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD;\n    } else {\n      this._isTooLargeForTokenization = false;\n    }\n\n    this._isTooLargeForSyncing = bufferTextLength > TextModel.MODEL_SYNC_LIMIT;\n    this._versionId = 1;\n    this._alternativeVersionId = 1;\n    this._initialUndoRedoSnapshot = null;\n    this._isDisposed = false;\n    this._isDisposing = false;\n    this._languageId = languageId || NULL_MODE_ID;\n    this._languageRegistryListener = this._languageConfigurationService.onDidChange(e => {\n      if (e.affects(this._languageId)) {\n        this._onDidChangeLanguageConfiguration.fire({});\n      }\n    });\n    this._instanceId = strings.singleLetterHash(MODEL_ID);\n    this._lastDecorationId = 0;\n    this._decorations = Object.create(null);\n    this._decorationsTree = new DecorationsTrees();\n    this._commandManager = new EditStack(this, this._undoRedoService);\n    this._isUndoing = false;\n    this._isRedoing = false;\n    this._trimAutoWhitespaceLines = null;\n    this._tokens = new TokensStore(this._modeService.languageIdCodec);\n    this._tokens2 = new TokensStore2(this._modeService.languageIdCodec);\n    this._tokenization = new TextModelTokenization(this, this._modeService.languageIdCodec);\n    this._bracketPairColorizer = this._register(new BracketPairs(this, this._languageConfigurationService));\n    this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n\n    this._register(this._decorationProvider.onDidChange(() => {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      this._onDidChangeDecorations.fire();\n\n      this._onDidChangeDecorations.endDeferredEmit();\n    }));\n  }\n\n  static resolveOptions(textBuffer, options) {\n    if (options.detectIndentation) {\n      const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n      return new model.TextModelResolvedOptions({\n        tabSize: guessedIndentation.tabSize,\n        indentSize: guessedIndentation.tabSize,\n        insertSpaces: guessedIndentation.insertSpaces,\n        trimAutoWhitespace: options.trimAutoWhitespace,\n        defaultEOL: options.defaultEOL,\n        bracketPairColorizationOptions: options.bracketPairColorizationOptions\n      });\n    }\n\n    return new model.TextModelResolvedOptions({\n      tabSize: options.tabSize,\n      indentSize: options.indentSize,\n      insertSpaces: options.insertSpaces,\n      trimAutoWhitespace: options.trimAutoWhitespace,\n      defaultEOL: options.defaultEOL,\n      bracketPairColorizationOptions: options.bracketPairColorizationOptions\n    });\n  }\n\n  onDidChangeContentFast(listener) {\n    return this._eventEmitter.fastEvent(e => listener(e.contentChangedEvent));\n  }\n\n  onDidChangeContent(listener) {\n    return this._eventEmitter.slowEvent(e => listener(e.contentChangedEvent));\n  }\n\n  get bracketPairs() {\n    return this._bracketPairColorizer;\n  }\n\n  get backgroundTokenizationState() {\n    return this._backgroundTokenizationState;\n  }\n\n  handleTokenizationProgress(completed) {\n    if (this._backgroundTokenizationState === 2\n    /* Completed */\n    ) {\n      // We already did a full tokenization and don't go back to progressing.\n      return;\n    }\n\n    const newState = completed ? 2\n    /* Completed */\n    : 1\n    /* InProgress */\n    ;\n\n    if (this._backgroundTokenizationState !== newState) {\n      this._backgroundTokenizationState = newState;\n\n      this._onBackgroundTokenizationStateChanged.fire();\n    }\n  }\n\n  dispose() {\n    this._isDisposing = true;\n\n    this._onWillDispose.fire();\n\n    this._languageRegistryListener.dispose();\n\n    this._tokenization.dispose();\n\n    this._isDisposed = true;\n    super.dispose();\n\n    this._bufferDisposable.dispose();\n\n    this._isDisposing = false; // Manually release reference to previous text buffer to avoid large leaks\n    // in case someone leaks a TextModel reference\n\n    const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n    emptyDisposedTextBuffer.dispose();\n    this._buffer = emptyDisposedTextBuffer;\n  }\n\n  _assertNotDisposed() {\n    if (this._isDisposed) {\n      throw new Error('Model is disposed!');\n    }\n  }\n\n  _emitContentChangedEvent(rawChange, change) {\n    this._bracketPairColorizer.handleContentChanged(change);\n\n    if (this._isDisposing) {\n      // Do not confuse listeners by emitting any event after disposing\n      return;\n    }\n\n    this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n  }\n\n  setValue(value) {\n    this._assertNotDisposed();\n\n    if (value === null) {\n      // There's nothing to do\n      return;\n    }\n\n    const {\n      textBuffer,\n      disposable\n    } = createTextBuffer(value, this._options.defaultEOL);\n\n    this._setValueFromTextBuffer(textBuffer, disposable);\n  }\n\n  _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {\n    return {\n      changes: [{\n        range: range,\n        rangeOffset: rangeOffset,\n        rangeLength: rangeLength,\n        text: text\n      }],\n      eol: this._buffer.getEOL(),\n      versionId: this.getVersionId(),\n      isUndoing: isUndoing,\n      isRedoing: isRedoing,\n      isFlush: isFlush\n    };\n  }\n\n  _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n    this._assertNotDisposed();\n\n    const oldFullModelRange = this.getFullModelRange();\n    const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n    const endLineNumber = this.getLineCount();\n    const endColumn = this.getLineMaxColumn(endLineNumber);\n    this._buffer = textBuffer;\n\n    this._bufferDisposable.dispose();\n\n    this._bufferDisposable = textBufferDisposable;\n\n    this._increaseVersionId(); // Flush all tokens\n\n\n    this._tokens.flush();\n\n    this._tokens2.flush(); // Destroy all my decorations\n\n\n    this._decorations = Object.create(null);\n    this._decorationsTree = new DecorationsTrees(); // Destroy my edit history and settings\n\n    this._commandManager.clear();\n\n    this._trimAutoWhitespaceLines = null;\n\n    this._emitContentChangedEvent(new ModelRawContentChangedEvent([new ModelRawFlush()], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));\n  }\n\n  setEOL(eol) {\n    this._assertNotDisposed();\n\n    const newEOL = eol === 1\n    /* CRLF */\n    ? '\\r\\n' : '\\n';\n\n    if (this._buffer.getEOL() === newEOL) {\n      // Nothing to do\n      return;\n    }\n\n    const oldFullModelRange = this.getFullModelRange();\n    const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n    const endLineNumber = this.getLineCount();\n    const endColumn = this.getLineMaxColumn(endLineNumber);\n\n    this._onBeforeEOLChange();\n\n    this._buffer.setEOL(newEOL);\n\n    this._increaseVersionId();\n\n    this._onAfterEOLChange();\n\n    this._emitContentChangedEvent(new ModelRawContentChangedEvent([new ModelRawEOLChanged()], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));\n  }\n\n  _onBeforeEOLChange() {\n    // Ensure all decorations get their `range` set.\n    this._decorationsTree.ensureAllNodesHaveRanges(this);\n  }\n\n  _onAfterEOLChange() {\n    // Transform back `range` to offsets\n    const versionId = this.getVersionId();\n\n    const allDecorations = this._decorationsTree.collectNodesPostOrder();\n\n    for (let i = 0, len = allDecorations.length; i < len; i++) {\n      const node = allDecorations[i];\n      const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n\n      const delta = node.cachedAbsoluteStart - node.start;\n\n      const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\n      const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n      node.cachedAbsoluteStart = startOffset;\n      node.cachedAbsoluteEnd = endOffset;\n      node.cachedVersionId = versionId;\n      node.start = startOffset - delta;\n      node.end = endOffset - delta;\n      recomputeMaxEnd(node);\n    }\n  }\n\n  onBeforeAttached() {\n    this._attachedEditorCount++;\n\n    if (this._attachedEditorCount === 1) {\n      this._onDidChangeAttached.fire(undefined);\n    }\n  }\n\n  onBeforeDetached() {\n    this._attachedEditorCount--;\n\n    if (this._attachedEditorCount === 0) {\n      this._onDidChangeAttached.fire(undefined);\n    }\n  }\n\n  isAttachedToEditor() {\n    return this._attachedEditorCount > 0;\n  }\n\n  getAttachedEditorCount() {\n    return this._attachedEditorCount;\n  }\n\n  isTooLargeForSyncing() {\n    return this._isTooLargeForSyncing;\n  }\n\n  isTooLargeForTokenization() {\n    return this._isTooLargeForTokenization;\n  }\n\n  isDisposed() {\n    return this._isDisposed;\n  }\n\n  isDominatedByLongLines() {\n    this._assertNotDisposed();\n\n    if (this.isTooLargeForTokenization()) {\n      // Cannot word wrap huge files anyways, so it doesn't really matter\n      return false;\n    }\n\n    let smallLineCharCount = 0;\n    let longLineCharCount = 0;\n\n    const lineCount = this._buffer.getLineCount();\n\n    for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n      const lineLength = this._buffer.getLineLength(lineNumber);\n\n      if (lineLength >= LONG_LINE_BOUNDARY) {\n        longLineCharCount += lineLength;\n      } else {\n        smallLineCharCount += lineLength;\n      }\n    }\n\n    return longLineCharCount > smallLineCharCount;\n  }\n\n  get uri() {\n    return this._associatedResource;\n  } //#region Options\n\n\n  getOptions() {\n    this._assertNotDisposed();\n\n    return this._options;\n  }\n\n  getFormattingOptions() {\n    return {\n      tabSize: this._options.indentSize,\n      insertSpaces: this._options.insertSpaces\n    };\n  }\n\n  updateOptions(_newOpts) {\n    this._assertNotDisposed();\n\n    let tabSize = typeof _newOpts.tabSize !== 'undefined' ? _newOpts.tabSize : this._options.tabSize;\n    let indentSize = typeof _newOpts.indentSize !== 'undefined' ? _newOpts.indentSize : this._options.indentSize;\n    let insertSpaces = typeof _newOpts.insertSpaces !== 'undefined' ? _newOpts.insertSpaces : this._options.insertSpaces;\n    let trimAutoWhitespace = typeof _newOpts.trimAutoWhitespace !== 'undefined' ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n    let bracketPairColorizationOptions = typeof _newOpts.bracketColorizationOptions !== 'undefined' ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n    let newOpts = new model.TextModelResolvedOptions({\n      tabSize: tabSize,\n      indentSize: indentSize,\n      insertSpaces: insertSpaces,\n      defaultEOL: this._options.defaultEOL,\n      trimAutoWhitespace: trimAutoWhitespace,\n      bracketPairColorizationOptions\n    });\n\n    if (this._options.equals(newOpts)) {\n      return;\n    }\n\n    let e = this._options.createChangeEvent(newOpts);\n\n    this._options = newOpts;\n\n    this._onDidChangeOptions.fire(e);\n  }\n\n  detectIndentation(defaultInsertSpaces, defaultTabSize) {\n    this._assertNotDisposed();\n\n    let guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n    this.updateOptions({\n      insertSpaces: guessedIndentation.insertSpaces,\n      tabSize: guessedIndentation.tabSize,\n      indentSize: guessedIndentation.tabSize // TODO@Alex: guess indentSize independent of tabSize\n\n    });\n  }\n\n  static _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n\n    for (let i = 0; i < str.length; i++) {\n      if (str.charAt(i) === '\\t') {\n        spacesCnt += indentSize;\n      } else {\n        spacesCnt++;\n      }\n    }\n\n    let result = '';\n\n    if (!insertSpaces) {\n      let tabsCnt = Math.floor(spacesCnt / indentSize);\n      spacesCnt = spacesCnt % indentSize;\n\n      for (let i = 0; i < tabsCnt; i++) {\n        result += '\\t';\n      }\n    }\n\n    for (let i = 0; i < spacesCnt; i++) {\n      result += ' ';\n    }\n\n    return result;\n  }\n\n  static normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n\n    if (firstNonWhitespaceIndex === -1) {\n      firstNonWhitespaceIndex = str.length;\n    }\n\n    return TextModel._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n  }\n\n  normalizeIndentation(str) {\n    this._assertNotDisposed();\n\n    return TextModel.normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n  } //#endregion\n  //#region Reading\n\n\n  getVersionId() {\n    this._assertNotDisposed();\n\n    return this._versionId;\n  }\n\n  mightContainRTL() {\n    return this._buffer.mightContainRTL();\n  }\n\n  mightContainUnusualLineTerminators() {\n    return this._buffer.mightContainUnusualLineTerminators();\n  }\n\n  removeUnusualLineTerminators() {\n    let selections = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    );\n\n    this._buffer.resetMightContainUnusualLineTerminators();\n\n    this.pushEditOperations(selections, matches.map(m => ({\n      range: m.range,\n      text: null\n    })), () => null);\n  }\n\n  mightContainNonBasicASCII() {\n    return this._buffer.mightContainNonBasicASCII();\n  }\n\n  getAlternativeVersionId() {\n    this._assertNotDisposed();\n\n    return this._alternativeVersionId;\n  }\n\n  getInitialUndoRedoSnapshot() {\n    this._assertNotDisposed();\n\n    return this._initialUndoRedoSnapshot;\n  }\n\n  getOffsetAt(rawPosition) {\n    this._assertNotDisposed();\n\n    let position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0\n    /* Relaxed */\n    );\n\n    return this._buffer.getOffsetAt(position.lineNumber, position.column);\n  }\n\n  getPositionAt(rawOffset) {\n    this._assertNotDisposed();\n\n    let offset = Math.min(this._buffer.getLength(), Math.max(0, rawOffset));\n    return this._buffer.getPositionAt(offset);\n  }\n\n  _increaseVersionId() {\n    this._versionId = this._versionId + 1;\n    this._alternativeVersionId = this._versionId;\n  }\n\n  _overwriteVersionId(versionId) {\n    this._versionId = versionId;\n  }\n\n  _overwriteAlternativeVersionId(newAlternativeVersionId) {\n    this._alternativeVersionId = newAlternativeVersionId;\n  }\n\n  _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n    this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n  }\n\n  getValue(eol) {\n    let preserveBOM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    this._assertNotDisposed();\n\n    const fullModelRange = this.getFullModelRange();\n    const fullModelValue = this.getValueInRange(fullModelRange, eol);\n\n    if (preserveBOM) {\n      return this._buffer.getBOM() + fullModelValue;\n    }\n\n    return fullModelValue;\n  }\n\n  createSnapshot() {\n    let preserveBOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n  }\n\n  getValueLength(eol) {\n    let preserveBOM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    this._assertNotDisposed();\n\n    const fullModelRange = this.getFullModelRange();\n    const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n\n    if (preserveBOM) {\n      return this._buffer.getBOM().length + fullModelValue;\n    }\n\n    return fullModelValue;\n  }\n\n  getValueInRange(rawRange) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    this._assertNotDisposed();\n\n    return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n  }\n\n  getValueLengthInRange(rawRange) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    this._assertNotDisposed();\n\n    return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n  }\n\n  getCharacterCountInRange(rawRange) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    this._assertNotDisposed();\n\n    return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n  }\n\n  getLineCount() {\n    this._assertNotDisposed();\n\n    return this._buffer.getLineCount();\n  }\n\n  getLineContent(lineNumber) {\n    this._assertNotDisposed();\n\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._buffer.getLineContent(lineNumber);\n  }\n\n  getLineLength(lineNumber) {\n    this._assertNotDisposed();\n\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._buffer.getLineLength(lineNumber);\n  }\n\n  getLinesContent() {\n    this._assertNotDisposed();\n\n    return this._buffer.getLinesContent();\n  }\n\n  getEOL() {\n    this._assertNotDisposed();\n\n    return this._buffer.getEOL();\n  }\n\n  getEndOfLineSequence() {\n    this._assertNotDisposed();\n\n    return this._buffer.getEOL() === '\\n' ? 0\n    /* LF */\n    : 1\n    /* CRLF */\n    ;\n  }\n\n  getLineMinColumn(lineNumber) {\n    this._assertNotDisposed();\n\n    return 1;\n  }\n\n  getLineMaxColumn(lineNumber) {\n    this._assertNotDisposed();\n\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._buffer.getLineLength(lineNumber) + 1;\n  }\n\n  getLineFirstNonWhitespaceColumn(lineNumber) {\n    this._assertNotDisposed();\n\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n  }\n\n  getLineLastNonWhitespaceColumn(lineNumber) {\n    this._assertNotDisposed();\n\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n  }\n  /**\n   * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n   * Will try to not allocate if possible.\n   */\n\n\n  _validateRangeRelaxedNoAllocations(range) {\n    const linesCount = this._buffer.getLineCount();\n\n    const initialStartLineNumber = range.startLineNumber;\n    const initialStartColumn = range.startColumn;\n    let startLineNumber = Math.floor(typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber) ? initialStartLineNumber : 1);\n    let startColumn = Math.floor(typeof initialStartColumn === 'number' && !isNaN(initialStartColumn) ? initialStartColumn : 1);\n\n    if (startLineNumber < 1) {\n      startLineNumber = 1;\n      startColumn = 1;\n    } else if (startLineNumber > linesCount) {\n      startLineNumber = linesCount;\n      startColumn = this.getLineMaxColumn(startLineNumber);\n    } else {\n      if (startColumn <= 1) {\n        startColumn = 1;\n      } else {\n        const maxColumn = this.getLineMaxColumn(startLineNumber);\n\n        if (startColumn >= maxColumn) {\n          startColumn = maxColumn;\n        }\n      }\n    }\n\n    const initialEndLineNumber = range.endLineNumber;\n    const initialEndColumn = range.endColumn;\n    let endLineNumber = Math.floor(typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber) ? initialEndLineNumber : 1);\n    let endColumn = Math.floor(typeof initialEndColumn === 'number' && !isNaN(initialEndColumn) ? initialEndColumn : 1);\n\n    if (endLineNumber < 1) {\n      endLineNumber = 1;\n      endColumn = 1;\n    } else if (endLineNumber > linesCount) {\n      endLineNumber = linesCount;\n      endColumn = this.getLineMaxColumn(endLineNumber);\n    } else {\n      if (endColumn <= 1) {\n        endColumn = 1;\n      } else {\n        const maxColumn = this.getLineMaxColumn(endLineNumber);\n\n        if (endColumn >= maxColumn) {\n          endColumn = maxColumn;\n        }\n      }\n    }\n\n    if (initialStartLineNumber === startLineNumber && initialStartColumn === startColumn && initialEndLineNumber === endLineNumber && initialEndColumn === endColumn && range instanceof Range && !(range instanceof Selection)) {\n      return range;\n    }\n\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n\n  _isValidPosition(lineNumber, column, validationType) {\n    if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n      return false;\n    }\n\n    if (isNaN(lineNumber) || isNaN(column)) {\n      return false;\n    }\n\n    if (lineNumber < 1 || column < 1) {\n      return false;\n    }\n\n    if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n      return false;\n    }\n\n    const lineCount = this._buffer.getLineCount();\n\n    if (lineNumber > lineCount) {\n      return false;\n    }\n\n    if (column === 1) {\n      return true;\n    }\n\n    const maxColumn = this.getLineMaxColumn(lineNumber);\n\n    if (column > maxColumn) {\n      return false;\n    }\n\n    if (validationType === 1\n    /* SurrogatePairs */\n    ) {\n      // !!At this point, column > 1\n      const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n\n      if (strings.isHighSurrogate(charCodeBefore)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _validatePosition(_lineNumber, _column, validationType) {\n    const lineNumber = Math.floor(typeof _lineNumber === 'number' && !isNaN(_lineNumber) ? _lineNumber : 1);\n    const column = Math.floor(typeof _column === 'number' && !isNaN(_column) ? _column : 1);\n\n    const lineCount = this._buffer.getLineCount();\n\n    if (lineNumber < 1) {\n      return new Position(1, 1);\n    }\n\n    if (lineNumber > lineCount) {\n      return new Position(lineCount, this.getLineMaxColumn(lineCount));\n    }\n\n    if (column <= 1) {\n      return new Position(lineNumber, 1);\n    }\n\n    const maxColumn = this.getLineMaxColumn(lineNumber);\n\n    if (column >= maxColumn) {\n      return new Position(lineNumber, maxColumn);\n    }\n\n    if (validationType === 1\n    /* SurrogatePairs */\n    ) {\n      // If the position would end up in the middle of a high-low surrogate pair,\n      // we move it to before the pair\n      // !!At this point, column > 1\n      const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n\n      if (strings.isHighSurrogate(charCodeBefore)) {\n        return new Position(lineNumber, column - 1);\n      }\n    }\n\n    return new Position(lineNumber, column);\n  }\n\n  validatePosition(position) {\n    const validationType = 1\n    /* SurrogatePairs */\n    ;\n\n    this._assertNotDisposed(); // Avoid object allocation and cover most likely case\n\n\n    if (position instanceof Position) {\n      if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n        return position;\n      }\n    }\n\n    return this._validatePosition(position.lineNumber, position.column, validationType);\n  }\n\n  _isValidRange(range, validationType) {\n    const startLineNumber = range.startLineNumber;\n    const startColumn = range.startColumn;\n    const endLineNumber = range.endLineNumber;\n    const endColumn = range.endColumn;\n\n    if (!this._isValidPosition(startLineNumber, startColumn, 0\n    /* Relaxed */\n    )) {\n      return false;\n    }\n\n    if (!this._isValidPosition(endLineNumber, endColumn, 0\n    /* Relaxed */\n    )) {\n      return false;\n    }\n\n    if (validationType === 1\n    /* SurrogatePairs */\n    ) {\n      const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;\n      const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;\n      const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n      const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n\n      if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n        return true;\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n\n  validateRange(_range) {\n    const validationType = 1\n    /* SurrogatePairs */\n    ;\n\n    this._assertNotDisposed(); // Avoid object allocation and cover most likely case\n\n\n    if (_range instanceof Range && !(_range instanceof Selection)) {\n      if (this._isValidRange(_range, validationType)) {\n        return _range;\n      }\n    }\n\n    const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0\n    /* Relaxed */\n    );\n\n    const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0\n    /* Relaxed */\n    );\n\n    const startLineNumber = start.lineNumber;\n    const startColumn = start.column;\n    const endLineNumber = end.lineNumber;\n    const endColumn = end.column;\n\n    if (validationType === 1\n    /* SurrogatePairs */\n    ) {\n      const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;\n      const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;\n      const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n      const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n\n      if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n      }\n\n      if (startLineNumber === endLineNumber && startColumn === endColumn) {\n        // do not expand a collapsed range, simply move it to a valid location\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n      }\n\n      if (startInsideSurrogatePair && endInsideSurrogatePair) {\n        // expand range at both ends\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n      }\n\n      if (startInsideSurrogatePair) {\n        // only expand range at the start\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n      } // only expand range at the end\n\n\n      return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n    }\n\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n\n  modifyPosition(rawPosition, offset) {\n    this._assertNotDisposed();\n\n    let candidate = this.getOffsetAt(rawPosition) + offset;\n    return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n  }\n\n  getFullModelRange() {\n    this._assertNotDisposed();\n\n    const lineCount = this.getLineCount();\n    return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n  }\n\n  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n    return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n  }\n\n  findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches) {\n    let limitResultCount = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : LIMIT_FIND_COUNT;\n\n    this._assertNotDisposed();\n\n    let searchRanges = null;\n\n    if (rawSearchScope !== null) {\n      if (!Array.isArray(rawSearchScope)) {\n        rawSearchScope = [rawSearchScope];\n      }\n\n      if (rawSearchScope.every(searchScope => Range.isIRange(searchScope))) {\n        searchRanges = rawSearchScope.map(searchScope => this.validateRange(searchScope));\n      }\n    }\n\n    if (searchRanges === null) {\n      searchRanges = [this.getFullModelRange()];\n    }\n\n    searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n    const uniqueSearchRanges = [];\n    uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n      if (Range.areIntersecting(prev, curr)) {\n        return prev.plusRange(curr);\n      }\n\n      uniqueSearchRanges.push(prev);\n      return curr;\n    }));\n    let matchMapper;\n\n    if (!isRegex && searchString.indexOf('\\n') < 0) {\n      // not regex, not multi line\n      const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n      const searchData = searchParams.parseSearchRequest();\n\n      if (!searchData) {\n        return [];\n      }\n\n      matchMapper = searchRange => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    } else {\n      matchMapper = searchRange => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n    }\n\n    return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n  }\n\n  findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n    this._assertNotDisposed();\n\n    const searchStart = this.validatePosition(rawSearchStart);\n\n    if (!isRegex && searchString.indexOf('\\n') < 0) {\n      const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n      const searchData = searchParams.parseSearchRequest();\n\n      if (!searchData) {\n        return null;\n      }\n\n      const lineCount = this.getLineCount();\n      let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n      let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n      TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n\n      if (ret.length > 0) {\n        return ret[0];\n      }\n\n      searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n      ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n\n      if (ret.length > 0) {\n        return ret[0];\n      }\n\n      return null;\n    }\n\n    return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n  }\n\n  findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n    this._assertNotDisposed();\n\n    const searchStart = this.validatePosition(rawSearchStart);\n    return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n  } //#endregion\n  //#region Editing\n\n\n  pushStackElement() {\n    this._commandManager.pushStackElement();\n  }\n\n  popStackElement() {\n    this._commandManager.popStackElement();\n  }\n\n  pushEOL(eol) {\n    const currentEOL = this.getEOL() === '\\n' ? 0\n    /* LF */\n    : 1\n    /* CRLF */\n    ;\n\n    if (currentEOL === eol) {\n      return;\n    }\n\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      this._eventEmitter.beginDeferredEmit();\n\n      if (this._initialUndoRedoSnapshot === null) {\n        this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n      }\n\n      this._commandManager.pushEOL(eol);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n\n  _validateEditOperation(rawOperation) {\n    if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n      return rawOperation;\n    }\n\n    return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n  }\n\n  _validateEditOperations(rawOperations) {\n    const result = [];\n\n    for (let i = 0, len = rawOperations.length; i < len; i++) {\n      result[i] = this._validateEditOperation(rawOperations[i]);\n    }\n\n    return result;\n  }\n\n  pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      this._eventEmitter.beginDeferredEmit();\n\n      return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n\n  _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n    if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n      // Go through each saved line number and insert a trim whitespace edit\n      // if it is safe to do so (no conflicts with other edits).\n      let incomingEdits = editOperations.map(op => {\n        return {\n          range: this.validateRange(op.range),\n          text: op.text\n        };\n      }); // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n      // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n\n      let editsAreNearCursors = true;\n\n      if (beforeCursorState) {\n        for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n          let sel = beforeCursorState[i];\n          let foundEditNearSel = false;\n\n          for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n            let editRange = incomingEdits[j].range;\n            let selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n            let selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n\n            if (!selIsAbove && !selIsBelow) {\n              foundEditNearSel = true;\n              break;\n            }\n          }\n\n          if (!foundEditNearSel) {\n            editsAreNearCursors = false;\n            break;\n          }\n        }\n      }\n\n      if (editsAreNearCursors) {\n        for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n          let trimLineNumber = this._trimAutoWhitespaceLines[i];\n          let maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n          let allowTrimLine = true;\n\n          for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n            let editRange = incomingEdits[j].range;\n            let editText = incomingEdits[j].text;\n\n            if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n              // `trimLine` is completely outside this edit\n              continue;\n            } // At this point:\n            //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n\n\n            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n              // This edit inserts a new line (and maybe other text) after `trimLine`\n              continue;\n            }\n\n            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1 && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n              // This edit inserts a new line (and maybe other text) before `trimLine`\n              continue;\n            } // Looks like we can't trim this line as it would interfere with an incoming edit\n\n\n            allowTrimLine = false;\n            break;\n          }\n\n          if (allowTrimLine) {\n            const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n            editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n          }\n        }\n      }\n\n      this._trimAutoWhitespaceLines = null;\n    }\n\n    if (this._initialUndoRedoSnapshot === null) {\n      this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n    }\n\n    return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);\n  }\n\n  _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n    const edits = changes.map(change => {\n      const rangeStart = this.getPositionAt(change.newPosition);\n      const rangeEnd = this.getPositionAt(change.newEnd);\n      return {\n        range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n        text: change.oldText\n      };\n    });\n\n    this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n  }\n\n  _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n    const edits = changes.map(change => {\n      const rangeStart = this.getPositionAt(change.oldPosition);\n      const rangeEnd = this.getPositionAt(change.oldEnd);\n      return {\n        range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n        text: change.newText\n      };\n    });\n\n    this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n  }\n\n  _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      this._eventEmitter.beginDeferredEmit();\n\n      this._isUndoing = isUndoing;\n      this._isRedoing = isRedoing;\n      this.applyEdits(edits, false);\n      this.setEOL(eol);\n\n      this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n    } finally {\n      this._isUndoing = false;\n      this._isRedoing = false;\n\n      this._eventEmitter.endDeferredEmit(resultingSelection);\n\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n\n  applyEdits(rawOperations) {\n    let computeUndoEdits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      this._eventEmitter.beginDeferredEmit();\n\n      const operations = this._validateEditOperations(rawOperations);\n\n      return this._doApplyEdits(operations, computeUndoEdits);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n\n  _doApplyEdits(rawOperations, computeUndoEdits) {\n    const oldLineCount = this._buffer.getLineCount();\n\n    const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n\n    const newLineCount = this._buffer.getLineCount();\n\n    const contentChanges = result.changes;\n    this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n\n    if (contentChanges.length !== 0) {\n      // We do a first pass to update tokens and decorations\n      // because we want to read decorations in the second pass\n      // where we will emit content change events\n      // and we want to read the final decorations\n      for (let i = 0, len = contentChanges.length; i < len; i++) {\n        const change = contentChanges[i];\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(change.text);\n\n        this._tokens.acceptEdit(change.range, eolCount, firstLineLength);\n\n        this._tokens2.acceptEdit(change.range, eolCount, firstLineLength, lastLineLength, change.text.length > 0 ? change.text.charCodeAt(0) : 0\n        /* Null */\n        );\n\n        this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n      }\n\n      let rawContentChanges = [];\n\n      this._increaseVersionId();\n\n      let lineCount = oldLineCount;\n\n      for (let i = 0, len = contentChanges.length; i < len; i++) {\n        const change = contentChanges[i];\n        const [eolCount] = countEOL(change.text);\n\n        this._onDidChangeDecorations.fire();\n\n        const startLineNumber = change.range.startLineNumber;\n        const endLineNumber = change.range.endLineNumber;\n        const deletingLinesCnt = endLineNumber - startLineNumber;\n        const insertingLinesCnt = eolCount;\n        const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n        const changeLineCountDelta = insertingLinesCnt - deletingLinesCnt;\n        const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n        const firstEditLineNumber = currentEditStartLineNumber;\n        const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n\n        const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n\n        const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n        const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n\n        for (let j = editingLinesCnt; j >= 0; j--) {\n          const editLineNumber = startLineNumber + j;\n          const currentEditLineNumber = currentEditStartLineNumber + j;\n          injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n          const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n          rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n        }\n\n        if (editingLinesCnt < deletingLinesCnt) {\n          // Must delete some lines\n          const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n          rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n        }\n\n        if (editingLinesCnt < insertingLinesCnt) {\n          const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange); // Must insert some lines\n\n          const spliceLineNumber = startLineNumber + editingLinesCnt;\n          const cnt = insertingLinesCnt - editingLinesCnt;\n          const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n          let injectedTexts = [];\n          let newLines = [];\n\n          for (let i = 0; i < cnt; i++) {\n            let lineNumber = fromLineNumber + i;\n            newLines[i] = this.getLineContent(lineNumber);\n            injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n            injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n          }\n\n          rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n        }\n\n        lineCount += changeLineCountDelta;\n      }\n\n      this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n        changes: contentChanges,\n        eol: this._buffer.getEOL(),\n        versionId: this.getVersionId(),\n        isUndoing: this._isUndoing,\n        isRedoing: this._isRedoing,\n        isFlush: false\n      });\n    }\n\n    return result.reverseEdits === null ? undefined : result.reverseEdits;\n  }\n\n  undo() {\n    return this._undoRedoService.undo(this.uri);\n  }\n\n  canUndo() {\n    return this._undoRedoService.canUndo(this.uri);\n  }\n\n  redo() {\n    return this._undoRedoService.redo(this.uri);\n  }\n\n  canRedo() {\n    return this._undoRedoService.canRedo(this.uri);\n  } //#endregion\n  //#region Decorations\n\n\n  handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n    // This is called before the decoration changed event is fired.\n    if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n      return;\n    }\n\n    const affectedLines = [...affectedInjectedTextLines];\n    const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n\n    this._onDidChangeContentOrInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n  }\n\n  changeDecorations(callback) {\n    let ownerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    this._assertNotDisposed();\n\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      return this._changeDecorations(ownerId, callback);\n    } finally {\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n\n  _changeDecorations(ownerId, callback) {\n    let changeAccessor = {\n      addDecoration: (range, options) => {\n        return this._deltaDecorationsImpl(ownerId, [], [{\n          range: range,\n          options: options\n        }])[0];\n      },\n      changeDecoration: (id, newRange) => {\n        this._changeDecorationImpl(id, newRange);\n      },\n      changeDecorationOptions: (id, options) => {\n        this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n      },\n      removeDecoration: id => {\n        this._deltaDecorationsImpl(ownerId, [id], []);\n      },\n      deltaDecorations: (oldDecorations, newDecorations) => {\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n          // nothing to do\n          return [];\n        }\n\n        return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n      }\n    };\n    let result = null;\n\n    try {\n      result = callback(changeAccessor);\n    } catch (e) {\n      onUnexpectedError(e);\n    } // Invalidate change accessor\n\n\n    changeAccessor.addDecoration = invalidFunc;\n    changeAccessor.changeDecoration = invalidFunc;\n    changeAccessor.changeDecorationOptions = invalidFunc;\n    changeAccessor.removeDecoration = invalidFunc;\n    changeAccessor.deltaDecorations = invalidFunc;\n    return result;\n  }\n\n  deltaDecorations(oldDecorations, newDecorations) {\n    let ownerId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    this._assertNotDisposed();\n\n    if (!oldDecorations) {\n      oldDecorations = [];\n    }\n\n    if (oldDecorations.length === 0 && newDecorations.length === 0) {\n      // nothing to do\n      return [];\n    }\n\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n    } finally {\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n\n  _getTrackedRange(id) {\n    return this.getDecorationRange(id);\n  }\n\n  _setTrackedRange(id, newRange, newStickiness) {\n    const node = id ? this._decorations[id] : null;\n\n    if (!node) {\n      if (!newRange) {\n        // node doesn't exist, the request is to delete => nothing to do\n        return null;\n      } // node doesn't exist, the request is to set => add the tracked range\n\n\n      return this._deltaDecorationsImpl(0, [], [{\n        range: newRange,\n        options: TRACKED_RANGE_OPTIONS[newStickiness]\n      }])[0];\n    }\n\n    if (!newRange) {\n      // node exists, the request is to delete => delete node\n      this._decorationsTree.delete(node);\n\n      delete this._decorations[node.id];\n      return null;\n    } // node exists, the request is to set => change the tracked range and its options\n\n\n    const range = this._validateRangeRelaxedNoAllocations(newRange);\n\n    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\n    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n    this._decorationsTree.delete(node);\n\n    node.reset(this.getVersionId(), startOffset, endOffset, range);\n    node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n\n    this._decorationsTree.insert(node);\n\n    return node.id;\n  }\n\n  removeAllDecorationsWithOwnerId(ownerId) {\n    if (this._isDisposed) {\n      return;\n    }\n\n    const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n\n    for (let i = 0, len = nodes.length; i < len; i++) {\n      const node = nodes[i];\n\n      this._decorationsTree.delete(node);\n\n      delete this._decorations[node.id];\n    }\n  }\n\n  getDecorationOptions(decorationId) {\n    const node = this._decorations[decorationId];\n\n    if (!node) {\n      return null;\n    }\n\n    return node.options;\n  }\n\n  getDecorationRange(decorationId) {\n    const node = this._decorations[decorationId];\n\n    if (!node) {\n      return null;\n    }\n\n    return this._decorationsTree.getNodeRange(this, node);\n  }\n\n  getLineDecorations(lineNumber) {\n    let ownerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let filterOutValidation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      return [];\n    }\n\n    return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n  }\n\n  getLinesDecorations(_startLineNumber, _endLineNumber) {\n    let ownerId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let filterOutValidation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let lineCount = this.getLineCount();\n    let startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n    let endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n    let endColumn = this.getLineMaxColumn(endLineNumber);\n    const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n\n    const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation);\n\n    decorations.push(...this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n    return decorations;\n  }\n\n  getDecorationsInRange(range) {\n    let ownerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let filterOutValidation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let validatedRange = this.validateRange(range);\n\n    const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);\n\n    decorations.push(...this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation));\n    return decorations;\n  }\n\n  getOverviewRulerDecorations() {\n    let ownerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let filterOutValidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true);\n  }\n\n  getInjectedTextDecorations() {\n    let ownerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return this._decorationsTree.getAllInjectedText(this, ownerId);\n  }\n\n  _getInjectedTextInLine(lineNumber) {\n    const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n\n    const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n\n    const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n\n    return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n  }\n\n  getAllDecorations() {\n    let ownerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let filterOutValidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false);\n\n    result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n    return result;\n  }\n\n  _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation) {\n    const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n\n    const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n\n    return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation);\n  }\n\n  getRangeAt(start, end) {\n    return this._buffer.getRangeAt(start, end - start);\n  }\n\n  _changeDecorationImpl(decorationId, _range) {\n    const node = this._decorations[decorationId];\n\n    if (!node) {\n      return;\n    }\n\n    if (node.options.after) {\n      const oldRange = this.getDecorationRange(decorationId);\n\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n    }\n\n    if (node.options.before) {\n      const oldRange = this.getDecorationRange(decorationId);\n\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n    }\n\n    const range = this._validateRangeRelaxedNoAllocations(_range);\n\n    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\n    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n    this._decorationsTree.delete(node);\n\n    node.reset(this.getVersionId(), startOffset, endOffset, range);\n\n    this._decorationsTree.insert(node);\n\n    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n\n    if (node.options.after) {\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n    }\n\n    if (node.options.before) {\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n    }\n  }\n\n  _changeDecorationOptionsImpl(decorationId, options) {\n    const node = this._decorations[decorationId];\n\n    if (!node) {\n      return;\n    }\n\n    const nodeWasInOverviewRuler = node.options.overviewRuler && node.options.overviewRuler.color ? true : false;\n    const nodeIsInOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n\n    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n\n    this._onDidChangeDecorations.checkAffectedAndFire(options);\n\n    if (node.options.after || options.after) {\n      const nodeRange = this._decorationsTree.getNodeRange(this, node);\n\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n    }\n\n    if (node.options.before || options.before) {\n      const nodeRange = this._decorationsTree.getNodeRange(this, node);\n\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n    }\n\n    if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\n      // Delete + Insert due to an overview ruler status change\n      this._decorationsTree.delete(node);\n\n      node.setOptions(options);\n\n      this._decorationsTree.insert(node);\n    } else {\n      node.setOptions(options);\n    }\n  }\n\n  _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations) {\n    const versionId = this.getVersionId();\n    const oldDecorationsLen = oldDecorationsIds.length;\n    let oldDecorationIndex = 0;\n    const newDecorationsLen = newDecorations.length;\n    let newDecorationIndex = 0;\n    let result = new Array(newDecorationsLen);\n\n    while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n      let node = null;\n\n      if (oldDecorationIndex < oldDecorationsLen) {\n        // (1) get ourselves an old node\n        do {\n          node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n        } while (!node && oldDecorationIndex < oldDecorationsLen); // (2) remove the node from the tree (if it exists)\n\n\n        if (node) {\n          if (node.options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n          }\n\n          if (node.options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n          }\n\n          this._decorationsTree.delete(node);\n\n          this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        }\n      }\n\n      if (newDecorationIndex < newDecorationsLen) {\n        // (3) create a new node if necessary\n        if (!node) {\n          const internalDecorationId = ++this._lastDecorationId;\n          const decorationId = `${this._instanceId};${internalDecorationId}`;\n          node = new IntervalNode(decorationId, 0, 0);\n          this._decorations[decorationId] = node;\n        } // (4) initialize node\n\n\n        const newDecoration = newDecorations[newDecorationIndex];\n\n        const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n\n        const options = _normalizeOptions(newDecoration.options);\n\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n        node.ownerId = ownerId;\n        node.reset(versionId, startOffset, endOffset, range);\n        node.setOptions(options);\n\n        if (node.options.after) {\n          this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n\n        if (node.options.before) {\n          this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n\n        this._decorationsTree.insert(node);\n\n        result[newDecorationIndex] = node.id;\n        newDecorationIndex++;\n      } else {\n        if (node) {\n          delete this._decorations[node.id];\n        }\n      }\n    }\n\n    return result;\n  }\n\n  setTokens(tokens) {\n    let backgroundTokenizationCompleted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (tokens.length !== 0) {\n      let ranges = [];\n\n      for (let i = 0, len = tokens.length; i < len; i++) {\n        const element = tokens[i];\n        let minChangedLineNumber = 0;\n        let maxChangedLineNumber = 0;\n        let hasChange = false;\n\n        for (let j = 0, lenJ = element.tokens.length; j < lenJ; j++) {\n          const lineNumber = element.startLineNumber + j;\n\n          if (hasChange) {\n            this._tokens.setTokens(this._languageId, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.tokens[j], false);\n\n            maxChangedLineNumber = lineNumber;\n          } else {\n            const lineHasChange = this._tokens.setTokens(this._languageId, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.tokens[j], true);\n\n            if (lineHasChange) {\n              hasChange = true;\n              minChangedLineNumber = lineNumber;\n              maxChangedLineNumber = lineNumber;\n            }\n          }\n        }\n\n        if (hasChange) {\n          ranges.push({\n            fromLineNumber: minChangedLineNumber,\n            toLineNumber: maxChangedLineNumber\n          });\n        }\n      }\n\n      if (ranges.length > 0) {\n        this._emitModelTokensChangedEvent({\n          tokenizationSupportChanged: false,\n          semanticTokensApplied: false,\n          ranges: ranges\n        });\n      }\n    }\n\n    this.handleTokenizationProgress(backgroundTokenizationCompleted);\n  }\n\n  setSemanticTokens(tokens, isComplete) {\n    this._tokens2.set(tokens, isComplete);\n\n    this._emitModelTokensChangedEvent({\n      tokenizationSupportChanged: false,\n      semanticTokensApplied: tokens !== null,\n      ranges: [{\n        fromLineNumber: 1,\n        toLineNumber: this.getLineCount()\n      }]\n    });\n  }\n\n  hasCompleteSemanticTokens() {\n    return this._tokens2.isComplete();\n  }\n\n  hasSomeSemanticTokens() {\n    return !this._tokens2.isEmpty();\n  }\n\n  setPartialSemanticTokens(range, tokens) {\n    if (this.hasCompleteSemanticTokens()) {\n      return;\n    }\n\n    const changedRange = this._tokens2.setPartial(range, tokens);\n\n    this._emitModelTokensChangedEvent({\n      tokenizationSupportChanged: false,\n      semanticTokensApplied: true,\n      ranges: [{\n        fromLineNumber: changedRange.startLineNumber,\n        toLineNumber: changedRange.endLineNumber\n      }]\n    });\n  }\n\n  tokenizeViewport(startLineNumber, endLineNumber) {\n    startLineNumber = Math.max(1, startLineNumber);\n    endLineNumber = Math.min(this._buffer.getLineCount(), endLineNumber);\n\n    this._tokenization.tokenizeViewport(startLineNumber, endLineNumber);\n  }\n\n  clearTokens() {\n    this._tokens.flush();\n\n    this._emitModelTokensChangedEvent({\n      tokenizationSupportChanged: true,\n      semanticTokensApplied: false,\n      ranges: [{\n        fromLineNumber: 1,\n        toLineNumber: this._buffer.getLineCount()\n      }]\n    });\n  }\n\n  _emitModelTokensChangedEvent(e) {\n    if (!this._isDisposing) {\n      this._onDidChangeTokens.fire(e);\n    }\n  }\n\n  resetTokenization() {\n    this._tokenization.reset();\n  }\n\n  forceTokenization(lineNumber) {\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    this._tokenization.forceTokenization(lineNumber);\n  }\n\n  isCheapToTokenize(lineNumber) {\n    return this._tokenization.isCheapToTokenize(lineNumber);\n  }\n\n  tokenizeIfCheap(lineNumber) {\n    if (this.isCheapToTokenize(lineNumber)) {\n      this.forceTokenization(lineNumber);\n    }\n  }\n\n  getLineTokens(lineNumber) {\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._getLineTokens(lineNumber);\n  }\n\n  _getLineTokens(lineNumber) {\n    const lineText = this.getLineContent(lineNumber);\n\n    const syntacticTokens = this._tokens.getTokens(this._languageId, lineNumber - 1, lineText);\n\n    return this._tokens2.addSemanticTokens(lineNumber, syntacticTokens);\n  }\n\n  getLanguageId() {\n    return this._languageId;\n  }\n\n  setMode(languageId) {\n    if (this._languageId === languageId) {\n      // There's nothing to do\n      return;\n    }\n\n    let e = {\n      oldLanguage: this._languageId,\n      newLanguage: languageId\n    };\n    this._languageId = languageId;\n\n    this._onDidChangeLanguage.fire(e);\n\n    this._onDidChangeLanguageConfiguration.fire({});\n  }\n\n  getLanguageIdAtPosition(lineNumber, column) {\n    const position = this.validatePosition(new Position(lineNumber, column));\n    const lineTokens = this.getLineTokens(position.lineNumber);\n    return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n  }\n\n  getLanguageConfiguration(languageId) {\n    return this._languageConfigurationService.getLanguageConfiguration(languageId);\n  } // Having tokens allows implementing additional helper methods\n\n\n  getWordAtPosition(_position) {\n    this._assertNotDisposed();\n\n    const position = this.validatePosition(_position);\n    const lineContent = this.getLineContent(position.lineNumber);\n\n    const lineTokens = this._getLineTokens(position.lineNumber);\n\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1); // (1). First try checking right biased word\n\n    const [rbStartOffset, rbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex);\n\n    const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset); // Make sure the result touches the original passed in position\n\n    if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {\n      return rightBiasedWord;\n    } // (2). Else, if we were at a language boundary, check the left biased word\n\n\n    if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n      // edge case, where `position` sits between two tokens belonging to two different languages\n      const [lbStartOffset, lbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n\n      const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset); // Make sure the result touches the original passed in position\n\n      if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {\n        return leftBiasedWord;\n      }\n    }\n\n    return null;\n  }\n\n  static _findLanguageBoundaries(lineTokens, tokenIndex) {\n    const languageId = lineTokens.getLanguageId(tokenIndex); // go left until a different language is hit\n\n    let startOffset = 0;\n\n    for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n      startOffset = lineTokens.getStartOffset(i);\n    } // go right until a different language is hit\n\n\n    let endOffset = lineTokens.getLineContent().length;\n\n    for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n      endOffset = lineTokens.getEndOffset(i);\n    }\n\n    return [startOffset, endOffset];\n  }\n\n  getWordUntilPosition(position) {\n    const wordAtPosition = this.getWordAtPosition(position);\n\n    if (!wordAtPosition) {\n      return {\n        word: '',\n        startColumn: position.column,\n        endColumn: position.column\n      };\n    }\n\n    return {\n      word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n      startColumn: wordAtPosition.startColumn,\n      endColumn: position.column\n    };\n  }\n\n  findMatchingBracketUp(_bracket, _position) {\n    let bracket = _bracket.toLowerCase();\n\n    let position = this.validatePosition(_position);\n\n    let lineTokens = this._getLineTokens(position.lineNumber);\n\n    let languageId = lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    let bracketsSupport = this.getLanguageConfiguration(languageId).brackets;\n\n    if (!bracketsSupport) {\n      return null;\n    }\n\n    let data = bracketsSupport.textIsBracket[bracket];\n\n    if (!data) {\n      return null;\n    }\n\n    return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, null));\n  }\n\n  matchBracket(position) {\n    return this._matchBracket(this.validatePosition(position));\n  }\n\n  _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n    const tokenCount = lineTokens.getCount();\n    const currentLanguageId = lineTokens.getLanguageId(tokenIndex); // limit search to not go before `maxBracketLength`\n\n    let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n\n    for (let i = tokenIndex - 1; i >= 0; i--) {\n      const tokenEndOffset = lineTokens.getEndOffset(i);\n\n      if (tokenEndOffset <= searchStartOffset) {\n        break;\n      }\n\n      if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n        searchStartOffset = tokenEndOffset;\n        break;\n      }\n    } // limit search to not go after `maxBracketLength`\n\n\n    let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n\n    for (let i = tokenIndex + 1; i < tokenCount; i++) {\n      const tokenStartOffset = lineTokens.getStartOffset(i);\n\n      if (tokenStartOffset >= searchEndOffset) {\n        break;\n      }\n\n      if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n        searchEndOffset = tokenStartOffset;\n        break;\n      }\n    }\n\n    return {\n      searchStartOffset,\n      searchEndOffset\n    };\n  }\n\n  _matchBracket(position) {\n    const lineNumber = position.lineNumber;\n\n    const lineTokens = this._getLineTokens(lineNumber);\n\n    const lineText = this._buffer.getLineContent(lineNumber);\n\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\n    if (tokenIndex < 0) {\n      return null;\n    }\n\n    const currentModeBrackets = this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets; // check that the token is not to be ignored\n\n    if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n      let {\n        searchStartOffset,\n        searchEndOffset\n      } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex); // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n      // `bestResult` will contain the most right-side result\n\n\n      let bestResult = null;\n\n      while (true) {\n        const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n        if (!foundBracket) {\n          // there are no more brackets in this text\n          break;\n        } // check that we didn't hit a bracket too far away from position\n\n\n        if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n          const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n\n          const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], null);\n\n          if (r) {\n            if (r instanceof BracketSearchCanceled) {\n              return null;\n            }\n\n            bestResult = r;\n          }\n        }\n\n        searchStartOffset = foundBracket.endColumn - 1;\n      }\n\n      if (bestResult) {\n        return bestResult;\n      }\n    } // If position is in between two tokens, try also looking in the previous token\n\n\n    if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n      const prevTokenIndex = tokenIndex - 1;\n      const prevModeBrackets = this.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets; // check that previous token is not to be ignored\n\n      if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n        let {\n          searchStartOffset,\n          searchEndOffset\n        } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n\n        const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset); // check that we didn't hit a bracket too far away from position\n\n        if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n          const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n\n          const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], null);\n\n          if (r) {\n            if (r instanceof BracketSearchCanceled) {\n              return null;\n            }\n\n            return r;\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n    if (!data) {\n      return null;\n    }\n\n    const matched = isOpen ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate) : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate);\n\n    if (!matched) {\n      return null;\n    }\n\n    if (matched instanceof BracketSearchCanceled) {\n      return matched;\n    }\n\n    return [foundBracket, matched];\n  }\n\n  _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n    // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n    const languageId = bracket.languageId;\n    const reversedBracketRegex = bracket.reversedRegex;\n    let count = -1;\n    let totalCallCount = 0;\n\n    const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n      while (true) {\n        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n          return BracketSearchCanceled.INSTANCE;\n        }\n\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n        if (!r) {\n          break;\n        }\n\n        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n\n        if (bracket.isOpen(hitText)) {\n          count++;\n        } else if (bracket.isClose(hitText)) {\n          count--;\n        }\n\n        if (count === 0) {\n          return r;\n        }\n\n        searchEndOffset = r.startColumn - 1;\n      }\n\n      return null;\n    };\n\n    for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n      const lineTokens = this._getLineTokens(lineNumber);\n\n      const tokenCount = lineTokens.getCount();\n\n      const lineText = this._buffer.getLineContent(lineNumber);\n\n      let tokenIndex = tokenCount - 1;\n      let searchStartOffset = lineText.length;\n      let searchEndOffset = lineText.length;\n\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n      }\n\n      let prevSearchInToken = true;\n\n      for (; tokenIndex >= 0; tokenIndex--) {\n        const searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchStartOffset\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n            if (r) {\n              return r;\n            }\n          }\n        }\n\n        prevSearchInToken = searchInToken;\n      }\n\n      if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n        if (r) {\n          return r;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n    // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n    const languageId = bracket.languageId;\n    const bracketRegex = bracket.forwardRegex;\n    let count = 1;\n    let totalCallCount = 0;\n\n    const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n      while (true) {\n        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n          return BracketSearchCanceled.INSTANCE;\n        }\n\n        const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n        if (!r) {\n          break;\n        }\n\n        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n\n        if (bracket.isOpen(hitText)) {\n          count++;\n        } else if (bracket.isClose(hitText)) {\n          count--;\n        }\n\n        if (count === 0) {\n          return r;\n        }\n\n        searchStartOffset = r.endColumn - 1;\n      }\n\n      return null;\n    };\n\n    const lineCount = this.getLineCount();\n\n    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n      const lineTokens = this._getLineTokens(lineNumber);\n\n      const tokenCount = lineTokens.getCount();\n\n      const lineText = this._buffer.getLineContent(lineNumber);\n\n      let tokenIndex = 0;\n      let searchStartOffset = 0;\n      let searchEndOffset = 0;\n\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n      }\n\n      let prevSearchInToken = true;\n\n      for (; tokenIndex < tokenCount; tokenIndex++) {\n        const searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchEndOffset\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n            if (r) {\n              return r;\n            }\n          }\n        }\n\n        prevSearchInToken = searchInToken;\n      }\n\n      if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n        if (r) {\n          return r;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  findPrevBracket(_position) {\n    const position = this.validatePosition(_position);\n    let languageId = null;\n    let modeBrackets = null;\n\n    for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n      const lineTokens = this._getLineTokens(lineNumber);\n\n      const tokenCount = lineTokens.getCount();\n\n      const lineText = this._buffer.getLineContent(lineNumber);\n\n      let tokenIndex = tokenCount - 1;\n      let searchStartOffset = lineText.length;\n      let searchEndOffset = lineText.length;\n\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n        if (languageId !== tokenLanguageId) {\n          languageId = tokenLanguageId;\n          modeBrackets = this.getLanguageConfiguration(languageId).brackets;\n        }\n      }\n\n      let prevSearchInToken = true;\n\n      for (; tokenIndex >= 0; tokenIndex--) {\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n        if (languageId !== tokenLanguageId) {\n          // language id change!\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n            if (r) {\n              return this._toFoundBracket(modeBrackets, r);\n            }\n\n            prevSearchInToken = false;\n          }\n\n          languageId = tokenLanguageId;\n          modeBrackets = this.getLanguageConfiguration(languageId).brackets;\n        }\n\n        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchStartOffset\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n            if (r) {\n              return this._toFoundBracket(modeBrackets, r);\n            }\n          }\n        }\n\n        prevSearchInToken = searchInToken;\n      }\n\n      if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n        if (r) {\n          return this._toFoundBracket(modeBrackets, r);\n        }\n      }\n    }\n\n    return null;\n  }\n\n  findNextBracket(_position) {\n    const position = this.validatePosition(_position);\n    const lineCount = this.getLineCount();\n    let languageId = null;\n    let modeBrackets = null;\n\n    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n      const lineTokens = this._getLineTokens(lineNumber);\n\n      const tokenCount = lineTokens.getCount();\n\n      const lineText = this._buffer.getLineContent(lineNumber);\n\n      let tokenIndex = 0;\n      let searchStartOffset = 0;\n      let searchEndOffset = 0;\n\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n        if (languageId !== tokenLanguageId) {\n          languageId = tokenLanguageId;\n          modeBrackets = this.getLanguageConfiguration(languageId).brackets;\n        }\n      }\n\n      let prevSearchInToken = true;\n\n      for (; tokenIndex < tokenCount; tokenIndex++) {\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n        if (languageId !== tokenLanguageId) {\n          // language id change!\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n            if (r) {\n              return this._toFoundBracket(modeBrackets, r);\n            }\n\n            prevSearchInToken = false;\n          }\n\n          languageId = tokenLanguageId;\n          modeBrackets = this.getLanguageConfiguration(languageId).brackets;\n        }\n\n        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchEndOffset\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n            if (r) {\n              return this._toFoundBracket(modeBrackets, r);\n            }\n          }\n        }\n\n        prevSearchInToken = searchInToken;\n      }\n\n      if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n        if (r) {\n          return this._toFoundBracket(modeBrackets, r);\n        }\n      }\n    }\n\n    return null;\n  }\n\n  findEnclosingBrackets(_position, maxDuration) {\n    let continueSearchPredicate;\n\n    if (typeof maxDuration === 'undefined') {\n      continueSearchPredicate = null;\n    } else {\n      const startTime = Date.now();\n\n      continueSearchPredicate = () => {\n        return Date.now() - startTime <= maxDuration;\n      };\n    }\n\n    const position = this.validatePosition(_position);\n    const lineCount = this.getLineCount();\n    const savedCounts = new Map();\n    let counts = [];\n\n    const resetCounts = (languageId, modeBrackets) => {\n      if (!savedCounts.has(languageId)) {\n        let tmp = [];\n\n        for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n          tmp[i] = 0;\n        }\n\n        savedCounts.set(languageId, tmp);\n      }\n\n      counts = savedCounts.get(languageId);\n    };\n\n    let totalCallCount = 0;\n\n    const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n      while (true) {\n        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n          return BracketSearchCanceled.INSTANCE;\n        }\n\n        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n        if (!r) {\n          break;\n        }\n\n        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const bracket = modeBrackets.textIsBracket[hitText];\n\n        if (bracket) {\n          if (bracket.isOpen(hitText)) {\n            counts[bracket.index]++;\n          } else if (bracket.isClose(hitText)) {\n            counts[bracket.index]--;\n          }\n\n          if (counts[bracket.index] === -1) {\n            return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n          }\n        }\n\n        searchStartOffset = r.endColumn - 1;\n      }\n\n      return null;\n    };\n\n    let languageId = null;\n    let modeBrackets = null;\n\n    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n      const lineTokens = this._getLineTokens(lineNumber);\n\n      const tokenCount = lineTokens.getCount();\n\n      const lineText = this._buffer.getLineContent(lineNumber);\n\n      let tokenIndex = 0;\n      let searchStartOffset = 0;\n      let searchEndOffset = 0;\n\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n        if (languageId !== tokenLanguageId) {\n          languageId = tokenLanguageId;\n          modeBrackets = this.getLanguageConfiguration(languageId).brackets;\n          resetCounts(languageId, modeBrackets);\n        }\n      }\n\n      let prevSearchInToken = true;\n\n      for (; tokenIndex < tokenCount; tokenIndex++) {\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n        if (languageId !== tokenLanguageId) {\n          // language id change!\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n            if (r) {\n              return stripBracketSearchCanceled(r);\n            }\n\n            prevSearchInToken = false;\n          }\n\n          languageId = tokenLanguageId;\n          modeBrackets = this.getLanguageConfiguration(languageId).brackets;\n          resetCounts(languageId, modeBrackets);\n        }\n\n        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchEndOffset\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n            if (r) {\n              return stripBracketSearchCanceled(r);\n            }\n          }\n        }\n\n        prevSearchInToken = searchInToken;\n      }\n\n      if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n        if (r) {\n          return stripBracketSearchCanceled(r);\n        }\n      }\n    }\n\n    return null;\n  }\n\n  _toFoundBracket(modeBrackets, r) {\n    if (!r) {\n      return null;\n    }\n\n    let text = this.getValueInRange(r);\n    text = text.toLowerCase();\n    let data = modeBrackets.textIsBracket[text];\n\n    if (!data) {\n      return null;\n    }\n\n    return {\n      range: r,\n      open: data.open,\n      close: data.close,\n      isOpen: modeBrackets.textIsOpenBracket[text]\n    };\n  }\n  /**\n   * Returns:\n   *  - -1 => the line consists of whitespace\n   *  - otherwise => the indent level is returned value\n   */\n\n\n  static computeIndentLevel(line, tabSize) {\n    let indent = 0;\n    let i = 0;\n    let len = line.length;\n\n    while (i < len) {\n      let chCode = line.charCodeAt(i);\n\n      if (chCode === 32\n      /* Space */\n      ) {\n        indent++;\n      } else if (chCode === 9\n      /* Tab */\n      ) {\n        indent = indent - indent % tabSize + tabSize;\n      } else {\n        break;\n      }\n\n      i++;\n    }\n\n    if (i === len) {\n      return -1; // line only consists of whitespace\n    }\n\n    return indent;\n  }\n\n  _computeIndentLevel(lineIndex) {\n    return TextModel.computeIndentLevel(this._buffer.getLineContent(lineIndex + 1), this._options.tabSize);\n  }\n\n  getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n    this._assertNotDisposed();\n\n    const lineCount = this.getLineCount();\n\n    if (lineNumber < 1 || lineNumber > lineCount) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    const foldingRules = this.getLanguageConfiguration(this._languageId).foldingRules;\n    const offSide = Boolean(foldingRules && foldingRules.offSide);\n    let up_aboveContentLineIndex = -2;\n    /* -2 is a marker for not having computed it */\n\n    let up_aboveContentLineIndent = -1;\n    let up_belowContentLineIndex = -2;\n    /* -2 is a marker for not having computed it */\n\n    let up_belowContentLineIndent = -1;\n\n    const up_resolveIndents = lineNumber => {\n      if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber - 1)) {\n        up_aboveContentLineIndex = -1;\n        up_aboveContentLineIndent = -1; // must find previous line with content\n\n        for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n          let indent = this._computeIndentLevel(lineIndex);\n\n          if (indent >= 0) {\n            up_aboveContentLineIndex = lineIndex;\n            up_aboveContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n\n      if (up_belowContentLineIndex === -2) {\n        up_belowContentLineIndex = -1;\n        up_belowContentLineIndent = -1; // must find next line with content\n\n        for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n          let indent = this._computeIndentLevel(lineIndex);\n\n          if (indent >= 0) {\n            up_belowContentLineIndex = lineIndex;\n            up_belowContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n    };\n\n    let down_aboveContentLineIndex = -2;\n    /* -2 is a marker for not having computed it */\n\n    let down_aboveContentLineIndent = -1;\n    let down_belowContentLineIndex = -2;\n    /* -2 is a marker for not having computed it */\n\n    let down_belowContentLineIndent = -1;\n\n    const down_resolveIndents = lineNumber => {\n      if (down_aboveContentLineIndex === -2) {\n        down_aboveContentLineIndex = -1;\n        down_aboveContentLineIndent = -1; // must find previous line with content\n\n        for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n          let indent = this._computeIndentLevel(lineIndex);\n\n          if (indent >= 0) {\n            down_aboveContentLineIndex = lineIndex;\n            down_aboveContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n\n      if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber - 1)) {\n        down_belowContentLineIndex = -1;\n        down_belowContentLineIndent = -1; // must find next line with content\n\n        for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n          let indent = this._computeIndentLevel(lineIndex);\n\n          if (indent >= 0) {\n            down_belowContentLineIndex = lineIndex;\n            down_belowContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n    };\n\n    let startLineNumber = 0;\n    let goUp = true;\n    let endLineNumber = 0;\n    let goDown = true;\n    let indent = 0;\n    let initialIndent = 0;\n\n    for (let distance = 0; goUp || goDown; distance++) {\n      const upLineNumber = lineNumber - distance;\n      const downLineNumber = lineNumber + distance;\n\n      if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n        goUp = false;\n      }\n\n      if (distance > 1 && (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n        goDown = false;\n      }\n\n      if (distance > 50000) {\n        // stop processing\n        goUp = false;\n        goDown = false;\n      }\n\n      let upLineIndentLevel = -1;\n\n      if (goUp) {\n        // compute indent level going up\n        const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n\n        if (currentIndent >= 0) {\n          // This line has content (besides whitespace)\n          // Use the line's indent\n          up_belowContentLineIndex = upLineNumber - 1;\n          up_belowContentLineIndent = currentIndent;\n          upLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\n        } else {\n          up_resolveIndents(upLineNumber);\n          upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n        }\n      }\n\n      let downLineIndentLevel = -1;\n\n      if (goDown) {\n        // compute indent level going down\n        const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n\n        if (currentIndent >= 0) {\n          // This line has content (besides whitespace)\n          // Use the line's indent\n          down_aboveContentLineIndex = downLineNumber - 1;\n          down_aboveContentLineIndent = currentIndent;\n          downLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\n        } else {\n          down_resolveIndents(downLineNumber);\n          downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n        }\n      }\n\n      if (distance === 0) {\n        initialIndent = upLineIndentLevel;\n        continue;\n      }\n\n      if (distance === 1) {\n        if (downLineNumber <= lineCount && downLineIndentLevel >= 0 && initialIndent + 1 === downLineIndentLevel) {\n          // This is the beginning of a scope, we have special handling here, since we want the\n          // child scope indent to be active, not the parent scope\n          goUp = false;\n          startLineNumber = downLineNumber;\n          endLineNumber = downLineNumber;\n          indent = downLineIndentLevel;\n          continue;\n        }\n\n        if (upLineNumber >= 1 && upLineIndentLevel >= 0 && upLineIndentLevel - 1 === initialIndent) {\n          // This is the end of a scope, just like above\n          goDown = false;\n          startLineNumber = upLineNumber;\n          endLineNumber = upLineNumber;\n          indent = upLineIndentLevel;\n          continue;\n        }\n\n        startLineNumber = lineNumber;\n        endLineNumber = lineNumber;\n        indent = initialIndent;\n\n        if (indent === 0) {\n          // No need to continue\n          return {\n            startLineNumber,\n            endLineNumber,\n            indent\n          };\n        }\n      }\n\n      if (goUp) {\n        if (upLineIndentLevel >= indent) {\n          startLineNumber = upLineNumber;\n        } else {\n          goUp = false;\n        }\n      }\n\n      if (goDown) {\n        if (downLineIndentLevel >= indent) {\n          endLineNumber = downLineNumber;\n        } else {\n          goDown = false;\n        }\n      }\n    }\n\n    return {\n      startLineNumber,\n      endLineNumber,\n      indent\n    };\n  }\n\n  getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n    var _a, _b, _c, _d, _e;\n\n    const result = [];\n\n    const bracketPairs = this._bracketPairColorizer.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.getLineMaxColumn(endLineNumber)));\n\n    let activeBracketPairRange = undefined;\n\n    if (activePosition && bracketPairs.length > 0) {\n      const bracketsContainingActivePosition = startLineNumber <= activePosition.lineNumber && activePosition.lineNumber <= endLineNumber // Does active position intersect with the view port? -> Intersect bracket pairs with activePosition\n      ? bracketPairs.filter(bp => bp.range.containsPosition(activePosition)) : this._bracketPairColorizer.getBracketPairsInRange(Range.fromPositions(activePosition));\n      activeBracketPairRange = (_a = findLast(bracketsContainingActivePosition,\n      /* Exclude single line bracket pairs for cases such as\n       * ```\n       * function test() {\n       * \t\tif (true) { | }\n       * }\n       * ```\n       */\n      i => i.range.startLineNumber !== i.range.endLineNumber)) === null || _a === void 0 ? void 0 : _a.range;\n    }\n\n    const queue = new ArrayQueue(bracketPairs);\n    /** Indexed by nesting level */\n\n    const activeGuides = new Array();\n    const nextGuides = new Array();\n    const colorProvider = new BracketPairGuidesClassNames();\n\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      let guides = new Array();\n\n      if (nextGuides.length > 0) {\n        guides = guides.concat(nextGuides);\n        nextGuides.length = 0;\n      }\n\n      result.push(guides); // Update activeGuides\n\n      for (const pair of queue.takeWhile(b => b.openingBracketRange.startLineNumber <= lineNumber) || []) {\n        if (pair.range.startLineNumber === pair.range.endLineNumber) {\n          // ignore single line brackets\n          continue;\n        }\n\n        const guideVisibleColumn = Math.min(this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition()), this.getVisibleColumnFromPosition((_c = (_b = pair.closingBracketRange) === null || _b === void 0 ? void 0 : _b.getStartPosition()) !== null && _c !== void 0 ? _c : pair.range.getEndPosition()), pair.minVisibleColumnIndentation + 1);\n        let renderHorizontalEndLineAtTheBottom = false;\n\n        if (pair.closingBracketRange) {\n          const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.getLineContent(pair.closingBracketRange.startLineNumber));\n\n          if (firstNonWsIndex < pair.closingBracketRange.startColumn - 1) {\n            renderHorizontalEndLineAtTheBottom = true;\n          }\n        } // TODO: Consider indentation when computing guideVisibleColumn\n\n\n        const start = pair.openingBracketRange.getStartPosition();\n        const end = (_e = (_d = pair.closingBracketRange) === null || _d === void 0 ? void 0 : _d.getStartPosition()) !== null && _e !== void 0 ? _e : pair.range.getEndPosition();\n\n        if (pair.closingBracketRange === undefined) {\n          // Don't show guides for bracket pairs that are not balanced.\n          // See #135125.\n          activeGuides[pair.nestingLevel] = null;\n        } else {\n          activeGuides[pair.nestingLevel] = {\n            nestingLevel: pair.nestingLevel,\n            guideVisibleColumn,\n            start,\n            visibleStartColumn: this.getVisibleColumnFromPosition(start),\n            end,\n            visibleEndColumn: this.getVisibleColumnFromPosition(end),\n            bracketPair: pair,\n            renderHorizontalEndLineAtTheBottom\n          };\n        }\n      }\n\n      for (const line of activeGuides) {\n        if (!line) {\n          continue;\n        }\n\n        const isActive = activeBracketPairRange && line.bracketPair.range.equalsRange(activeBracketPairRange);\n        const className = colorProvider.getInlineClassNameOfLevel(line.nestingLevel) + (options.highlightActive && isActive ? ' ' + colorProvider.activeClassName : '');\n\n        if (isActive && options.horizontalGuides !== model.HorizontalGuidesState.Disabled || options.includeInactive && options.horizontalGuides === model.HorizontalGuidesState.Enabled) {\n          if (line.start.lineNumber === lineNumber) {\n            if (line.guideVisibleColumn < line.visibleStartColumn) {\n              guides.push(new model.IndentGuide(line.guideVisibleColumn, className, new model.IndentGuideHorizontalLine(false, line.start.column)));\n            }\n          }\n\n          if (line.end.lineNumber === lineNumber + 1) {\n            // The next line might have horizontal guides.\n            // However, the next line might also have a new bracket pair with the same indentation,\n            // so the current bracket pair might get replaced. That's why we push the guide to nextGuides one line ahead.\n            if (line.guideVisibleColumn < line.visibleEndColumn) {\n              nextGuides.push(new model.IndentGuide(line.guideVisibleColumn, className, new model.IndentGuideHorizontalLine(!line.renderHorizontalEndLineAtTheBottom, line.end.column)));\n            }\n          }\n        }\n      }\n\n      let lastVisibleColumnCount = Number.MAX_SAFE_INTEGER; // Going backwards, so the last guide potentially replaces others\n\n      for (let i = activeGuides.length - 1; i >= 0; i--) {\n        const line = activeGuides[i];\n\n        if (!line) {\n          continue;\n        }\n\n        const isActive = options.highlightActive && activeBracketPairRange && line.bracketPair.range.equalsRange(activeBracketPairRange);\n        const className = colorProvider.getInlineClassNameOfLevel(line.nestingLevel) + (isActive ? ' ' + colorProvider.activeClassName : '');\n\n        if (isActive || options.includeInactive) {\n          if (line.renderHorizontalEndLineAtTheBottom && line.end.lineNumber === lineNumber + 1) {\n            nextGuides.push(new model.IndentGuide(line.guideVisibleColumn, className, null));\n          }\n        }\n\n        if (line.end.lineNumber <= lineNumber || line.start.lineNumber >= lineNumber) {\n          continue;\n        }\n\n        if (line.guideVisibleColumn >= lastVisibleColumnCount && !isActive) {\n          // Don't render a guide on top of an existing guide, unless it is active.\n          continue;\n        }\n\n        lastVisibleColumnCount = line.guideVisibleColumn;\n\n        if (isActive || options.includeInactive) {\n          guides.push(new model.IndentGuide(line.guideVisibleColumn, className, null));\n        }\n      }\n\n      guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n    }\n\n    return result;\n  }\n\n  getVisibleColumnFromPosition(position) {\n    return CursorColumns.visibleColumnFromColumn(this.getLineContent(position.lineNumber), position.column, this._options.tabSize) + 1;\n  }\n\n  getLinesIndentGuides(startLineNumber, endLineNumber) {\n    this._assertNotDisposed();\n\n    const lineCount = this.getLineCount();\n\n    if (startLineNumber < 1 || startLineNumber > lineCount) {\n      throw new Error('Illegal value for startLineNumber');\n    }\n\n    if (endLineNumber < 1 || endLineNumber > lineCount) {\n      throw new Error('Illegal value for endLineNumber');\n    }\n\n    const foldingRules = this.getLanguageConfiguration(this._languageId).foldingRules;\n    const offSide = Boolean(foldingRules && foldingRules.offSide);\n    let result = new Array(endLineNumber - startLineNumber + 1);\n    let aboveContentLineIndex = -2;\n    /* -2 is a marker for not having computed it */\n\n    let aboveContentLineIndent = -1;\n    let belowContentLineIndex = -2;\n    /* -2 is a marker for not having computed it */\n\n    let belowContentLineIndent = -1;\n\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      let resultIndex = lineNumber - startLineNumber;\n\n      const currentIndent = this._computeIndentLevel(lineNumber - 1);\n\n      if (currentIndent >= 0) {\n        // This line has content (besides whitespace)\n        // Use the line's indent\n        aboveContentLineIndex = lineNumber - 1;\n        aboveContentLineIndent = currentIndent;\n        result[resultIndex] = Math.ceil(currentIndent / this._options.indentSize);\n        continue;\n      }\n\n      if (aboveContentLineIndex === -2) {\n        aboveContentLineIndex = -1;\n        aboveContentLineIndent = -1; // must find previous line with content\n\n        for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n          let indent = this._computeIndentLevel(lineIndex);\n\n          if (indent >= 0) {\n            aboveContentLineIndex = lineIndex;\n            aboveContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n\n      if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n        belowContentLineIndex = -1;\n        belowContentLineIndent = -1; // must find next line with content\n\n        for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n          let indent = this._computeIndentLevel(lineIndex);\n\n          if (indent >= 0) {\n            belowContentLineIndex = lineIndex;\n            belowContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n\n      result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n    }\n\n    return result;\n  }\n\n  _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n    if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n      // At the top or bottom of the file\n      return 0;\n    } else if (aboveContentLineIndent < belowContentLineIndent) {\n      // we are inside the region above\n      return 1 + Math.floor(aboveContentLineIndent / this._options.indentSize);\n    } else if (aboveContentLineIndent === belowContentLineIndent) {\n      // we are in between two regions\n      return Math.ceil(belowContentLineIndent / this._options.indentSize);\n    } else {\n      if (offSide) {\n        // same level as region below\n        return Math.ceil(belowContentLineIndent / this._options.indentSize);\n      } else {\n        // we are inside the region that ends below\n        return 1 + Math.floor(belowContentLineIndent / this._options.indentSize);\n      }\n    }\n  } //#endregion\n\n\n  normalizePosition(position, affinity) {\n    return position;\n  }\n  /**\n   * Gets the column at which indentation stops at a given line.\n   * @internal\n  */\n\n\n  getLineIndentColumn(lineNumber) {\n    // Columns start with 1.\n    return indentOfLine(this.getLineContent(lineNumber)) + 1;\n  }\n\n};\nTextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB\n\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\n\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\n\nTextModel.DEFAULT_CREATION_OPTIONS = {\n  isForSimpleWidget: false,\n  tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n  indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n  insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n  detectIndentation: false,\n  defaultEOL: 1\n  /* LF */\n  ,\n  trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n  largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n  bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions\n};\nTextModel = __decorate([__param(4, IUndoRedoService), __param(5, IModeService), __param(6, ILanguageConfigurationService)], TextModel);\nexport { TextModel };\n\nfunction indentOfLine(line) {\n  let indent = 0;\n\n  for (const c of line) {\n    if (c === ' ' || c === '\\t') {\n      indent++;\n    } else {\n      break;\n    }\n  }\n\n  return indent;\n}\n\nexport class BracketPairGuidesClassNames {\n  constructor() {\n    this.activeClassName = 'indent-active';\n  }\n\n  getInlineClassNameOfLevel(level) {\n    // To support a dynamic amount of colors up to 6 colors,\n    // we use a number that is a lcm of all numbers from 1 to 6.\n    return `bracket-indent-guide lvl-${level % 30}`;\n  }\n\n} //#region Decorations\n\nfunction isNodeInOverviewRuler(node) {\n  return node.options.overviewRuler && node.options.overviewRuler.color ? true : false;\n}\n\nfunction isNodeInjectedText(node) {\n  return !!node.options.after || !!node.options.before;\n}\n\nclass DecorationsTrees {\n  constructor() {\n    this._decorationsTree0 = new IntervalTree();\n    this._decorationsTree1 = new IntervalTree();\n    this._injectedTextDecorationsTree = new IntervalTree();\n  }\n\n  ensureAllNodesHaveRanges(host) {\n    this.getAll(host, 0, false, false);\n  }\n\n  _ensureNodesHaveRanges(host, nodes) {\n    for (const node of nodes) {\n      if (node.range === null) {\n        node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n      }\n    }\n\n    return nodes;\n  }\n\n  getAllInInterval(host, start, end, filterOwnerId, filterOutValidation) {\n    const versionId = host.getVersionId();\n\n    const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId);\n\n    return this._ensureNodesHaveRanges(host, result);\n  }\n\n  _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n    const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n\n    const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n\n    const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n\n    return r0.concat(r1).concat(r2);\n  }\n\n  getInjectedTextInInterval(host, start, end, filterOwnerId) {\n    const versionId = host.getVersionId();\n\n    const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId);\n\n    return this._ensureNodesHaveRanges(host, result).filter(i => i.options.showIfCollapsed || !i.range.isEmpty());\n  }\n\n  getAllInjectedText(host, filterOwnerId) {\n    const versionId = host.getVersionId();\n\n    const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId);\n\n    return this._ensureNodesHaveRanges(host, result).filter(i => i.options.showIfCollapsed || !i.range.isEmpty());\n  }\n\n  getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly) {\n    const versionId = host.getVersionId();\n\n    const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId);\n\n    return this._ensureNodesHaveRanges(host, result);\n  }\n\n  _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {\n    if (overviewRulerOnly) {\n      return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n    } else {\n      const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);\n\n      const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n\n      const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId);\n\n      return r0.concat(r1).concat(r2);\n    }\n  }\n\n  collectNodesFromOwner(ownerId) {\n    const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n\n    const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n\n    const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n\n    return r0.concat(r1).concat(r2);\n  }\n\n  collectNodesPostOrder() {\n    const r0 = this._decorationsTree0.collectNodesPostOrder();\n\n    const r1 = this._decorationsTree1.collectNodesPostOrder();\n\n    const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n\n    return r0.concat(r1).concat(r2);\n  }\n\n  insert(node) {\n    if (isNodeInjectedText(node)) {\n      this._injectedTextDecorationsTree.insert(node);\n    } else if (isNodeInOverviewRuler(node)) {\n      this._decorationsTree1.insert(node);\n    } else {\n      this._decorationsTree0.insert(node);\n    }\n  }\n\n  delete(node) {\n    if (isNodeInjectedText(node)) {\n      this._injectedTextDecorationsTree.delete(node);\n    } else if (isNodeInOverviewRuler(node)) {\n      this._decorationsTree1.delete(node);\n    } else {\n      this._decorationsTree0.delete(node);\n    }\n  }\n\n  getNodeRange(host, node) {\n    const versionId = host.getVersionId();\n\n    if (node.cachedVersionId !== versionId) {\n      this._resolveNode(node, versionId);\n    }\n\n    if (node.range === null) {\n      node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n    }\n\n    return node.range;\n  }\n\n  _resolveNode(node, cachedVersionId) {\n    if (isNodeInjectedText(node)) {\n      this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n    } else if (isNodeInOverviewRuler(node)) {\n      this._decorationsTree1.resolveNode(node, cachedVersionId);\n    } else {\n      this._decorationsTree0.resolveNode(node, cachedVersionId);\n    }\n  }\n\n  acceptReplace(offset, length, textLength, forceMoveMarkers) {\n    this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n\n    this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n\n    this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n  }\n\n}\n\nfunction cleanClassName(className) {\n  return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\n\nclass DecorationOptions {\n  constructor(options) {\n    this.color = options.color || '';\n    this.darkColor = options.darkColor || '';\n  }\n\n}\n\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n  constructor(options) {\n    super(options);\n    this._resolvedColor = null;\n    this.position = typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center;\n  }\n\n  getColor(theme) {\n    if (!this._resolvedColor) {\n      if (theme.type !== 'light' && this.darkColor) {\n        this._resolvedColor = this._resolveColor(this.darkColor, theme);\n      } else {\n        this._resolvedColor = this._resolveColor(this.color, theme);\n      }\n    }\n\n    return this._resolvedColor;\n  }\n\n  invalidateCachedColor() {\n    this._resolvedColor = null;\n  }\n\n  _resolveColor(color, theme) {\n    if (typeof color === 'string') {\n      return color;\n    }\n\n    let c = color ? theme.getColor(color.id) : null;\n\n    if (!c) {\n      return '';\n    }\n\n    return c.toString();\n  }\n\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n  constructor(options) {\n    super(options);\n    this.position = options.position;\n  }\n\n  getColor(theme) {\n    if (!this._resolvedColor) {\n      if (theme.type !== 'light' && this.darkColor) {\n        this._resolvedColor = this._resolveColor(this.darkColor, theme);\n      } else {\n        this._resolvedColor = this._resolveColor(this.color, theme);\n      }\n    }\n\n    return this._resolvedColor;\n  }\n\n  invalidateCachedColor() {\n    this._resolvedColor = undefined;\n  }\n\n  _resolveColor(color, theme) {\n    if (typeof color === 'string') {\n      return Color.fromHex(color);\n    }\n\n    return theme.getColor(color.id);\n  }\n\n}\nexport class ModelDecorationInjectedTextOptions {\n  constructor(options) {\n    this.content = options.content || '';\n    this.inlineClassName = options.inlineClassName || null;\n    this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n  }\n\n  static from(options) {\n    if (options instanceof ModelDecorationInjectedTextOptions) {\n      return options;\n    }\n\n    return new ModelDecorationInjectedTextOptions(options);\n  }\n\n}\nexport class ModelDecorationOptions {\n  constructor(options) {\n    this.description = options.description;\n    this.stickiness = options.stickiness || 0\n    /* AlwaysGrowsWhenTypingAtEdges */\n    ;\n    this.zIndex = options.zIndex || 0;\n    this.className = options.className ? cleanClassName(options.className) : null;\n    this.hoverMessage = options.hoverMessage || null;\n    this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n    this.isWholeLine = options.isWholeLine || false;\n    this.showIfCollapsed = options.showIfCollapsed || false;\n    this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n    this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n    this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n    this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n    this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n    this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n    this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n    this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n    this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n    this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n    this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n    this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n    this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n  }\n\n  static register(options) {\n    return new ModelDecorationOptions(options);\n  }\n\n  static createDynamic(options) {\n    return new ModelDecorationOptions(options);\n  }\n\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({\n  description: 'empty'\n});\n/**\n * The order carefully matches the values of the enum.\n */\n\nconst TRACKED_RANGE_OPTIONS = [ModelDecorationOptions.register({\n  description: 'tracked-range-always-grows-when-typing-at-edges',\n  stickiness: 0\n  /* AlwaysGrowsWhenTypingAtEdges */\n\n}), ModelDecorationOptions.register({\n  description: 'tracked-range-never-grows-when-typing-at-edges',\n  stickiness: 1\n  /* NeverGrowsWhenTypingAtEdges */\n\n}), ModelDecorationOptions.register({\n  description: 'tracked-range-grows-only-when-typing-before',\n  stickiness: 2\n  /* GrowsOnlyWhenTypingBefore */\n\n}), ModelDecorationOptions.register({\n  description: 'tracked-range-grows-only-when-typing-after',\n  stickiness: 3\n  /* GrowsOnlyWhenTypingAfter */\n\n})];\n\nfunction _normalizeOptions(options) {\n  if (options instanceof ModelDecorationOptions) {\n    return options;\n  }\n\n  return ModelDecorationOptions.createDynamic(options);\n}\n\nexport class DidChangeDecorationsEmitter extends Disposable {\n  constructor(handleBeforeFire) {\n    super();\n    this.handleBeforeFire = handleBeforeFire;\n    this._actual = this._register(new Emitter());\n    this.event = this._actual.event;\n    this._affectedInjectedTextLines = null;\n    this._deferredCnt = 0;\n    this._shouldFire = false;\n    this._affectsMinimap = false;\n    this._affectsOverviewRuler = false;\n  }\n\n  beginDeferredEmit() {\n    this._deferredCnt++;\n  }\n\n  endDeferredEmit() {\n    var _a;\n\n    this._deferredCnt--;\n\n    if (this._deferredCnt === 0) {\n      if (this._shouldFire) {\n        this.handleBeforeFire(this._affectedInjectedTextLines);\n        const event = {\n          affectsMinimap: this._affectsMinimap,\n          affectsOverviewRuler: this._affectsOverviewRuler\n        };\n        this._shouldFire = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n\n        this._actual.fire(event);\n      }\n\n      (_a = this._affectedInjectedTextLines) === null || _a === void 0 ? void 0 : _a.clear();\n      this._affectedInjectedTextLines = null;\n    }\n  }\n\n  recordLineAffectedByInjectedText(lineNumber) {\n    if (!this._affectedInjectedTextLines) {\n      this._affectedInjectedTextLines = new Set();\n    }\n\n    this._affectedInjectedTextLines.add(lineNumber);\n  }\n\n  checkAffectedAndFire(options) {\n    if (!this._affectsMinimap) {\n      this._affectsMinimap = options.minimap && options.minimap.position ? true : false;\n    }\n\n    if (!this._affectsOverviewRuler) {\n      this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n    }\n\n    this._shouldFire = true;\n  }\n\n  fire() {\n    this._affectsMinimap = true;\n    this._affectsOverviewRuler = true;\n    this._shouldFire = true;\n  }\n\n} //#endregion\n\nexport class DidChangeContentEmitter extends Disposable {\n  constructor() {\n    super();\n    /**\n     * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n     */\n\n    this._fastEmitter = this._register(new Emitter());\n    this.fastEvent = this._fastEmitter.event;\n    this._slowEmitter = this._register(new Emitter());\n    this.slowEvent = this._slowEmitter.event;\n    this._deferredCnt = 0;\n    this._deferredEvent = null;\n  }\n\n  beginDeferredEmit() {\n    this._deferredCnt++;\n  }\n\n  endDeferredEmit() {\n    let resultingSelection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    this._deferredCnt--;\n\n    if (this._deferredCnt === 0) {\n      if (this._deferredEvent !== null) {\n        this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n        const e = this._deferredEvent;\n        this._deferredEvent = null;\n\n        this._fastEmitter.fire(e);\n\n        this._slowEmitter.fire(e);\n      }\n    }\n  }\n\n  fire(e) {\n    if (this._deferredCnt > 0) {\n      if (this._deferredEvent) {\n        this._deferredEvent = this._deferredEvent.merge(e);\n      } else {\n        this._deferredEvent = e;\n      }\n\n      return;\n    }\n\n    this._fastEmitter.fire(e);\n\n    this._slowEmitter.fire(e);\n  }\n\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","onUnexpectedError","Emitter","Disposable","strings","URI","EDITOR_MODEL_DEFAULTS","Position","Range","Selection","model","EditStack","guessIndentation","IntervalNode","IntervalTree","recomputeMaxEnd","PieceTreeTextBufferBuilder","InternalModelContentChangeEvent","LineInjectedText","ModelInjectedTextChangedEvent","ModelRawContentChangedEvent","ModelRawEOLChanged","ModelRawFlush","ModelRawLineChanged","ModelRawLinesDeleted","ModelRawLinesInserted","SearchParams","TextModelSearch","TextModelTokenization","getWordAtText","ILanguageConfigurationService","NULL_MODE_ID","ignoreBracketsInToken","BracketsUtils","TokensStore","countEOL","TokensStore2","Color","IUndoRedoService","PieceTreeTextBuffer","ArrayQueue","findLast","BracketPairs","ColorizedBracketPairsDecorationProvider","CursorColumns","IModeService","createTextBufferBuilder","createTextBufferFactory","text","builder","acceptChunk","finish","createTextBuffer","value","defaultEOL","factory","create","MODEL_ID","LIMIT_FIND_COUNT","LONG_LINE_BOUNDARY","TextModelSnapshot","constructor","source","_source","_eos","read","result","resultCnt","resultLength","tmp","join","invalidFunc","Error","BracketSearchCanceled","_searchCanceledBrand","undefined","INSTANCE","stripBracketSearchCanceled","TextModel","creationOptions","languageId","associatedResource","_undoRedoService","_modeService","_languageConfigurationService","_onWillDispose","_register","onWillDispose","event","_onDidChangeDecorations","DidChangeDecorationsEmitter","affectedInjectedTextLines","handleBeforeFireDecorationsChangedEvent","onDidChangeDecorations","_onDidChangeLanguage","onDidChangeLanguage","_onDidChangeLanguageConfiguration","onDidChangeLanguageConfiguration","_onDidChangeTokens","onDidChangeTokens","_onDidChangeOptions","onDidChangeOptions","_onDidChangeAttached","onDidChangeAttached","_onDidChangeContentOrInjectedText","onDidChangeContentOrInjectedText","_eventEmitter","DidChangeContentEmitter","_backgroundTokenizationState","_onBackgroundTokenizationStateChanged","onBackgroundTokenizationStateChanged","fastEvent","e","fire","rawContentChangedEvent","id","isForSimpleWidget","_associatedResource","parse","_attachedEditorCount","textBuffer","disposable","_buffer","_bufferDisposable","_options","resolveOptions","bufferLineCount","getLineCount","bufferTextLength","getValueLengthInRange","getLineLength","largeFileOptimizations","_isTooLargeForTokenization","LARGE_FILE_SIZE_THRESHOLD","LARGE_FILE_LINE_COUNT_THRESHOLD","_isTooLargeForSyncing","MODEL_SYNC_LIMIT","_versionId","_alternativeVersionId","_initialUndoRedoSnapshot","_isDisposed","_isDisposing","_languageId","_languageRegistryListener","onDidChange","affects","_instanceId","singleLetterHash","_lastDecorationId","_decorations","_decorationsTree","DecorationsTrees","_commandManager","_isUndoing","_isRedoing","_trimAutoWhitespaceLines","_tokens","languageIdCodec","_tokens2","_tokenization","_bracketPairColorizer","_decorationProvider","beginDeferredEmit","endDeferredEmit","options","detectIndentation","guessedIndentation","tabSize","insertSpaces","TextModelResolvedOptions","indentSize","trimAutoWhitespace","bracketPairColorizationOptions","onDidChangeContentFast","listener","contentChangedEvent","onDidChangeContent","slowEvent","bracketPairs","backgroundTokenizationState","handleTokenizationProgress","completed","newState","dispose","emptyDisposedTextBuffer","_assertNotDisposed","_emitContentChangedEvent","rawChange","change","handleContentChanged","setValue","_setValueFromTextBuffer","_createContentChanged2","range","rangeOffset","rangeLength","isUndoing","isRedoing","isFlush","changes","eol","getEOL","versionId","getVersionId","textBufferDisposable","oldFullModelRange","getFullModelRange","oldModelValueLength","endLineNumber","endColumn","getLineMaxColumn","_increaseVersionId","flush","clear","getValue","setEOL","newEOL","_onBeforeEOLChange","_onAfterEOLChange","ensureAllNodesHaveRanges","allDecorations","collectNodesPostOrder","len","node","delta","cachedAbsoluteStart","start","startOffset","getOffsetAt","startLineNumber","startColumn","endOffset","cachedAbsoluteEnd","cachedVersionId","end","onBeforeAttached","onBeforeDetached","isAttachedToEditor","getAttachedEditorCount","isTooLargeForSyncing","isTooLargeForTokenization","isDisposed","isDominatedByLongLines","smallLineCharCount","longLineCharCount","lineCount","lineNumber","lineLength","uri","getOptions","getFormattingOptions","updateOptions","_newOpts","bracketColorizationOptions","newOpts","equals","createChangeEvent","defaultInsertSpaces","defaultTabSize","_normalizeIndentationFromWhitespace","str","spacesCnt","charAt","tabsCnt","Math","floor","normalizeIndentation","firstNonWhitespaceIndex","substring","mightContainRTL","mightContainUnusualLineTerminators","removeUnusualLineTerminators","selections","matches","findMatches","UNUSUAL_LINE_TERMINATORS","resetMightContainUnusualLineTerminators","pushEditOperations","map","m","mightContainNonBasicASCII","getAlternativeVersionId","getInitialUndoRedoSnapshot","rawPosition","position","_validatePosition","column","getPositionAt","rawOffset","offset","min","getLength","max","_overwriteVersionId","_overwriteAlternativeVersionId","newAlternativeVersionId","_overwriteInitialUndoRedoSnapshot","newInitialUndoRedoSnapshot","preserveBOM","fullModelRange","fullModelValue","getValueInRange","getBOM","createSnapshot","getValueLength","rawRange","validateRange","getCharacterCountInRange","getLineContent","getLinesContent","getEndOfLineSequence","getLineMinColumn","getLineFirstNonWhitespaceColumn","getLineLastNonWhitespaceColumn","_validateRangeRelaxedNoAllocations","linesCount","initialStartLineNumber","initialStartColumn","isNaN","maxColumn","initialEndLineNumber","initialEndColumn","_isValidPosition","validationType","charCodeBefore","getLineCharCode","isHighSurrogate","_lineNumber","_column","validatePosition","_isValidRange","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","_range","modifyPosition","candidate","findMatchesLineByLine","searchRange","searchData","captureMatches","limitResultCount","searchString","rawSearchScope","isRegex","matchCase","wordSeparators","searchRanges","Array","isArray","every","searchScope","isIRange","sort","d1","d2","uniqueSearchRanges","push","reduce","prev","curr","areIntersecting","plusRange","matchMapper","indexOf","searchParams","parseSearchRequest","arr","concat","findNextMatch","rawSearchStart","searchStart","ret","findPreviousMatch","pushStackElement","popStackElement","pushEOL","currentEOL","_validateEditOperation","rawOperation","ValidAnnotatedEditOperation","identifier","forceMoveMarkers","isAutoWhitespaceEdit","_isTracked","_validateEditOperations","rawOperations","beforeCursorState","editOperations","cursorStateComputer","_pushEditOperations","incomingEdits","op","editsAreNearCursors","sel","foundEditNearSel","j","lenJ","editRange","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","isEmpty","trimRange","pushEditOperation","_applyUndo","resultingAlternativeVersionId","resultingSelection","edits","rangeStart","newPosition","rangeEnd","newEnd","oldText","_applyUndoRedoEdits","_applyRedo","oldPosition","oldEnd","newText","applyEdits","computeUndoEdits","operations","_doApplyEdits","oldLineCount","newLineCount","contentChanges","trimAutoWhitespaceLineNumbers","eolCount","firstLineLength","lastLineLength","acceptEdit","charCodeAt","acceptReplace","rawContentChanges","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","changeLineCountDelta","currentEditStartLineNumber","firstEditLineNumber","lastInsertedLineNumber","decorationsWithInjectedTextInEditedRange","getInjectedTextInInterval","injectedTextInEditedRange","fromDecorations","injectedTextInEditedRangeQueue","editLineNumber","currentEditLineNumber","takeFromEndWhile","decorationsInCurrentLine","spliceStartLineNumber","spliceLineNumber","cnt","fromLineNumber","injectedTexts","newLines","takeWhile","reverseEdits","undo","canUndo","redo","canRedo","size","affectedLines","lineChangeEvents","_getInjectedTextInLine","changeDecorations","callback","ownerId","_changeDecorations","changeAccessor","addDecoration","_deltaDecorationsImpl","changeDecoration","newRange","_changeDecorationImpl","changeDecorationOptions","_changeDecorationOptionsImpl","_normalizeOptions","removeDecoration","deltaDecorations","oldDecorations","newDecorations","_getTrackedRange","getDecorationRange","_setTrackedRange","newStickiness","TRACKED_RANGE_OPTIONS","delete","reset","setOptions","insert","removeAllDecorationsWithOwnerId","nodes","collectNodesFromOwner","getDecorationOptions","decorationId","getNodeRange","getLineDecorations","filterOutValidation","getLinesDecorations","_startLineNumber","_endLineNumber","decorations","_getDecorationsInRange","getDecorationsInRange","validatedRange","getOverviewRulerDecorations","getAll","getInjectedTextDecorations","getAllInjectedText","filter","t","getAllDecorations","filterRange","filterOwnerId","getAllInInterval","getRangeAt","after","oldRange","recordLineAffectedByInjectedText","before","checkAffectedAndFire","nodeWasInOverviewRuler","overviewRuler","color","nodeIsInOverviewRuler","nodeRange","oldDecorationsIds","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","newDecoration","setTokens","tokens","backgroundTokenizationCompleted","ranges","element","minChangedLineNumber","maxChangedLineNumber","hasChange","lineHasChange","toLineNumber","_emitModelTokensChangedEvent","tokenizationSupportChanged","semanticTokensApplied","setSemanticTokens","isComplete","set","hasCompleteSemanticTokens","hasSomeSemanticTokens","setPartialSemanticTokens","changedRange","setPartial","tokenizeViewport","clearTokens","resetTokenization","forceTokenization","isCheapToTokenize","tokenizeIfCheap","getLineTokens","_getLineTokens","lineText","syntacticTokens","getTokens","addSemanticTokens","getLanguageId","setMode","oldLanguage","newLanguage","getLanguageIdAtPosition","lineTokens","findTokenIndexAtOffset","getLanguageConfiguration","getWordAtPosition","_position","lineContent","tokenIndex","rbStartOffset","rbEndOffset","_findLanguageBoundaries","rightBiasedWord","getWordDefinition","lbStartOffset","lbEndOffset","leftBiasedWord","getStartOffset","tokenCount","getCount","getEndOffset","getWordUntilPosition","wordAtPosition","word","substr","findMatchingBracketUp","_bracket","bracket","toLowerCase","bracketsSupport","brackets","data","textIsBracket","_findMatchingBracketUp","matchBracket","_matchBracket","_establishBracketSearchOffsets","modeBrackets","currentLanguageId","searchStartOffset","maxBracketLength","tokenEndOffset","getStandardTokenType","searchEndOffset","tokenStartOffset","currentModeBrackets","bestResult","foundBracket","findNextBracketInRange","forwardRegex","foundBracketText","_matchFoundBracket","textIsOpenBracket","prevTokenIndex","prevModeBrackets","findPrevBracketInRange","reversedRegex","isOpen","continueSearchPredicate","matched","_findMatchingBracketDown","getEndPosition","getStartPosition","reversedBracketRegex","count","totalCallCount","searchPrevMatchingBracketInRange","hitText","isClose","prevSearchInToken","searchInToken","bracketRegex","searchNextMatchingBracketInRange","findPrevBracket","tokenLanguageId","_toFoundBracket","findNextBracket","findEnclosingBrackets","maxDuration","startTime","Date","now","savedCounts","Map","counts","resetCounts","has","get","searchInRange","index","open","close","computeIndentLevel","line","indent","chCode","_computeIndentLevel","lineIndex","getActiveIndentGuide","minLineNumber","maxLineNumber","foldingRules","offSide","Boolean","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","goUp","goDown","initialIndent","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","ceil","_getIndentLevelForWhitespaceLine","downLineIndentLevel","getLinesBracketGuides","activePosition","_a","_b","_c","_d","_e","getBracketPairsInRangeWithMinIndentation","activeBracketPairRange","bracketsContainingActivePosition","bp","containsPosition","getBracketPairsInRange","fromPositions","queue","activeGuides","nextGuides","colorProvider","BracketPairGuidesClassNames","guides","pair","b","openingBracketRange","guideVisibleColumn","getVisibleColumnFromPosition","closingBracketRange","minVisibleColumnIndentation","renderHorizontalEndLineAtTheBottom","firstNonWsIndex","nestingLevel","visibleStartColumn","visibleEndColumn","bracketPair","isActive","equalsRange","className","getInlineClassNameOfLevel","highlightActive","activeClassName","horizontalGuides","HorizontalGuidesState","Disabled","includeInactive","Enabled","IndentGuide","IndentGuideHorizontalLine","lastVisibleColumnCount","Number","MAX_SAFE_INTEGER","a","visibleColumn","visibleColumnFromColumn","getLinesIndentGuides","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","normalizePosition","affinity","getLineIndentColumn","indentOfLine","DEFAULT_CREATION_OPTIONS","level","isNodeInOverviewRuler","isNodeInjectedText","_decorationsTree0","_decorationsTree1","_injectedTextDecorationsTree","host","_ensureNodesHaveRanges","_intervalSearch","r0","intervalSearch","r1","r2","showIfCollapsed","search","overviewRulerOnly","_search","_resolveNode","resolveNode","textLength","cleanClassName","replace","DecorationOptions","darkColor","ModelDecorationOverviewRulerOptions","_resolvedColor","OverviewRulerLane","Center","getColor","theme","type","_resolveColor","invalidateCachedColor","toString","ModelDecorationMinimapOptions","fromHex","ModelDecorationInjectedTextOptions","content","inlineClassName","inlineClassNameAffectsLetterSpacing","from","ModelDecorationOptions","description","stickiness","zIndex","hoverMessage","glyphMarginHoverMessage","isWholeLine","collapseOnReplaceEdit","minimap","glyphMarginClassName","linesDecorationsClassName","firstLineDecorationClassName","marginClassName","beforeContentClassName","afterContentClassName","register","createDynamic","EMPTY","handleBeforeFire","_actual","_affectedInjectedTextLines","_deferredCnt","_shouldFire","_affectsMinimap","_affectsOverviewRuler","affectsMinimap","affectsOverviewRuler","Set","add","_fastEmitter","_slowEmitter","_deferredEvent","merge"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../config/editorOptions.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport * as model from '../model.js';\nimport { EditStack } from './editStack.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from './textModelEvents.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TextModelTokenization } from './textModelTokens.js';\nimport { getWordAtText } from './wordHelper.js';\nimport { ILanguageConfigurationService } from '../modes/languageConfigurationRegistry.js';\nimport { NULL_MODE_ID } from '../modes/nullMode.js';\nimport { ignoreBracketsInToken } from '../modes/supports.js';\nimport { BracketsUtils } from '../modes/supports/richEditBrackets.js';\nimport { TokensStore, countEOL, TokensStore2 } from './tokensStore.js';\nimport { Color } from '../../../base/common/color.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { ArrayQueue, findLast } from '../../../base/common/arrays.js';\nimport { BracketPairs } from './bracketPairs/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairs/colorizedBracketPairsDecorationProvider.js';\nimport { CursorColumns } from '../controller/cursorColumns.js';\nimport { IModeService } from '../services/modeService.js';\nfunction createTextBufferBuilder() {\n    return new PieceTreeTextBufferBuilder();\n}\nexport function createTextBufferFactory(text) {\n    const builder = createTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    const factory = (typeof value === 'string' ? createTextBufferFactory(value) : value);\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nexport const LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        let result = [], resultCnt = 0, resultLength = 0;\n        do {\n            let tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nclass BracketSearchCanceled {\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\nlet TextModel = class TextModel extends Disposable {\n    constructor(source, creationOptions, languageId, associatedResource = null, _undoRedoService, _modeService, _languageConfigurationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._modeService = _modeService;\n        this._languageConfigurationService = _languageConfigurationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeContentOrInjectedText = this._register(new Emitter());\n        this.onDidChangeContentOrInjectedText = this._onDidChangeContentOrInjectedText.event;\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._backgroundTokenizationState = 0 /* Uninitialized */;\n        this._onBackgroundTokenizationStateChanged = this._register(new Emitter());\n        this.onBackgroundTokenizationStateChanged = this._onBackgroundTokenizationStateChanged.event;\n        this._register(this._eventEmitter.fastEvent((e) => {\n            this._onDidChangeContentOrInjectedText.fire(e.rawContentChangedEvent);\n        }));\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel.resolveOptions(this._buffer, creationOptions);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD));\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel.MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this._isDisposing = false;\n        this._languageId = languageId || NULL_MODE_ID;\n        this._languageRegistryListener = this._languageConfigurationService.onDidChange(e => {\n            if (e.affects(this._languageId)) {\n                this._onDidChangeLanguageConfiguration.fire({});\n            }\n        });\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._tokens = new TokensStore(this._modeService.languageIdCodec);\n        this._tokens2 = new TokensStore2(this._modeService.languageIdCodec);\n        this._tokenization = new TextModelTokenization(this, this._modeService.languageIdCodec);\n        this._bracketPairColorizer = this._register(new BracketPairs(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n    }\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: guessedIndentation.tabSize,\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions({\n            tabSize: options.tabSize,\n            indentSize: options.indentSize,\n            insertSpaces: options.insertSpaces,\n            trimAutoWhitespace: options.trimAutoWhitespace,\n            defaultEOL: options.defaultEOL,\n            bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n        });\n    }\n    onDidChangeContentFast(listener) {\n        return this._eventEmitter.fastEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    get bracketPairs() { return this._bracketPairColorizer; }\n    get backgroundTokenizationState() {\n        return this._backgroundTokenizationState;\n    }\n    handleTokenizationProgress(completed) {\n        if (this._backgroundTokenizationState === 2 /* Completed */) {\n            // We already did a full tokenization and don't go back to progressing.\n            return;\n        }\n        const newState = completed ? 2 /* Completed */ : 1 /* InProgress */;\n        if (this._backgroundTokenizationState !== newState) {\n            this._backgroundTokenizationState = newState;\n            this._onBackgroundTokenizationStateChanged.fire();\n        }\n    }\n    dispose() {\n        this._isDisposing = true;\n        this._onWillDispose.fire();\n        this._languageRegistryListener.dispose();\n        this._tokenization.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this._isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        this._bracketPairColorizer.handleContentChanged(change);\n        if (this._isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null) {\n            // There's nothing to do\n            return;\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Flush all tokens\n        this._tokens.flush();\n        this._tokens2.flush();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._onDidChangeAttached.fire(undefined);\n        }\n    }\n    onBeforeDetached() {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._onDidChangeAttached.fire(undefined);\n        }\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        let tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        let indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.indentSize;\n        let insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        let trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        let bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        let newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        let e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        let guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    static _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n        let spacesCnt = 0;\n        for (let i = 0; i < str.length; i++) {\n            if (str.charAt(i) === '\\t') {\n                spacesCnt += indentSize;\n            }\n            else {\n                spacesCnt++;\n            }\n        }\n        let result = '';\n        if (!insertSpaces) {\n            let tabsCnt = Math.floor(spacesCnt / indentSize);\n            spacesCnt = spacesCnt % indentSize;\n            for (let i = 0; i < tabsCnt; i++) {\n                result += '\\t';\n            }\n        }\n        for (let i = 0; i < spacesCnt; i++) {\n            result += ' ';\n        }\n        return result;\n    }\n    static normalizeIndentation(str, indentSize, insertSpaces) {\n        let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n        if (firstNonWhitespaceIndex === -1) {\n            firstNonWhitespaceIndex = str.length;\n        }\n        return TextModel._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return TextModel.normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        let position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        let offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* LF */\n            : 1 /* CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        let candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* LF */ : 1 /* CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            let incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    let sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        let editRange = incomingEdits[j].range;\n                        let selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        let selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    let trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    let maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        let editRange = incomingEdits[j].range;\n                        let editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update tokens and decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(change.text);\n                this._tokens.acceptEdit(change.range, eolCount, firstLineLength);\n                this._tokens2.acceptEdit(change.range, eolCount, firstLineLength, lastLineLength, change.text.length > 0 ? change.text.charCodeAt(0) : 0 /* Null */);\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            let rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    let injectedTexts = [];\n                    let newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        let lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = [...affectedInjectedTextLines];\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeContentOrInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        let changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }])[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false) {\n        let lineCount = this.getLineCount();\n        let startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        let endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        let endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation);\n        decorations.push(...this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false) {\n        let validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);\n        decorations.push(...this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\n            // Delete + Insert due to an overview ruler status change\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        let result = new Array(newDecorationsLen);\n        while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n            let node = null;\n            if (oldDecorationIndex < oldDecorationsLen) {\n                // (1) get ourselves an old node\n                do {\n                    node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                } while (!node && oldDecorationIndex < oldDecorationsLen);\n                // (2) remove the node from the tree (if it exists)\n                if (node) {\n                    if (node.options.after) {\n                        const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                    }\n                    this._decorationsTree.delete(node);\n                    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                }\n            }\n            if (newDecorationIndex < newDecorationsLen) {\n                // (3) create a new node if necessary\n                if (!node) {\n                    const internalDecorationId = (++this._lastDecorationId);\n                    const decorationId = `${this._instanceId};${internalDecorationId}`;\n                    node = new IntervalNode(decorationId, 0, 0);\n                    this._decorations[decorationId] = node;\n                }\n                // (4) initialize node\n                const newDecoration = newDecorations[newDecorationIndex];\n                const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                const options = _normalizeOptions(newDecoration.options);\n                const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                node.ownerId = ownerId;\n                node.reset(versionId, startOffset, endOffset, range);\n                node.setOptions(options);\n                if (node.options.after) {\n                    this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                }\n                if (node.options.before) {\n                    this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                }\n                this._onDidChangeDecorations.checkAffectedAndFire(options);\n                this._decorationsTree.insert(node);\n                result[newDecorationIndex] = node.id;\n                newDecorationIndex++;\n            }\n            else {\n                if (node) {\n                    delete this._decorations[node.id];\n                }\n            }\n        }\n        return result;\n    }\n    setTokens(tokens, backgroundTokenizationCompleted = false) {\n        if (tokens.length !== 0) {\n            let ranges = [];\n            for (let i = 0, len = tokens.length; i < len; i++) {\n                const element = tokens[i];\n                let minChangedLineNumber = 0;\n                let maxChangedLineNumber = 0;\n                let hasChange = false;\n                for (let j = 0, lenJ = element.tokens.length; j < lenJ; j++) {\n                    const lineNumber = element.startLineNumber + j;\n                    if (hasChange) {\n                        this._tokens.setTokens(this._languageId, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.tokens[j], false);\n                        maxChangedLineNumber = lineNumber;\n                    }\n                    else {\n                        const lineHasChange = this._tokens.setTokens(this._languageId, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.tokens[j], true);\n                        if (lineHasChange) {\n                            hasChange = true;\n                            minChangedLineNumber = lineNumber;\n                            maxChangedLineNumber = lineNumber;\n                        }\n                    }\n                }\n                if (hasChange) {\n                    ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber });\n                }\n            }\n            if (ranges.length > 0) {\n                this._emitModelTokensChangedEvent({\n                    tokenizationSupportChanged: false,\n                    semanticTokensApplied: false,\n                    ranges: ranges\n                });\n            }\n        }\n        this.handleTokenizationProgress(backgroundTokenizationCompleted);\n    }\n    setSemanticTokens(tokens, isComplete) {\n        this._tokens2.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            tokenizationSupportChanged: false,\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this.getLineCount() }]\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._tokens2.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._tokens2.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this._tokens2.setPartial(range, tokens);\n        this._emitModelTokensChangedEvent({\n            tokenizationSupportChanged: false,\n            semanticTokensApplied: true,\n            ranges: [{ fromLineNumber: changedRange.startLineNumber, toLineNumber: changedRange.endLineNumber }]\n        });\n    }\n    tokenizeViewport(startLineNumber, endLineNumber) {\n        startLineNumber = Math.max(1, startLineNumber);\n        endLineNumber = Math.min(this._buffer.getLineCount(), endLineNumber);\n        this._tokenization.tokenizeViewport(startLineNumber, endLineNumber);\n    }\n    clearTokens() {\n        this._tokens.flush();\n        this._emitModelTokensChangedEvent({\n            tokenizationSupportChanged: true,\n            semanticTokensApplied: false,\n            ranges: [{\n                    fromLineNumber: 1,\n                    toLineNumber: this._buffer.getLineCount()\n                }]\n        });\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._isDisposing) {\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    resetTokenization() {\n        this._tokenization.reset();\n    }\n    forceTokenization(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        this._tokenization.forceTokenization(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        return this._tokenization.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n    getLineTokens(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._getLineTokens(lineNumber);\n    }\n    _getLineTokens(lineNumber) {\n        const lineText = this.getLineContent(lineNumber);\n        const syntacticTokens = this._tokens.getTokens(this._languageId, lineNumber - 1, lineText);\n        return this._tokens2.addSemanticTokens(lineNumber, syntacticTokens);\n    }\n    getLanguageId() {\n        return this._languageId;\n    }\n    setMode(languageId) {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        let e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId\n        };\n        this._languageId = languageId;\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    // Having tokens allows implementing additional helper methods\n    getWordAtPosition(_position) {\n        this._assertNotDisposed();\n        const position = this.validatePosition(_position);\n        const lineContent = this.getLineContent(position.lineNumber);\n        const lineTokens = this._getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return {\n                word: '',\n                startColumn: position.column,\n                endColumn: position.column\n            };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column\n        };\n    }\n    findMatchingBracketUp(_bracket, _position) {\n        let bracket = _bracket.toLowerCase();\n        let position = this.validatePosition(_position);\n        let lineTokens = this._getLineTokens(position.lineNumber);\n        let languageId = lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n        let bracketsSupport = this.getLanguageConfiguration(languageId).brackets;\n        if (!bracketsSupport) {\n            return null;\n        }\n        let data = bracketsSupport.textIsBracket[bracket];\n        if (!data) {\n            return null;\n        }\n        return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, null));\n    }\n    matchBracket(position) {\n        return this._matchBracket(this.validatePosition(position));\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this._getLineTokens(lineNumber);\n        const lineText = this._buffer.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], null);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], null);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this._getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this._buffer.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this._getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this._buffer.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        const position = this.validatePosition(_position);\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this._getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this._buffer.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.getLanguageConfiguration(languageId).brackets;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(modeBrackets, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.getLanguageConfiguration(languageId).brackets;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(modeBrackets, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(modeBrackets, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        const position = this.validatePosition(_position);\n        const lineCount = this.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this._getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this._buffer.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.getLanguageConfiguration(languageId).brackets;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(modeBrackets, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.getLanguageConfiguration(languageId).brackets;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(modeBrackets, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(modeBrackets, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        let continueSearchPredicate;\n        if (typeof maxDuration === 'undefined') {\n            continueSearchPredicate = null;\n        }\n        else {\n            const startTime = Date.now();\n            continueSearchPredicate = () => {\n                return (Date.now() - startTime <= maxDuration);\n            };\n        }\n        const position = this.validatePosition(_position);\n        const lineCount = this.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                let tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this._getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this._buffer.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(modeBrackets, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.getValueInRange(r);\n        text = text.toLowerCase();\n        let data = modeBrackets.textIsBracket[text];\n        if (!data) {\n            return null;\n        }\n        return {\n            range: r,\n            open: data.open,\n            close: data.close,\n            isOpen: modeBrackets.textIsOpenBracket[text]\n        };\n    }\n    /**\n     * Returns:\n     *  - -1 => the line consists of whitespace\n     *  - otherwise => the indent level is returned value\n     */\n    static computeIndentLevel(line, tabSize) {\n        let indent = 0;\n        let i = 0;\n        let len = line.length;\n        while (i < len) {\n            let chCode = line.charCodeAt(i);\n            if (chCode === 32 /* Space */) {\n                indent++;\n            }\n            else if (chCode === 9 /* Tab */) {\n                indent = indent - indent % tabSize + tabSize;\n            }\n            else {\n                break;\n            }\n            i++;\n        }\n        if (i === len) {\n            return -1; // line only consists of whitespace\n        }\n        return indent;\n    }\n    _computeIndentLevel(lineIndex) {\n        return TextModel.computeIndentLevel(this._buffer.getLineContent(lineIndex + 1), this._options.tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this._languageId).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    let indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    let indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    let indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    let indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 && (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount && downLineIndentLevel >= 0 && initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 && upLineIndentLevel >= 0 && upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        var _a, _b, _c, _d, _e;\n        const result = [];\n        const bracketPairs = this._bracketPairColorizer.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.getLineMaxColumn(endLineNumber)));\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber && activePosition.lineNumber <= endLineNumber)\n                // Does active position intersect with the view port? -> Intersect bracket pairs with activePosition\n                ? bracketPairs.filter(bp => bp.range.containsPosition(activePosition))\n                : this._bracketPairColorizer.getBracketPairsInRange(Range.fromPositions(activePosition));\n            activeBracketPairRange = (_a = findLast(bracketsContainingActivePosition, \n            /* Exclude single line bracket pairs for cases such as\n             * ```\n             * function test() {\n             * \t\tif (true) { | }\n             * }\n             * ```\n             */\n            (i) => i.range.startLineNumber !== i.range.endLineNumber)) === null || _a === void 0 ? void 0 : _a.range;\n        }\n        const queue = new ArrayQueue(bracketPairs);\n        /** Indexed by nesting level */\n        const activeGuides = new Array();\n        const nextGuides = new Array();\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            let guides = new Array();\n            if (nextGuides.length > 0) {\n                guides = guides.concat(nextGuides);\n                nextGuides.length = 0;\n            }\n            result.push(guides);\n            // Update activeGuides\n            for (const pair of queue.takeWhile(b => b.openingBracketRange.startLineNumber <= lineNumber) || []) {\n                if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                    // ignore single line brackets\n                    continue;\n                }\n                const guideVisibleColumn = Math.min(this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition()), this.getVisibleColumnFromPosition((_c = (_b = pair.closingBracketRange) === null || _b === void 0 ? void 0 : _b.getStartPosition()) !== null && _c !== void 0 ? _c : pair.range.getEndPosition()), pair.minVisibleColumnIndentation + 1);\n                let renderHorizontalEndLineAtTheBottom = false;\n                if (pair.closingBracketRange) {\n                    const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.getLineContent(pair.closingBracketRange.startLineNumber));\n                    if (firstNonWsIndex < pair.closingBracketRange.startColumn - 1) {\n                        renderHorizontalEndLineAtTheBottom = true;\n                    }\n                }\n                // TODO: Consider indentation when computing guideVisibleColumn\n                const start = pair.openingBracketRange.getStartPosition();\n                const end = ((_e = (_d = pair.closingBracketRange) === null || _d === void 0 ? void 0 : _d.getStartPosition()) !== null && _e !== void 0 ? _e : pair.range.getEndPosition());\n                if (pair.closingBracketRange === undefined) {\n                    // Don't show guides for bracket pairs that are not balanced.\n                    // See #135125.\n                    activeGuides[pair.nestingLevel] = null;\n                }\n                else {\n                    activeGuides[pair.nestingLevel] = {\n                        nestingLevel: pair.nestingLevel,\n                        guideVisibleColumn,\n                        start,\n                        visibleStartColumn: this.getVisibleColumnFromPosition(start),\n                        end,\n                        visibleEndColumn: this.getVisibleColumnFromPosition(end),\n                        bracketPair: pair,\n                        renderHorizontalEndLineAtTheBottom\n                    };\n                }\n            }\n            for (const line of activeGuides) {\n                if (!line) {\n                    continue;\n                }\n                const isActive = activeBracketPairRange && line.bracketPair.range.equalsRange(activeBracketPairRange);\n                const className = colorProvider.getInlineClassNameOfLevel(line.nestingLevel) +\n                    (options.highlightActive && isActive ? ' ' + colorProvider.activeClassName : '');\n                if ((isActive && options.horizontalGuides !== model.HorizontalGuidesState.Disabled)\n                    || (options.includeInactive && options.horizontalGuides === model.HorizontalGuidesState.Enabled)) {\n                    if (line.start.lineNumber === lineNumber) {\n                        if (line.guideVisibleColumn < line.visibleStartColumn) {\n                            guides.push(new model.IndentGuide(line.guideVisibleColumn, className, new model.IndentGuideHorizontalLine(false, line.start.column)));\n                        }\n                    }\n                    if (line.end.lineNumber === lineNumber + 1) {\n                        // The next line might have horizontal guides.\n                        // However, the next line might also have a new bracket pair with the same indentation,\n                        // so the current bracket pair might get replaced. That's why we push the guide to nextGuides one line ahead.\n                        if (line.guideVisibleColumn < line.visibleEndColumn) {\n                            nextGuides.push(new model.IndentGuide(line.guideVisibleColumn, className, new model.IndentGuideHorizontalLine(!line.renderHorizontalEndLineAtTheBottom, line.end.column)));\n                        }\n                    }\n                }\n            }\n            let lastVisibleColumnCount = Number.MAX_SAFE_INTEGER;\n            // Going backwards, so the last guide potentially replaces others\n            for (let i = activeGuides.length - 1; i >= 0; i--) {\n                const line = activeGuides[i];\n                if (!line) {\n                    continue;\n                }\n                const isActive = options.highlightActive && activeBracketPairRange &&\n                    line.bracketPair.range.equalsRange(activeBracketPairRange);\n                const className = colorProvider.getInlineClassNameOfLevel(line.nestingLevel) +\n                    (isActive ? ' ' + colorProvider.activeClassName : '');\n                if (isActive || options.includeInactive) {\n                    if (line.renderHorizontalEndLineAtTheBottom && line.end.lineNumber === lineNumber + 1) {\n                        nextGuides.push(new model.IndentGuide(line.guideVisibleColumn, className, null));\n                    }\n                }\n                if (line.end.lineNumber <= lineNumber\n                    || line.start.lineNumber >= lineNumber) {\n                    continue;\n                }\n                if (line.guideVisibleColumn >= lastVisibleColumnCount && !isActive) {\n                    // Don't render a guide on top of an existing guide, unless it is active.\n                    continue;\n                }\n                lastVisibleColumnCount = line.guideVisibleColumn;\n                if (isActive || options.includeInactive) {\n                    guides.push(new model.IndentGuide(line.guideVisibleColumn, className, null));\n                }\n            }\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return CursorColumns.visibleColumnFromColumn(this.getLineContent(position.lineNumber), position.column, this._options.tabSize) + 1;\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this._languageId).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            let resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / this._options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    let indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    let indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return (1 + Math.floor(aboveContentLineIndent / this._options.indentSize));\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / this._options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / this._options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return (1 + Math.floor(belowContentLineIndent / this._options.indentSize));\n            }\n        }\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\nTextModel.DEFAULT_CREATION_OPTIONS = {\n    isForSimpleWidget: false,\n    tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n    indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n    insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n    detectIndentation: false,\n    defaultEOL: 1 /* LF */,\n    trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n    largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n    bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n};\nTextModel = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, IModeService),\n    __param(6, ILanguageConfigurationService)\n], TextModel);\nexport { TextModel };\nfunction indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\nexport class BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        let c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n    }\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n}\nexport class ModelDecorationOptions {\n    constructor(options) {\n        this.description = options.description;\n        this.stickiness = options.stickiness || 0 /* AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n    }\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nexport class DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFire = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        var _a;\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFire) {\n                this.handleBeforeFire(this._affectedInjectedTextLines);\n                const event = {\n                    affectsMinimap: this._affectsMinimap,\n                    affectsOverviewRuler: this._affectsOverviewRuler\n                };\n                this._shouldFire = false;\n                this._affectsMinimap = false;\n                this._affectsOverviewRuler = false;\n                this._actual.fire(event);\n            }\n            (_a = this._affectedInjectedTextLines) === null || _a === void 0 ? void 0 : _a.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        if (!this._affectsMinimap) {\n            this._affectsMinimap = options.minimap && options.minimap.position ? true : false;\n        }\n        if (!this._affectsOverviewRuler) {\n            this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n        }\n        this._shouldFire = true;\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._shouldFire = true;\n    }\n}\n//#endregion\nexport class DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}