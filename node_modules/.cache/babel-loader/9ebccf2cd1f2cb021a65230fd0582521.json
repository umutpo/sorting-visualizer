{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { stringDiff } from '../../../base/common/diff/diff.js';\nimport { globals } from '../../../base/common/platform.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { DiffComputer } from '../diff/diffComputer.js';\nimport { MirrorTextModel as BaseMirrorModel } from '../model/mirrorTextModel.js';\nimport { ensureValidWordDefinition, getWordAtText } from '../model/wordHelper.js';\nimport { computeLinks } from '../modes/linkComputer.js';\nimport { BasicInplaceReplace } from '../modes/supports/inplaceReplaceSupport.js';\nimport { createMonacoBaseAPI } from '../standalone/standaloneBase.js';\nimport * as types from '../../../base/common/types.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\n/**\n * @internal\n */\n\nexport class MirrorModel extends BaseMirrorModel {\n  get uri() {\n    return this._uri;\n  }\n\n  get eol() {\n    return this._eol;\n  }\n\n  getValue() {\n    return this.getText();\n  }\n\n  getLinesContent() {\n    return this._lines.slice(0);\n  }\n\n  getLineCount() {\n    return this._lines.length;\n  }\n\n  getLineContent(lineNumber) {\n    return this._lines[lineNumber - 1];\n  }\n\n  getWordAtPosition(position, wordDefinition) {\n    let wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);\n\n    if (wordAtText) {\n      return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n    }\n\n    return null;\n  }\n\n  words(wordDefinition) {\n    const lines = this._lines;\n\n    const wordenize = this._wordenize.bind(this);\n\n    let lineNumber = 0;\n    let lineText = '';\n    let wordRangesIdx = 0;\n    let wordRanges = [];\n    return {\n      *[Symbol.iterator]() {\n        while (true) {\n          if (wordRangesIdx < wordRanges.length) {\n            const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\n            wordRangesIdx += 1;\n            yield value;\n          } else {\n            if (lineNumber < lines.length) {\n              lineText = lines[lineNumber];\n              wordRanges = wordenize(lineText, wordDefinition);\n              wordRangesIdx = 0;\n              lineNumber += 1;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n\n    };\n  }\n\n  getLineWords(lineNumber, wordDefinition) {\n    let content = this._lines[lineNumber - 1];\n\n    let ranges = this._wordenize(content, wordDefinition);\n\n    let words = [];\n\n    for (const range of ranges) {\n      words.push({\n        word: content.substring(range.start, range.end),\n        startColumn: range.start + 1,\n        endColumn: range.end + 1\n      });\n    }\n\n    return words;\n  }\n\n  _wordenize(content, wordDefinition) {\n    const result = [];\n    let match;\n    wordDefinition.lastIndex = 0; // reset lastIndex just to be sure\n\n    while (match = wordDefinition.exec(content)) {\n      if (match[0].length === 0) {\n        // it did match the empty string\n        break;\n      }\n\n      result.push({\n        start: match.index,\n        end: match.index + match[0].length\n      });\n    }\n\n    return result;\n  }\n\n  getValueInRange(range) {\n    range = this._validateRange(range);\n\n    if (range.startLineNumber === range.endLineNumber) {\n      return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n    }\n\n    let lineEnding = this._eol;\n    let startLineIndex = range.startLineNumber - 1;\n    let endLineIndex = range.endLineNumber - 1;\n    let resultLines = [];\n    resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n\n    for (let i = startLineIndex + 1; i < endLineIndex; i++) {\n      resultLines.push(this._lines[i]);\n    }\n\n    resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n    return resultLines.join(lineEnding);\n  }\n\n  offsetAt(position) {\n    position = this._validatePosition(position);\n\n    this._ensureLineStarts();\n\n    return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);\n  }\n\n  positionAt(offset) {\n    offset = Math.floor(offset);\n    offset = Math.max(0, offset);\n\n    this._ensureLineStarts();\n\n    let out = this._lineStarts.getIndexOf(offset);\n\n    let lineLength = this._lines[out.index].length; // Ensure we return a valid position\n\n    return {\n      lineNumber: 1 + out.index,\n      column: 1 + Math.min(out.remainder, lineLength)\n    };\n  }\n\n  _validateRange(range) {\n    const start = this._validatePosition({\n      lineNumber: range.startLineNumber,\n      column: range.startColumn\n    });\n\n    const end = this._validatePosition({\n      lineNumber: range.endLineNumber,\n      column: range.endColumn\n    });\n\n    if (start.lineNumber !== range.startLineNumber || start.column !== range.startColumn || end.lineNumber !== range.endLineNumber || end.column !== range.endColumn) {\n      return {\n        startLineNumber: start.lineNumber,\n        startColumn: start.column,\n        endLineNumber: end.lineNumber,\n        endColumn: end.column\n      };\n    }\n\n    return range;\n  }\n\n  _validatePosition(position) {\n    if (!Position.isIPosition(position)) {\n      throw new Error('bad position');\n    }\n\n    let {\n      lineNumber,\n      column\n    } = position;\n    let hasChanged = false;\n\n    if (lineNumber < 1) {\n      lineNumber = 1;\n      column = 1;\n      hasChanged = true;\n    } else if (lineNumber > this._lines.length) {\n      lineNumber = this._lines.length;\n      column = this._lines[lineNumber - 1].length + 1;\n      hasChanged = true;\n    } else {\n      let maxCharacter = this._lines[lineNumber - 1].length + 1;\n\n      if (column < 1) {\n        column = 1;\n        hasChanged = true;\n      } else if (column > maxCharacter) {\n        column = maxCharacter;\n        hasChanged = true;\n      }\n    }\n\n    if (!hasChanged) {\n      return position;\n    } else {\n      return {\n        lineNumber,\n        column\n      };\n    }\n  }\n\n}\n/**\n * @internal\n */\n\nexport class EditorSimpleWorker {\n  constructor(host, foreignModuleFactory) {\n    this._host = host;\n    this._models = Object.create(null);\n    this._foreignModuleFactory = foreignModuleFactory;\n    this._foreignModule = null;\n  }\n\n  dispose() {\n    this._models = Object.create(null);\n  }\n\n  _getModel(uri) {\n    return this._models[uri];\n  }\n\n  _getModels() {\n    let all = [];\n    Object.keys(this._models).forEach(key => all.push(this._models[key]));\n    return all;\n  }\n\n  acceptNewModel(data) {\n    this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);\n  }\n\n  acceptModelChanged(strURL, e) {\n    if (!this._models[strURL]) {\n      return;\n    }\n\n    let model = this._models[strURL];\n    model.onEvents(e);\n  }\n\n  acceptRemovedModel(strURL) {\n    if (!this._models[strURL]) {\n      return;\n    }\n\n    delete this._models[strURL];\n  } // ---- BEGIN diff --------------------------------------------------------------------------\n\n\n  computeDiff(originalUrl, modifiedUrl, ignoreTrimWhitespace, maxComputationTime) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const original = this._getModel(originalUrl);\n\n      const modified = this._getModel(modifiedUrl);\n\n      if (!original || !modified) {\n        return null;\n      }\n\n      const originalLines = original.getLinesContent();\n      const modifiedLines = modified.getLinesContent();\n      const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n        shouldComputeCharChanges: true,\n        shouldPostProcessCharChanges: true,\n        shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\n        shouldMakePrettyDiff: true,\n        maxComputationTime: maxComputationTime\n      });\n      const diffResult = diffComputer.computeDiff();\n      const identical = diffResult.changes.length > 0 ? false : this._modelsAreIdentical(original, modified);\n      return {\n        quitEarly: diffResult.quitEarly,\n        identical: identical,\n        changes: diffResult.changes\n      };\n    });\n  }\n\n  _modelsAreIdentical(original, modified) {\n    const originalLineCount = original.getLineCount();\n    const modifiedLineCount = modified.getLineCount();\n\n    if (originalLineCount !== modifiedLineCount) {\n      return false;\n    }\n\n    for (let line = 1; line <= originalLineCount; line++) {\n      const originalLine = original.getLineContent(line);\n      const modifiedLine = modified.getLineContent(line);\n\n      if (originalLine !== modifiedLine) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  computeMoreMinimalEdits(modelUrl, edits) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const model = this._getModel(modelUrl);\n\n      if (!model) {\n        return edits;\n      }\n\n      const result = [];\n      let lastEol = undefined;\n      edits = edits.slice(0).sort((a, b) => {\n        if (a.range && b.range) {\n          return Range.compareRangesUsingStarts(a.range, b.range);\n        } // eol only changes should go to the end\n\n\n        let aRng = a.range ? 0 : 1;\n        let bRng = b.range ? 0 : 1;\n        return aRng - bRng;\n      });\n\n      for (let {\n        range,\n        text,\n        eol\n      } of edits) {\n        if (typeof eol === 'number') {\n          lastEol = eol;\n        }\n\n        if (Range.isEmpty(range) && !text) {\n          // empty change\n          continue;\n        }\n\n        const original = model.getValueInRange(range);\n        text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n\n        if (original === text) {\n          // noop\n          continue;\n        } // make sure diff won't take too long\n\n\n        if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\n          result.push({\n            range,\n            text\n          });\n          continue;\n        } // compute diff between original and edit.text\n\n\n        const changes = stringDiff(original, text, false);\n        const editOffset = model.offsetAt(Range.lift(range).getStartPosition());\n\n        for (const change of changes) {\n          const start = model.positionAt(editOffset + change.originalStart);\n          const end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n          const newEdit = {\n            text: text.substr(change.modifiedStart, change.modifiedLength),\n            range: {\n              startLineNumber: start.lineNumber,\n              startColumn: start.column,\n              endLineNumber: end.lineNumber,\n              endColumn: end.column\n            }\n          };\n\n          if (model.getValueInRange(newEdit.range) !== newEdit.text) {\n            result.push(newEdit);\n          }\n        }\n      }\n\n      if (typeof lastEol === 'number') {\n        result.push({\n          eol: lastEol,\n          text: '',\n          range: {\n            startLineNumber: 0,\n            startColumn: 0,\n            endLineNumber: 0,\n            endColumn: 0\n          }\n        });\n      }\n\n      return result;\n    });\n  } // ---- END minimal edits ---------------------------------------------------------------\n\n\n  computeLinks(modelUrl) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let model = this._getModel(modelUrl);\n\n      if (!model) {\n        return null;\n      }\n\n      return computeLinks(model);\n    });\n  }\n\n  textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const sw = new StopWatch(true);\n      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n      const seen = new Set();\n\n      outer: for (let url of modelUrls) {\n        const model = this._getModel(url);\n\n        if (!model) {\n          continue;\n        }\n\n        for (let word of model.words(wordDefRegExp)) {\n          if (word === leadingWord || !isNaN(Number(word))) {\n            continue;\n          }\n\n          seen.add(word);\n\n          if (seen.size > EditorSimpleWorker._suggestionsLimit) {\n            break outer;\n          }\n        }\n      }\n\n      return {\n        words: Array.from(seen),\n        duration: sw.elapsed()\n      };\n    });\n  } // ---- END suggest --------------------------------------------------------------------------\n  //#region -- word ranges --\n\n\n  computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let model = this._getModel(modelUrl);\n\n      if (!model) {\n        return Object.create(null);\n      }\n\n      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n      const result = Object.create(null);\n\n      for (let line = range.startLineNumber; line < range.endLineNumber; line++) {\n        let words = model.getLineWords(line, wordDefRegExp);\n\n        for (const word of words) {\n          if (!isNaN(Number(word.word))) {\n            continue;\n          }\n\n          let array = result[word.word];\n\n          if (!array) {\n            array = [];\n            result[word.word] = array;\n          }\n\n          array.push({\n            startLineNumber: line,\n            startColumn: word.startColumn,\n            endLineNumber: line,\n            endColumn: word.endColumn\n          });\n        }\n      }\n\n      return result;\n    });\n  } //#endregion\n\n\n  navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let model = this._getModel(modelUrl);\n\n      if (!model) {\n        return null;\n      }\n\n      let wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n\n      if (range.startColumn === range.endColumn) {\n        range = {\n          startLineNumber: range.startLineNumber,\n          startColumn: range.startColumn,\n          endLineNumber: range.endLineNumber,\n          endColumn: range.endColumn + 1\n        };\n      }\n\n      let selectionText = model.getValueInRange(range);\n      let wordRange = model.getWordAtPosition({\n        lineNumber: range.startLineNumber,\n        column: range.startColumn\n      }, wordDefRegExp);\n\n      if (!wordRange) {\n        return null;\n      }\n\n      let word = model.getValueInRange(wordRange);\n      let result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n      return result;\n    });\n  } // ---- BEGIN foreign module support --------------------------------------------------------------------------\n\n\n  loadForeignModule(moduleId, createData, foreignHostMethods) {\n    const proxyMethodRequest = (method, args) => {\n      return this._host.fhr(method, args);\n    };\n\n    const foreignHost = types.createProxyObject(foreignHostMethods, proxyMethodRequest);\n    let ctx = {\n      host: foreignHost,\n      getMirrorModels: () => {\n        return this._getModels();\n      }\n    };\n\n    if (this._foreignModuleFactory) {\n      this._foreignModule = this._foreignModuleFactory(ctx, createData); // static foreing module\n\n      return Promise.resolve(types.getAllMethodNames(this._foreignModule));\n    } // ESM-comment-begin\n    // \t\treturn new Promise<any>((resolve, reject) => {\n    // \t\t\trequire([moduleId], (foreignModule: { create: IForeignModuleFactory }) => {\n    // \t\t\t\tthis._foreignModule = foreignModule.create(ctx, createData);\n    // \n    // \t\t\t\tresolve(types.getAllMethodNames(this._foreignModule));\n    // \n    // \t\t\t}, reject);\n    // \t\t});\n    // ESM-comment-end\n    // ESM-uncomment-begin\n\n\n    return Promise.reject(new Error(`Unexpected usage`)); // ESM-uncomment-end\n  } // foreign method request\n\n\n  fmr(method, args) {\n    if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\n      return Promise.reject(new Error('Missing requestHandler or method: ' + method));\n    }\n\n    try {\n      return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n\n} // ---- END diff --------------------------------------------------------------------------\n// ---- BEGIN minimal edits ---------------------------------------------------------------\n\nEditorSimpleWorker._diffLimit = 100000; // ---- BEGIN suggest --------------------------------------------------------------------------\n\nEditorSimpleWorker._suggestionsLimit = 10000;\n/**\n * Called on the worker side\n * @internal\n */\n\nexport function create(host) {\n  return new EditorSimpleWorker(host, null);\n}\n\nif (typeof importScripts === 'function') {\n  // Running in a web worker\n  globals.monaco = createMonacoBaseAPI();\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","stringDiff","globals","URI","Position","Range","DiffComputer","MirrorTextModel","BaseMirrorModel","ensureValidWordDefinition","getWordAtText","computeLinks","BasicInplaceReplace","createMonacoBaseAPI","types","StopWatch","MirrorModel","uri","_uri","eol","_eol","getValue","getText","getLinesContent","_lines","slice","getLineCount","length","getLineContent","lineNumber","getWordAtPosition","position","wordDefinition","wordAtText","column","startColumn","endColumn","words","lines","wordenize","_wordenize","bind","lineText","wordRangesIdx","wordRanges","Symbol","iterator","substring","start","end","getLineWords","content","ranges","range","push","word","match","lastIndex","exec","index","getValueInRange","_validateRange","startLineNumber","endLineNumber","lineEnding","startLineIndex","endLineIndex","resultLines","i","join","offsetAt","_validatePosition","_ensureLineStarts","_lineStarts","getPrefixSum","positionAt","offset","Math","floor","max","out","getIndexOf","lineLength","min","remainder","isIPosition","Error","hasChanged","maxCharacter","EditorSimpleWorker","constructor","host","foreignModuleFactory","_host","_models","Object","create","_foreignModuleFactory","_foreignModule","dispose","_getModel","_getModels","all","keys","forEach","key","acceptNewModel","data","url","parse","EOL","versionId","acceptModelChanged","strURL","model","onEvents","acceptRemovedModel","computeDiff","originalUrl","modifiedUrl","ignoreTrimWhitespace","maxComputationTime","original","modified","originalLines","modifiedLines","diffComputer","shouldComputeCharChanges","shouldPostProcessCharChanges","shouldIgnoreTrimWhitespace","shouldMakePrettyDiff","diffResult","identical","changes","_modelsAreIdentical","quitEarly","originalLineCount","modifiedLineCount","line","originalLine","modifiedLine","computeMoreMinimalEdits","modelUrl","edits","lastEol","undefined","sort","a","b","compareRangesUsingStarts","aRng","bRng","text","isEmpty","replace","_diffLimit","editOffset","lift","getStartPosition","change","originalStart","originalLength","newEdit","substr","modifiedStart","modifiedLength","textualSuggest","modelUrls","leadingWord","wordDef","wordDefFlags","sw","wordDefRegExp","RegExp","seen","Set","outer","isNaN","Number","add","size","_suggestionsLimit","Array","from","duration","elapsed","computeWordRanges","array","navigateValueSet","up","selectionText","wordRange","INSTANCE","loadForeignModule","moduleId","createData","foreignHostMethods","proxyMethodRequest","method","args","fhr","foreignHost","createProxyObject","ctx","getMirrorModels","getAllMethodNames","fmr","importScripts","monaco"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { stringDiff } from '../../../base/common/diff/diff.js';\nimport { globals } from '../../../base/common/platform.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { DiffComputer } from '../diff/diffComputer.js';\nimport { MirrorTextModel as BaseMirrorModel } from '../model/mirrorTextModel.js';\nimport { ensureValidWordDefinition, getWordAtText } from '../model/wordHelper.js';\nimport { computeLinks } from '../modes/linkComputer.js';\nimport { BasicInplaceReplace } from '../modes/supports/inplaceReplaceSupport.js';\nimport { createMonacoBaseAPI } from '../standalone/standaloneBase.js';\nimport * as types from '../../../base/common/types.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\n/**\n * @internal\n */\nexport class MirrorModel extends BaseMirrorModel {\n    get uri() {\n        return this._uri;\n    }\n    get eol() {\n        return this._eol;\n    }\n    getValue() {\n        return this.getText();\n    }\n    getLinesContent() {\n        return this._lines.slice(0);\n    }\n    getLineCount() {\n        return this._lines.length;\n    }\n    getLineContent(lineNumber) {\n        return this._lines[lineNumber - 1];\n    }\n    getWordAtPosition(position, wordDefinition) {\n        let wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);\n        if (wordAtText) {\n            return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n        }\n        return null;\n    }\n    words(wordDefinition) {\n        const lines = this._lines;\n        const wordenize = this._wordenize.bind(this);\n        let lineNumber = 0;\n        let lineText = '';\n        let wordRangesIdx = 0;\n        let wordRanges = [];\n        return {\n            *[Symbol.iterator]() {\n                while (true) {\n                    if (wordRangesIdx < wordRanges.length) {\n                        const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\n                        wordRangesIdx += 1;\n                        yield value;\n                    }\n                    else {\n                        if (lineNumber < lines.length) {\n                            lineText = lines[lineNumber];\n                            wordRanges = wordenize(lineText, wordDefinition);\n                            wordRangesIdx = 0;\n                            lineNumber += 1;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n            }\n        };\n    }\n    getLineWords(lineNumber, wordDefinition) {\n        let content = this._lines[lineNumber - 1];\n        let ranges = this._wordenize(content, wordDefinition);\n        let words = [];\n        for (const range of ranges) {\n            words.push({\n                word: content.substring(range.start, range.end),\n                startColumn: range.start + 1,\n                endColumn: range.end + 1\n            });\n        }\n        return words;\n    }\n    _wordenize(content, wordDefinition) {\n        const result = [];\n        let match;\n        wordDefinition.lastIndex = 0; // reset lastIndex just to be sure\n        while (match = wordDefinition.exec(content)) {\n            if (match[0].length === 0) {\n                // it did match the empty string\n                break;\n            }\n            result.push({ start: match.index, end: match.index + match[0].length });\n        }\n        return result;\n    }\n    getValueInRange(range) {\n        range = this._validateRange(range);\n        if (range.startLineNumber === range.endLineNumber) {\n            return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n        }\n        let lineEnding = this._eol;\n        let startLineIndex = range.startLineNumber - 1;\n        let endLineIndex = range.endLineNumber - 1;\n        let resultLines = [];\n        resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n        for (let i = startLineIndex + 1; i < endLineIndex; i++) {\n            resultLines.push(this._lines[i]);\n        }\n        resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n        return resultLines.join(lineEnding);\n    }\n    offsetAt(position) {\n        position = this._validatePosition(position);\n        this._ensureLineStarts();\n        return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);\n    }\n    positionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        this._ensureLineStarts();\n        let out = this._lineStarts.getIndexOf(offset);\n        let lineLength = this._lines[out.index].length;\n        // Ensure we return a valid position\n        return {\n            lineNumber: 1 + out.index,\n            column: 1 + Math.min(out.remainder, lineLength)\n        };\n    }\n    _validateRange(range) {\n        const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });\n        const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });\n        if (start.lineNumber !== range.startLineNumber\n            || start.column !== range.startColumn\n            || end.lineNumber !== range.endLineNumber\n            || end.column !== range.endColumn) {\n            return {\n                startLineNumber: start.lineNumber,\n                startColumn: start.column,\n                endLineNumber: end.lineNumber,\n                endColumn: end.column\n            };\n        }\n        return range;\n    }\n    _validatePosition(position) {\n        if (!Position.isIPosition(position)) {\n            throw new Error('bad position');\n        }\n        let { lineNumber, column } = position;\n        let hasChanged = false;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            column = 1;\n            hasChanged = true;\n        }\n        else if (lineNumber > this._lines.length) {\n            lineNumber = this._lines.length;\n            column = this._lines[lineNumber - 1].length + 1;\n            hasChanged = true;\n        }\n        else {\n            let maxCharacter = this._lines[lineNumber - 1].length + 1;\n            if (column < 1) {\n                column = 1;\n                hasChanged = true;\n            }\n            else if (column > maxCharacter) {\n                column = maxCharacter;\n                hasChanged = true;\n            }\n        }\n        if (!hasChanged) {\n            return position;\n        }\n        else {\n            return { lineNumber, column };\n        }\n    }\n}\n/**\n * @internal\n */\nexport class EditorSimpleWorker {\n    constructor(host, foreignModuleFactory) {\n        this._host = host;\n        this._models = Object.create(null);\n        this._foreignModuleFactory = foreignModuleFactory;\n        this._foreignModule = null;\n    }\n    dispose() {\n        this._models = Object.create(null);\n    }\n    _getModel(uri) {\n        return this._models[uri];\n    }\n    _getModels() {\n        let all = [];\n        Object.keys(this._models).forEach((key) => all.push(this._models[key]));\n        return all;\n    }\n    acceptNewModel(data) {\n        this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);\n    }\n    acceptModelChanged(strURL, e) {\n        if (!this._models[strURL]) {\n            return;\n        }\n        let model = this._models[strURL];\n        model.onEvents(e);\n    }\n    acceptRemovedModel(strURL) {\n        if (!this._models[strURL]) {\n            return;\n        }\n        delete this._models[strURL];\n    }\n    // ---- BEGIN diff --------------------------------------------------------------------------\n    computeDiff(originalUrl, modifiedUrl, ignoreTrimWhitespace, maxComputationTime) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const original = this._getModel(originalUrl);\n            const modified = this._getModel(modifiedUrl);\n            if (!original || !modified) {\n                return null;\n            }\n            const originalLines = original.getLinesContent();\n            const modifiedLines = modified.getLinesContent();\n            const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n                shouldComputeCharChanges: true,\n                shouldPostProcessCharChanges: true,\n                shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\n                shouldMakePrettyDiff: true,\n                maxComputationTime: maxComputationTime\n            });\n            const diffResult = diffComputer.computeDiff();\n            const identical = (diffResult.changes.length > 0 ? false : this._modelsAreIdentical(original, modified));\n            return {\n                quitEarly: diffResult.quitEarly,\n                identical: identical,\n                changes: diffResult.changes\n            };\n        });\n    }\n    _modelsAreIdentical(original, modified) {\n        const originalLineCount = original.getLineCount();\n        const modifiedLineCount = modified.getLineCount();\n        if (originalLineCount !== modifiedLineCount) {\n            return false;\n        }\n        for (let line = 1; line <= originalLineCount; line++) {\n            const originalLine = original.getLineContent(line);\n            const modifiedLine = modified.getLineContent(line);\n            if (originalLine !== modifiedLine) {\n                return false;\n            }\n        }\n        return true;\n    }\n    computeMoreMinimalEdits(modelUrl, edits) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const model = this._getModel(modelUrl);\n            if (!model) {\n                return edits;\n            }\n            const result = [];\n            let lastEol = undefined;\n            edits = edits.slice(0).sort((a, b) => {\n                if (a.range && b.range) {\n                    return Range.compareRangesUsingStarts(a.range, b.range);\n                }\n                // eol only changes should go to the end\n                let aRng = a.range ? 0 : 1;\n                let bRng = b.range ? 0 : 1;\n                return aRng - bRng;\n            });\n            for (let { range, text, eol } of edits) {\n                if (typeof eol === 'number') {\n                    lastEol = eol;\n                }\n                if (Range.isEmpty(range) && !text) {\n                    // empty change\n                    continue;\n                }\n                const original = model.getValueInRange(range);\n                text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n                if (original === text) {\n                    // noop\n                    continue;\n                }\n                // make sure diff won't take too long\n                if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\n                    result.push({ range, text });\n                    continue;\n                }\n                // compute diff between original and edit.text\n                const changes = stringDiff(original, text, false);\n                const editOffset = model.offsetAt(Range.lift(range).getStartPosition());\n                for (const change of changes) {\n                    const start = model.positionAt(editOffset + change.originalStart);\n                    const end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n                    const newEdit = {\n                        text: text.substr(change.modifiedStart, change.modifiedLength),\n                        range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\n                    };\n                    if (model.getValueInRange(newEdit.range) !== newEdit.text) {\n                        result.push(newEdit);\n                    }\n                }\n            }\n            if (typeof lastEol === 'number') {\n                result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n            }\n            return result;\n        });\n    }\n    // ---- END minimal edits ---------------------------------------------------------------\n    computeLinks(modelUrl) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let model = this._getModel(modelUrl);\n            if (!model) {\n                return null;\n            }\n            return computeLinks(model);\n        });\n    }\n    textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const sw = new StopWatch(true);\n            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n            const seen = new Set();\n            outer: for (let url of modelUrls) {\n                const model = this._getModel(url);\n                if (!model) {\n                    continue;\n                }\n                for (let word of model.words(wordDefRegExp)) {\n                    if (word === leadingWord || !isNaN(Number(word))) {\n                        continue;\n                    }\n                    seen.add(word);\n                    if (seen.size > EditorSimpleWorker._suggestionsLimit) {\n                        break outer;\n                    }\n                }\n            }\n            return { words: Array.from(seen), duration: sw.elapsed() };\n        });\n    }\n    // ---- END suggest --------------------------------------------------------------------------\n    //#region -- word ranges --\n    computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let model = this._getModel(modelUrl);\n            if (!model) {\n                return Object.create(null);\n            }\n            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n            const result = Object.create(null);\n            for (let line = range.startLineNumber; line < range.endLineNumber; line++) {\n                let words = model.getLineWords(line, wordDefRegExp);\n                for (const word of words) {\n                    if (!isNaN(Number(word.word))) {\n                        continue;\n                    }\n                    let array = result[word.word];\n                    if (!array) {\n                        array = [];\n                        result[word.word] = array;\n                    }\n                    array.push({\n                        startLineNumber: line,\n                        startColumn: word.startColumn,\n                        endLineNumber: line,\n                        endColumn: word.endColumn\n                    });\n                }\n            }\n            return result;\n        });\n    }\n    //#endregion\n    navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let model = this._getModel(modelUrl);\n            if (!model) {\n                return null;\n            }\n            let wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n            if (range.startColumn === range.endColumn) {\n                range = {\n                    startLineNumber: range.startLineNumber,\n                    startColumn: range.startColumn,\n                    endLineNumber: range.endLineNumber,\n                    endColumn: range.endColumn + 1\n                };\n            }\n            let selectionText = model.getValueInRange(range);\n            let wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\n            if (!wordRange) {\n                return null;\n            }\n            let word = model.getValueInRange(wordRange);\n            let result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n            return result;\n        });\n    }\n    // ---- BEGIN foreign module support --------------------------------------------------------------------------\n    loadForeignModule(moduleId, createData, foreignHostMethods) {\n        const proxyMethodRequest = (method, args) => {\n            return this._host.fhr(method, args);\n        };\n        const foreignHost = types.createProxyObject(foreignHostMethods, proxyMethodRequest);\n        let ctx = {\n            host: foreignHost,\n            getMirrorModels: () => {\n                return this._getModels();\n            }\n        };\n        if (this._foreignModuleFactory) {\n            this._foreignModule = this._foreignModuleFactory(ctx, createData);\n            // static foreing module\n            return Promise.resolve(types.getAllMethodNames(this._foreignModule));\n        }\n        // ESM-comment-begin\n        // \t\treturn new Promise<any>((resolve, reject) => {\n        // \t\t\trequire([moduleId], (foreignModule: { create: IForeignModuleFactory }) => {\n        // \t\t\t\tthis._foreignModule = foreignModule.create(ctx, createData);\n        // \n        // \t\t\t\tresolve(types.getAllMethodNames(this._foreignModule));\n        // \n        // \t\t\t}, reject);\n        // \t\t});\n        // ESM-comment-end\n        // ESM-uncomment-begin\n        return Promise.reject(new Error(`Unexpected usage`));\n        // ESM-uncomment-end\n    }\n    // foreign method request\n    fmr(method, args) {\n        if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\n            return Promise.reject(new Error('Missing requestHandler or method: ' + method));\n        }\n        try {\n            return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n}\n// ---- END diff --------------------------------------------------------------------------\n// ---- BEGIN minimal edits ---------------------------------------------------------------\nEditorSimpleWorker._diffLimit = 100000;\n// ---- BEGIN suggest --------------------------------------------------------------------------\nEditorSimpleWorker._suggestionsLimit = 10000;\n/**\n * Called on the worker side\n * @internal\n */\nexport function create(host) {\n    return new EditorSimpleWorker(host, null);\n}\nif (typeof importScripts === 'function') {\n    // Running in a web worker\n    globals.monaco = createMonacoBaseAPI();\n}\n"]},"metadata":{},"sourceType":"module"}