{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nexport const _debugComposition = false;\nexport class TextAreaState {\n  constructor(value, selectionStart, selectionEnd, selectionStartPosition, selectionEndPosition) {\n    this.value = value;\n    this.selectionStart = selectionStart;\n    this.selectionEnd = selectionEnd;\n    this.selectionStartPosition = selectionStartPosition;\n    this.selectionEndPosition = selectionEndPosition;\n  }\n\n  toString() {\n    return '[ <' + this.value + '>, selectionStart: ' + this.selectionStart + ', selectionEnd: ' + this.selectionEnd + ']';\n  }\n\n  static readFromTextArea(textArea) {\n    return new TextAreaState(textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), null, null);\n  }\n\n  collapseSelection() {\n    return new TextAreaState(this.value, this.value.length, this.value.length, null, null);\n  }\n\n  writeToTextArea(reason, textArea, select) {\n    if (_debugComposition) {\n      console.log('writeToTextArea ' + reason + ': ' + this.toString());\n    }\n\n    textArea.setValue(reason, this.value);\n\n    if (select) {\n      textArea.setSelectionRange(reason, this.selectionStart, this.selectionEnd);\n    }\n  }\n\n  deduceEditorPosition(offset) {\n    if (offset <= this.selectionStart) {\n      const str = this.value.substring(offset, this.selectionStart);\n      return this._finishDeduceEditorPosition(this.selectionStartPosition, str, -1);\n    }\n\n    if (offset >= this.selectionEnd) {\n      const str = this.value.substring(this.selectionEnd, offset);\n      return this._finishDeduceEditorPosition(this.selectionEndPosition, str, 1);\n    }\n\n    const str1 = this.value.substring(this.selectionStart, offset);\n\n    if (str1.indexOf(String.fromCharCode(8230)) === -1) {\n      return this._finishDeduceEditorPosition(this.selectionStartPosition, str1, 1);\n    }\n\n    const str2 = this.value.substring(offset, this.selectionEnd);\n    return this._finishDeduceEditorPosition(this.selectionEndPosition, str2, -1);\n  }\n\n  _finishDeduceEditorPosition(anchor, deltaText, signum) {\n    let lineFeedCnt = 0;\n    let lastLineFeedIndex = -1;\n\n    while ((lastLineFeedIndex = deltaText.indexOf('\\n', lastLineFeedIndex + 1)) !== -1) {\n      lineFeedCnt++;\n    }\n\n    return [anchor, signum * deltaText.length, lineFeedCnt];\n  }\n\n  static selectedText(text) {\n    return new TextAreaState(text, 0, text.length, null, null);\n  }\n\n  static deduceInput(previousState, currentState, couldBeEmojiInput) {\n    if (!previousState) {\n      // This is the EMPTY state\n      return {\n        text: '',\n        replacePrevCharCnt: 0,\n        replaceNextCharCnt: 0,\n        positionDelta: 0\n      };\n    }\n\n    if (_debugComposition) {\n      console.log('------------------------deduceInput');\n      console.log('PREVIOUS STATE: ' + previousState.toString());\n      console.log('CURRENT STATE: ' + currentState.toString());\n    }\n\n    let previousValue = previousState.value;\n    let previousSelectionStart = previousState.selectionStart;\n    let previousSelectionEnd = previousState.selectionEnd;\n    let currentValue = currentState.value;\n    let currentSelectionStart = currentState.selectionStart;\n    let currentSelectionEnd = currentState.selectionEnd; // Strip the previous suffix from the value (without interfering with the current selection)\n\n    const previousSuffix = previousValue.substring(previousSelectionEnd);\n    const currentSuffix = currentValue.substring(currentSelectionEnd);\n    const suffixLength = strings.commonSuffixLength(previousSuffix, currentSuffix);\n    currentValue = currentValue.substring(0, currentValue.length - suffixLength);\n    previousValue = previousValue.substring(0, previousValue.length - suffixLength);\n    const previousPrefix = previousValue.substring(0, previousSelectionStart);\n    const currentPrefix = currentValue.substring(0, currentSelectionStart);\n    const prefixLength = strings.commonPrefixLength(previousPrefix, currentPrefix);\n    currentValue = currentValue.substring(prefixLength);\n    previousValue = previousValue.substring(prefixLength);\n    currentSelectionStart -= prefixLength;\n    previousSelectionStart -= prefixLength;\n    currentSelectionEnd -= prefixLength;\n    previousSelectionEnd -= prefixLength;\n\n    if (_debugComposition) {\n      console.log('AFTER DIFFING PREVIOUS STATE: <' + previousValue + '>, selectionStart: ' + previousSelectionStart + ', selectionEnd: ' + previousSelectionEnd);\n      console.log('AFTER DIFFING CURRENT STATE: <' + currentValue + '>, selectionStart: ' + currentSelectionStart + ', selectionEnd: ' + currentSelectionEnd);\n    }\n\n    if (couldBeEmojiInput && currentSelectionStart === currentSelectionEnd && previousValue.length > 0) {\n      // on OSX, emojis from the emoji picker are inserted at random locations\n      // the only hints we can use is that the selection is immediately after the inserted emoji\n      // and that none of the old text has been deleted\n      let potentialEmojiInput = null;\n\n      if (currentSelectionStart === currentValue.length) {\n        // emoji potentially inserted \"somewhere\" after the previous selection => it should appear at the end of `currentValue`\n        if (currentValue.startsWith(previousValue)) {\n          // only if all of the old text is accounted for\n          potentialEmojiInput = currentValue.substring(previousValue.length);\n        }\n      } else {\n        // emoji potentially inserted \"somewhere\" before the previous selection => it should appear at the start of `currentValue`\n        if (currentValue.endsWith(previousValue)) {\n          // only if all of the old text is accounted for\n          potentialEmojiInput = currentValue.substring(0, currentValue.length - previousValue.length);\n        }\n      }\n\n      if (potentialEmojiInput !== null && potentialEmojiInput.length > 0) {\n        // now we check that this is indeed an emoji\n        // emojis can grow quite long, so a length check is of no help\n        // e.g. 1F3F4 E0067 E0062 E0065 E006E E0067 E007F  ; fully-qualified     # 🏴󠁧󠁢󠁥󠁮󠁧󠁿 England\n        // Oftentimes, emojis use Variation Selector-16 (U+FE0F), so that is a good hint\n        // http://emojipedia.org/variation-selector-16/\n        // > An invisible codepoint which specifies that the preceding character\n        // > should be displayed with emoji presentation. Only required if the\n        // > preceding character defaults to text presentation.\n        if (/\\uFE0F/.test(potentialEmojiInput) || strings.containsEmoji(potentialEmojiInput)) {\n          return {\n            text: potentialEmojiInput,\n            replacePrevCharCnt: 0,\n            replaceNextCharCnt: 0,\n            positionDelta: 0\n          };\n        }\n      }\n    }\n\n    if (currentSelectionStart === currentSelectionEnd) {\n      // composition accept case (noticed in FF + Japanese)\n      // [blahblah] => blahblah|\n      if (previousValue === currentValue && previousSelectionStart === 0 && previousSelectionEnd === previousValue.length && currentSelectionStart === currentValue.length && currentValue.indexOf('\\n') === -1) {\n        if (strings.containsFullWidthCharacter(currentValue)) {\n          return {\n            text: '',\n            replacePrevCharCnt: 0,\n            replaceNextCharCnt: 0,\n            positionDelta: 0\n          };\n        }\n      } // no current selection\n\n\n      const replacePreviousCharacters = previousPrefix.length - prefixLength;\n\n      if (_debugComposition) {\n        console.log('REMOVE PREVIOUS: ' + (previousPrefix.length - prefixLength) + ' chars');\n      }\n\n      return {\n        text: currentValue,\n        replacePrevCharCnt: replacePreviousCharacters,\n        replaceNextCharCnt: 0,\n        positionDelta: 0\n      };\n    } // there is a current selection => composition case\n\n\n    const replacePreviousCharacters = previousSelectionEnd - previousSelectionStart;\n    return {\n      text: currentValue,\n      replacePrevCharCnt: replacePreviousCharacters,\n      replaceNextCharCnt: 0,\n      positionDelta: 0\n    };\n  }\n\n  static deduceAndroidCompositionInput(previousState, currentState) {\n    if (!previousState) {\n      // This is the EMPTY state\n      return {\n        text: '',\n        replacePrevCharCnt: 0,\n        replaceNextCharCnt: 0,\n        positionDelta: 0\n      };\n    }\n\n    if (_debugComposition) {\n      console.log('------------------------deduceAndroidCompositionInput');\n      console.log('PREVIOUS STATE: ' + previousState.toString());\n      console.log('CURRENT STATE: ' + currentState.toString());\n    }\n\n    if (previousState.value === currentState.value) {\n      return {\n        text: '',\n        replacePrevCharCnt: 0,\n        replaceNextCharCnt: 0,\n        positionDelta: currentState.selectionEnd - previousState.selectionEnd\n      };\n    }\n\n    const prefixLength = Math.min(strings.commonPrefixLength(previousState.value, currentState.value), previousState.selectionEnd);\n    const suffixLength = Math.min(strings.commonSuffixLength(previousState.value, currentState.value), previousState.value.length - previousState.selectionEnd);\n    const previousValue = previousState.value.substring(prefixLength, previousState.value.length - suffixLength);\n    const currentValue = currentState.value.substring(prefixLength, currentState.value.length - suffixLength);\n    const previousSelectionStart = previousState.selectionStart - prefixLength;\n    const previousSelectionEnd = previousState.selectionEnd - prefixLength;\n    const currentSelectionStart = currentState.selectionStart - prefixLength;\n    const currentSelectionEnd = currentState.selectionEnd - prefixLength;\n\n    if (_debugComposition) {\n      console.log('AFTER DIFFING PREVIOUS STATE: <' + previousValue + '>, selectionStart: ' + previousSelectionStart + ', selectionEnd: ' + previousSelectionEnd);\n      console.log('AFTER DIFFING CURRENT STATE: <' + currentValue + '>, selectionStart: ' + currentSelectionStart + ', selectionEnd: ' + currentSelectionEnd);\n    }\n\n    return {\n      text: currentValue,\n      replacePrevCharCnt: previousSelectionEnd,\n      replaceNextCharCnt: previousValue.length - previousSelectionEnd,\n      positionDelta: currentSelectionEnd - currentValue.length\n    };\n  }\n\n}\nTextAreaState.EMPTY = new TextAreaState('', 0, 0, null, null);\nexport class PagedScreenReaderStrategy {\n  static _getPageOfLine(lineNumber, linesPerPage) {\n    return Math.floor((lineNumber - 1) / linesPerPage);\n  }\n\n  static _getRangeForPage(page, linesPerPage) {\n    const offset = page * linesPerPage;\n    const startLineNumber = offset + 1;\n    const endLineNumber = offset + linesPerPage;\n    return new Range(startLineNumber, 1, endLineNumber + 1, 1);\n  }\n\n  static fromEditorSelection(previousState, model, selection, linesPerPage, trimLongText) {\n    const selectionStartPage = PagedScreenReaderStrategy._getPageOfLine(selection.startLineNumber, linesPerPage);\n\n    const selectionStartPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionStartPage, linesPerPage);\n\n    const selectionEndPage = PagedScreenReaderStrategy._getPageOfLine(selection.endLineNumber, linesPerPage);\n\n    const selectionEndPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionEndPage, linesPerPage);\n\n    const pretextRange = selectionStartPageRange.intersectRanges(new Range(1, 1, selection.startLineNumber, selection.startColumn));\n    let pretext = model.getValueInRange(pretextRange, 1\n    /* LF */\n    );\n    const lastLine = model.getLineCount();\n    const lastLineMaxColumn = model.getLineMaxColumn(lastLine);\n    const posttextRange = selectionEndPageRange.intersectRanges(new Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));\n    let posttext = model.getValueInRange(posttextRange, 1\n    /* LF */\n    );\n    let text;\n\n    if (selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage) {\n      // take full selection\n      text = model.getValueInRange(selection, 1\n      /* LF */\n      );\n    } else {\n      const selectionRange1 = selectionStartPageRange.intersectRanges(selection);\n      const selectionRange2 = selectionEndPageRange.intersectRanges(selection);\n      text = model.getValueInRange(selectionRange1, 1\n      /* LF */\n      ) + String.fromCharCode(8230) + model.getValueInRange(selectionRange2, 1\n      /* LF */\n      );\n    } // Chromium handles very poorly text even of a few thousand chars\n    // Cut text to avoid stalling the entire UI\n\n\n    if (trimLongText) {\n      const LIMIT_CHARS = 500;\n\n      if (pretext.length > LIMIT_CHARS) {\n        pretext = pretext.substring(pretext.length - LIMIT_CHARS, pretext.length);\n      }\n\n      if (posttext.length > LIMIT_CHARS) {\n        posttext = posttext.substring(0, LIMIT_CHARS);\n      }\n\n      if (text.length > 2 * LIMIT_CHARS) {\n        text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);\n      }\n    }\n\n    return new TextAreaState(pretext + text + posttext, pretext.length, pretext.length + text.length, new Position(selection.startLineNumber, selection.startColumn), new Position(selection.endLineNumber, selection.endColumn));\n  }\n\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaState.js"],"names":["strings","Position","Range","_debugComposition","TextAreaState","constructor","value","selectionStart","selectionEnd","selectionStartPosition","selectionEndPosition","toString","readFromTextArea","textArea","getValue","getSelectionStart","getSelectionEnd","collapseSelection","length","writeToTextArea","reason","select","console","log","setValue","setSelectionRange","deduceEditorPosition","offset","str","substring","_finishDeduceEditorPosition","str1","indexOf","String","fromCharCode","str2","anchor","deltaText","signum","lineFeedCnt","lastLineFeedIndex","selectedText","text","deduceInput","previousState","currentState","couldBeEmojiInput","replacePrevCharCnt","replaceNextCharCnt","positionDelta","previousValue","previousSelectionStart","previousSelectionEnd","currentValue","currentSelectionStart","currentSelectionEnd","previousSuffix","currentSuffix","suffixLength","commonSuffixLength","previousPrefix","currentPrefix","prefixLength","commonPrefixLength","potentialEmojiInput","startsWith","endsWith","test","containsEmoji","containsFullWidthCharacter","replacePreviousCharacters","deduceAndroidCompositionInput","Math","min","EMPTY","PagedScreenReaderStrategy","_getPageOfLine","lineNumber","linesPerPage","floor","_getRangeForPage","page","startLineNumber","endLineNumber","fromEditorSelection","model","selection","trimLongText","selectionStartPage","selectionStartPageRange","selectionEndPage","selectionEndPageRange","pretextRange","intersectRanges","startColumn","pretext","getValueInRange","lastLine","getLineCount","lastLineMaxColumn","getLineMaxColumn","posttextRange","endColumn","posttext","selectionRange1","selectionRange2","LIMIT_CHARS"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nexport const _debugComposition = false;\nexport class TextAreaState {\n    constructor(value, selectionStart, selectionEnd, selectionStartPosition, selectionEndPosition) {\n        this.value = value;\n        this.selectionStart = selectionStart;\n        this.selectionEnd = selectionEnd;\n        this.selectionStartPosition = selectionStartPosition;\n        this.selectionEndPosition = selectionEndPosition;\n    }\n    toString() {\n        return '[ <' + this.value + '>, selectionStart: ' + this.selectionStart + ', selectionEnd: ' + this.selectionEnd + ']';\n    }\n    static readFromTextArea(textArea) {\n        return new TextAreaState(textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), null, null);\n    }\n    collapseSelection() {\n        return new TextAreaState(this.value, this.value.length, this.value.length, null, null);\n    }\n    writeToTextArea(reason, textArea, select) {\n        if (_debugComposition) {\n            console.log('writeToTextArea ' + reason + ': ' + this.toString());\n        }\n        textArea.setValue(reason, this.value);\n        if (select) {\n            textArea.setSelectionRange(reason, this.selectionStart, this.selectionEnd);\n        }\n    }\n    deduceEditorPosition(offset) {\n        if (offset <= this.selectionStart) {\n            const str = this.value.substring(offset, this.selectionStart);\n            return this._finishDeduceEditorPosition(this.selectionStartPosition, str, -1);\n        }\n        if (offset >= this.selectionEnd) {\n            const str = this.value.substring(this.selectionEnd, offset);\n            return this._finishDeduceEditorPosition(this.selectionEndPosition, str, 1);\n        }\n        const str1 = this.value.substring(this.selectionStart, offset);\n        if (str1.indexOf(String.fromCharCode(8230)) === -1) {\n            return this._finishDeduceEditorPosition(this.selectionStartPosition, str1, 1);\n        }\n        const str2 = this.value.substring(offset, this.selectionEnd);\n        return this._finishDeduceEditorPosition(this.selectionEndPosition, str2, -1);\n    }\n    _finishDeduceEditorPosition(anchor, deltaText, signum) {\n        let lineFeedCnt = 0;\n        let lastLineFeedIndex = -1;\n        while ((lastLineFeedIndex = deltaText.indexOf('\\n', lastLineFeedIndex + 1)) !== -1) {\n            lineFeedCnt++;\n        }\n        return [anchor, signum * deltaText.length, lineFeedCnt];\n    }\n    static selectedText(text) {\n        return new TextAreaState(text, 0, text.length, null, null);\n    }\n    static deduceInput(previousState, currentState, couldBeEmojiInput) {\n        if (!previousState) {\n            // This is the EMPTY state\n            return {\n                text: '',\n                replacePrevCharCnt: 0,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n        }\n        if (_debugComposition) {\n            console.log('------------------------deduceInput');\n            console.log('PREVIOUS STATE: ' + previousState.toString());\n            console.log('CURRENT STATE: ' + currentState.toString());\n        }\n        let previousValue = previousState.value;\n        let previousSelectionStart = previousState.selectionStart;\n        let previousSelectionEnd = previousState.selectionEnd;\n        let currentValue = currentState.value;\n        let currentSelectionStart = currentState.selectionStart;\n        let currentSelectionEnd = currentState.selectionEnd;\n        // Strip the previous suffix from the value (without interfering with the current selection)\n        const previousSuffix = previousValue.substring(previousSelectionEnd);\n        const currentSuffix = currentValue.substring(currentSelectionEnd);\n        const suffixLength = strings.commonSuffixLength(previousSuffix, currentSuffix);\n        currentValue = currentValue.substring(0, currentValue.length - suffixLength);\n        previousValue = previousValue.substring(0, previousValue.length - suffixLength);\n        const previousPrefix = previousValue.substring(0, previousSelectionStart);\n        const currentPrefix = currentValue.substring(0, currentSelectionStart);\n        const prefixLength = strings.commonPrefixLength(previousPrefix, currentPrefix);\n        currentValue = currentValue.substring(prefixLength);\n        previousValue = previousValue.substring(prefixLength);\n        currentSelectionStart -= prefixLength;\n        previousSelectionStart -= prefixLength;\n        currentSelectionEnd -= prefixLength;\n        previousSelectionEnd -= prefixLength;\n        if (_debugComposition) {\n            console.log('AFTER DIFFING PREVIOUS STATE: <' + previousValue + '>, selectionStart: ' + previousSelectionStart + ', selectionEnd: ' + previousSelectionEnd);\n            console.log('AFTER DIFFING CURRENT STATE: <' + currentValue + '>, selectionStart: ' + currentSelectionStart + ', selectionEnd: ' + currentSelectionEnd);\n        }\n        if (couldBeEmojiInput && currentSelectionStart === currentSelectionEnd && previousValue.length > 0) {\n            // on OSX, emojis from the emoji picker are inserted at random locations\n            // the only hints we can use is that the selection is immediately after the inserted emoji\n            // and that none of the old text has been deleted\n            let potentialEmojiInput = null;\n            if (currentSelectionStart === currentValue.length) {\n                // emoji potentially inserted \"somewhere\" after the previous selection => it should appear at the end of `currentValue`\n                if (currentValue.startsWith(previousValue)) {\n                    // only if all of the old text is accounted for\n                    potentialEmojiInput = currentValue.substring(previousValue.length);\n                }\n            }\n            else {\n                // emoji potentially inserted \"somewhere\" before the previous selection => it should appear at the start of `currentValue`\n                if (currentValue.endsWith(previousValue)) {\n                    // only if all of the old text is accounted for\n                    potentialEmojiInput = currentValue.substring(0, currentValue.length - previousValue.length);\n                }\n            }\n            if (potentialEmojiInput !== null && potentialEmojiInput.length > 0) {\n                // now we check that this is indeed an emoji\n                // emojis can grow quite long, so a length check is of no help\n                // e.g. 1F3F4 E0067 E0062 E0065 E006E E0067 E007F  ; fully-qualified     # 🏴󠁧󠁢󠁥󠁮󠁧󠁿 England\n                // Oftentimes, emojis use Variation Selector-16 (U+FE0F), so that is a good hint\n                // http://emojipedia.org/variation-selector-16/\n                // > An invisible codepoint which specifies that the preceding character\n                // > should be displayed with emoji presentation. Only required if the\n                // > preceding character defaults to text presentation.\n                if (/\\uFE0F/.test(potentialEmojiInput) || strings.containsEmoji(potentialEmojiInput)) {\n                    return {\n                        text: potentialEmojiInput,\n                        replacePrevCharCnt: 0,\n                        replaceNextCharCnt: 0,\n                        positionDelta: 0\n                    };\n                }\n            }\n        }\n        if (currentSelectionStart === currentSelectionEnd) {\n            // composition accept case (noticed in FF + Japanese)\n            // [blahblah] => blahblah|\n            if (previousValue === currentValue\n                && previousSelectionStart === 0\n                && previousSelectionEnd === previousValue.length\n                && currentSelectionStart === currentValue.length\n                && currentValue.indexOf('\\n') === -1) {\n                if (strings.containsFullWidthCharacter(currentValue)) {\n                    return {\n                        text: '',\n                        replacePrevCharCnt: 0,\n                        replaceNextCharCnt: 0,\n                        positionDelta: 0\n                    };\n                }\n            }\n            // no current selection\n            const replacePreviousCharacters = (previousPrefix.length - prefixLength);\n            if (_debugComposition) {\n                console.log('REMOVE PREVIOUS: ' + (previousPrefix.length - prefixLength) + ' chars');\n            }\n            return {\n                text: currentValue,\n                replacePrevCharCnt: replacePreviousCharacters,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n        }\n        // there is a current selection => composition case\n        const replacePreviousCharacters = previousSelectionEnd - previousSelectionStart;\n        return {\n            text: currentValue,\n            replacePrevCharCnt: replacePreviousCharacters,\n            replaceNextCharCnt: 0,\n            positionDelta: 0\n        };\n    }\n    static deduceAndroidCompositionInput(previousState, currentState) {\n        if (!previousState) {\n            // This is the EMPTY state\n            return {\n                text: '',\n                replacePrevCharCnt: 0,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n        }\n        if (_debugComposition) {\n            console.log('------------------------deduceAndroidCompositionInput');\n            console.log('PREVIOUS STATE: ' + previousState.toString());\n            console.log('CURRENT STATE: ' + currentState.toString());\n        }\n        if (previousState.value === currentState.value) {\n            return {\n                text: '',\n                replacePrevCharCnt: 0,\n                replaceNextCharCnt: 0,\n                positionDelta: currentState.selectionEnd - previousState.selectionEnd\n            };\n        }\n        const prefixLength = Math.min(strings.commonPrefixLength(previousState.value, currentState.value), previousState.selectionEnd);\n        const suffixLength = Math.min(strings.commonSuffixLength(previousState.value, currentState.value), previousState.value.length - previousState.selectionEnd);\n        const previousValue = previousState.value.substring(prefixLength, previousState.value.length - suffixLength);\n        const currentValue = currentState.value.substring(prefixLength, currentState.value.length - suffixLength);\n        const previousSelectionStart = previousState.selectionStart - prefixLength;\n        const previousSelectionEnd = previousState.selectionEnd - prefixLength;\n        const currentSelectionStart = currentState.selectionStart - prefixLength;\n        const currentSelectionEnd = currentState.selectionEnd - prefixLength;\n        if (_debugComposition) {\n            console.log('AFTER DIFFING PREVIOUS STATE: <' + previousValue + '>, selectionStart: ' + previousSelectionStart + ', selectionEnd: ' + previousSelectionEnd);\n            console.log('AFTER DIFFING CURRENT STATE: <' + currentValue + '>, selectionStart: ' + currentSelectionStart + ', selectionEnd: ' + currentSelectionEnd);\n        }\n        return {\n            text: currentValue,\n            replacePrevCharCnt: previousSelectionEnd,\n            replaceNextCharCnt: previousValue.length - previousSelectionEnd,\n            positionDelta: currentSelectionEnd - currentValue.length\n        };\n    }\n}\nTextAreaState.EMPTY = new TextAreaState('', 0, 0, null, null);\nexport class PagedScreenReaderStrategy {\n    static _getPageOfLine(lineNumber, linesPerPage) {\n        return Math.floor((lineNumber - 1) / linesPerPage);\n    }\n    static _getRangeForPage(page, linesPerPage) {\n        const offset = page * linesPerPage;\n        const startLineNumber = offset + 1;\n        const endLineNumber = offset + linesPerPage;\n        return new Range(startLineNumber, 1, endLineNumber + 1, 1);\n    }\n    static fromEditorSelection(previousState, model, selection, linesPerPage, trimLongText) {\n        const selectionStartPage = PagedScreenReaderStrategy._getPageOfLine(selection.startLineNumber, linesPerPage);\n        const selectionStartPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionStartPage, linesPerPage);\n        const selectionEndPage = PagedScreenReaderStrategy._getPageOfLine(selection.endLineNumber, linesPerPage);\n        const selectionEndPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionEndPage, linesPerPage);\n        const pretextRange = selectionStartPageRange.intersectRanges(new Range(1, 1, selection.startLineNumber, selection.startColumn));\n        let pretext = model.getValueInRange(pretextRange, 1 /* LF */);\n        const lastLine = model.getLineCount();\n        const lastLineMaxColumn = model.getLineMaxColumn(lastLine);\n        const posttextRange = selectionEndPageRange.intersectRanges(new Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));\n        let posttext = model.getValueInRange(posttextRange, 1 /* LF */);\n        let text;\n        if (selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage) {\n            // take full selection\n            text = model.getValueInRange(selection, 1 /* LF */);\n        }\n        else {\n            const selectionRange1 = selectionStartPageRange.intersectRanges(selection);\n            const selectionRange2 = selectionEndPageRange.intersectRanges(selection);\n            text = (model.getValueInRange(selectionRange1, 1 /* LF */)\n                + String.fromCharCode(8230)\n                + model.getValueInRange(selectionRange2, 1 /* LF */));\n        }\n        // Chromium handles very poorly text even of a few thousand chars\n        // Cut text to avoid stalling the entire UI\n        if (trimLongText) {\n            const LIMIT_CHARS = 500;\n            if (pretext.length > LIMIT_CHARS) {\n                pretext = pretext.substring(pretext.length - LIMIT_CHARS, pretext.length);\n            }\n            if (posttext.length > LIMIT_CHARS) {\n                posttext = posttext.substring(0, LIMIT_CHARS);\n            }\n            if (text.length > 2 * LIMIT_CHARS) {\n                text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);\n            }\n        }\n        return new TextAreaState(pretext + text + posttext, pretext.length, pretext.length + text.length, new Position(selection.startLineNumber, selection.startColumn), new Position(selection.endLineNumber, selection.endColumn));\n    }\n}\n"]},"metadata":{},"sourceType":"module"}