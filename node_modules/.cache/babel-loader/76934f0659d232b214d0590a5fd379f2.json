{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class Viewport {\n  constructor(top, left, width, height) {\n    this._viewportBrand = undefined;\n    this.top = top | 0;\n    this.left = left | 0;\n    this.width = width | 0;\n    this.height = height | 0;\n  }\n\n}\nexport class OutputPosition {\n  constructor(outputLineIndex, outputOffset) {\n    this.outputLineIndex = outputLineIndex;\n    this.outputOffset = outputOffset;\n  }\n\n  toString() {\n    return `${this.outputLineIndex}:${this.outputOffset}`;\n  }\n\n  toPosition(baseLineNumber, wrappedTextIndentLength) {\n    const delta = this.outputLineIndex > 0 ? wrappedTextIndentLength : 0;\n    return new Position(baseLineNumber + this.outputLineIndex, delta + this.outputOffset + 1);\n  }\n\n}\nexport class LineBreakData {\n  constructor(breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength, injectionOffsets, injectionOptions) {\n    this.breakOffsets = breakOffsets;\n    this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;\n    this.wrappedTextIndentLength = wrappedTextIndentLength;\n    this.injectionOffsets = injectionOffsets;\n    this.injectionOptions = injectionOptions;\n  }\n\n  getInputOffsetOfOutputPosition(outputLineIndex, outputOffset) {\n    let inputOffset = 0;\n\n    if (outputLineIndex === 0) {\n      inputOffset = outputOffset;\n    } else {\n      inputOffset = this.breakOffsets[outputLineIndex - 1] + outputOffset;\n    }\n\n    if (this.injectionOffsets !== null) {\n      for (let i = 0; i < this.injectionOffsets.length; i++) {\n        if (inputOffset > this.injectionOffsets[i]) {\n          if (inputOffset < this.injectionOffsets[i] + this.injectionOptions[i].content.length) {\n            // `inputOffset` is within injected text\n            inputOffset = this.injectionOffsets[i];\n          } else {\n            inputOffset -= this.injectionOptions[i].content.length;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n\n    return inputOffset;\n  }\n\n  getOutputPositionOfInputOffset(inputOffset) {\n    let affinity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    let delta = 0;\n\n    if (this.injectionOffsets !== null) {\n      for (let i = 0; i < this.injectionOffsets.length; i++) {\n        if (inputOffset < this.injectionOffsets[i]) {\n          break;\n        }\n\n        if (affinity !== 1\n        /* Right */\n        && inputOffset === this.injectionOffsets[i]) {\n          break;\n        }\n\n        delta += this.injectionOptions[i].content.length;\n      }\n    }\n\n    inputOffset += delta;\n    return this.getOutputPositionOfOffsetInUnwrappedLine(inputOffset, affinity);\n  }\n\n  getOutputPositionOfOffsetInUnwrappedLine(inputOffset) {\n    let affinity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    let low = 0;\n    let high = this.breakOffsets.length - 1;\n    let mid = 0;\n    let midStart = 0;\n\n    while (low <= high) {\n      mid = low + (high - low) / 2 | 0;\n      const midStop = this.breakOffsets[mid];\n      midStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n\n      if (affinity === 0\n      /* Left */\n      ) {\n        if (inputOffset <= midStart) {\n          high = mid - 1;\n        } else if (inputOffset > midStop) {\n          low = mid + 1;\n        } else {\n          break;\n        }\n      } else {\n        if (inputOffset < midStart) {\n          high = mid - 1;\n        } else if (inputOffset >= midStop) {\n          low = mid + 1;\n        } else {\n          break;\n        }\n      }\n    }\n\n    return new OutputPosition(mid, inputOffset - midStart);\n  }\n\n  outputPositionToOffsetInUnwrappedLine(outputLineIndex, outputOffset) {\n    let result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n\n    if (outputLineIndex > 0) {\n      result -= this.wrappedTextIndentLength;\n    }\n\n    return result;\n  }\n\n  normalizeOffsetAroundInjections(offsetInUnwrappedLine, affinity) {\n    const injectedText = this.getInjectedTextAtOffset(offsetInUnwrappedLine);\n\n    if (!injectedText) {\n      return offsetInUnwrappedLine;\n    }\n\n    if (affinity === 2\n    /* None */\n    ) {\n      if (offsetInUnwrappedLine === injectedText.offsetInUnwrappedLine + injectedText.length) {\n        // go to the end of this injected text\n        return injectedText.offsetInUnwrappedLine + injectedText.length;\n      } else {\n        // go to the start of this injected text\n        return injectedText.offsetInUnwrappedLine;\n      }\n    }\n\n    if (affinity === 1\n    /* Right */\n    ) {\n      let result = injectedText.offsetInUnwrappedLine + injectedText.length;\n      let index = injectedText.injectedTextIndex; // traverse all injected text that touch eachother\n\n      while (index + 1 < this.injectionOffsets.length && this.injectionOffsets[index + 1] === this.injectionOffsets[index]) {\n        result += this.injectionOptions[index + 1].content.length;\n        index++;\n      }\n\n      return result;\n    } // affinity is left\n\n\n    let result = injectedText.offsetInUnwrappedLine;\n    let index = injectedText.injectedTextIndex; // traverse all injected text that touch eachother\n\n    while (index - 1 >= 0 && this.injectionOffsets[index - 1] === this.injectionOffsets[index]) {\n      result -= this.injectionOptions[index - 1].content.length;\n      index++;\n    }\n\n    return result;\n  }\n\n  getInjectedText(outputLineIndex, outputOffset) {\n    const offset = this.outputPositionToOffsetInUnwrappedLine(outputLineIndex, outputOffset);\n    const injectedText = this.getInjectedTextAtOffset(offset);\n\n    if (!injectedText) {\n      return null;\n    }\n\n    return {\n      options: this.injectionOptions[injectedText.injectedTextIndex]\n    };\n  }\n\n  getInjectedTextAtOffset(offsetInUnwrappedLine) {\n    const injectionOffsets = this.injectionOffsets;\n    const injectionOptions = this.injectionOptions;\n\n    if (injectionOffsets !== null) {\n      let totalInjectedTextLengthBefore = 0;\n\n      for (let i = 0; i < injectionOffsets.length; i++) {\n        const length = injectionOptions[i].content.length;\n        const injectedTextStartOffsetInUnwrappedLine = injectionOffsets[i] + totalInjectedTextLengthBefore;\n        const injectedTextEndOffsetInUnwrappedLine = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n\n        if (injectedTextStartOffsetInUnwrappedLine > offsetInUnwrappedLine) {\n          // Injected text starts later.\n          break; // All later injected texts have an even larger offset.\n        }\n\n        if (offsetInUnwrappedLine <= injectedTextEndOffsetInUnwrappedLine) {\n          // Injected text ends after or with the given position (but also starts with or before it).\n          return {\n            injectedTextIndex: i,\n            offsetInUnwrappedLine: injectedTextStartOffsetInUnwrappedLine,\n            length\n          };\n        }\n\n        totalInjectedTextLengthBefore += length;\n      }\n    }\n\n    return undefined;\n  }\n\n}\nexport class InjectedText {\n  constructor(options) {\n    this.options = options;\n  }\n\n}\nexport class MinimapLinesRenderingData {\n  constructor(tabSize, data) {\n    this.tabSize = tabSize;\n    this.data = data;\n  }\n\n}\nexport class ViewLineData {\n  constructor(content, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations) {\n    this._viewLineDataBrand = undefined;\n    this.content = content;\n    this.continuesWithWrappedLine = continuesWithWrappedLine;\n    this.minColumn = minColumn;\n    this.maxColumn = maxColumn;\n    this.startVisibleColumn = startVisibleColumn;\n    this.tokens = tokens;\n    this.inlineDecorations = inlineDecorations;\n  }\n\n}\nexport class ViewLineRenderingData {\n  constructor(minColumn, maxColumn, content, continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, tokens, inlineDecorations, tabSize, startVisibleColumn) {\n    this.minColumn = minColumn;\n    this.maxColumn = maxColumn;\n    this.content = content;\n    this.continuesWithWrappedLine = continuesWithWrappedLine;\n    this.isBasicASCII = ViewLineRenderingData.isBasicASCII(content, mightContainNonBasicASCII);\n    this.containsRTL = ViewLineRenderingData.containsRTL(content, this.isBasicASCII, mightContainRTL);\n    this.tokens = tokens;\n    this.inlineDecorations = inlineDecorations;\n    this.tabSize = tabSize;\n    this.startVisibleColumn = startVisibleColumn;\n  }\n\n  static isBasicASCII(lineContent, mightContainNonBasicASCII) {\n    if (mightContainNonBasicASCII) {\n      return strings.isBasicASCII(lineContent);\n    }\n\n    return true;\n  }\n\n  static containsRTL(lineContent, isBasicASCII, mightContainRTL) {\n    if (!isBasicASCII && mightContainRTL) {\n      return strings.containsRTL(lineContent);\n    }\n\n    return false;\n  }\n\n}\nexport class InlineDecoration {\n  constructor(range, inlineClassName, type) {\n    this.range = range;\n    this.inlineClassName = inlineClassName;\n    this.type = type;\n  }\n\n}\nexport class SingleLineInlineDecoration {\n  constructor(startOffset, endOffset, inlineClassName, inlineClassNameAffectsLetterSpacing) {\n    this.startOffset = startOffset;\n    this.endOffset = endOffset;\n    this.inlineClassName = inlineClassName;\n    this.inlineClassNameAffectsLetterSpacing = inlineClassNameAffectsLetterSpacing;\n  }\n\n  toInlineDecoration(lineNumber) {\n    return new InlineDecoration(new Range(lineNumber, this.startOffset + 1, lineNumber, this.endOffset + 1), this.inlineClassName, this.inlineClassNameAffectsLetterSpacing ? 3\n    /* RegularAffectingLetterSpacing */\n    : 0\n    /* Regular */\n    );\n  }\n\n}\nexport class ViewModelDecoration {\n  constructor(range, options) {\n    this._viewModelDecorationBrand = undefined;\n    this.range = range;\n    this.options = options;\n  }\n\n}\nexport class OverviewRulerDecorationsGroup {\n  constructor(color, zIndex,\n  /**\n   * Decorations are encoded in a number array using the following scheme:\n   *  - 3*i = lane\n   *  - 3*i+1 = startLineNumber\n   *  - 3*i+2 = endLineNumber\n   */\n  data) {\n    this.color = color;\n    this.zIndex = zIndex;\n    this.data = data;\n  }\n\n  static cmp(a, b) {\n    if (a.zIndex === b.zIndex) {\n      if (a.color < b.color) {\n        return -1;\n      }\n\n      if (a.color > b.color) {\n        return 1;\n      }\n\n      return 0;\n    }\n\n    return a.zIndex - b.zIndex;\n  }\n\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModel.js"],"names":["strings","Position","Range","Viewport","constructor","top","left","width","height","_viewportBrand","undefined","OutputPosition","outputLineIndex","outputOffset","toString","toPosition","baseLineNumber","wrappedTextIndentLength","delta","LineBreakData","breakOffsets","breakOffsetsVisibleColumn","injectionOffsets","injectionOptions","getInputOffsetOfOutputPosition","inputOffset","i","length","content","getOutputPositionOfInputOffset","affinity","getOutputPositionOfOffsetInUnwrappedLine","low","high","mid","midStart","midStop","outputPositionToOffsetInUnwrappedLine","result","normalizeOffsetAroundInjections","offsetInUnwrappedLine","injectedText","getInjectedTextAtOffset","index","injectedTextIndex","getInjectedText","offset","options","totalInjectedTextLengthBefore","injectedTextStartOffsetInUnwrappedLine","injectedTextEndOffsetInUnwrappedLine","InjectedText","MinimapLinesRenderingData","tabSize","data","ViewLineData","continuesWithWrappedLine","minColumn","maxColumn","startVisibleColumn","tokens","inlineDecorations","_viewLineDataBrand","ViewLineRenderingData","mightContainRTL","mightContainNonBasicASCII","isBasicASCII","containsRTL","lineContent","InlineDecoration","range","inlineClassName","type","SingleLineInlineDecoration","startOffset","endOffset","inlineClassNameAffectsLetterSpacing","toInlineDecoration","lineNumber","ViewModelDecoration","_viewModelDecorationBrand","OverviewRulerDecorationsGroup","color","zIndex","cmp","a","b"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class Viewport {\n    constructor(top, left, width, height) {\n        this._viewportBrand = undefined;\n        this.top = top | 0;\n        this.left = left | 0;\n        this.width = width | 0;\n        this.height = height | 0;\n    }\n}\nexport class OutputPosition {\n    constructor(outputLineIndex, outputOffset) {\n        this.outputLineIndex = outputLineIndex;\n        this.outputOffset = outputOffset;\n    }\n    toString() {\n        return `${this.outputLineIndex}:${this.outputOffset}`;\n    }\n    toPosition(baseLineNumber, wrappedTextIndentLength) {\n        const delta = (this.outputLineIndex > 0 ? wrappedTextIndentLength : 0);\n        return new Position(baseLineNumber + this.outputLineIndex, delta + this.outputOffset + 1);\n    }\n}\nexport class LineBreakData {\n    constructor(breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength, injectionOffsets, injectionOptions) {\n        this.breakOffsets = breakOffsets;\n        this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;\n        this.wrappedTextIndentLength = wrappedTextIndentLength;\n        this.injectionOffsets = injectionOffsets;\n        this.injectionOptions = injectionOptions;\n    }\n    getInputOffsetOfOutputPosition(outputLineIndex, outputOffset) {\n        let inputOffset = 0;\n        if (outputLineIndex === 0) {\n            inputOffset = outputOffset;\n        }\n        else {\n            inputOffset = this.breakOffsets[outputLineIndex - 1] + outputOffset;\n        }\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (inputOffset > this.injectionOffsets[i]) {\n                    if (inputOffset < this.injectionOffsets[i] + this.injectionOptions[i].content.length) {\n                        // `inputOffset` is within injected text\n                        inputOffset = this.injectionOffsets[i];\n                    }\n                    else {\n                        inputOffset -= this.injectionOptions[i].content.length;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return inputOffset;\n    }\n    getOutputPositionOfInputOffset(inputOffset, affinity = 2 /* None */) {\n        let delta = 0;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (inputOffset < this.injectionOffsets[i]) {\n                    break;\n                }\n                if (affinity !== 1 /* Right */ && inputOffset === this.injectionOffsets[i]) {\n                    break;\n                }\n                delta += this.injectionOptions[i].content.length;\n            }\n        }\n        inputOffset += delta;\n        return this.getOutputPositionOfOffsetInUnwrappedLine(inputOffset, affinity);\n    }\n    getOutputPositionOfOffsetInUnwrappedLine(inputOffset, affinity = 2 /* None */) {\n        let low = 0;\n        let high = this.breakOffsets.length - 1;\n        let mid = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            const midStop = this.breakOffsets[mid];\n            midStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n            if (affinity === 0 /* Left */) {\n                if (inputOffset <= midStart) {\n                    high = mid - 1;\n                }\n                else if (inputOffset > midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                if (inputOffset < midStart) {\n                    high = mid - 1;\n                }\n                else if (inputOffset >= midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return new OutputPosition(mid, inputOffset - midStart);\n    }\n    outputPositionToOffsetInUnwrappedLine(outputLineIndex, outputOffset) {\n        let result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n        if (outputLineIndex > 0) {\n            result -= this.wrappedTextIndentLength;\n        }\n        return result;\n    }\n    normalizeOffsetAroundInjections(offsetInUnwrappedLine, affinity) {\n        const injectedText = this.getInjectedTextAtOffset(offsetInUnwrappedLine);\n        if (!injectedText) {\n            return offsetInUnwrappedLine;\n        }\n        if (affinity === 2 /* None */) {\n            if (offsetInUnwrappedLine === injectedText.offsetInUnwrappedLine + injectedText.length) {\n                // go to the end of this injected text\n                return injectedText.offsetInUnwrappedLine + injectedText.length;\n            }\n            else {\n                // go to the start of this injected text\n                return injectedText.offsetInUnwrappedLine;\n            }\n        }\n        if (affinity === 1 /* Right */) {\n            let result = injectedText.offsetInUnwrappedLine + injectedText.length;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch eachother\n            while (index + 1 < this.injectionOffsets.length && this.injectionOffsets[index + 1] === this.injectionOffsets[index]) {\n                result += this.injectionOptions[index + 1].content.length;\n                index++;\n            }\n            return result;\n        }\n        // affinity is left\n        let result = injectedText.offsetInUnwrappedLine;\n        let index = injectedText.injectedTextIndex;\n        // traverse all injected text that touch eachother\n        while (index - 1 >= 0 && this.injectionOffsets[index - 1] === this.injectionOffsets[index]) {\n            result -= this.injectionOptions[index - 1].content.length;\n            index++;\n        }\n        return result;\n    }\n    getInjectedText(outputLineIndex, outputOffset) {\n        const offset = this.outputPositionToOffsetInUnwrappedLine(outputLineIndex, outputOffset);\n        const injectedText = this.getInjectedTextAtOffset(offset);\n        if (!injectedText) {\n            return null;\n        }\n        return {\n            options: this.injectionOptions[injectedText.injectedTextIndex]\n        };\n    }\n    getInjectedTextAtOffset(offsetInUnwrappedLine) {\n        const injectionOffsets = this.injectionOffsets;\n        const injectionOptions = this.injectionOptions;\n        if (injectionOffsets !== null) {\n            let totalInjectedTextLengthBefore = 0;\n            for (let i = 0; i < injectionOffsets.length; i++) {\n                const length = injectionOptions[i].content.length;\n                const injectedTextStartOffsetInUnwrappedLine = injectionOffsets[i] + totalInjectedTextLengthBefore;\n                const injectedTextEndOffsetInUnwrappedLine = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n                if (injectedTextStartOffsetInUnwrappedLine > offsetInUnwrappedLine) {\n                    // Injected text starts later.\n                    break; // All later injected texts have an even larger offset.\n                }\n                if (offsetInUnwrappedLine <= injectedTextEndOffsetInUnwrappedLine) {\n                    // Injected text ends after or with the given position (but also starts with or before it).\n                    return {\n                        injectedTextIndex: i,\n                        offsetInUnwrappedLine: injectedTextStartOffsetInUnwrappedLine,\n                        length\n                    };\n                }\n                totalInjectedTextLengthBefore += length;\n            }\n        }\n        return undefined;\n    }\n}\nexport class InjectedText {\n    constructor(options) {\n        this.options = options;\n    }\n}\nexport class MinimapLinesRenderingData {\n    constructor(tabSize, data) {\n        this.tabSize = tabSize;\n        this.data = data;\n    }\n}\nexport class ViewLineData {\n    constructor(content, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations) {\n        this._viewLineDataBrand = undefined;\n        this.content = content;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.minColumn = minColumn;\n        this.maxColumn = maxColumn;\n        this.startVisibleColumn = startVisibleColumn;\n        this.tokens = tokens;\n        this.inlineDecorations = inlineDecorations;\n    }\n}\nexport class ViewLineRenderingData {\n    constructor(minColumn, maxColumn, content, continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, tokens, inlineDecorations, tabSize, startVisibleColumn) {\n        this.minColumn = minColumn;\n        this.maxColumn = maxColumn;\n        this.content = content;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = ViewLineRenderingData.isBasicASCII(content, mightContainNonBasicASCII);\n        this.containsRTL = ViewLineRenderingData.containsRTL(content, this.isBasicASCII, mightContainRTL);\n        this.tokens = tokens;\n        this.inlineDecorations = inlineDecorations;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n    }\n    static isBasicASCII(lineContent, mightContainNonBasicASCII) {\n        if (mightContainNonBasicASCII) {\n            return strings.isBasicASCII(lineContent);\n        }\n        return true;\n    }\n    static containsRTL(lineContent, isBasicASCII, mightContainRTL) {\n        if (!isBasicASCII && mightContainRTL) {\n            return strings.containsRTL(lineContent);\n        }\n        return false;\n    }\n}\nexport class InlineDecoration {\n    constructor(range, inlineClassName, type) {\n        this.range = range;\n        this.inlineClassName = inlineClassName;\n        this.type = type;\n    }\n}\nexport class SingleLineInlineDecoration {\n    constructor(startOffset, endOffset, inlineClassName, inlineClassNameAffectsLetterSpacing) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.inlineClassName = inlineClassName;\n        this.inlineClassNameAffectsLetterSpacing = inlineClassNameAffectsLetterSpacing;\n    }\n    toInlineDecoration(lineNumber) {\n        return new InlineDecoration(new Range(lineNumber, this.startOffset + 1, lineNumber, this.endOffset + 1), this.inlineClassName, this.inlineClassNameAffectsLetterSpacing ? 3 /* RegularAffectingLetterSpacing */ : 0 /* Regular */);\n    }\n}\nexport class ViewModelDecoration {\n    constructor(range, options) {\n        this._viewModelDecorationBrand = undefined;\n        this.range = range;\n        this.options = options;\n    }\n}\nexport class OverviewRulerDecorationsGroup {\n    constructor(color, zIndex, \n    /**\n     * Decorations are encoded in a number array using the following scheme:\n     *  - 3*i = lane\n     *  - 3*i+1 = startLineNumber\n     *  - 3*i+2 = endLineNumber\n     */\n    data) {\n        this.color = color;\n        this.zIndex = zIndex;\n        this.data = data;\n    }\n    static cmp(a, b) {\n        if (a.zIndex === b.zIndex) {\n            if (a.color < b.color) {\n                return -1;\n            }\n            if (a.color > b.color) {\n                return 1;\n            }\n            return 0;\n        }\n        return a.zIndex - b.zIndex;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}