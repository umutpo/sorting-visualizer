{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorColumns, CursorContext, CursorState, EditOperationResult } from './cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../model/textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../view/viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModel/viewModelEventDispatcher.js';\n/**\n * A snapshot of the cursor and the model state\n */\n\nexport class CursorModelState {\n  constructor(model, cursor) {\n    this.modelVersionId = model.getVersionId();\n    this.cursorState = cursor.getCursorStates();\n  }\n\n  equals(other) {\n    if (!other) {\n      return false;\n    }\n\n    if (this.modelVersionId !== other.modelVersionId) {\n      return false;\n    }\n\n    if (this.cursorState.length !== other.cursorState.length) {\n      return false;\n    }\n\n    for (let i = 0, len = this.cursorState.length; i < len; i++) {\n      if (!this.cursorState[i].equals(other.cursorState[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nclass AutoClosedAction {\n  constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n    this._model = model;\n    this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n    this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n  }\n\n  static getAllAutoClosedCharacters(autoClosedActions) {\n    let autoClosedCharacters = [];\n\n    for (const autoClosedAction of autoClosedActions) {\n      autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n    }\n\n    return autoClosedCharacters;\n  }\n\n  dispose() {\n    this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n    this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n  }\n\n  getAutoClosedCharactersRanges() {\n    let result = [];\n\n    for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n      const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n\n      if (decorationRange) {\n        result.push(decorationRange);\n      }\n    }\n\n    return result;\n  }\n\n  isValid(selections) {\n    let enclosingRanges = [];\n\n    for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n      const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n\n      if (decorationRange) {\n        enclosingRanges.push(decorationRange);\n\n        if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n          // Stop tracking if the range becomes multiline...\n          return false;\n        }\n      }\n    }\n\n    enclosingRanges.sort(Range.compareRangesUsingStarts);\n    selections.sort(Range.compareRangesUsingStarts);\n\n    for (let i = 0; i < selections.length; i++) {\n      if (i >= enclosingRanges.length) {\n        return false;\n      }\n\n      if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nexport class CursorsController extends Disposable {\n  constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n    super();\n    this._model = model;\n    this._knownModelVersionId = this._model.getVersionId();\n    this._viewModel = viewModel;\n    this._coordinatesConverter = coordinatesConverter;\n    this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n    this._cursors = new CursorCollection(this.context);\n    this._hasFocus = false;\n    this._isHandling = false;\n    this._isDoingComposition = false;\n    this._selectionsWhenCompositionStarted = null;\n    this._columnSelectData = null;\n    this._autoClosedActions = [];\n    this._prevEditOperationType = 0\n    /* Other */\n    ;\n  }\n\n  dispose() {\n    this._cursors.dispose();\n\n    this._autoClosedActions = dispose(this._autoClosedActions);\n    super.dispose();\n  }\n\n  updateConfiguration(cursorConfig) {\n    this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n\n    this._cursors.updateContext(this.context);\n  }\n\n  onLineMappingChanged(eventsCollector) {\n    if (this._knownModelVersionId !== this._model.getVersionId()) {\n      // There are model change events that I didn't yet receive.\n      //\n      // This can happen when editing the model, and the view model receives the change events first,\n      // and the view model emits line mapping changed events, all before the cursor gets a chance to\n      // recover from markers.\n      //\n      // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n      return;\n    } // Ensure valid state\n\n\n    this.setStates(eventsCollector, 'viewModel', 0\n    /* NotSet */\n    , this.getCursorStates());\n  }\n\n  setHasFocus(hasFocus) {\n    this._hasFocus = hasFocus;\n  }\n\n  _validateAutoClosedActions() {\n    if (this._autoClosedActions.length > 0) {\n      let selections = this._cursors.getSelections();\n\n      for (let i = 0; i < this._autoClosedActions.length; i++) {\n        const autoClosedAction = this._autoClosedActions[i];\n\n        if (!autoClosedAction.isValid(selections)) {\n          autoClosedAction.dispose();\n\n          this._autoClosedActions.splice(i, 1);\n\n          i--;\n        }\n      }\n    }\n  } // ------ some getters/setters\n\n\n  getPrimaryCursorState() {\n    return this._cursors.getPrimaryCursor();\n  }\n\n  getLastAddedCursorIndex() {\n    return this._cursors.getLastAddedCursorIndex();\n  }\n\n  getCursorStates() {\n    return this._cursors.getAll();\n  }\n\n  setStates(eventsCollector, source, reason, states) {\n    let reachedMaxCursorCount = false;\n\n    if (states !== null && states.length > CursorsController.MAX_CURSOR_COUNT) {\n      states = states.slice(0, CursorsController.MAX_CURSOR_COUNT);\n      reachedMaxCursorCount = true;\n    }\n\n    const oldState = new CursorModelState(this._model, this);\n\n    this._cursors.setStates(states);\n\n    this._cursors.normalize();\n\n    this._columnSelectData = null;\n\n    this._validateAutoClosedActions();\n\n    return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n  }\n\n  setCursorColumnSelectData(columnSelectData) {\n    this._columnSelectData = columnSelectData;\n  }\n\n  revealPrimary(eventsCollector, source, revealHorizontal, scrollType) {\n    const viewPositions = this._cursors.getViewPositions();\n\n    if (viewPositions.length > 1) {\n      this._emitCursorRevealRange(eventsCollector, source, null, this._cursors.getViewSelections(), 0\n      /* Simple */\n      , revealHorizontal, scrollType);\n\n      return;\n    } else {\n      const viewPosition = viewPositions[0];\n      const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n\n      this._emitCursorRevealRange(eventsCollector, source, viewRange, null, 0\n      /* Simple */\n      , revealHorizontal, scrollType);\n    }\n  }\n\n  _revealPrimaryCursor(eventsCollector, source, verticalType, revealHorizontal, scrollType) {\n    const viewPositions = this._cursors.getViewPositions();\n\n    if (viewPositions.length > 1) {\n      this._emitCursorRevealRange(eventsCollector, source, null, this._cursors.getViewSelections(), verticalType, revealHorizontal, scrollType);\n    } else {\n      const viewPosition = viewPositions[0];\n      const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n\n      this._emitCursorRevealRange(eventsCollector, source, viewRange, null, verticalType, revealHorizontal, scrollType);\n    }\n  }\n\n  _emitCursorRevealRange(eventsCollector, source, viewRange, viewSelections, verticalType, revealHorizontal, scrollType) {\n    eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, viewRange, viewSelections, verticalType, revealHorizontal, scrollType));\n  }\n\n  saveState() {\n    let result = [];\n\n    const selections = this._cursors.getSelections();\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      result.push({\n        inSelectionMode: !selection.isEmpty(),\n        selectionStart: {\n          lineNumber: selection.selectionStartLineNumber,\n          column: selection.selectionStartColumn\n        },\n        position: {\n          lineNumber: selection.positionLineNumber,\n          column: selection.positionColumn\n        }\n      });\n    }\n\n    return result;\n  }\n\n  restoreState(eventsCollector, states) {\n    let desiredSelections = [];\n\n    for (let i = 0, len = states.length; i < len; i++) {\n      const state = states[i];\n      let positionLineNumber = 1;\n      let positionColumn = 1; // Avoid missing properties on the literal\n\n      if (state.position && state.position.lineNumber) {\n        positionLineNumber = state.position.lineNumber;\n      }\n\n      if (state.position && state.position.column) {\n        positionColumn = state.position.column;\n      }\n\n      let selectionStartLineNumber = positionLineNumber;\n      let selectionStartColumn = positionColumn; // Avoid missing properties on the literal\n\n      if (state.selectionStart && state.selectionStart.lineNumber) {\n        selectionStartLineNumber = state.selectionStart.lineNumber;\n      }\n\n      if (state.selectionStart && state.selectionStart.column) {\n        selectionStartColumn = state.selectionStart.column;\n      }\n\n      desiredSelections.push({\n        selectionStartLineNumber: selectionStartLineNumber,\n        selectionStartColumn: selectionStartColumn,\n        positionLineNumber: positionLineNumber,\n        positionColumn: positionColumn\n      });\n    }\n\n    this.setStates(eventsCollector, 'restoreState', 0\n    /* NotSet */\n    , CursorState.fromModelSelections(desiredSelections));\n    this.revealPrimary(eventsCollector, 'restoreState', true, 1\n    /* Immediate */\n    );\n  }\n\n  onModelContentChanged(eventsCollector, e) {\n    if (e instanceof ModelInjectedTextChangedEvent) {\n      // If injected texts change, the view positions of all cursors need to be updated.\n      if (this._isHandling) {\n        // The view positions will be updated when handling finishes\n        return;\n      } // setStates might remove markers, which could trigger a decoration change.\n      // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n      // and an endless recursion happens.\n      // _isHandling prevents that.\n\n\n      this._isHandling = true;\n\n      try {\n        this.setStates(eventsCollector, 'modelChange', 0\n        /* NotSet */\n        , this.getCursorStates());\n      } finally {\n        this._isHandling = false;\n      }\n    } else {\n      this._knownModelVersionId = e.versionId;\n\n      if (this._isHandling) {\n        return;\n      }\n\n      const hadFlushEvent = e.containsEvent(1\n      /* Flush */\n      );\n      this._prevEditOperationType = 0\n      /* Other */\n      ;\n\n      if (hadFlushEvent) {\n        // a model.setValue() was called\n        this._cursors.dispose();\n\n        this._cursors = new CursorCollection(this.context);\n\n        this._validateAutoClosedActions();\n\n        this._emitStateChangedIfNecessary(eventsCollector, 'model', 1\n        /* ContentFlush */\n        , null, false);\n      } else {\n        if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n          const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n\n          if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5\n          /* Undo */\n          : e.isRedoing ? 6\n          /* Redo */\n          : 2\n          /* RecoverFromMarkers */\n          , cursorState)) {\n            this._revealPrimaryCursor(eventsCollector, 'modelChange', 0\n            /* Simple */\n            , true, 0\n            /* Smooth */\n            );\n          }\n        } else {\n          const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n\n          this.setStates(eventsCollector, 'modelChange', 2\n          /* RecoverFromMarkers */\n          , CursorState.fromModelSelections(selectionsFromMarkers));\n        }\n      }\n    }\n  }\n\n  getSelection() {\n    return this._cursors.getPrimaryCursor().modelState.selection;\n  }\n\n  getTopMostViewPosition() {\n    return this._cursors.getTopMostViewPosition();\n  }\n\n  getBottomMostViewPosition() {\n    return this._cursors.getBottomMostViewPosition();\n  }\n\n  getCursorColumnSelectData() {\n    if (this._columnSelectData) {\n      return this._columnSelectData;\n    }\n\n    const primaryCursor = this._cursors.getPrimaryCursor();\n\n    const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n    const viewPosition = primaryCursor.viewState.position;\n    return {\n      isReal: false,\n      fromViewLineNumber: viewSelectionStart.lineNumber,\n      fromViewVisualColumn: CursorColumns.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, viewSelectionStart),\n      toViewLineNumber: viewPosition.lineNumber,\n      toViewVisualColumn: CursorColumns.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, viewPosition)\n    };\n  }\n\n  getSelections() {\n    return this._cursors.getSelections();\n  }\n\n  setSelections(eventsCollector, source, selections, reason) {\n    this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n  }\n\n  getPrevEditOperationType() {\n    return this._prevEditOperationType;\n  }\n\n  setPrevEditOperationType(type) {\n    this._prevEditOperationType = type;\n  } // ------ auxiliary handling logic\n\n\n  _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n    let autoClosedCharactersDeltaDecorations = [];\n    let autoClosedEnclosingDeltaDecorations = [];\n\n    for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n      autoClosedCharactersDeltaDecorations.push({\n        range: autoClosedCharactersRanges[i],\n        options: {\n          description: 'auto-closed-character',\n          inlineClassName: 'auto-closed-character',\n          stickiness: 1\n          /* NeverGrowsWhenTypingAtEdges */\n\n        }\n      });\n      autoClosedEnclosingDeltaDecorations.push({\n        range: autoClosedEnclosingRanges[i],\n        options: {\n          description: 'auto-closed-enclosing',\n          stickiness: 1\n          /* NeverGrowsWhenTypingAtEdges */\n\n        }\n      });\n    }\n\n    const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n\n    const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n\n    this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n  }\n\n  _executeEditOperation(opResult) {\n    if (!opResult) {\n      // Nothing to execute\n      return;\n    }\n\n    if (opResult.shouldPushStackElementBefore) {\n      this._model.pushStackElement();\n    }\n\n    const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n\n    if (result) {\n      // The commands were applied correctly\n      this._interpretCommandResult(result); // Check for auto-closing closed characters\n\n\n      let autoClosedCharactersRanges = [];\n      let autoClosedEnclosingRanges = [];\n\n      for (let i = 0; i < opResult.commands.length; i++) {\n        const command = opResult.commands[i];\n\n        if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n          autoClosedCharactersRanges.push(command.closeCharacterRange);\n          autoClosedEnclosingRanges.push(command.enclosingRange);\n        }\n      }\n\n      if (autoClosedCharactersRanges.length > 0) {\n        this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n      }\n\n      this._prevEditOperationType = opResult.type;\n    }\n\n    if (opResult.shouldPushStackElementAfter) {\n      this._model.pushStackElement();\n    }\n  }\n\n  _interpretCommandResult(cursorState) {\n    if (!cursorState || cursorState.length === 0) {\n      cursorState = this._cursors.readSelectionFromMarkers();\n    }\n\n    this._columnSelectData = null;\n\n    this._cursors.setSelections(cursorState);\n\n    this._cursors.normalize();\n  } // -----------------------------------------------------------------------------------------------------------\n  // ----- emitting events\n\n\n  _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n    const newState = new CursorModelState(this._model, this);\n\n    if (newState.equals(oldState)) {\n      return false;\n    }\n\n    const selections = this._cursors.getSelections();\n\n    const viewSelections = this._cursors.getViewSelections(); // Let the view get the event first.\n\n\n    eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections)); // Only after the view has been notified, let the rest of the world know...\n\n    if (!oldState || oldState.cursorState.length !== newState.cursorState.length || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n      const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n      const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n      eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n    }\n\n    return true;\n  } // -----------------------------------------------------------------------------------------------------------\n  // ----- handlers beyond this point\n\n\n  _findAutoClosingPairs(edits) {\n    if (!edits.length) {\n      return null;\n    }\n\n    let indices = [];\n\n    for (let i = 0, len = edits.length; i < len; i++) {\n      const edit = edits[i];\n\n      if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n        return null;\n      }\n\n      const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n\n      if (!m) {\n        return null;\n      }\n\n      const closeChar = m[1];\n      const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n\n      if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n        return null;\n      }\n\n      const openChar = autoClosingPairsCandidates[0].open;\n      const closeCharIndex = edit.text.length - m[2].length - 1;\n      const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n\n      if (openCharIndex === -1) {\n        return null;\n      }\n\n      indices.push([openCharIndex, closeCharIndex]);\n    }\n\n    return indices;\n  }\n\n  executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n    let autoClosingIndices = null;\n\n    if (source === 'snippet') {\n      autoClosingIndices = this._findAutoClosingPairs(edits);\n    }\n\n    if (autoClosingIndices) {\n      edits[0]._isTracked = true;\n    }\n\n    let autoClosedCharactersRanges = [];\n    let autoClosedEnclosingRanges = [];\n\n    const selections = this._model.pushEditOperations(this.getSelections(), edits, undoEdits => {\n      if (autoClosingIndices) {\n        for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n          const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n          const undoEdit = undoEdits[i];\n          const lineNumber = undoEdit.range.startLineNumber;\n          const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n          const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n          autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n          autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n        }\n      }\n\n      const selections = cursorStateComputer(undoEdits);\n\n      if (selections) {\n        // Don't recover the selection from markers because\n        // we know what it should be.\n        this._isHandling = true;\n      }\n\n      return selections;\n    });\n\n    if (selections) {\n      this._isHandling = false;\n      this.setSelections(eventsCollector, source, selections, 0\n      /* NotSet */\n      );\n    }\n\n    if (autoClosedCharactersRanges.length > 0) {\n      this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n    }\n  }\n\n  _executeEdit(callback, eventsCollector, source) {\n    let cursorChangeReason = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n    if (this.context.cursorConfig.readOnly) {\n      // we cannot edit when read only...\n      return;\n    }\n\n    const oldState = new CursorModelState(this._model, this);\n\n    this._cursors.stopTrackingSelections();\n\n    this._isHandling = true;\n\n    try {\n      this._cursors.ensureValidState();\n\n      callback();\n    } catch (err) {\n      onUnexpectedError(err);\n    }\n\n    this._isHandling = false;\n\n    this._cursors.startTrackingSelections();\n\n    this._validateAutoClosedActions();\n\n    if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n      this._revealPrimaryCursor(eventsCollector, source, 0\n      /* Simple */\n      , true, 0\n      /* Smooth */\n      );\n    }\n  }\n\n  setIsDoingComposition(isDoingComposition) {\n    this._isDoingComposition = isDoingComposition;\n  }\n\n  getAutoClosedCharacters() {\n    return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n  }\n\n  startComposition(eventsCollector) {\n    this._selectionsWhenCompositionStarted = this.getSelections().slice(0);\n  }\n\n  endComposition(eventsCollector, source) {\n    this._executeEdit(() => {\n      if (source === 'keyboard') {\n        // composition finishes, let's check if we need to auto complete if necessary.\n        this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this._selectionsWhenCompositionStarted, this.getSelections(), this.getAutoClosedCharacters()));\n\n        this._selectionsWhenCompositionStarted = null;\n      }\n    }, eventsCollector, source);\n  }\n\n  type(eventsCollector, text, source) {\n    this._executeEdit(() => {\n      if (source === 'keyboard') {\n        // If this event is coming straight from the keyboard, look for electric characters and enter\n        const len = text.length;\n        let offset = 0;\n\n        while (offset < len) {\n          const charLength = strings.nextCharLength(text, offset);\n          const chr = text.substr(offset, charLength); // Here we must interpret each typed character individually\n\n          this._executeEditOperation(TypeOperations.typeWithInterceptors(this._isDoingComposition, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n\n          offset += charLength;\n        }\n      } else {\n        this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n      }\n    }, eventsCollector, source);\n  }\n\n  compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n    if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n      // this edit is a no-op\n      if (positionDelta !== 0) {\n        // but it still wants to move the cursor\n        const newSelections = this.getSelections().map(selection => {\n          const position = selection.getPosition();\n          return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n        });\n        this.setSelections(eventsCollector, source, newSelections, 0\n        /* NotSet */\n        );\n      }\n\n      return;\n    }\n\n    this._executeEdit(() => {\n      this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n    }, eventsCollector, source);\n  }\n\n  paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n    this._executeEdit(() => {\n      this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n    }, eventsCollector, source, 4\n    /* Paste */\n    );\n  }\n\n  cut(eventsCollector, source) {\n    this._executeEdit(() => {\n      this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n    }, eventsCollector, source);\n  }\n\n  executeCommand(eventsCollector, command, source) {\n    this._executeEdit(() => {\n      this._cursors.killSecondaryCursors();\n\n      this._executeEditOperation(new EditOperationResult(0\n      /* Other */\n      , [command], {\n        shouldPushStackElementBefore: false,\n        shouldPushStackElementAfter: false\n      }));\n    }, eventsCollector, source);\n  }\n\n  executeCommands(eventsCollector, commands, source) {\n    this._executeEdit(() => {\n      this._executeEditOperation(new EditOperationResult(0\n      /* Other */\n      , commands, {\n        shouldPushStackElementBefore: false,\n        shouldPushStackElementAfter: false\n      }));\n    }, eventsCollector, source);\n  }\n\n}\nCursorsController.MAX_CURSOR_COUNT = 10000;\n\nclass CommandExecutor {\n  static executeCommands(model, selectionsBefore, commands) {\n    const ctx = {\n      model: model,\n      selectionsBefore: selectionsBefore,\n      trackedRanges: [],\n      trackedRangesDirection: []\n    };\n\n    const result = this._innerExecuteCommands(ctx, commands);\n\n    for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n      ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0\n      /* AlwaysGrowsWhenTypingAtEdges */\n      );\n    }\n\n    return result;\n  }\n\n  static _innerExecuteCommands(ctx, commands) {\n    if (this._arrayIsEmpty(commands)) {\n      return null;\n    }\n\n    const commandsData = this._getEditOperations(ctx, commands);\n\n    if (commandsData.operations.length === 0) {\n      return null;\n    }\n\n    const rawOperations = commandsData.operations;\n\n    const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n\n    if (loserCursorsMap.hasOwnProperty('0')) {\n      // These commands are very messed up\n      console.warn('Ignoring commands');\n      return null;\n    } // Remove operations belonging to losing cursors\n\n\n    let filteredOperations = [];\n\n    for (let i = 0, len = rawOperations.length; i < len; i++) {\n      if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n        filteredOperations.push(rawOperations[i]);\n      }\n    } // TODO@Alex: find a better way to do this.\n    // give the hint that edit operations are tracked to the model\n\n\n    if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n      filteredOperations[0]._isTracked = true;\n    }\n\n    let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, inverseEditOperations => {\n      let groupedInverseEditOperations = [];\n\n      for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n        groupedInverseEditOperations[i] = [];\n      }\n\n      for (const op of inverseEditOperations) {\n        if (!op.identifier) {\n          // perhaps auto whitespace trim edits\n          continue;\n        }\n\n        groupedInverseEditOperations[op.identifier.major].push(op);\n      }\n\n      const minorBasedSorter = (a, b) => {\n        return a.identifier.minor - b.identifier.minor;\n      };\n\n      let cursorSelections = [];\n\n      for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n        if (groupedInverseEditOperations[i].length > 0) {\n          groupedInverseEditOperations[i].sort(minorBasedSorter);\n          cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n            getInverseEditOperations: () => {\n              return groupedInverseEditOperations[i];\n            },\n            getTrackedSelection: id => {\n              const idx = parseInt(id, 10);\n\n              const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n\n              if (ctx.trackedRangesDirection[idx] === 0\n              /* LTR */\n              ) {\n                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n              }\n\n              return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n            }\n          });\n        } else {\n          cursorSelections[i] = ctx.selectionsBefore[i];\n        }\n      }\n\n      return cursorSelections;\n    });\n\n    if (!selectionsAfter) {\n      selectionsAfter = ctx.selectionsBefore;\n    } // Extract losing cursors\n\n\n    let losingCursors = [];\n\n    for (let losingCursorIndex in loserCursorsMap) {\n      if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n        losingCursors.push(parseInt(losingCursorIndex, 10));\n      }\n    } // Sort losing cursors descending\n\n\n    losingCursors.sort((a, b) => {\n      return b - a;\n    }); // Remove losing cursors\n\n    for (const losingCursor of losingCursors) {\n      selectionsAfter.splice(losingCursor, 1);\n    }\n\n    return selectionsAfter;\n  }\n\n  static _arrayIsEmpty(commands) {\n    for (let i = 0, len = commands.length; i < len; i++) {\n      if (commands[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  static _getEditOperations(ctx, commands) {\n    let operations = [];\n    let hadTrackedEditOperation = false;\n\n    for (let i = 0, len = commands.length; i < len; i++) {\n      const command = commands[i];\n\n      if (command) {\n        const r = this._getEditOperationsFromCommand(ctx, i, command);\n\n        operations = operations.concat(r.operations);\n        hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n      }\n    }\n\n    return {\n      operations: operations,\n      hadTrackedEditOperation: hadTrackedEditOperation\n    };\n  }\n\n  static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n    // This method acts as a transaction, if the command fails\n    // everything it has done is ignored\n    let operations = [];\n    let operationMinor = 0;\n\n    const addEditOperation = function (range, text) {\n      let forceMoveMarkers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (Range.isEmpty(range) && text === '') {\n        // This command wants to add a no-op => no thank you\n        return;\n      }\n\n      operations.push({\n        identifier: {\n          major: majorIdentifier,\n          minor: operationMinor++\n        },\n        range: range,\n        text: text,\n        forceMoveMarkers: forceMoveMarkers,\n        isAutoWhitespaceEdit: command.insertsAutoWhitespace\n      });\n    };\n\n    let hadTrackedEditOperation = false;\n\n    const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n      hadTrackedEditOperation = true;\n      addEditOperation(selection, text, forceMoveMarkers);\n    };\n\n    const trackSelection = (_selection, trackPreviousOnEmpty) => {\n      const selection = Selection.liftSelection(_selection);\n      let stickiness;\n\n      if (selection.isEmpty()) {\n        if (typeof trackPreviousOnEmpty === 'boolean') {\n          if (trackPreviousOnEmpty) {\n            stickiness = 2\n            /* GrowsOnlyWhenTypingBefore */\n            ;\n          } else {\n            stickiness = 3\n            /* GrowsOnlyWhenTypingAfter */\n            ;\n          }\n        } else {\n          // Try to lock it with surrounding text\n          const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n\n          if (selection.startColumn === maxLineColumn) {\n            stickiness = 2\n            /* GrowsOnlyWhenTypingBefore */\n            ;\n          } else {\n            stickiness = 3\n            /* GrowsOnlyWhenTypingAfter */\n            ;\n          }\n        }\n      } else {\n        stickiness = 1\n        /* NeverGrowsWhenTypingAtEdges */\n        ;\n      }\n\n      const l = ctx.trackedRanges.length;\n\n      const id = ctx.model._setTrackedRange(null, selection, stickiness);\n\n      ctx.trackedRanges[l] = id;\n      ctx.trackedRangesDirection[l] = selection.getDirection();\n      return l.toString();\n    };\n\n    const editOperationBuilder = {\n      addEditOperation: addEditOperation,\n      addTrackedEditOperation: addTrackedEditOperation,\n      trackSelection: trackSelection\n    };\n\n    try {\n      command.getEditOperations(ctx.model, editOperationBuilder);\n    } catch (e) {\n      // TODO@Alex use notification service if this should be user facing\n      // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n      onUnexpectedError(e);\n      return {\n        operations: [],\n        hadTrackedEditOperation: false\n      };\n    }\n\n    return {\n      operations: operations,\n      hadTrackedEditOperation: hadTrackedEditOperation\n    };\n  }\n\n  static _getLoserCursorMap(operations) {\n    // This is destructive on the array\n    operations = operations.slice(0); // Sort operations with last one first\n\n    operations.sort((a, b) => {\n      // Note the minus!\n      return -Range.compareRangesUsingEnds(a.range, b.range);\n    }); // Operations can not overlap!\n\n    let loserCursorsMap = {};\n\n    for (let i = 1; i < operations.length; i++) {\n      const previousOp = operations[i - 1];\n      const currentOp = operations[i];\n\n      if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n        let loserMajor;\n\n        if (previousOp.identifier.major > currentOp.identifier.major) {\n          // previousOp loses the battle\n          loserMajor = previousOp.identifier.major;\n        } else {\n          loserMajor = currentOp.identifier.major;\n        }\n\n        loserCursorsMap[loserMajor.toString()] = true;\n\n        for (let j = 0; j < operations.length; j++) {\n          if (operations[j].identifier.major === loserMajor) {\n            operations.splice(j, 1);\n\n            if (j < i) {\n              i--;\n            }\n\n            j--;\n          }\n        }\n\n        if (i > 0) {\n          i--;\n        }\n      }\n    }\n\n    return loserCursorsMap;\n  }\n\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/common/controller/cursor.js"],"names":["onUnexpectedError","strings","CursorCollection","CursorColumns","CursorContext","CursorState","EditOperationResult","DeleteOperations","TypeOperations","TypeWithAutoClosingCommand","Range","Selection","ModelInjectedTextChangedEvent","ViewCursorStateChangedEvent","ViewRevealRangeRequestEvent","dispose","Disposable","CursorStateChangedEvent","CursorModelState","constructor","model","cursor","modelVersionId","getVersionId","cursorState","getCursorStates","equals","other","length","i","len","AutoClosedAction","autoClosedCharactersDecorations","autoClosedEnclosingDecorations","_model","_autoClosedCharactersDecorations","_autoClosedEnclosingDecorations","getAllAutoClosedCharacters","autoClosedActions","autoClosedCharacters","autoClosedAction","concat","getAutoClosedCharactersRanges","deltaDecorations","result","decorationRange","getDecorationRange","push","isValid","selections","enclosingRanges","startLineNumber","endLineNumber","sort","compareRangesUsingStarts","strictContainsRange","CursorsController","viewModel","coordinatesConverter","cursorConfig","_knownModelVersionId","_viewModel","_coordinatesConverter","context","_cursors","_hasFocus","_isHandling","_isDoingComposition","_selectionsWhenCompositionStarted","_columnSelectData","_autoClosedActions","_prevEditOperationType","updateConfiguration","updateContext","onLineMappingChanged","eventsCollector","setStates","setHasFocus","hasFocus","_validateAutoClosedActions","getSelections","splice","getPrimaryCursorState","getPrimaryCursor","getLastAddedCursorIndex","getAll","source","reason","states","reachedMaxCursorCount","MAX_CURSOR_COUNT","slice","oldState","normalize","_emitStateChangedIfNecessary","setCursorColumnSelectData","columnSelectData","revealPrimary","revealHorizontal","scrollType","viewPositions","getViewPositions","_emitCursorRevealRange","getViewSelections","viewPosition","viewRange","lineNumber","column","_revealPrimaryCursor","verticalType","viewSelections","emitViewEvent","saveState","selection","inSelectionMode","isEmpty","selectionStart","selectionStartLineNumber","selectionStartColumn","position","positionLineNumber","positionColumn","restoreState","desiredSelections","state","fromModelSelections","onModelContentChanged","e","versionId","hadFlushEvent","containsEvent","resultingSelection","isUndoing","isRedoing","selectionsFromMarkers","readSelectionFromMarkers","getSelection","modelState","getTopMostViewPosition","getBottomMostViewPosition","getCursorColumnSelectData","primaryCursor","viewSelectionStart","viewState","getStartPosition","isReal","fromViewLineNumber","fromViewVisualColumn","visibleColumnFromColumn2","toViewLineNumber","toViewVisualColumn","setSelections","getPrevEditOperationType","setPrevEditOperationType","type","_pushAutoClosedAction","autoClosedCharactersRanges","autoClosedEnclosingRanges","autoClosedCharactersDeltaDecorations","autoClosedEnclosingDeltaDecorations","range","options","description","inlineClassName","stickiness","_executeEditOperation","opResult","shouldPushStackElementBefore","pushStackElement","CommandExecutor","executeCommands","commands","_interpretCommandResult","command","enclosingRange","closeCharacterRange","shouldPushStackElementAfter","newState","some","newCursorState","oldSelections","map","s","oldModelVersionId","emitOutgoingEvent","_findAutoClosingPairs","edits","indices","edit","text","indexOf","m","match","closeChar","autoClosingPairsCandidates","autoClosingPairs","autoClosingPairsCloseSingleChar","get","openChar","open","closeCharIndex","openCharIndex","lastIndexOf","executeEdits","cursorStateComputer","autoClosingIndices","_isTracked","pushEditOperations","undoEdits","openCharInnerIndex","closeCharInnerIndex","undoEdit","startColumn","_executeEdit","callback","cursorChangeReason","readOnly","stopTrackingSelections","ensureValidState","err","startTrackingSelections","setIsDoingComposition","isDoingComposition","getAutoClosedCharacters","startComposition","endComposition","compositionEndWithInterceptors","offset","charLength","nextCharLength","chr","substr","typeWithInterceptors","typeWithoutInterceptors","compositionType","replacePrevCharCnt","replaceNextCharCnt","positionDelta","newSelections","getPosition","paste","pasteOnNewLine","multicursorText","cut","executeCommand","killSecondaryCursors","selectionsBefore","ctx","trackedRanges","trackedRangesDirection","_innerExecuteCommands","_setTrackedRange","_arrayIsEmpty","commandsData","_getEditOperations","operations","rawOperations","loserCursorsMap","_getLoserCursorMap","hasOwnProperty","console","warn","filteredOperations","identifier","major","toString","hadTrackedEditOperation","selectionsAfter","inverseEditOperations","groupedInverseEditOperations","op","minorBasedSorter","a","b","minor","cursorSelections","computeCursorState","getInverseEditOperations","getTrackedSelection","id","idx","parseInt","_getTrackedRange","endColumn","losingCursors","losingCursorIndex","losingCursor","r","_getEditOperationsFromCommand","majorIdentifier","operationMinor","addEditOperation","forceMoveMarkers","isAutoWhitespaceEdit","insertsAutoWhitespace","addTrackedEditOperation","trackSelection","_selection","trackPreviousOnEmpty","liftSelection","maxLineColumn","getLineMaxColumn","l","getDirection","editOperationBuilder","getEditOperations","compareRangesUsingEnds","previousOp","currentOp","isBefore","getEndPosition","loserMajor","j"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,iBAAT,QAAkC,gCAAlC;AACA,OAAO,KAAKC,OAAZ,MAAyB,iCAAzB;AACA,SAASC,gBAAT,QAAiC,uBAAjC;AACA,SAASC,aAAT,EAAwBC,aAAxB,EAAuCC,WAAvC,EAAoDC,mBAApD,QAA+E,mBAA/E;AACA,SAASC,gBAAT,QAAiC,6BAAjC;AACA,SAASC,cAAT,EAAyBC,0BAAzB,QAA2D,2BAA3D;AACA,SAASC,KAAT,QAAsB,kBAAtB;AACA,SAASC,SAAT,QAA0B,sBAA1B;AACA,SAASC,6BAAT,QAA8C,6BAA9C;AACA,SAASC,2BAAT,EAAsCC,2BAAtC,QAAyE,uBAAzE;AACA,SAASC,OAAT,EAAkBC,UAAlB,QAAoC,mCAApC;AACA,SAASC,uBAAT,QAAwC,0CAAxC;AACA;AACA;AACA;;AACA,OAAO,MAAMC,gBAAN,CAAuB;AAC1BC,EAAAA,WAAW,CAACC,KAAD,EAAQC,MAAR,EAAgB;AACvB,SAAKC,cAAL,GAAsBF,KAAK,CAACG,YAAN,EAAtB;AACA,SAAKC,WAAL,GAAmBH,MAAM,CAACI,eAAP,EAAnB;AACH;;AACDC,EAAAA,MAAM,CAACC,KAAD,EAAQ;AACV,QAAI,CAACA,KAAL,EAAY;AACR,aAAO,KAAP;AACH;;AACD,QAAI,KAAKL,cAAL,KAAwBK,KAAK,CAACL,cAAlC,EAAkD;AAC9C,aAAO,KAAP;AACH;;AACD,QAAI,KAAKE,WAAL,CAAiBI,MAAjB,KAA4BD,KAAK,CAACH,WAAN,CAAkBI,MAAlD,EAA0D;AACtD,aAAO,KAAP;AACH;;AACD,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAG,KAAKN,WAAL,CAAiBI,MAAvC,EAA+CC,CAAC,GAAGC,GAAnD,EAAwDD,CAAC,EAAzD,EAA6D;AACzD,UAAI,CAAC,KAAKL,WAAL,CAAiBK,CAAjB,EAAoBH,MAApB,CAA2BC,KAAK,CAACH,WAAN,CAAkBK,CAAlB,CAA3B,CAAL,EAAuD;AACnD,eAAO,KAAP;AACH;AACJ;;AACD,WAAO,IAAP;AACH;;AArByB;;AAuB9B,MAAME,gBAAN,CAAuB;AACnBZ,EAAAA,WAAW,CAACC,KAAD,EAAQY,+BAAR,EAAyCC,8BAAzC,EAAyE;AAChF,SAAKC,MAAL,GAAcd,KAAd;AACA,SAAKe,gCAAL,GAAwCH,+BAAxC;AACA,SAAKI,+BAAL,GAAuCH,8BAAvC;AACH;;AACgC,SAA1BI,0BAA0B,CAACC,iBAAD,EAAoB;AACjD,QAAIC,oBAAoB,GAAG,EAA3B;;AACA,SAAK,MAAMC,gBAAX,IAA+BF,iBAA/B,EAAkD;AAC9CC,MAAAA,oBAAoB,GAAGA,oBAAoB,CAACE,MAArB,CAA4BD,gBAAgB,CAACE,6BAAjB,EAA5B,CAAvB;AACH;;AACD,WAAOH,oBAAP;AACH;;AACDxB,EAAAA,OAAO,GAAG;AACN,SAAKoB,gCAAL,GAAwC,KAAKD,MAAL,CAAYS,gBAAZ,CAA6B,KAAKR,gCAAlC,EAAoE,EAApE,CAAxC;AACA,SAAKC,+BAAL,GAAuC,KAAKF,MAAL,CAAYS,gBAAZ,CAA6B,KAAKP,+BAAlC,EAAmE,EAAnE,CAAvC;AACH;;AACDM,EAAAA,6BAA6B,GAAG;AAC5B,QAAIE,MAAM,GAAG,EAAb;;AACA,SAAK,IAAIf,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKM,gCAAL,CAAsCP,MAA1D,EAAkEC,CAAC,EAAnE,EAAuE;AACnE,YAAMgB,eAAe,GAAG,KAAKX,MAAL,CAAYY,kBAAZ,CAA+B,KAAKX,gCAAL,CAAsCN,CAAtC,CAA/B,CAAxB;;AACA,UAAIgB,eAAJ,EAAqB;AACjBD,QAAAA,MAAM,CAACG,IAAP,CAAYF,eAAZ;AACH;AACJ;;AACD,WAAOD,MAAP;AACH;;AACDI,EAAAA,OAAO,CAACC,UAAD,EAAa;AAChB,QAAIC,eAAe,GAAG,EAAtB;;AACA,SAAK,IAAIrB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKO,+BAAL,CAAqCR,MAAzD,EAAiEC,CAAC,EAAlE,EAAsE;AAClE,YAAMgB,eAAe,GAAG,KAAKX,MAAL,CAAYY,kBAAZ,CAA+B,KAAKV,+BAAL,CAAqCP,CAArC,CAA/B,CAAxB;;AACA,UAAIgB,eAAJ,EAAqB;AACjBK,QAAAA,eAAe,CAACH,IAAhB,CAAqBF,eAArB;;AACA,YAAIA,eAAe,CAACM,eAAhB,KAAoCN,eAAe,CAACO,aAAxD,EAAuE;AACnE;AACA,iBAAO,KAAP;AACH;AACJ;AACJ;;AACDF,IAAAA,eAAe,CAACG,IAAhB,CAAqB3C,KAAK,CAAC4C,wBAA3B;AACAL,IAAAA,UAAU,CAACI,IAAX,CAAgB3C,KAAK,CAAC4C,wBAAtB;;AACA,SAAK,IAAIzB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoB,UAAU,CAACrB,MAA/B,EAAuCC,CAAC,EAAxC,EAA4C;AACxC,UAAIA,CAAC,IAAIqB,eAAe,CAACtB,MAAzB,EAAiC;AAC7B,eAAO,KAAP;AACH;;AACD,UAAI,CAACsB,eAAe,CAACrB,CAAD,CAAf,CAAmB0B,mBAAnB,CAAuCN,UAAU,CAACpB,CAAD,CAAjD,CAAL,EAA4D;AACxD,eAAO,KAAP;AACH;AACJ;;AACD,WAAO,IAAP;AACH;;AAlDkB;;AAoDvB,OAAO,MAAM2B,iBAAN,SAAgCxC,UAAhC,CAA2C;AAC9CG,EAAAA,WAAW,CAACC,KAAD,EAAQqC,SAAR,EAAmBC,oBAAnB,EAAyCC,YAAzC,EAAuD;AAC9D;AACA,SAAKzB,MAAL,GAAcd,KAAd;AACA,SAAKwC,oBAAL,GAA4B,KAAK1B,MAAL,CAAYX,YAAZ,EAA5B;AACA,SAAKsC,UAAL,GAAkBJ,SAAlB;AACA,SAAKK,qBAAL,GAA6BJ,oBAA7B;AACA,SAAKK,OAAL,GAAe,IAAI3D,aAAJ,CAAkB,KAAK8B,MAAvB,EAA+B,KAAK2B,UAApC,EAAgD,KAAKC,qBAArD,EAA4EH,YAA5E,CAAf;AACA,SAAKK,QAAL,GAAgB,IAAI9D,gBAAJ,CAAqB,KAAK6D,OAA1B,CAAhB;AACA,SAAKE,SAAL,GAAiB,KAAjB;AACA,SAAKC,WAAL,GAAmB,KAAnB;AACA,SAAKC,mBAAL,GAA2B,KAA3B;AACA,SAAKC,iCAAL,GAAyC,IAAzC;AACA,SAAKC,iBAAL,GAAyB,IAAzB;AACA,SAAKC,kBAAL,GAA0B,EAA1B;AACA,SAAKC,sBAAL,GAA8B;AAAE;AAAhC;AACH;;AACDxD,EAAAA,OAAO,GAAG;AACN,SAAKiD,QAAL,CAAcjD,OAAd;;AACA,SAAKuD,kBAAL,GAA0BvD,OAAO,CAAC,KAAKuD,kBAAN,CAAjC;AACA,UAAMvD,OAAN;AACH;;AACDyD,EAAAA,mBAAmB,CAACb,YAAD,EAAe;AAC9B,SAAKI,OAAL,GAAe,IAAI3D,aAAJ,CAAkB,KAAK8B,MAAvB,EAA+B,KAAK2B,UAApC,EAAgD,KAAKC,qBAArD,EAA4EH,YAA5E,CAAf;;AACA,SAAKK,QAAL,CAAcS,aAAd,CAA4B,KAAKV,OAAjC;AACH;;AACDW,EAAAA,oBAAoB,CAACC,eAAD,EAAkB;AAClC,QAAI,KAAKf,oBAAL,KAA8B,KAAK1B,MAAL,CAAYX,YAAZ,EAAlC,EAA8D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACH,KAViC,CAWlC;;;AACA,SAAKqD,SAAL,CAAeD,eAAf,EAAgC,WAAhC,EAA6C;AAAE;AAA/C,MAA6D,KAAKlD,eAAL,EAA7D;AACH;;AACDoD,EAAAA,WAAW,CAACC,QAAD,EAAW;AAClB,SAAKb,SAAL,GAAiBa,QAAjB;AACH;;AACDC,EAAAA,0BAA0B,GAAG;AACzB,QAAI,KAAKT,kBAAL,CAAwB1C,MAAxB,GAAiC,CAArC,EAAwC;AACpC,UAAIqB,UAAU,GAAG,KAAKe,QAAL,CAAcgB,aAAd,EAAjB;;AACA,WAAK,IAAInD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKyC,kBAAL,CAAwB1C,MAA5C,EAAoDC,CAAC,EAArD,EAAyD;AACrD,cAAMW,gBAAgB,GAAG,KAAK8B,kBAAL,CAAwBzC,CAAxB,CAAzB;;AACA,YAAI,CAACW,gBAAgB,CAACQ,OAAjB,CAAyBC,UAAzB,CAAL,EAA2C;AACvCT,UAAAA,gBAAgB,CAACzB,OAAjB;;AACA,eAAKuD,kBAAL,CAAwBW,MAAxB,CAA+BpD,CAA/B,EAAkC,CAAlC;;AACAA,UAAAA,CAAC;AACJ;AACJ;AACJ;AACJ,GAvD6C,CAwD9C;;;AACAqD,EAAAA,qBAAqB,GAAG;AACpB,WAAO,KAAKlB,QAAL,CAAcmB,gBAAd,EAAP;AACH;;AACDC,EAAAA,uBAAuB,GAAG;AACtB,WAAO,KAAKpB,QAAL,CAAcoB,uBAAd,EAAP;AACH;;AACD3D,EAAAA,eAAe,GAAG;AACd,WAAO,KAAKuC,QAAL,CAAcqB,MAAd,EAAP;AACH;;AACDT,EAAAA,SAAS,CAACD,eAAD,EAAkBW,MAAlB,EAA0BC,MAA1B,EAAkCC,MAAlC,EAA0C;AAC/C,QAAIC,qBAAqB,GAAG,KAA5B;;AACA,QAAID,MAAM,KAAK,IAAX,IAAmBA,MAAM,CAAC5D,MAAP,GAAgB4B,iBAAiB,CAACkC,gBAAzD,EAA2E;AACvEF,MAAAA,MAAM,GAAGA,MAAM,CAACG,KAAP,CAAa,CAAb,EAAgBnC,iBAAiB,CAACkC,gBAAlC,CAAT;AACAD,MAAAA,qBAAqB,GAAG,IAAxB;AACH;;AACD,UAAMG,QAAQ,GAAG,IAAI1E,gBAAJ,CAAqB,KAAKgB,MAA1B,EAAkC,IAAlC,CAAjB;;AACA,SAAK8B,QAAL,CAAcY,SAAd,CAAwBY,MAAxB;;AACA,SAAKxB,QAAL,CAAc6B,SAAd;;AACA,SAAKxB,iBAAL,GAAyB,IAAzB;;AACA,SAAKU,0BAAL;;AACA,WAAO,KAAKe,4BAAL,CAAkCnB,eAAlC,EAAmDW,MAAnD,EAA2DC,MAA3D,EAAmEK,QAAnE,EAA6EH,qBAA7E,CAAP;AACH;;AACDM,EAAAA,yBAAyB,CAACC,gBAAD,EAAmB;AACxC,SAAK3B,iBAAL,GAAyB2B,gBAAzB;AACH;;AACDC,EAAAA,aAAa,CAACtB,eAAD,EAAkBW,MAAlB,EAA0BY,gBAA1B,EAA4CC,UAA5C,EAAwD;AACjE,UAAMC,aAAa,GAAG,KAAKpC,QAAL,CAAcqC,gBAAd,EAAtB;;AACA,QAAID,aAAa,CAACxE,MAAd,GAAuB,CAA3B,EAA8B;AAC1B,WAAK0E,sBAAL,CAA4B3B,eAA5B,EAA6CW,MAA7C,EAAqD,IAArD,EAA2D,KAAKtB,QAAL,CAAcuC,iBAAd,EAA3D,EAA8F;AAAE;AAAhG,QAA8GL,gBAA9G,EAAgIC,UAAhI;;AACA;AACH,KAHD,MAIK;AACD,YAAMK,YAAY,GAAGJ,aAAa,CAAC,CAAD,CAAlC;AACA,YAAMK,SAAS,GAAG,IAAI/F,KAAJ,CAAU8F,YAAY,CAACE,UAAvB,EAAmCF,YAAY,CAACG,MAAhD,EAAwDH,YAAY,CAACE,UAArE,EAAiFF,YAAY,CAACG,MAA9F,CAAlB;;AACA,WAAKL,sBAAL,CAA4B3B,eAA5B,EAA6CW,MAA7C,EAAqDmB,SAArD,EAAgE,IAAhE,EAAsE;AAAE;AAAxE,QAAsFP,gBAAtF,EAAwGC,UAAxG;AACH;AACJ;;AACDS,EAAAA,oBAAoB,CAACjC,eAAD,EAAkBW,MAAlB,EAA0BuB,YAA1B,EAAwCX,gBAAxC,EAA0DC,UAA1D,EAAsE;AACtF,UAAMC,aAAa,GAAG,KAAKpC,QAAL,CAAcqC,gBAAd,EAAtB;;AACA,QAAID,aAAa,CAACxE,MAAd,GAAuB,CAA3B,EAA8B;AAC1B,WAAK0E,sBAAL,CAA4B3B,eAA5B,EAA6CW,MAA7C,EAAqD,IAArD,EAA2D,KAAKtB,QAAL,CAAcuC,iBAAd,EAA3D,EAA8FM,YAA9F,EAA4GX,gBAA5G,EAA8HC,UAA9H;AACH,KAFD,MAGK;AACD,YAAMK,YAAY,GAAGJ,aAAa,CAAC,CAAD,CAAlC;AACA,YAAMK,SAAS,GAAG,IAAI/F,KAAJ,CAAU8F,YAAY,CAACE,UAAvB,EAAmCF,YAAY,CAACG,MAAhD,EAAwDH,YAAY,CAACE,UAArE,EAAiFF,YAAY,CAACG,MAA9F,CAAlB;;AACA,WAAKL,sBAAL,CAA4B3B,eAA5B,EAA6CW,MAA7C,EAAqDmB,SAArD,EAAgE,IAAhE,EAAsEI,YAAtE,EAAoFX,gBAApF,EAAsGC,UAAtG;AACH;AACJ;;AACDG,EAAAA,sBAAsB,CAAC3B,eAAD,EAAkBW,MAAlB,EAA0BmB,SAA1B,EAAqCK,cAArC,EAAqDD,YAArD,EAAmEX,gBAAnE,EAAqFC,UAArF,EAAiG;AACnHxB,IAAAA,eAAe,CAACoC,aAAhB,CAA8B,IAAIjG,2BAAJ,CAAgCwE,MAAhC,EAAwCmB,SAAxC,EAAmDK,cAAnD,EAAmED,YAAnE,EAAiFX,gBAAjF,EAAmGC,UAAnG,CAA9B;AACH;;AACDa,EAAAA,SAAS,GAAG;AACR,QAAIpE,MAAM,GAAG,EAAb;;AACA,UAAMK,UAAU,GAAG,KAAKe,QAAL,CAAcgB,aAAd,EAAnB;;AACA,SAAK,IAAInD,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGmB,UAAU,CAACrB,MAAjC,EAAyCC,CAAC,GAAGC,GAA7C,EAAkDD,CAAC,EAAnD,EAAuD;AACnD,YAAMoF,SAAS,GAAGhE,UAAU,CAACpB,CAAD,CAA5B;AACAe,MAAAA,MAAM,CAACG,IAAP,CAAY;AACRmE,QAAAA,eAAe,EAAE,CAACD,SAAS,CAACE,OAAV,EADV;AAERC,QAAAA,cAAc,EAAE;AACZV,UAAAA,UAAU,EAAEO,SAAS,CAACI,wBADV;AAEZV,UAAAA,MAAM,EAAEM,SAAS,CAACK;AAFN,SAFR;AAMRC,QAAAA,QAAQ,EAAE;AACNb,UAAAA,UAAU,EAAEO,SAAS,CAACO,kBADhB;AAENb,UAAAA,MAAM,EAAEM,SAAS,CAACQ;AAFZ;AANF,OAAZ;AAWH;;AACD,WAAO7E,MAAP;AACH;;AACD8E,EAAAA,YAAY,CAAC/C,eAAD,EAAkBa,MAAlB,EAA0B;AAClC,QAAImC,iBAAiB,GAAG,EAAxB;;AACA,SAAK,IAAI9F,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAG0D,MAAM,CAAC5D,MAA7B,EAAqCC,CAAC,GAAGC,GAAzC,EAA8CD,CAAC,EAA/C,EAAmD;AAC/C,YAAM+F,KAAK,GAAGpC,MAAM,CAAC3D,CAAD,CAApB;AACA,UAAI2F,kBAAkB,GAAG,CAAzB;AACA,UAAIC,cAAc,GAAG,CAArB,CAH+C,CAI/C;;AACA,UAAIG,KAAK,CAACL,QAAN,IAAkBK,KAAK,CAACL,QAAN,CAAeb,UAArC,EAAiD;AAC7Cc,QAAAA,kBAAkB,GAAGI,KAAK,CAACL,QAAN,CAAeb,UAApC;AACH;;AACD,UAAIkB,KAAK,CAACL,QAAN,IAAkBK,KAAK,CAACL,QAAN,CAAeZ,MAArC,EAA6C;AACzCc,QAAAA,cAAc,GAAGG,KAAK,CAACL,QAAN,CAAeZ,MAAhC;AACH;;AACD,UAAIU,wBAAwB,GAAGG,kBAA/B;AACA,UAAIF,oBAAoB,GAAGG,cAA3B,CAZ+C,CAa/C;;AACA,UAAIG,KAAK,CAACR,cAAN,IAAwBQ,KAAK,CAACR,cAAN,CAAqBV,UAAjD,EAA6D;AACzDW,QAAAA,wBAAwB,GAAGO,KAAK,CAACR,cAAN,CAAqBV,UAAhD;AACH;;AACD,UAAIkB,KAAK,CAACR,cAAN,IAAwBQ,KAAK,CAACR,cAAN,CAAqBT,MAAjD,EAAyD;AACrDW,QAAAA,oBAAoB,GAAGM,KAAK,CAACR,cAAN,CAAqBT,MAA5C;AACH;;AACDgB,MAAAA,iBAAiB,CAAC5E,IAAlB,CAAuB;AACnBsE,QAAAA,wBAAwB,EAAEA,wBADP;AAEnBC,QAAAA,oBAAoB,EAAEA,oBAFH;AAGnBE,QAAAA,kBAAkB,EAAEA,kBAHD;AAInBC,QAAAA,cAAc,EAAEA;AAJG,OAAvB;AAMH;;AACD,SAAK7C,SAAL,CAAeD,eAAf,EAAgC,cAAhC,EAAgD;AAAE;AAAlD,MAAgEtE,WAAW,CAACwH,mBAAZ,CAAgCF,iBAAhC,CAAhE;AACA,SAAK1B,aAAL,CAAmBtB,eAAnB,EAAoC,cAApC,EAAoD,IAApD,EAA0D;AAAE;AAA5D;AACH;;AACDmD,EAAAA,qBAAqB,CAACnD,eAAD,EAAkBoD,CAAlB,EAAqB;AACtC,QAAIA,CAAC,YAAYnH,6BAAjB,EAAgD;AAC5C;AACA,UAAI,KAAKsD,WAAT,EAAsB;AAClB;AACA;AACH,OAL2C,CAM5C;AACA;AACA;AACA;;;AACA,WAAKA,WAAL,GAAmB,IAAnB;;AACA,UAAI;AACA,aAAKU,SAAL,CAAeD,eAAf,EAAgC,aAAhC,EAA+C;AAAE;AAAjD,UAA+D,KAAKlD,eAAL,EAA/D;AACH,OAFD,SAGQ;AACJ,aAAKyC,WAAL,GAAmB,KAAnB;AACH;AACJ,KAjBD,MAkBK;AACD,WAAKN,oBAAL,GAA4BmE,CAAC,CAACC,SAA9B;;AACA,UAAI,KAAK9D,WAAT,EAAsB;AAClB;AACH;;AACD,YAAM+D,aAAa,GAAGF,CAAC,CAACG,aAAF,CAAgB;AAAE;AAAlB,OAAtB;AACA,WAAK3D,sBAAL,GAA8B;AAAE;AAAhC;;AACA,UAAI0D,aAAJ,EAAmB;AACf;AACA,aAAKjE,QAAL,CAAcjD,OAAd;;AACA,aAAKiD,QAAL,GAAgB,IAAI9D,gBAAJ,CAAqB,KAAK6D,OAA1B,CAAhB;;AACA,aAAKgB,0BAAL;;AACA,aAAKe,4BAAL,CAAkCnB,eAAlC,EAAmD,OAAnD,EAA4D;AAAE;AAA9D,UAAkF,IAAlF,EAAwF,KAAxF;AACH,OAND,MAOK;AACD,YAAI,KAAKV,SAAL,IAAkB8D,CAAC,CAACI,kBAApB,IAA0CJ,CAAC,CAACI,kBAAF,CAAqBvG,MAArB,GAA8B,CAA5E,EAA+E;AAC3E,gBAAMJ,WAAW,GAAGnB,WAAW,CAACwH,mBAAZ,CAAgCE,CAAC,CAACI,kBAAlC,CAApB;;AACA,cAAI,KAAKvD,SAAL,CAAeD,eAAf,EAAgC,aAAhC,EAA+CoD,CAAC,CAACK,SAAF,GAAc;AAAE;AAAhB,YAA6BL,CAAC,CAACM,SAAF,GAAc;AAAE;AAAhB,YAA6B;AAAE;AAA3G,YAAqI7G,WAArI,CAAJ,EAAuJ;AACnJ,iBAAKoF,oBAAL,CAA0BjC,eAA1B,EAA2C,aAA3C,EAA0D;AAAE;AAA5D,cAA0E,IAA1E,EAAgF;AAAE;AAAlF;AACH;AACJ,SALD,MAMK;AACD,gBAAM2D,qBAAqB,GAAG,KAAKtE,QAAL,CAAcuE,wBAAd,EAA9B;;AACA,eAAK3D,SAAL,CAAeD,eAAf,EAAgC,aAAhC,EAA+C;AAAE;AAAjD,YAA2EtE,WAAW,CAACwH,mBAAZ,CAAgCS,qBAAhC,CAA3E;AACH;AACJ;AACJ;AACJ;;AACDE,EAAAA,YAAY,GAAG;AACX,WAAO,KAAKxE,QAAL,CAAcmB,gBAAd,GAAiCsD,UAAjC,CAA4CxB,SAAnD;AACH;;AACDyB,EAAAA,sBAAsB,GAAG;AACrB,WAAO,KAAK1E,QAAL,CAAc0E,sBAAd,EAAP;AACH;;AACDC,EAAAA,yBAAyB,GAAG;AACxB,WAAO,KAAK3E,QAAL,CAAc2E,yBAAd,EAAP;AACH;;AACDC,EAAAA,yBAAyB,GAAG;AACxB,QAAI,KAAKvE,iBAAT,EAA4B;AACxB,aAAO,KAAKA,iBAAZ;AACH;;AACD,UAAMwE,aAAa,GAAG,KAAK7E,QAAL,CAAcmB,gBAAd,EAAtB;;AACA,UAAM2D,kBAAkB,GAAGD,aAAa,CAACE,SAAd,CAAwB3B,cAAxB,CAAuC4B,gBAAvC,EAA3B;AACA,UAAMxC,YAAY,GAAGqC,aAAa,CAACE,SAAd,CAAwBxB,QAA7C;AACA,WAAO;AACH0B,MAAAA,MAAM,EAAE,KADL;AAEHC,MAAAA,kBAAkB,EAAEJ,kBAAkB,CAACpC,UAFpC;AAGHyC,MAAAA,oBAAoB,EAAEhJ,aAAa,CAACiJ,wBAAd,CAAuC,KAAKrF,OAAL,CAAaJ,YAApD,EAAkE,KAAKE,UAAvE,EAAmFiF,kBAAnF,CAHnB;AAIHO,MAAAA,gBAAgB,EAAE7C,YAAY,CAACE,UAJ5B;AAKH4C,MAAAA,kBAAkB,EAAEnJ,aAAa,CAACiJ,wBAAd,CAAuC,KAAKrF,OAAL,CAAaJ,YAApD,EAAkE,KAAKE,UAAvE,EAAmF2C,YAAnF;AALjB,KAAP;AAOH;;AACDxB,EAAAA,aAAa,GAAG;AACZ,WAAO,KAAKhB,QAAL,CAAcgB,aAAd,EAAP;AACH;;AACDuE,EAAAA,aAAa,CAAC5E,eAAD,EAAkBW,MAAlB,EAA0BrC,UAA1B,EAAsCsC,MAAtC,EAA8C;AACvD,SAAKX,SAAL,CAAeD,eAAf,EAAgCW,MAAhC,EAAwCC,MAAxC,EAAgDlF,WAAW,CAACwH,mBAAZ,CAAgC5E,UAAhC,CAAhD;AACH;;AACDuG,EAAAA,wBAAwB,GAAG;AACvB,WAAO,KAAKjF,sBAAZ;AACH;;AACDkF,EAAAA,wBAAwB,CAACC,IAAD,EAAO;AAC3B,SAAKnF,sBAAL,GAA8BmF,IAA9B;AACH,GAjP6C,CAkP9C;;;AACAC,EAAAA,qBAAqB,CAACC,0BAAD,EAA6BC,yBAA7B,EAAwD;AACzE,QAAIC,oCAAoC,GAAG,EAA3C;AACA,QAAIC,mCAAmC,GAAG,EAA1C;;AACA,SAAK,IAAIlI,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAG8H,0BAA0B,CAAChI,MAAjD,EAAyDC,CAAC,GAAGC,GAA7D,EAAkED,CAAC,EAAnE,EAAuE;AACnEiI,MAAAA,oCAAoC,CAAC/G,IAArC,CAA0C;AACtCiH,QAAAA,KAAK,EAAEJ,0BAA0B,CAAC/H,CAAD,CADK;AAEtCoI,QAAAA,OAAO,EAAE;AACLC,UAAAA,WAAW,EAAE,uBADR;AAELC,UAAAA,eAAe,EAAE,uBAFZ;AAGLC,UAAAA,UAAU,EAAE;AAAE;;AAHT;AAF6B,OAA1C;AAQAL,MAAAA,mCAAmC,CAAChH,IAApC,CAAyC;AACrCiH,QAAAA,KAAK,EAAEH,yBAAyB,CAAChI,CAAD,CADK;AAErCoI,QAAAA,OAAO,EAAE;AACLC,UAAAA,WAAW,EAAE,uBADR;AAELE,UAAAA,UAAU,EAAE;AAAE;;AAFT;AAF4B,OAAzC;AAOH;;AACD,UAAMpI,+BAA+B,GAAG,KAAKE,MAAL,CAAYS,gBAAZ,CAA6B,EAA7B,EAAiCmH,oCAAjC,CAAxC;;AACA,UAAM7H,8BAA8B,GAAG,KAAKC,MAAL,CAAYS,gBAAZ,CAA6B,EAA7B,EAAiCoH,mCAAjC,CAAvC;;AACA,SAAKzF,kBAAL,CAAwBvB,IAAxB,CAA6B,IAAIhB,gBAAJ,CAAqB,KAAKG,MAA1B,EAAkCF,+BAAlC,EAAmEC,8BAAnE,CAA7B;AACH;;AACDoI,EAAAA,qBAAqB,CAACC,QAAD,EAAW;AAC5B,QAAI,CAACA,QAAL,EAAe;AACX;AACA;AACH;;AACD,QAAIA,QAAQ,CAACC,4BAAb,EAA2C;AACvC,WAAKrI,MAAL,CAAYsI,gBAAZ;AACH;;AACD,UAAM5H,MAAM,GAAG6H,eAAe,CAACC,eAAhB,CAAgC,KAAKxI,MAArC,EAA6C,KAAK8B,QAAL,CAAcgB,aAAd,EAA7C,EAA4EsF,QAAQ,CAACK,QAArF,CAAf;;AACA,QAAI/H,MAAJ,EAAY;AACR;AACA,WAAKgI,uBAAL,CAA6BhI,MAA7B,EAFQ,CAGR;;;AACA,UAAIgH,0BAA0B,GAAG,EAAjC;AACA,UAAIC,yBAAyB,GAAG,EAAhC;;AACA,WAAK,IAAIhI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyI,QAAQ,CAACK,QAAT,CAAkB/I,MAAtC,EAA8CC,CAAC,EAA/C,EAAmD;AAC/C,cAAMgJ,OAAO,GAAGP,QAAQ,CAACK,QAAT,CAAkB9I,CAAlB,CAAhB;;AACA,YAAIgJ,OAAO,YAAYpK,0BAAnB,IAAiDoK,OAAO,CAACC,cAAzD,IAA2ED,OAAO,CAACE,mBAAvF,EAA4G;AACxGnB,UAAAA,0BAA0B,CAAC7G,IAA3B,CAAgC8H,OAAO,CAACE,mBAAxC;AACAlB,UAAAA,yBAAyB,CAAC9G,IAA1B,CAA+B8H,OAAO,CAACC,cAAvC;AACH;AACJ;;AACD,UAAIlB,0BAA0B,CAAChI,MAA3B,GAAoC,CAAxC,EAA2C;AACvC,aAAK+H,qBAAL,CAA2BC,0BAA3B,EAAuDC,yBAAvD;AACH;;AACD,WAAKtF,sBAAL,GAA8B+F,QAAQ,CAACZ,IAAvC;AACH;;AACD,QAAIY,QAAQ,CAACU,2BAAb,EAA0C;AACtC,WAAK9I,MAAL,CAAYsI,gBAAZ;AACH;AACJ;;AACDI,EAAAA,uBAAuB,CAACpJ,WAAD,EAAc;AACjC,QAAI,CAACA,WAAD,IAAgBA,WAAW,CAACI,MAAZ,KAAuB,CAA3C,EAA8C;AAC1CJ,MAAAA,WAAW,GAAG,KAAKwC,QAAL,CAAcuE,wBAAd,EAAd;AACH;;AACD,SAAKlE,iBAAL,GAAyB,IAAzB;;AACA,SAAKL,QAAL,CAAcuF,aAAd,CAA4B/H,WAA5B;;AACA,SAAKwC,QAAL,CAAc6B,SAAd;AACH,GAjT6C,CAkT9C;AACA;;;AACAC,EAAAA,4BAA4B,CAACnB,eAAD,EAAkBW,MAAlB,EAA0BC,MAA1B,EAAkCK,QAAlC,EAA4CH,qBAA5C,EAAmE;AAC3F,UAAMwF,QAAQ,GAAG,IAAI/J,gBAAJ,CAAqB,KAAKgB,MAA1B,EAAkC,IAAlC,CAAjB;;AACA,QAAI+I,QAAQ,CAACvJ,MAAT,CAAgBkE,QAAhB,CAAJ,EAA+B;AAC3B,aAAO,KAAP;AACH;;AACD,UAAM3C,UAAU,GAAG,KAAKe,QAAL,CAAcgB,aAAd,EAAnB;;AACA,UAAM8B,cAAc,GAAG,KAAK9C,QAAL,CAAcuC,iBAAd,EAAvB,CAN2F,CAO3F;;;AACA5B,IAAAA,eAAe,CAACoC,aAAhB,CAA8B,IAAIlG,2BAAJ,CAAgCiG,cAAhC,EAAgD7D,UAAhD,CAA9B,EAR2F,CAS3F;;AACA,QAAI,CAAC2C,QAAD,IACGA,QAAQ,CAACpE,WAAT,CAAqBI,MAArB,KAAgCqJ,QAAQ,CAACzJ,WAAT,CAAqBI,MADxD,IAEGqJ,QAAQ,CAACzJ,WAAT,CAAqB0J,IAArB,CAA0B,CAACC,cAAD,EAAiBtJ,CAAjB,KAAuB,CAACsJ,cAAc,CAAC1C,UAAf,CAA0B/G,MAA1B,CAAiCkE,QAAQ,CAACpE,WAAT,CAAqBK,CAArB,EAAwB4G,UAAzD,CAAlD,CAFP,EAEgI;AAC5H,YAAM2C,aAAa,GAAGxF,QAAQ,GAAGA,QAAQ,CAACpE,WAAT,CAAqB6J,GAArB,CAAyBC,CAAC,IAAIA,CAAC,CAAC7C,UAAF,CAAaxB,SAA3C,CAAH,GAA2D,IAAzF;AACA,YAAMsE,iBAAiB,GAAG3F,QAAQ,GAAGA,QAAQ,CAACtE,cAAZ,GAA6B,CAA/D;AACAqD,MAAAA,eAAe,CAAC6G,iBAAhB,CAAkC,IAAIvK,uBAAJ,CAA4BmK,aAA5B,EAA2CnI,UAA3C,EAAuDsI,iBAAvD,EAA0EN,QAAQ,CAAC3J,cAAnF,EAAmGgE,MAAM,IAAI,UAA7G,EAAyHC,MAAzH,EAAiIE,qBAAjI,CAAlC;AACH;;AACD,WAAO,IAAP;AACH,GAtU6C,CAuU9C;AACA;;;AACAgG,EAAAA,qBAAqB,CAACC,KAAD,EAAQ;AACzB,QAAI,CAACA,KAAK,CAAC9J,MAAX,EAAmB;AACf,aAAO,IAAP;AACH;;AACD,QAAI+J,OAAO,GAAG,EAAd;;AACA,SAAK,IAAI9J,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAG4J,KAAK,CAAC9J,MAA5B,EAAoCC,CAAC,GAAGC,GAAxC,EAA6CD,CAAC,EAA9C,EAAkD;AAC9C,YAAM+J,IAAI,GAAGF,KAAK,CAAC7J,CAAD,CAAlB;;AACA,UAAI,CAAC+J,IAAI,CAACC,IAAN,IAAcD,IAAI,CAACC,IAAL,CAAUC,OAAV,CAAkB,IAAlB,KAA2B,CAA7C,EAAgD;AAC5C,eAAO,IAAP;AACH;;AACD,YAAMC,CAAC,GAAGH,IAAI,CAACC,IAAL,CAAUG,KAAV,CAAgB,6BAAhB,CAAV;;AACA,UAAI,CAACD,CAAL,EAAQ;AACJ,eAAO,IAAP;AACH;;AACD,YAAME,SAAS,GAAGF,CAAC,CAAC,CAAD,CAAnB;AACA,YAAMG,0BAA0B,GAAG,KAAKnI,OAAL,CAAaJ,YAAb,CAA0BwI,gBAA1B,CAA2CC,+BAA3C,CAA2EC,GAA3E,CAA+EJ,SAA/E,CAAnC;;AACA,UAAI,CAACC,0BAAD,IAA+BA,0BAA0B,CAACtK,MAA3B,KAAsC,CAAzE,EAA4E;AACxE,eAAO,IAAP;AACH;;AACD,YAAM0K,QAAQ,GAAGJ,0BAA0B,CAAC,CAAD,CAA1B,CAA8BK,IAA/C;AACA,YAAMC,cAAc,GAAGZ,IAAI,CAACC,IAAL,CAAUjK,MAAV,GAAmBmK,CAAC,CAAC,CAAD,CAAD,CAAKnK,MAAxB,GAAiC,CAAxD;AACA,YAAM6K,aAAa,GAAGb,IAAI,CAACC,IAAL,CAAUa,WAAV,CAAsBJ,QAAtB,EAAgCE,cAAc,GAAG,CAAjD,CAAtB;;AACA,UAAIC,aAAa,KAAK,CAAC,CAAvB,EAA0B;AACtB,eAAO,IAAP;AACH;;AACDd,MAAAA,OAAO,CAAC5I,IAAR,CAAa,CAAC0J,aAAD,EAAgBD,cAAhB,CAAb;AACH;;AACD,WAAOb,OAAP;AACH;;AACDgB,EAAAA,YAAY,CAAChI,eAAD,EAAkBW,MAAlB,EAA0BoG,KAA1B,EAAiCkB,mBAAjC,EAAsD;AAC9D,QAAIC,kBAAkB,GAAG,IAAzB;;AACA,QAAIvH,MAAM,KAAK,SAAf,EAA0B;AACtBuH,MAAAA,kBAAkB,GAAG,KAAKpB,qBAAL,CAA2BC,KAA3B,CAArB;AACH;;AACD,QAAImB,kBAAJ,EAAwB;AACpBnB,MAAAA,KAAK,CAAC,CAAD,CAAL,CAASoB,UAAT,GAAsB,IAAtB;AACH;;AACD,QAAIlD,0BAA0B,GAAG,EAAjC;AACA,QAAIC,yBAAyB,GAAG,EAAhC;;AACA,UAAM5G,UAAU,GAAG,KAAKf,MAAL,CAAY6K,kBAAZ,CAA+B,KAAK/H,aAAL,EAA/B,EAAqD0G,KAArD,EAA6DsB,SAAD,IAAe;AAC1F,UAAIH,kBAAJ,EAAwB;AACpB,aAAK,IAAIhL,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAG+K,kBAAkB,CAACjL,MAAzC,EAAiDC,CAAC,GAAGC,GAArD,EAA0DD,CAAC,EAA3D,EAA+D;AAC3D,gBAAM,CAACoL,kBAAD,EAAqBC,mBAArB,IAA4CL,kBAAkB,CAAChL,CAAD,CAApE;AACA,gBAAMsL,QAAQ,GAAGH,SAAS,CAACnL,CAAD,CAA1B;AACA,gBAAM6E,UAAU,GAAGyG,QAAQ,CAACnD,KAAT,CAAe7G,eAAlC;AACA,gBAAMsJ,aAAa,GAAGU,QAAQ,CAACnD,KAAT,CAAeoD,WAAf,GAA6B,CAA7B,GAAiCH,kBAAvD;AACA,gBAAMT,cAAc,GAAGW,QAAQ,CAACnD,KAAT,CAAeoD,WAAf,GAA6B,CAA7B,GAAiCF,mBAAxD;AACAtD,UAAAA,0BAA0B,CAAC7G,IAA3B,CAAgC,IAAIrC,KAAJ,CAAUgG,UAAV,EAAsB8F,cAAc,GAAG,CAAvC,EAA0C9F,UAA1C,EAAsD8F,cAAc,GAAG,CAAvE,CAAhC;AACA3C,UAAAA,yBAAyB,CAAC9G,IAA1B,CAA+B,IAAIrC,KAAJ,CAAUgG,UAAV,EAAsB+F,aAAa,GAAG,CAAtC,EAAyC/F,UAAzC,EAAqD8F,cAAc,GAAG,CAAtE,CAA/B;AACH;AACJ;;AACD,YAAMvJ,UAAU,GAAG2J,mBAAmB,CAACI,SAAD,CAAtC;;AACA,UAAI/J,UAAJ,EAAgB;AACZ;AACA;AACA,aAAKiB,WAAL,GAAmB,IAAnB;AACH;;AACD,aAAOjB,UAAP;AACH,KAnBkB,CAAnB;;AAoBA,QAAIA,UAAJ,EAAgB;AACZ,WAAKiB,WAAL,GAAmB,KAAnB;AACA,WAAKqF,aAAL,CAAmB5E,eAAnB,EAAoCW,MAApC,EAA4CrC,UAA5C,EAAwD;AAAE;AAA1D;AACH;;AACD,QAAI2G,0BAA0B,CAAChI,MAA3B,GAAoC,CAAxC,EAA2C;AACvC,WAAK+H,qBAAL,CAA2BC,0BAA3B,EAAuDC,yBAAvD;AACH;AACJ;;AACDwD,EAAAA,YAAY,CAACC,QAAD,EAAW3I,eAAX,EAA4BW,MAA5B,EAAyE;AAAA,QAArCiI,kBAAqC,uEAAhB,CAAgB;;AACjF,QAAI,KAAKxJ,OAAL,CAAaJ,YAAb,CAA0B6J,QAA9B,EAAwC;AACpC;AACA;AACH;;AACD,UAAM5H,QAAQ,GAAG,IAAI1E,gBAAJ,CAAqB,KAAKgB,MAA1B,EAAkC,IAAlC,CAAjB;;AACA,SAAK8B,QAAL,CAAcyJ,sBAAd;;AACA,SAAKvJ,WAAL,GAAmB,IAAnB;;AACA,QAAI;AACA,WAAKF,QAAL,CAAc0J,gBAAd;;AACAJ,MAAAA,QAAQ;AACX,KAHD,CAIA,OAAOK,GAAP,EAAY;AACR3N,MAAAA,iBAAiB,CAAC2N,GAAD,CAAjB;AACH;;AACD,SAAKzJ,WAAL,GAAmB,KAAnB;;AACA,SAAKF,QAAL,CAAc4J,uBAAd;;AACA,SAAK7I,0BAAL;;AACA,QAAI,KAAKe,4BAAL,CAAkCnB,eAAlC,EAAmDW,MAAnD,EAA2DiI,kBAA3D,EAA+E3H,QAA/E,EAAyF,KAAzF,CAAJ,EAAqG;AACjG,WAAKgB,oBAAL,CAA0BjC,eAA1B,EAA2CW,MAA3C,EAAmD;AAAE;AAArD,QAAmE,IAAnE,EAAyE;AAAE;AAA3E;AACH;AACJ;;AACDuI,EAAAA,qBAAqB,CAACC,kBAAD,EAAqB;AACtC,SAAK3J,mBAAL,GAA2B2J,kBAA3B;AACH;;AACDC,EAAAA,uBAAuB,GAAG;AACtB,WAAOhM,gBAAgB,CAACM,0BAAjB,CAA4C,KAAKiC,kBAAjD,CAAP;AACH;;AACD0J,EAAAA,gBAAgB,CAACrJ,eAAD,EAAkB;AAC9B,SAAKP,iCAAL,GAAyC,KAAKY,aAAL,GAAqBW,KAArB,CAA2B,CAA3B,CAAzC;AACH;;AACDsI,EAAAA,cAAc,CAACtJ,eAAD,EAAkBW,MAAlB,EAA0B;AACpC,SAAK+H,YAAL,CAAkB,MAAM;AACpB,UAAI/H,MAAM,KAAK,UAAf,EAA2B;AACvB;AACA,aAAK+E,qBAAL,CAA2B7J,cAAc,CAAC0N,8BAAf,CAA8C,KAAK3J,sBAAnD,EAA2E,KAAKR,OAAL,CAAaJ,YAAxF,EAAsG,KAAKzB,MAA3G,EAAmH,KAAKkC,iCAAxH,EAA2J,KAAKY,aAAL,EAA3J,EAAiL,KAAK+I,uBAAL,EAAjL,CAA3B;;AACA,aAAK3J,iCAAL,GAAyC,IAAzC;AACH;AACJ,KAND,EAMGO,eANH,EAMoBW,MANpB;AAOH;;AACDoE,EAAAA,IAAI,CAAC/E,eAAD,EAAkBkH,IAAlB,EAAwBvG,MAAxB,EAAgC;AAChC,SAAK+H,YAAL,CAAkB,MAAM;AACpB,UAAI/H,MAAM,KAAK,UAAf,EAA2B;AACvB;AACA,cAAMxD,GAAG,GAAG+J,IAAI,CAACjK,MAAjB;AACA,YAAIuM,MAAM,GAAG,CAAb;;AACA,eAAOA,MAAM,GAAGrM,GAAhB,EAAqB;AACjB,gBAAMsM,UAAU,GAAGnO,OAAO,CAACoO,cAAR,CAAuBxC,IAAvB,EAA6BsC,MAA7B,CAAnB;AACA,gBAAMG,GAAG,GAAGzC,IAAI,CAAC0C,MAAL,CAAYJ,MAAZ,EAAoBC,UAApB,CAAZ,CAFiB,CAGjB;;AACA,eAAK/D,qBAAL,CAA2B7J,cAAc,CAACgO,oBAAf,CAAoC,KAAKrK,mBAAzC,EAA8D,KAAKI,sBAAnE,EAA2F,KAAKR,OAAL,CAAaJ,YAAxG,EAAsH,KAAKzB,MAA3H,EAAmI,KAAK8C,aAAL,EAAnI,EAAyJ,KAAK+I,uBAAL,EAAzJ,EAAyLO,GAAzL,CAA3B;;AACAH,UAAAA,MAAM,IAAIC,UAAV;AACH;AACJ,OAXD,MAYK;AACD,aAAK/D,qBAAL,CAA2B7J,cAAc,CAACiO,uBAAf,CAAuC,KAAKlK,sBAA5C,EAAoE,KAAKR,OAAL,CAAaJ,YAAjF,EAA+F,KAAKzB,MAApG,EAA4G,KAAK8C,aAAL,EAA5G,EAAkI6G,IAAlI,CAA3B;AACH;AACJ,KAhBD,EAgBGlH,eAhBH,EAgBoBW,MAhBpB;AAiBH;;AACDoJ,EAAAA,eAAe,CAAC/J,eAAD,EAAkBkH,IAAlB,EAAwB8C,kBAAxB,EAA4CC,kBAA5C,EAAgEC,aAAhE,EAA+EvJ,MAA/E,EAAuF;AAClG,QAAIuG,IAAI,CAACjK,MAAL,KAAgB,CAAhB,IAAqB+M,kBAAkB,KAAK,CAA5C,IAAiDC,kBAAkB,KAAK,CAA5E,EAA+E;AAC3E;AACA,UAAIC,aAAa,KAAK,CAAtB,EAAyB;AACrB;AACA,cAAMC,aAAa,GAAG,KAAK9J,aAAL,GAAqBqG,GAArB,CAAyBpE,SAAS,IAAI;AACxD,gBAAMM,QAAQ,GAAGN,SAAS,CAAC8H,WAAV,EAAjB;AACA,iBAAO,IAAIpO,SAAJ,CAAc4G,QAAQ,CAACb,UAAvB,EAAmCa,QAAQ,CAACZ,MAAT,GAAkBkI,aAArD,EAAoEtH,QAAQ,CAACb,UAA7E,EAAyFa,QAAQ,CAACZ,MAAT,GAAkBkI,aAA3G,CAAP;AACH,SAHqB,CAAtB;AAIA,aAAKtF,aAAL,CAAmB5E,eAAnB,EAAoCW,MAApC,EAA4CwJ,aAA5C,EAA2D;AAAE;AAA7D;AACH;;AACD;AACH;;AACD,SAAKzB,YAAL,CAAkB,MAAM;AACpB,WAAKhD,qBAAL,CAA2B7J,cAAc,CAACkO,eAAf,CAA+B,KAAKnK,sBAApC,EAA4D,KAAKR,OAAL,CAAaJ,YAAzE,EAAuF,KAAKzB,MAA5F,EAAoG,KAAK8C,aAAL,EAApG,EAA0H6G,IAA1H,EAAgI8C,kBAAhI,EAAoJC,kBAApJ,EAAwKC,aAAxK,CAA3B;AACH,KAFD,EAEGlK,eAFH,EAEoBW,MAFpB;AAGH;;AACD0J,EAAAA,KAAK,CAACrK,eAAD,EAAkBkH,IAAlB,EAAwBoD,cAAxB,EAAwCC,eAAxC,EAAyD5J,MAAzD,EAAiE;AAClE,SAAK+H,YAAL,CAAkB,MAAM;AACpB,WAAKhD,qBAAL,CAA2B7J,cAAc,CAACwO,KAAf,CAAqB,KAAKjL,OAAL,CAAaJ,YAAlC,EAAgD,KAAKzB,MAArD,EAA6D,KAAK8C,aAAL,EAA7D,EAAmF6G,IAAnF,EAAyFoD,cAAzF,EAAyGC,eAAe,IAAI,EAA5H,CAA3B;AACH,KAFD,EAEGvK,eAFH,EAEoBW,MAFpB,EAE4B;AAAE;AAF9B;AAGH;;AACD6J,EAAAA,GAAG,CAACxK,eAAD,EAAkBW,MAAlB,EAA0B;AACzB,SAAK+H,YAAL,CAAkB,MAAM;AACpB,WAAKhD,qBAAL,CAA2B9J,gBAAgB,CAAC4O,GAAjB,CAAqB,KAAKpL,OAAL,CAAaJ,YAAlC,EAAgD,KAAKzB,MAArD,EAA6D,KAAK8C,aAAL,EAA7D,CAA3B;AACH,KAFD,EAEGL,eAFH,EAEoBW,MAFpB;AAGH;;AACD8J,EAAAA,cAAc,CAACzK,eAAD,EAAkBkG,OAAlB,EAA2BvF,MAA3B,EAAmC;AAC7C,SAAK+H,YAAL,CAAkB,MAAM;AACpB,WAAKrJ,QAAL,CAAcqL,oBAAd;;AACA,WAAKhF,qBAAL,CAA2B,IAAI/J,mBAAJ,CAAwB;AAAE;AAA1B,QAAuC,CAACuK,OAAD,CAAvC,EAAkD;AACzEN,QAAAA,4BAA4B,EAAE,KAD2C;AAEzES,QAAAA,2BAA2B,EAAE;AAF4C,OAAlD,CAA3B;AAIH,KAND,EAMGrG,eANH,EAMoBW,MANpB;AAOH;;AACDoF,EAAAA,eAAe,CAAC/F,eAAD,EAAkBgG,QAAlB,EAA4BrF,MAA5B,EAAoC;AAC/C,SAAK+H,YAAL,CAAkB,MAAM;AACpB,WAAKhD,qBAAL,CAA2B,IAAI/J,mBAAJ,CAAwB;AAAE;AAA1B,QAAuCqK,QAAvC,EAAiD;AACxEJ,QAAAA,4BAA4B,EAAE,KAD0C;AAExES,QAAAA,2BAA2B,EAAE;AAF2C,OAAjD,CAA3B;AAIH,KALD,EAKGrG,eALH,EAKoBW,MALpB;AAMH;;AAlf6C;AAoflD9B,iBAAiB,CAACkC,gBAAlB,GAAqC,KAArC;;AACA,MAAM+E,eAAN,CAAsB;AACI,SAAfC,eAAe,CAACtJ,KAAD,EAAQkO,gBAAR,EAA0B3E,QAA1B,EAAoC;AACtD,UAAM4E,GAAG,GAAG;AACRnO,MAAAA,KAAK,EAAEA,KADC;AAERkO,MAAAA,gBAAgB,EAAEA,gBAFV;AAGRE,MAAAA,aAAa,EAAE,EAHP;AAIRC,MAAAA,sBAAsB,EAAE;AAJhB,KAAZ;;AAMA,UAAM7M,MAAM,GAAG,KAAK8M,qBAAL,CAA2BH,GAA3B,EAAgC5E,QAAhC,CAAf;;AACA,SAAK,IAAI9I,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGyN,GAAG,CAACC,aAAJ,CAAkB5N,MAAxC,EAAgDC,CAAC,GAAGC,GAApD,EAAyDD,CAAC,EAA1D,EAA8D;AAC1D0N,MAAAA,GAAG,CAACnO,KAAJ,CAAUuO,gBAAV,CAA2BJ,GAAG,CAACC,aAAJ,CAAkB3N,CAAlB,CAA3B,EAAiD,IAAjD,EAAuD;AAAE;AAAzD;AACH;;AACD,WAAOe,MAAP;AACH;;AAC2B,SAArB8M,qBAAqB,CAACH,GAAD,EAAM5E,QAAN,EAAgB;AACxC,QAAI,KAAKiF,aAAL,CAAmBjF,QAAnB,CAAJ,EAAkC;AAC9B,aAAO,IAAP;AACH;;AACD,UAAMkF,YAAY,GAAG,KAAKC,kBAAL,CAAwBP,GAAxB,EAA6B5E,QAA7B,CAArB;;AACA,QAAIkF,YAAY,CAACE,UAAb,CAAwBnO,MAAxB,KAAmC,CAAvC,EAA0C;AACtC,aAAO,IAAP;AACH;;AACD,UAAMoO,aAAa,GAAGH,YAAY,CAACE,UAAnC;;AACA,UAAME,eAAe,GAAG,KAAKC,kBAAL,CAAwBF,aAAxB,CAAxB;;AACA,QAAIC,eAAe,CAACE,cAAhB,CAA+B,GAA/B,CAAJ,EAAyC;AACrC;AACAC,MAAAA,OAAO,CAACC,IAAR,CAAa,mBAAb;AACA,aAAO,IAAP;AACH,KAduC,CAexC;;;AACA,QAAIC,kBAAkB,GAAG,EAAzB;;AACA,SAAK,IAAIzO,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGkO,aAAa,CAACpO,MAApC,EAA4CC,CAAC,GAAGC,GAAhD,EAAqDD,CAAC,EAAtD,EAA0D;AACtD,UAAI,CAACoO,eAAe,CAACE,cAAhB,CAA+BH,aAAa,CAACnO,CAAD,CAAb,CAAiB0O,UAAjB,CAA4BC,KAA5B,CAAkCC,QAAlC,EAA/B,CAAL,EAAmF;AAC/EH,QAAAA,kBAAkB,CAACvN,IAAnB,CAAwBiN,aAAa,CAACnO,CAAD,CAArC;AACH;AACJ,KArBuC,CAsBxC;AACA;;;AACA,QAAIgO,YAAY,CAACa,uBAAb,IAAwCJ,kBAAkB,CAAC1O,MAAnB,GAA4B,CAAxE,EAA2E;AACvE0O,MAAAA,kBAAkB,CAAC,CAAD,CAAlB,CAAsBxD,UAAtB,GAAmC,IAAnC;AACH;;AACD,QAAI6D,eAAe,GAAGpB,GAAG,CAACnO,KAAJ,CAAU2L,kBAAV,CAA6BwC,GAAG,CAACD,gBAAjC,EAAmDgB,kBAAnD,EAAwEM,qBAAD,IAA2B;AACpH,UAAIC,4BAA4B,GAAG,EAAnC;;AACA,WAAK,IAAIhP,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0N,GAAG,CAACD,gBAAJ,CAAqB1N,MAAzC,EAAiDC,CAAC,EAAlD,EAAsD;AAClDgP,QAAAA,4BAA4B,CAAChP,CAAD,CAA5B,GAAkC,EAAlC;AACH;;AACD,WAAK,MAAMiP,EAAX,IAAiBF,qBAAjB,EAAwC;AACpC,YAAI,CAACE,EAAE,CAACP,UAAR,EAAoB;AAChB;AACA;AACH;;AACDM,QAAAA,4BAA4B,CAACC,EAAE,CAACP,UAAH,CAAcC,KAAf,CAA5B,CAAkDzN,IAAlD,CAAuD+N,EAAvD;AACH;;AACD,YAAMC,gBAAgB,GAAG,CAACC,CAAD,EAAIC,CAAJ,KAAU;AAC/B,eAAOD,CAAC,CAACT,UAAF,CAAaW,KAAb,GAAqBD,CAAC,CAACV,UAAF,CAAaW,KAAzC;AACH,OAFD;;AAGA,UAAIC,gBAAgB,GAAG,EAAvB;;AACA,WAAK,IAAItP,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0N,GAAG,CAACD,gBAAJ,CAAqB1N,MAAzC,EAAiDC,CAAC,EAAlD,EAAsD;AAClD,YAAIgP,4BAA4B,CAAChP,CAAD,CAA5B,CAAgCD,MAAhC,GAAyC,CAA7C,EAAgD;AAC5CiP,UAAAA,4BAA4B,CAAChP,CAAD,CAA5B,CAAgCwB,IAAhC,CAAqC0N,gBAArC;AACAI,UAAAA,gBAAgB,CAACtP,CAAD,CAAhB,GAAsB8I,QAAQ,CAAC9I,CAAD,CAAR,CAAYuP,kBAAZ,CAA+B7B,GAAG,CAACnO,KAAnC,EAA0C;AAC5DiQ,YAAAA,wBAAwB,EAAE,MAAM;AAC5B,qBAAOR,4BAA4B,CAAChP,CAAD,CAAnC;AACH,aAH2D;AAI5DyP,YAAAA,mBAAmB,EAAGC,EAAD,IAAQ;AACzB,oBAAMC,GAAG,GAAGC,QAAQ,CAACF,EAAD,EAAK,EAAL,CAApB;;AACA,oBAAMvH,KAAK,GAAGuF,GAAG,CAACnO,KAAJ,CAAUsQ,gBAAV,CAA2BnC,GAAG,CAACC,aAAJ,CAAkBgC,GAAlB,CAA3B,CAAd;;AACA,kBAAIjC,GAAG,CAACE,sBAAJ,CAA2B+B,GAA3B,MAAoC;AAAE;AAA1C,gBAAqD;AACjD,uBAAO,IAAI7Q,SAAJ,CAAcqJ,KAAK,CAAC7G,eAApB,EAAqC6G,KAAK,CAACoD,WAA3C,EAAwDpD,KAAK,CAAC5G,aAA9D,EAA6E4G,KAAK,CAAC2H,SAAnF,CAAP;AACH;;AACD,qBAAO,IAAIhR,SAAJ,CAAcqJ,KAAK,CAAC5G,aAApB,EAAmC4G,KAAK,CAAC2H,SAAzC,EAAoD3H,KAAK,CAAC7G,eAA1D,EAA2E6G,KAAK,CAACoD,WAAjF,CAAP;AACH;AAX2D,WAA1C,CAAtB;AAaH,SAfD,MAgBK;AACD+D,UAAAA,gBAAgB,CAACtP,CAAD,CAAhB,GAAsB0N,GAAG,CAACD,gBAAJ,CAAqBzN,CAArB,CAAtB;AACH;AACJ;;AACD,aAAOsP,gBAAP;AACH,KAtCqB,CAAtB;;AAuCA,QAAI,CAACR,eAAL,EAAsB;AAClBA,MAAAA,eAAe,GAAGpB,GAAG,CAACD,gBAAtB;AACH,KApEuC,CAqExC;;;AACA,QAAIsC,aAAa,GAAG,EAApB;;AACA,SAAK,IAAIC,iBAAT,IAA8B5B,eAA9B,EAA+C;AAC3C,UAAIA,eAAe,CAACE,cAAhB,CAA+B0B,iBAA/B,CAAJ,EAAuD;AACnDD,QAAAA,aAAa,CAAC7O,IAAd,CAAmB0O,QAAQ,CAACI,iBAAD,EAAoB,EAApB,CAA3B;AACH;AACJ,KA3EuC,CA4ExC;;;AACAD,IAAAA,aAAa,CAACvO,IAAd,CAAmB,CAAC2N,CAAD,EAAIC,CAAJ,KAAU;AACzB,aAAOA,CAAC,GAAGD,CAAX;AACH,KAFD,EA7EwC,CAgFxC;;AACA,SAAK,MAAMc,YAAX,IAA2BF,aAA3B,EAA0C;AACtCjB,MAAAA,eAAe,CAAC1L,MAAhB,CAAuB6M,YAAvB,EAAqC,CAArC;AACH;;AACD,WAAOnB,eAAP;AACH;;AACmB,SAAbf,aAAa,CAACjF,QAAD,EAAW;AAC3B,SAAK,IAAI9I,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAG6I,QAAQ,CAAC/I,MAA/B,EAAuCC,CAAC,GAAGC,GAA3C,EAAgDD,CAAC,EAAjD,EAAqD;AACjD,UAAI8I,QAAQ,CAAC9I,CAAD,CAAZ,EAAiB;AACb,eAAO,KAAP;AACH;AACJ;;AACD,WAAO,IAAP;AACH;;AACwB,SAAlBiO,kBAAkB,CAACP,GAAD,EAAM5E,QAAN,EAAgB;AACrC,QAAIoF,UAAU,GAAG,EAAjB;AACA,QAAIW,uBAAuB,GAAG,KAA9B;;AACA,SAAK,IAAI7O,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAG6I,QAAQ,CAAC/I,MAA/B,EAAuCC,CAAC,GAAGC,GAA3C,EAAgDD,CAAC,EAAjD,EAAqD;AACjD,YAAMgJ,OAAO,GAAGF,QAAQ,CAAC9I,CAAD,CAAxB;;AACA,UAAIgJ,OAAJ,EAAa;AACT,cAAMkH,CAAC,GAAG,KAAKC,6BAAL,CAAmCzC,GAAnC,EAAwC1N,CAAxC,EAA2CgJ,OAA3C,CAAV;;AACAkF,QAAAA,UAAU,GAAGA,UAAU,CAACtN,MAAX,CAAkBsP,CAAC,CAAChC,UAApB,CAAb;AACAW,QAAAA,uBAAuB,GAAGA,uBAAuB,IAAIqB,CAAC,CAACrB,uBAAvD;AACH;AACJ;;AACD,WAAO;AACHX,MAAAA,UAAU,EAAEA,UADT;AAEHW,MAAAA,uBAAuB,EAAEA;AAFtB,KAAP;AAIH;;AACmC,SAA7BsB,6BAA6B,CAACzC,GAAD,EAAM0C,eAAN,EAAuBpH,OAAvB,EAAgC;AAChE;AACA;AACA,QAAIkF,UAAU,GAAG,EAAjB;AACA,QAAImC,cAAc,GAAG,CAArB;;AACA,UAAMC,gBAAgB,GAAG,UAACnI,KAAD,EAAQ6B,IAAR,EAA2C;AAAA,UAA7BuG,gBAA6B,uEAAV,KAAU;;AAChE,UAAI1R,KAAK,CAACyG,OAAN,CAAc6C,KAAd,KAAwB6B,IAAI,KAAK,EAArC,EAAyC;AACrC;AACA;AACH;;AACDkE,MAAAA,UAAU,CAAChN,IAAX,CAAgB;AACZwN,QAAAA,UAAU,EAAE;AACRC,UAAAA,KAAK,EAAEyB,eADC;AAERf,UAAAA,KAAK,EAAEgB,cAAc;AAFb,SADA;AAKZlI,QAAAA,KAAK,EAAEA,KALK;AAMZ6B,QAAAA,IAAI,EAAEA,IANM;AAOZuG,QAAAA,gBAAgB,EAAEA,gBAPN;AAQZC,QAAAA,oBAAoB,EAAExH,OAAO,CAACyH;AARlB,OAAhB;AAUH,KAfD;;AAgBA,QAAI5B,uBAAuB,GAAG,KAA9B;;AACA,UAAM6B,uBAAuB,GAAG,CAACtL,SAAD,EAAY4E,IAAZ,EAAkBuG,gBAAlB,KAAuC;AACnE1B,MAAAA,uBAAuB,GAAG,IAA1B;AACAyB,MAAAA,gBAAgB,CAAClL,SAAD,EAAY4E,IAAZ,EAAkBuG,gBAAlB,CAAhB;AACH,KAHD;;AAIA,UAAMI,cAAc,GAAG,CAACC,UAAD,EAAaC,oBAAb,KAAsC;AACzD,YAAMzL,SAAS,GAAGtG,SAAS,CAACgS,aAAV,CAAwBF,UAAxB,CAAlB;AACA,UAAIrI,UAAJ;;AACA,UAAInD,SAAS,CAACE,OAAV,EAAJ,EAAyB;AACrB,YAAI,OAAOuL,oBAAP,KAAgC,SAApC,EAA+C;AAC3C,cAAIA,oBAAJ,EAA0B;AACtBtI,YAAAA,UAAU,GAAG;AAAE;AAAf;AACH,WAFD,MAGK;AACDA,YAAAA,UAAU,GAAG;AAAE;AAAf;AACH;AACJ,SAPD,MAQK;AACD;AACA,gBAAMwI,aAAa,GAAGrD,GAAG,CAACnO,KAAJ,CAAUyR,gBAAV,CAA2B5L,SAAS,CAAC9D,eAArC,CAAtB;;AACA,cAAI8D,SAAS,CAACmG,WAAV,KAA0BwF,aAA9B,EAA6C;AACzCxI,YAAAA,UAAU,GAAG;AAAE;AAAf;AACH,WAFD,MAGK;AACDA,YAAAA,UAAU,GAAG;AAAE;AAAf;AACH;AACJ;AACJ,OAnBD,MAoBK;AACDA,QAAAA,UAAU,GAAG;AAAE;AAAf;AACH;;AACD,YAAM0I,CAAC,GAAGvD,GAAG,CAACC,aAAJ,CAAkB5N,MAA5B;;AACA,YAAM2P,EAAE,GAAGhC,GAAG,CAACnO,KAAJ,CAAUuO,gBAAV,CAA2B,IAA3B,EAAiC1I,SAAjC,EAA4CmD,UAA5C,CAAX;;AACAmF,MAAAA,GAAG,CAACC,aAAJ,CAAkBsD,CAAlB,IAAuBvB,EAAvB;AACAhC,MAAAA,GAAG,CAACE,sBAAJ,CAA2BqD,CAA3B,IAAgC7L,SAAS,CAAC8L,YAAV,EAAhC;AACA,aAAOD,CAAC,CAACrC,QAAF,EAAP;AACH,KA/BD;;AAgCA,UAAMuC,oBAAoB,GAAG;AACzBb,MAAAA,gBAAgB,EAAEA,gBADO;AAEzBI,MAAAA,uBAAuB,EAAEA,uBAFA;AAGzBC,MAAAA,cAAc,EAAEA;AAHS,KAA7B;;AAKA,QAAI;AACA3H,MAAAA,OAAO,CAACoI,iBAAR,CAA0B1D,GAAG,CAACnO,KAA9B,EAAqC4R,oBAArC;AACH,KAFD,CAGA,OAAOjL,CAAP,EAAU;AACN;AACA;AACA/H,MAAAA,iBAAiB,CAAC+H,CAAD,CAAjB;AACA,aAAO;AACHgI,QAAAA,UAAU,EAAE,EADT;AAEHW,QAAAA,uBAAuB,EAAE;AAFtB,OAAP;AAIH;;AACD,WAAO;AACHX,MAAAA,UAAU,EAAEA,UADT;AAEHW,MAAAA,uBAAuB,EAAEA;AAFtB,KAAP;AAIH;;AACwB,SAAlBR,kBAAkB,CAACH,UAAD,EAAa;AAClC;AACAA,IAAAA,UAAU,GAAGA,UAAU,CAACpK,KAAX,CAAiB,CAAjB,CAAb,CAFkC,CAGlC;;AACAoK,IAAAA,UAAU,CAAC1M,IAAX,CAAgB,CAAC2N,CAAD,EAAIC,CAAJ,KAAU;AACtB;AACA,aAAO,CAAEvQ,KAAK,CAACwS,sBAAN,CAA6BlC,CAAC,CAAChH,KAA/B,EAAsCiH,CAAC,CAACjH,KAAxC,CAAT;AACH,KAHD,EAJkC,CAQlC;;AACA,QAAIiG,eAAe,GAAG,EAAtB;;AACA,SAAK,IAAIpO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkO,UAAU,CAACnO,MAA/B,EAAuCC,CAAC,EAAxC,EAA4C;AACxC,YAAMsR,UAAU,GAAGpD,UAAU,CAAClO,CAAC,GAAG,CAAL,CAA7B;AACA,YAAMuR,SAAS,GAAGrD,UAAU,CAAClO,CAAD,CAA5B;;AACA,UAAInB,KAAK,CAACsI,gBAAN,CAAuBmK,UAAU,CAACnJ,KAAlC,EAAyCqJ,QAAzC,CAAkD3S,KAAK,CAAC4S,cAAN,CAAqBF,SAAS,CAACpJ,KAA/B,CAAlD,CAAJ,EAA8F;AAC1F,YAAIuJ,UAAJ;;AACA,YAAIJ,UAAU,CAAC5C,UAAX,CAAsBC,KAAtB,GAA8B4C,SAAS,CAAC7C,UAAV,CAAqBC,KAAvD,EAA8D;AAC1D;AACA+C,UAAAA,UAAU,GAAGJ,UAAU,CAAC5C,UAAX,CAAsBC,KAAnC;AACH,SAHD,MAIK;AACD+C,UAAAA,UAAU,GAAGH,SAAS,CAAC7C,UAAV,CAAqBC,KAAlC;AACH;;AACDP,QAAAA,eAAe,CAACsD,UAAU,CAAC9C,QAAX,EAAD,CAAf,GAAyC,IAAzC;;AACA,aAAK,IAAI+C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzD,UAAU,CAACnO,MAA/B,EAAuC4R,CAAC,EAAxC,EAA4C;AACxC,cAAIzD,UAAU,CAACyD,CAAD,CAAV,CAAcjD,UAAd,CAAyBC,KAAzB,KAAmC+C,UAAvC,EAAmD;AAC/CxD,YAAAA,UAAU,CAAC9K,MAAX,CAAkBuO,CAAlB,EAAqB,CAArB;;AACA,gBAAIA,CAAC,GAAG3R,CAAR,EAAW;AACPA,cAAAA,CAAC;AACJ;;AACD2R,YAAAA,CAAC;AACJ;AACJ;;AACD,YAAI3R,CAAC,GAAG,CAAR,EAAW;AACPA,UAAAA,CAAC;AACJ;AACJ;AACJ;;AACD,WAAOoO,eAAP;AACH;;AAlPiB","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorColumns, CursorContext, CursorState, EditOperationResult } from './cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../model/textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../view/viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModel/viewModelEventDispatcher.js';\n/**\n * A snapshot of the cursor and the model state\n */\nexport class CursorModelState {\n    constructor(model, cursor) {\n        this.modelVersionId = model.getVersionId();\n        this.cursorState = cursor.getCursorStates();\n    }\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        if (this.modelVersionId !== other.modelVersionId) {\n            return false;\n        }\n        if (this.cursorState.length !== other.cursorState.length) {\n            return false;\n        }\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass AutoClosedAction {\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n        this._model = model;\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n    }\n    static getAllAutoClosedCharacters(autoClosedActions) {\n        let autoClosedCharacters = [];\n        for (const autoClosedAction of autoClosedActions) {\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n        return autoClosedCharacters;\n    }\n    dispose() {\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n    getAutoClosedCharactersRanges() {\n        let result = [];\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n            if (decorationRange) {\n                result.push(decorationRange);\n            }\n        }\n        return result;\n    }\n    isValid(selections) {\n        let enclosingRanges = [];\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n            if (decorationRange) {\n                enclosingRanges.push(decorationRange);\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n                    // Stop tracking if the range becomes multiline...\n                    return false;\n                }\n            }\n        }\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\n        selections.sort(Range.compareRangesUsingStarts);\n        for (let i = 0; i < selections.length; i++) {\n            if (i >= enclosingRanges.length) {\n                return false;\n            }\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nexport class CursorsController extends Disposable {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        super();\n        this._model = model;\n        this._knownModelVersionId = this._model.getVersionId();\n        this._viewModel = viewModel;\n        this._coordinatesConverter = coordinatesConverter;\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors = new CursorCollection(this.context);\n        this._hasFocus = false;\n        this._isHandling = false;\n        this._isDoingComposition = false;\n        this._selectionsWhenCompositionStarted = null;\n        this._columnSelectData = null;\n        this._autoClosedActions = [];\n        this._prevEditOperationType = 0 /* Other */;\n    }\n    dispose() {\n        this._cursors.dispose();\n        this._autoClosedActions = dispose(this._autoClosedActions);\n        super.dispose();\n    }\n    updateConfiguration(cursorConfig) {\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors.updateContext(this.context);\n    }\n    onLineMappingChanged(eventsCollector) {\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\n            // There are model change events that I didn't yet receive.\n            //\n            // This can happen when editing the model, and the view model receives the change events first,\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\n            // recover from markers.\n            //\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n            return;\n        }\n        // Ensure valid state\n        this.setStates(eventsCollector, 'viewModel', 0 /* NotSet */, this.getCursorStates());\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n    }\n    _validateAutoClosedActions() {\n        if (this._autoClosedActions.length > 0) {\n            let selections = this._cursors.getSelections();\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\n                const autoClosedAction = this._autoClosedActions[i];\n                if (!autoClosedAction.isValid(selections)) {\n                    autoClosedAction.dispose();\n                    this._autoClosedActions.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n    // ------ some getters/setters\n    getPrimaryCursorState() {\n        return this._cursors.getPrimaryCursor();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursors.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursors.getAll();\n    }\n    setStates(eventsCollector, source, reason, states) {\n        let reachedMaxCursorCount = false;\n        if (states !== null && states.length > CursorsController.MAX_CURSOR_COUNT) {\n            states = states.slice(0, CursorsController.MAX_CURSOR_COUNT);\n            reachedMaxCursorCount = true;\n        }\n        const oldState = new CursorModelState(this._model, this);\n        this._cursors.setStates(states);\n        this._cursors.normalize();\n        this._columnSelectData = null;\n        this._validateAutoClosedActions();\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._columnSelectData = columnSelectData;\n    }\n    revealPrimary(eventsCollector, source, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        if (viewPositions.length > 1) {\n            this._emitCursorRevealRange(eventsCollector, source, null, this._cursors.getViewSelections(), 0 /* Simple */, revealHorizontal, scrollType);\n            return;\n        }\n        else {\n            const viewPosition = viewPositions[0];\n            const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n            this._emitCursorRevealRange(eventsCollector, source, viewRange, null, 0 /* Simple */, revealHorizontal, scrollType);\n        }\n    }\n    _revealPrimaryCursor(eventsCollector, source, verticalType, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        if (viewPositions.length > 1) {\n            this._emitCursorRevealRange(eventsCollector, source, null, this._cursors.getViewSelections(), verticalType, revealHorizontal, scrollType);\n        }\n        else {\n            const viewPosition = viewPositions[0];\n            const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n            this._emitCursorRevealRange(eventsCollector, source, viewRange, null, verticalType, revealHorizontal, scrollType);\n        }\n    }\n    _emitCursorRevealRange(eventsCollector, source, viewRange, viewSelections, verticalType, revealHorizontal, scrollType) {\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, viewRange, viewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    saveState() {\n        let result = [];\n        const selections = this._cursors.getSelections();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            result.push({\n                inSelectionMode: !selection.isEmpty(),\n                selectionStart: {\n                    lineNumber: selection.selectionStartLineNumber,\n                    column: selection.selectionStartColumn,\n                },\n                position: {\n                    lineNumber: selection.positionLineNumber,\n                    column: selection.positionColumn,\n                }\n            });\n        }\n        return result;\n    }\n    restoreState(eventsCollector, states) {\n        let desiredSelections = [];\n        for (let i = 0, len = states.length; i < len; i++) {\n            const state = states[i];\n            let positionLineNumber = 1;\n            let positionColumn = 1;\n            // Avoid missing properties on the literal\n            if (state.position && state.position.lineNumber) {\n                positionLineNumber = state.position.lineNumber;\n            }\n            if (state.position && state.position.column) {\n                positionColumn = state.position.column;\n            }\n            let selectionStartLineNumber = positionLineNumber;\n            let selectionStartColumn = positionColumn;\n            // Avoid missing properties on the literal\n            if (state.selectionStart && state.selectionStart.lineNumber) {\n                selectionStartLineNumber = state.selectionStart.lineNumber;\n            }\n            if (state.selectionStart && state.selectionStart.column) {\n                selectionStartColumn = state.selectionStart.column;\n            }\n            desiredSelections.push({\n                selectionStartLineNumber: selectionStartLineNumber,\n                selectionStartColumn: selectionStartColumn,\n                positionLineNumber: positionLineNumber,\n                positionColumn: positionColumn\n            });\n        }\n        this.setStates(eventsCollector, 'restoreState', 0 /* NotSet */, CursorState.fromModelSelections(desiredSelections));\n        this.revealPrimary(eventsCollector, 'restoreState', true, 1 /* Immediate */);\n    }\n    onModelContentChanged(eventsCollector, e) {\n        if (e instanceof ModelInjectedTextChangedEvent) {\n            // If injected texts change, the view positions of all cursors need to be updated.\n            if (this._isHandling) {\n                // The view positions will be updated when handling finishes\n                return;\n            }\n            // setStates might remove markers, which could trigger a decoration change.\n            // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n            // and an endless recursion happens.\n            // _isHandling prevents that.\n            this._isHandling = true;\n            try {\n                this.setStates(eventsCollector, 'modelChange', 0 /* NotSet */, this.getCursorStates());\n            }\n            finally {\n                this._isHandling = false;\n            }\n        }\n        else {\n            this._knownModelVersionId = e.versionId;\n            if (this._isHandling) {\n                return;\n            }\n            const hadFlushEvent = e.containsEvent(1 /* Flush */);\n            this._prevEditOperationType = 0 /* Other */;\n            if (hadFlushEvent) {\n                // a model.setValue() was called\n                this._cursors.dispose();\n                this._cursors = new CursorCollection(this.context);\n                this._validateAutoClosedActions();\n                this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* ContentFlush */, null, false);\n            }\n            else {\n                if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n                    const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n                    if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* Undo */ : e.isRedoing ? 6 /* Redo */ : 2 /* RecoverFromMarkers */, cursorState)) {\n                        this._revealPrimaryCursor(eventsCollector, 'modelChange', 0 /* Simple */, true, 0 /* Smooth */);\n                    }\n                }\n                else {\n                    const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n                    this.setStates(eventsCollector, 'modelChange', 2 /* RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n                }\n            }\n        }\n    }\n    getSelection() {\n        return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n    getTopMostViewPosition() {\n        return this._cursors.getTopMostViewPosition();\n    }\n    getBottomMostViewPosition() {\n        return this._cursors.getBottomMostViewPosition();\n    }\n    getCursorColumnSelectData() {\n        if (this._columnSelectData) {\n            return this._columnSelectData;\n        }\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n        const viewPosition = primaryCursor.viewState.position;\n        return {\n            isReal: false,\n            fromViewLineNumber: viewSelectionStart.lineNumber,\n            fromViewVisualColumn: CursorColumns.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, viewSelectionStart),\n            toViewLineNumber: viewPosition.lineNumber,\n            toViewVisualColumn: CursorColumns.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, viewPosition),\n        };\n    }\n    getSelections() {\n        return this._cursors.getSelections();\n    }\n    setSelections(eventsCollector, source, selections, reason) {\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n    getPrevEditOperationType() {\n        return this._prevEditOperationType;\n    }\n    setPrevEditOperationType(type) {\n        this._prevEditOperationType = type;\n    }\n    // ------ auxiliary handling logic\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n        let autoClosedCharactersDeltaDecorations = [];\n        let autoClosedEnclosingDeltaDecorations = [];\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n            autoClosedCharactersDeltaDecorations.push({\n                range: autoClosedCharactersRanges[i],\n                options: {\n                    description: 'auto-closed-character',\n                    inlineClassName: 'auto-closed-character',\n                    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */\n                }\n            });\n            autoClosedEnclosingDeltaDecorations.push({\n                range: autoClosedEnclosingRanges[i],\n                options: {\n                    description: 'auto-closed-enclosing',\n                    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */\n                }\n            });\n        }\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n    _executeEditOperation(opResult) {\n        if (!opResult) {\n            // Nothing to execute\n            return;\n        }\n        if (opResult.shouldPushStackElementBefore) {\n            this._model.pushStackElement();\n        }\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n        if (result) {\n            // The commands were applied correctly\n            this._interpretCommandResult(result);\n            // Check for auto-closing closed characters\n            let autoClosedCharactersRanges = [];\n            let autoClosedEnclosingRanges = [];\n            for (let i = 0; i < opResult.commands.length; i++) {\n                const command = opResult.commands[i];\n                if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\n                }\n            }\n            if (autoClosedCharactersRanges.length > 0) {\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n            }\n            this._prevEditOperationType = opResult.type;\n        }\n        if (opResult.shouldPushStackElementAfter) {\n            this._model.pushStackElement();\n        }\n    }\n    _interpretCommandResult(cursorState) {\n        if (!cursorState || cursorState.length === 0) {\n            cursorState = this._cursors.readSelectionFromMarkers();\n        }\n        this._columnSelectData = null;\n        this._cursors.setSelections(cursorState);\n        this._cursors.normalize();\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n        const newState = new CursorModelState(this._model, this);\n        if (newState.equals(oldState)) {\n            return false;\n        }\n        const selections = this._cursors.getSelections();\n        const viewSelections = this._cursors.getViewSelections();\n        // Let the view get the event first.\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections));\n        // Only after the view has been notified, let the rest of the world know...\n        if (!oldState\n            || oldState.cursorState.length !== newState.cursorState.length\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n        }\n        return true;\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n    _findAutoClosingPairs(edits) {\n        if (!edits.length) {\n            return null;\n        }\n        let indices = [];\n        for (let i = 0, len = edits.length; i < len; i++) {\n            const edit = edits[i];\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n                return null;\n            }\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n            if (!m) {\n                return null;\n            }\n            const closeChar = m[1];\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n                return null;\n            }\n            const openChar = autoClosingPairsCandidates[0].open;\n            const closeCharIndex = edit.text.length - m[2].length - 1;\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n            if (openCharIndex === -1) {\n                return null;\n            }\n            indices.push([openCharIndex, closeCharIndex]);\n        }\n        return indices;\n    }\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n        let autoClosingIndices = null;\n        if (source === 'snippet') {\n            autoClosingIndices = this._findAutoClosingPairs(edits);\n        }\n        if (autoClosingIndices) {\n            edits[0]._isTracked = true;\n        }\n        let autoClosedCharactersRanges = [];\n        let autoClosedEnclosingRanges = [];\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n            if (autoClosingIndices) {\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n                    const undoEdit = undoEdits[i];\n                    const lineNumber = undoEdit.range.startLineNumber;\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n                }\n            }\n            const selections = cursorStateComputer(undoEdits);\n            if (selections) {\n                // Don't recover the selection from markers because\n                // we know what it should be.\n                this._isHandling = true;\n            }\n            return selections;\n        });\n        if (selections) {\n            this._isHandling = false;\n            this.setSelections(eventsCollector, source, selections, 0 /* NotSet */);\n        }\n        if (autoClosedCharactersRanges.length > 0) {\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n    }\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* NotSet */) {\n        if (this.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            return;\n        }\n        const oldState = new CursorModelState(this._model, this);\n        this._cursors.stopTrackingSelections();\n        this._isHandling = true;\n        try {\n            this._cursors.ensureValidState();\n            callback();\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n        this._isHandling = false;\n        this._cursors.startTrackingSelections();\n        this._validateAutoClosedActions();\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n            this._revealPrimaryCursor(eventsCollector, source, 0 /* Simple */, true, 0 /* Smooth */);\n        }\n    }\n    setIsDoingComposition(isDoingComposition) {\n        this._isDoingComposition = isDoingComposition;\n    }\n    getAutoClosedCharacters() {\n        return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n    }\n    startComposition(eventsCollector) {\n        this._selectionsWhenCompositionStarted = this.getSelections().slice(0);\n    }\n    endComposition(eventsCollector, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // composition finishes, let's check if we need to auto complete if necessary.\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this._selectionsWhenCompositionStarted, this.getSelections(), this.getAutoClosedCharacters()));\n                this._selectionsWhenCompositionStarted = null;\n            }\n        }, eventsCollector, source);\n    }\n    type(eventsCollector, text, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // If this event is coming straight from the keyboard, look for electric characters and enter\n                const len = text.length;\n                let offset = 0;\n                while (offset < len) {\n                    const charLength = strings.nextCharLength(text, offset);\n                    const chr = text.substr(offset, charLength);\n                    // Here we must interpret each typed character individually\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(this._isDoingComposition, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n                    offset += charLength;\n                }\n            }\n            else {\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n            }\n        }, eventsCollector, source);\n    }\n    compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n            // this edit is a no-op\n            if (positionDelta !== 0) {\n                // but it still wants to move the cursor\n                const newSelections = this.getSelections().map(selection => {\n                    const position = selection.getPosition();\n                    return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n                });\n                this.setSelections(eventsCollector, source, newSelections, 0 /* NotSet */);\n            }\n            return;\n        }\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        }, eventsCollector, source);\n    }\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n        }, eventsCollector, source, 4 /* Paste */);\n    }\n    cut(eventsCollector, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n        }, eventsCollector, source);\n    }\n    executeCommand(eventsCollector, command, source) {\n        this._executeEdit(() => {\n            this._cursors.killSecondaryCursors();\n            this._executeEditOperation(new EditOperationResult(0 /* Other */, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n    executeCommands(eventsCollector, commands, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(new EditOperationResult(0 /* Other */, commands, {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n}\nCursorsController.MAX_CURSOR_COUNT = 10000;\nclass CommandExecutor {\n    static executeCommands(model, selectionsBefore, commands) {\n        const ctx = {\n            model: model,\n            selectionsBefore: selectionsBefore,\n            trackedRanges: [],\n            trackedRangesDirection: []\n        };\n        const result = this._innerExecuteCommands(ctx, commands);\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* AlwaysGrowsWhenTypingAtEdges */);\n        }\n        return result;\n    }\n    static _innerExecuteCommands(ctx, commands) {\n        if (this._arrayIsEmpty(commands)) {\n            return null;\n        }\n        const commandsData = this._getEditOperations(ctx, commands);\n        if (commandsData.operations.length === 0) {\n            return null;\n        }\n        const rawOperations = commandsData.operations;\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n        if (loserCursorsMap.hasOwnProperty('0')) {\n            // These commands are very messed up\n            console.warn('Ignoring commands');\n            return null;\n        }\n        // Remove operations belonging to losing cursors\n        let filteredOperations = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                filteredOperations.push(rawOperations[i]);\n            }\n        }\n        // TODO@Alex: find a better way to do this.\n        // give the hint that edit operations are tracked to the model\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n            filteredOperations[0]._isTracked = true;\n        }\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\n            let groupedInverseEditOperations = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                groupedInverseEditOperations[i] = [];\n            }\n            for (const op of inverseEditOperations) {\n                if (!op.identifier) {\n                    // perhaps auto whitespace trim edits\n                    continue;\n                }\n                groupedInverseEditOperations[op.identifier.major].push(op);\n            }\n            const minorBasedSorter = (a, b) => {\n                return a.identifier.minor - b.identifier.minor;\n            };\n            let cursorSelections = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                if (groupedInverseEditOperations[i].length > 0) {\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                        getInverseEditOperations: () => {\n                            return groupedInverseEditOperations[i];\n                        },\n                        getTrackedSelection: (id) => {\n                            const idx = parseInt(id, 10);\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                            if (ctx.trackedRangesDirection[idx] === 0 /* LTR */) {\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                            }\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                        }\n                    });\n                }\n                else {\n                    cursorSelections[i] = ctx.selectionsBefore[i];\n                }\n            }\n            return cursorSelections;\n        });\n        if (!selectionsAfter) {\n            selectionsAfter = ctx.selectionsBefore;\n        }\n        // Extract losing cursors\n        let losingCursors = [];\n        for (let losingCursorIndex in loserCursorsMap) {\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                losingCursors.push(parseInt(losingCursorIndex, 10));\n            }\n        }\n        // Sort losing cursors descending\n        losingCursors.sort((a, b) => {\n            return b - a;\n        });\n        // Remove losing cursors\n        for (const losingCursor of losingCursors) {\n            selectionsAfter.splice(losingCursor, 1);\n        }\n        return selectionsAfter;\n    }\n    static _arrayIsEmpty(commands) {\n        for (let i = 0, len = commands.length; i < len; i++) {\n            if (commands[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _getEditOperations(ctx, commands) {\n        let operations = [];\n        let hadTrackedEditOperation = false;\n        for (let i = 0, len = commands.length; i < len; i++) {\n            const command = commands[i];\n            if (command) {\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\n                operations = operations.concat(r.operations);\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n            }\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n        // This method acts as a transaction, if the command fails\n        // everything it has done is ignored\n        let operations = [];\n        let operationMinor = 0;\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\n            if (Range.isEmpty(range) && text === '') {\n                // This command wants to add a no-op => no thank you\n                return;\n            }\n            operations.push({\n                identifier: {\n                    major: majorIdentifier,\n                    minor: operationMinor++\n                },\n                range: range,\n                text: text,\n                forceMoveMarkers: forceMoveMarkers,\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\n            });\n        };\n        let hadTrackedEditOperation = false;\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n            hadTrackedEditOperation = true;\n            addEditOperation(selection, text, forceMoveMarkers);\n        };\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\n            const selection = Selection.liftSelection(_selection);\n            let stickiness;\n            if (selection.isEmpty()) {\n                if (typeof trackPreviousOnEmpty === 'boolean') {\n                    if (trackPreviousOnEmpty) {\n                        stickiness = 2 /* GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n                else {\n                    // Try to lock it with surrounding text\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn === maxLineColumn) {\n                        stickiness = 2 /* GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n            }\n            else {\n                stickiness = 1 /* NeverGrowsWhenTypingAtEdges */;\n            }\n            const l = ctx.trackedRanges.length;\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\n            ctx.trackedRanges[l] = id;\n            ctx.trackedRangesDirection[l] = selection.getDirection();\n            return l.toString();\n        };\n        const editOperationBuilder = {\n            addEditOperation: addEditOperation,\n            addTrackedEditOperation: addTrackedEditOperation,\n            trackSelection: trackSelection\n        };\n        try {\n            command.getEditOperations(ctx.model, editOperationBuilder);\n        }\n        catch (e) {\n            // TODO@Alex use notification service if this should be user facing\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n            onUnexpectedError(e);\n            return {\n                operations: [],\n                hadTrackedEditOperation: false\n            };\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getLoserCursorMap(operations) {\n        // This is destructive on the array\n        operations = operations.slice(0);\n        // Sort operations with last one first\n        operations.sort((a, b) => {\n            // Note the minus!\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\n        });\n        // Operations can not overlap!\n        let loserCursorsMap = {};\n        for (let i = 1; i < operations.length; i++) {\n            const previousOp = operations[i - 1];\n            const currentOp = operations[i];\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n                let loserMajor;\n                if (previousOp.identifier.major > currentOp.identifier.major) {\n                    // previousOp loses the battle\n                    loserMajor = previousOp.identifier.major;\n                }\n                else {\n                    loserMajor = currentOp.identifier.major;\n                }\n                loserCursorsMap[loserMajor.toString()] = true;\n                for (let j = 0; j < operations.length; j++) {\n                    if (operations[j].identifier.major === loserMajor) {\n                        operations.splice(j, 1);\n                        if (j < i) {\n                            i--;\n                        }\n                        j--;\n                    }\n                }\n                if (i > 0) {\n                    i--;\n                }\n            }\n        }\n        return loserCursorsMap;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}