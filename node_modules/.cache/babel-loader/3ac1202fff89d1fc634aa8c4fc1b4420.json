{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../model/wordHelper.js';\nimport { IndentAction, AutoClosingPairs } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { IModeService } from '../services/modeService.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nexport class LanguageConfigurationServiceChangeEvent {\n  constructor(languageId) {\n    this.languageId = languageId;\n  }\n\n  affects(languageId) {\n    return !this.languageId ? true : this.languageId === languageId;\n  }\n\n}\nexport const ILanguageConfigurationService = createDecorator('languageConfigurationService');\nlet LanguageConfigurationService = class LanguageConfigurationService extends Disposable {\n  constructor(configurationService, modeService) {\n    super();\n    this.configurationService = configurationService;\n    this.modeService = modeService;\n    this.onDidChangeEmitter = this._register(new Emitter());\n    this.onDidChange = this.onDidChangeEmitter.event;\n    this.configurations = new Map();\n    const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));\n\n    this._register(this.configurationService.onDidChangeConfiguration(e => {\n      const globalConfigChanged = e.change.keys.some(k => languageConfigKeys.has(k));\n      const localConfigChanged = e.change.overrides.filter(_ref => {\n        let [overrideLangName, keys] = _ref;\n        return keys.some(k => languageConfigKeys.has(k));\n      }).map(_ref2 => {\n        let [overrideLangName] = _ref2;\n        return this.modeService.validateLanguageId(overrideLangName);\n      });\n\n      if (globalConfigChanged) {\n        this.configurations.clear();\n        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));\n      } else {\n        for (const languageId of localConfigChanged) {\n          if (languageId) {\n            this.configurations.delete(languageId);\n            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));\n          }\n        }\n      }\n    }));\n\n    this._register(LanguageConfigurationRegistry.onDidChange(e => {\n      this.configurations.delete(e.languageId);\n      this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));\n    }));\n  }\n\n  getLanguageConfiguration(languageId) {\n    let result = this.configurations.get(languageId);\n\n    if (!result) {\n      result = computeConfig(languageId, this.configurationService, this.modeService);\n      this.configurations.set(languageId, result);\n    }\n\n    return result;\n  }\n\n};\nLanguageConfigurationService = __decorate([__param(0, IConfigurationService), __param(1, IModeService)], LanguageConfigurationService);\nexport { LanguageConfigurationService };\n\nfunction computeConfig(languageId, configurationService, modeService) {\n  let languageConfig = LanguageConfigurationRegistry.getLanguageConfiguration(languageId);\n\n  if (!languageConfig) {\n    const validLanguageId = modeService.validateLanguageId(languageId);\n\n    if (!validLanguageId) {\n      throw new Error('Unexpected languageId');\n    }\n\n    languageConfig = new ResolvedLanguageConfiguration(validLanguageId, {});\n  }\n\n  const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);\n  const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);\n  const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);\n  return config;\n}\n\nconst customizedLanguageConfigKeys = {\n  brackets: 'editor.language.brackets',\n  colorizedBracketPairs: 'editor.language.colorizedBracketPairs'\n};\n\nfunction getCustomizedLanguageConfig(languageId, configurationService) {\n  const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {\n    overrideIdentifier: languageId\n  });\n  const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {\n    overrideIdentifier: languageId\n  });\n  return {\n    brackets: validateBracketPairs(brackets),\n    colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs)\n  };\n}\n\nfunction validateBracketPairs(data) {\n  if (!Array.isArray(data)) {\n    return undefined;\n  }\n\n  return data.map(pair => {\n    if (!Array.isArray(pair) || pair.length !== 2) {\n      return undefined;\n    }\n\n    return [pair[0], pair[1]];\n  }).filter(p => !!p);\n}\n\nexport class LanguageConfigurationChangeEvent {\n  constructor(languageId) {\n    this.languageId = languageId;\n  }\n\n}\nexport class LanguageConfigurationRegistryImpl {\n  constructor() {\n    this._entries = new Map();\n    this._onDidChange = new Emitter();\n    this.onDidChange = this._onDidChange.event;\n  }\n  /**\n   * @param priority Use a higher number for higher priority\n   */\n\n\n  register(languageId, configuration) {\n    let priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    let entries = this._entries.get(languageId);\n\n    if (!entries) {\n      entries = new ComposedLanguageConfiguration(languageId);\n\n      this._entries.set(languageId, entries);\n    }\n\n    const disposable = entries.register(configuration, priority);\n\n    this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n\n    return toDisposable(() => {\n      disposable.dispose();\n\n      this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n    });\n  }\n\n  getLanguageConfiguration(languageId) {\n    let entries = this._entries.get(languageId);\n\n    return (entries === null || entries === void 0 ? void 0 : entries.getResolvedConfiguration()) || null;\n  }\n\n  getIndentationRules(languageId) {\n    const value = this.getLanguageConfiguration(languageId);\n    return value ? value.indentationRules || null : null;\n  } // begin electricCharacter\n\n\n  _getElectricCharacterSupport(languageId) {\n    let value = this.getLanguageConfiguration(languageId);\n\n    if (!value) {\n      return null;\n    }\n\n    return value.electricCharacter || null;\n  }\n\n  getElectricCharacters(languageId) {\n    let electricCharacterSupport = this._getElectricCharacterSupport(languageId);\n\n    if (!electricCharacterSupport) {\n      return [];\n    }\n\n    return electricCharacterSupport.getElectricCharacters();\n  }\n  /**\n   * Should return opening bracket type to match indentation with\n   */\n\n\n  onElectricCharacter(character, context, column) {\n    let scopedLineTokens = createScopedLineTokens(context, column - 1);\n\n    let electricCharacterSupport = this._getElectricCharacterSupport(scopedLineTokens.languageId);\n\n    if (!electricCharacterSupport) {\n      return null;\n    }\n\n    return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n  } // end electricCharacter\n\n\n  getComments(languageId) {\n    let value = this.getLanguageConfiguration(languageId);\n\n    if (!value) {\n      return null;\n    }\n\n    return value.comments || null;\n  } // begin characterPair\n\n\n  _getCharacterPairSupport(languageId) {\n    let value = this.getLanguageConfiguration(languageId);\n\n    if (!value) {\n      return null;\n    }\n\n    return value.characterPair || null;\n  }\n\n  getAutoClosingPairs(languageId) {\n    const characterPairSupport = this._getCharacterPairSupport(languageId);\n\n    return new AutoClosingPairs(characterPairSupport ? characterPairSupport.getAutoClosingPairs() : []);\n  }\n\n  getAutoCloseBeforeSet(languageId) {\n    let characterPairSupport = this._getCharacterPairSupport(languageId);\n\n    if (!characterPairSupport) {\n      return CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;\n    }\n\n    return characterPairSupport.getAutoCloseBeforeSet();\n  }\n\n  getSurroundingPairs(languageId) {\n    let characterPairSupport = this._getCharacterPairSupport(languageId);\n\n    if (!characterPairSupport) {\n      return [];\n    }\n\n    return characterPairSupport.getSurroundingPairs();\n  }\n\n  shouldAutoClosePair(autoClosingPair, context, column) {\n    const scopedLineTokens = createScopedLineTokens(context, column - 1);\n    return CharacterPairSupport.shouldAutoClosePair(autoClosingPair, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n  } // end characterPair\n\n\n  getWordDefinition(languageId) {\n    let value = this.getLanguageConfiguration(languageId);\n\n    if (!value) {\n      return ensureValidWordDefinition(null);\n    }\n\n    return ensureValidWordDefinition(value.wordDefinition || null);\n  }\n\n  getFoldingRules(languageId) {\n    let value = this.getLanguageConfiguration(languageId);\n\n    if (!value) {\n      return {};\n    }\n\n    return value.foldingRules;\n  } // begin Indent Rules\n\n\n  getIndentRulesSupport(languageId) {\n    let value = this.getLanguageConfiguration(languageId);\n\n    if (!value) {\n      return null;\n    }\n\n    return value.indentRulesSupport || null;\n  }\n  /**\n   * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.\n   * Result:\n   * -1: run into the boundary of embedded languages\n   * 0: every line above are invalid\n   * else: nearest preceding line of the same language\n   */\n\n\n  getPrecedingValidLine(model, lineNumber, indentRulesSupport) {\n    let languageID = model.getLanguageIdAtPosition(lineNumber, 0);\n\n    if (lineNumber > 1) {\n      let lastLineNumber;\n      let resultLineNumber = -1;\n\n      for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n        if (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageID) {\n          return resultLineNumber;\n        }\n\n        let text = model.getLineContent(lastLineNumber);\n\n        if (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n          resultLineNumber = lastLineNumber;\n          continue;\n        }\n\n        return lastLineNumber;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Get inherited indentation from above lines.\n   * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n   * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n   * 3. If this line doesn't match any indent rules\n   *   a. check whether the line above it matches indentNextLinePattern\n   *   b. If not, the indent level of this line is the result\n   *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n   * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n   *\n   * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n   */\n\n\n  getInheritIndentForLine(autoIndent, model, lineNumber) {\n    let honorIntentialIndent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    if (autoIndent < 4\n    /* Full */\n    ) {\n      return null;\n    }\n\n    const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageId());\n\n    if (!indentRulesSupport) {\n      return null;\n    }\n\n    if (lineNumber <= 1) {\n      return {\n        indentation: '',\n        action: null\n      };\n    }\n\n    const precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n\n    if (precedingUnIgnoredLine < 0) {\n      return null;\n    } else if (precedingUnIgnoredLine < 1) {\n      return {\n        indentation: '',\n        action: null\n      };\n    }\n\n    const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n\n    if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n      return {\n        indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n        action: IndentAction.Indent,\n        line: precedingUnIgnoredLine\n      };\n    } else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n      return {\n        indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n        action: null,\n        line: precedingUnIgnoredLine\n      };\n    } else {\n      // precedingUnIgnoredLine can not be ignored.\n      // it doesn't increase indent of following lines\n      // it doesn't increase just next line\n      // so current line is not affect by precedingUnIgnoredLine\n      // and then we should get a correct inheritted indentation from above lines\n      if (precedingUnIgnoredLine === 1) {\n        return {\n          indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n          action: null,\n          line: precedingUnIgnoredLine\n        };\n      }\n\n      const previousLine = precedingUnIgnoredLine - 1;\n      const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n\n      if (!(previousLineIndentMetadata & (1\n      /* INCREASE_MASK */\n      | 2\n      /* DECREASE_MASK */\n      )) && previousLineIndentMetadata & 4\n      /* INDENT_NEXTLINE_MASK */\n      ) {\n        let stopLine = 0;\n\n        for (let i = previousLine - 1; i > 0; i--) {\n          if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n            continue;\n          }\n\n          stopLine = i;\n          break;\n        }\n\n        return {\n          indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n          action: null,\n          line: stopLine + 1\n        };\n      }\n\n      if (honorIntentialIndent) {\n        return {\n          indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n          action: null,\n          line: precedingUnIgnoredLine\n        };\n      } else {\n        // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n        for (let i = precedingUnIgnoredLine; i > 0; i--) {\n          const lineContent = model.getLineContent(i);\n\n          if (indentRulesSupport.shouldIncrease(lineContent)) {\n            return {\n              indentation: strings.getLeadingWhitespace(lineContent),\n              action: IndentAction.Indent,\n              line: i\n            };\n          } else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n            let stopLine = 0;\n\n            for (let j = i - 1; j > 0; j--) {\n              if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                continue;\n              }\n\n              stopLine = j;\n              break;\n            }\n\n            return {\n              indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n              action: null,\n              line: stopLine + 1\n            };\n          } else if (indentRulesSupport.shouldDecrease(lineContent)) {\n            return {\n              indentation: strings.getLeadingWhitespace(lineContent),\n              action: null,\n              line: i\n            };\n          }\n        }\n\n        return {\n          indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n          action: null,\n          line: 1\n        };\n      }\n    }\n  }\n\n  getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter) {\n    if (autoIndent < 4\n    /* Full */\n    ) {\n      return null;\n    }\n\n    const richEditSupport = this.getLanguageConfiguration(languageId);\n\n    if (!richEditSupport) {\n      return null;\n    }\n\n    const indentRulesSupport = this.getIndentRulesSupport(languageId);\n\n    if (!indentRulesSupport) {\n      return null;\n    }\n\n    const indent = this.getInheritIndentForLine(autoIndent, virtualModel, lineNumber);\n    const lineContent = virtualModel.getLineContent(lineNumber);\n\n    if (indent) {\n      const inheritLine = indent.line;\n\n      if (inheritLine !== undefined) {\n        const enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n\n        if (enterResult) {\n          let indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n\n          if (enterResult.removeText) {\n            indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n          }\n\n          if (enterResult.indentAction === IndentAction.Indent || enterResult.indentAction === IndentAction.IndentOutdent) {\n            indentation = indentConverter.shiftIndent(indentation);\n          } else if (enterResult.indentAction === IndentAction.Outdent) {\n            indentation = indentConverter.unshiftIndent(indentation);\n          }\n\n          if (indentRulesSupport.shouldDecrease(lineContent)) {\n            indentation = indentConverter.unshiftIndent(indentation);\n          }\n\n          if (enterResult.appendText) {\n            indentation += enterResult.appendText;\n          }\n\n          return strings.getLeadingWhitespace(indentation);\n        }\n      }\n\n      if (indentRulesSupport.shouldDecrease(lineContent)) {\n        if (indent.action === IndentAction.Indent) {\n          return indent.indentation;\n        } else {\n          return indentConverter.unshiftIndent(indent.indentation);\n        }\n      } else {\n        if (indent.action === IndentAction.Indent) {\n          return indentConverter.shiftIndent(indent.indentation);\n        } else {\n          return indent.indentation;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  getIndentForEnter(autoIndent, model, range, indentConverter) {\n    if (autoIndent < 4\n    /* Full */\n    ) {\n      return null;\n    }\n\n    model.forceTokenization(range.startLineNumber);\n    const lineTokens = model.getLineTokens(range.startLineNumber);\n    const scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n    const scopedLineText = scopedLineTokens.getLineContent();\n    let embeddedLanguage = false;\n    let beforeEnterText;\n\n    if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n      // we are in the embeded language content\n      embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n\n      beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    } else {\n      beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n    }\n\n    let afterEnterText;\n\n    if (range.isEmpty()) {\n      afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    } else {\n      const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n      afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n\n    const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n\n    if (!indentRulesSupport) {\n      return null;\n    }\n\n    const beforeEnterResult = beforeEnterText;\n    const beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n    const virtualModel = {\n      getLineTokens: lineNumber => {\n        return model.getLineTokens(lineNumber);\n      },\n      getLanguageId: () => {\n        return model.getLanguageId();\n      },\n      getLanguageIdAtPosition: (lineNumber, column) => {\n        return model.getLanguageIdAtPosition(lineNumber, column);\n      },\n      getLineContent: lineNumber => {\n        if (lineNumber === range.startLineNumber) {\n          return beforeEnterResult;\n        } else {\n          return model.getLineContent(lineNumber);\n        }\n      }\n    };\n    const currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n    const afterEnterAction = this.getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1);\n\n    if (!afterEnterAction) {\n      const beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n      return {\n        beforeEnter: beforeEnter,\n        afterEnter: beforeEnter\n      };\n    }\n\n    let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n\n    if (afterEnterAction.action === IndentAction.Indent) {\n      afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n    }\n\n    if (indentRulesSupport.shouldDecrease(afterEnterText)) {\n      afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n    }\n\n    return {\n      beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n      afterEnter: afterEnterIndent\n    };\n  }\n  /**\n   * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n   * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n   */\n\n\n  getIndentActionForType(autoIndent, model, range, ch, indentConverter) {\n    if (autoIndent < 4\n    /* Full */\n    ) {\n      return null;\n    }\n\n    const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n\n    if (scopedLineTokens.firstCharOffset) {\n      // this line has mixed languages and indentation rules will not work\n      return null;\n    }\n\n    const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n\n    if (!indentRulesSupport) {\n      return null;\n    }\n\n    const scopedLineText = scopedLineTokens.getLineContent();\n    const beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset); // selection support\n\n    let afterTypeText;\n\n    if (range.isEmpty()) {\n      afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    } else {\n      const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n      afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    } // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n    // Users might change the indentation by purpose and we should honor that instead of readjusting.\n\n\n    if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n      // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n      // 1. Get inherited indent action\n      const r = this.getInheritIndentForLine(autoIndent, model, range.startLineNumber, false);\n\n      if (!r) {\n        return null;\n      }\n\n      let indentation = r.indentation;\n\n      if (r.action !== IndentAction.Indent) {\n        indentation = indentConverter.unshiftIndent(indentation);\n      }\n\n      return indentation;\n    }\n\n    return null;\n  }\n\n  getIndentMetadata(model, lineNumber) {\n    const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageId());\n\n    if (!indentRulesSupport) {\n      return null;\n    }\n\n    if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n      return null;\n    }\n\n    return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n  } // end Indent Rules\n  // begin onEnter\n\n\n  getEnterAction(autoIndent, model, range) {\n    const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n    const richEditSupport = this.getLanguageConfiguration(scopedLineTokens.languageId);\n\n    if (!richEditSupport) {\n      return null;\n    }\n\n    const scopedLineText = scopedLineTokens.getLineContent();\n    const beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset); // selection support\n\n    let afterEnterText;\n\n    if (range.isEmpty()) {\n      afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    } else {\n      const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n      afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n\n    let previousLineText = '';\n\n    if (range.startLineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\n      // This is not the first line and the entire line belongs to this mode\n      const oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber - 1);\n\n      if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\n        // The line above ends with text belonging to the same mode\n        previousLineText = oneLineAboveScopedLineTokens.getLineContent();\n      }\n    }\n\n    const enterResult = richEditSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n\n    if (!enterResult) {\n      return null;\n    }\n\n    const indentAction = enterResult.indentAction;\n    let appendText = enterResult.appendText;\n    const removeText = enterResult.removeText || 0; // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\n\n    if (!appendText) {\n      if (indentAction === IndentAction.Indent || indentAction === IndentAction.IndentOutdent) {\n        appendText = '\\t';\n      } else {\n        appendText = '';\n      }\n    } else if (indentAction === IndentAction.Indent) {\n      appendText = '\\t' + appendText;\n    }\n\n    let indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n\n    if (removeText) {\n      indentation = indentation.substring(0, indentation.length - removeText);\n    }\n\n    return {\n      indentAction: indentAction,\n      appendText: appendText,\n      removeText: removeText,\n      indentation: indentation\n    };\n  }\n\n  getIndentationAtPosition(model, lineNumber, column) {\n    const lineText = model.getLineContent(lineNumber);\n    let indentation = strings.getLeadingWhitespace(lineText);\n\n    if (indentation.length > column - 1) {\n      indentation = indentation.substring(0, column - 1);\n    }\n\n    return indentation;\n  }\n\n  getScopedLineTokens(model, lineNumber, columnNumber) {\n    model.forceTokenization(lineNumber);\n    const lineTokens = model.getLineTokens(lineNumber);\n    const column = typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1;\n    return createScopedLineTokens(lineTokens, column);\n  }\n\n}\nexport const LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();\n\nclass ComposedLanguageConfiguration {\n  constructor(languageId) {\n    this.languageId = languageId;\n    this._resolved = null;\n    this._entries = [];\n    this._order = 0;\n    this._resolved = null;\n  }\n\n  register(configuration, priority) {\n    const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);\n\n    this._entries.push(entry);\n\n    this._resolved = null;\n    return toDisposable(() => {\n      for (let i = 0; i < this._entries.length; i++) {\n        if (this._entries[i] === entry) {\n          this._entries.splice(i, 1);\n\n          this._resolved = null;\n          break;\n        }\n      }\n    });\n  }\n\n  getResolvedConfiguration() {\n    if (!this._resolved) {\n      const config = this._resolve();\n\n      if (config) {\n        this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);\n      }\n    }\n\n    return this._resolved;\n  }\n\n  _resolve() {\n    if (this._entries.length === 0) {\n      return null;\n    }\n\n    this._entries.sort(LanguageConfigurationContribution.cmp);\n\n    return combineLanguageConfigurations(this._entries.map(e => e.configuration));\n  }\n\n}\n\nfunction combineLanguageConfigurations(configs) {\n  let result = {\n    comments: undefined,\n    brackets: undefined,\n    wordPattern: undefined,\n    indentationRules: undefined,\n    onEnterRules: undefined,\n    autoClosingPairs: undefined,\n    surroundingPairs: undefined,\n    autoCloseBefore: undefined,\n    folding: undefined,\n    colorizedBracketPairs: undefined,\n    __electricCharacterSupport: undefined\n  };\n\n  for (const entry of configs) {\n    result = {\n      comments: entry.comments || result.comments,\n      brackets: entry.brackets || result.brackets,\n      wordPattern: entry.wordPattern || result.wordPattern,\n      indentationRules: entry.indentationRules || result.indentationRules,\n      onEnterRules: entry.onEnterRules || result.onEnterRules,\n      autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,\n      surroundingPairs: entry.surroundingPairs || result.surroundingPairs,\n      autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,\n      folding: entry.folding || result.folding,\n      colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,\n      __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport\n    };\n  }\n\n  return result;\n}\n\nclass LanguageConfigurationContribution {\n  constructor(configuration, priority, order) {\n    this.configuration = configuration;\n    this.priority = priority;\n    this.order = order;\n  }\n\n  static cmp(a, b) {\n    if (a.priority === b.priority) {\n      // higher order last\n      return a.order - b.order;\n    } // higher priority last\n\n\n    return a.priority - b.priority;\n  }\n\n}\n/**\n * Immutable.\n*/\n\n\nexport class ResolvedLanguageConfiguration {\n  constructor(languageId, underlyingConfig) {\n    this.languageId = languageId;\n    this.underlyingConfig = underlyingConfig;\n    this._brackets = null;\n    this._electricCharacter = null;\n    this._onEnterSupport = this.underlyingConfig.brackets || this.underlyingConfig.indentationRules || this.underlyingConfig.onEnterRules ? new OnEnterSupport(this.underlyingConfig) : null;\n    this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);\n    this.characterPair = new CharacterPairSupport(this.underlyingConfig);\n    this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;\n    this.indentationRules = this.underlyingConfig.indentationRules;\n\n    if (this.underlyingConfig.indentationRules) {\n      this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);\n    } else {\n      this.indentRulesSupport = null;\n    }\n\n    this.foldingRules = this.underlyingConfig.folding || {};\n  }\n\n  getWordDefinition() {\n    return ensureValidWordDefinition(this.wordDefinition);\n  }\n\n  get brackets() {\n    if (!this._brackets && this.underlyingConfig.brackets) {\n      this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);\n    }\n\n    return this._brackets;\n  }\n\n  get electricCharacter() {\n    if (!this._electricCharacter) {\n      this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n    }\n\n    return this._electricCharacter;\n  }\n\n  onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n    if (!this._onEnterSupport) {\n      return null;\n    }\n\n    return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n  }\n\n  static _handleComments(conf) {\n    let commentRule = conf.comments;\n\n    if (!commentRule) {\n      return null;\n    } // comment configuration\n\n\n    let comments = {};\n\n    if (commentRule.lineComment) {\n      comments.lineCommentToken = commentRule.lineComment;\n    }\n\n    if (commentRule.blockComment) {\n      let [blockStart, blockEnd] = commentRule.blockComment;\n      comments.blockCommentStartToken = blockStart;\n      comments.blockCommentEndToken = blockEnd;\n    }\n\n    return comments;\n  }\n\n}\nregisterSingleton(ILanguageConfigurationService, LanguageConfigurationService);","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/common/modes/languageConfigurationRegistry.js"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","Emitter","Disposable","toDisposable","strings","DEFAULT_WORD_REGEXP","ensureValidWordDefinition","IndentAction","AutoClosingPairs","createScopedLineTokens","CharacterPairSupport","BracketElectricCharacterSupport","IndentRulesSupport","OnEnterSupport","RichEditBrackets","createDecorator","IConfigurationService","IModeService","registerSingleton","LanguageConfigurationServiceChangeEvent","constructor","languageId","affects","ILanguageConfigurationService","LanguageConfigurationService","configurationService","modeService","onDidChangeEmitter","_register","onDidChange","event","configurations","Map","languageConfigKeys","Set","values","customizedLanguageConfigKeys","onDidChangeConfiguration","e","globalConfigChanged","change","keys","some","k","has","localConfigChanged","overrides","filter","overrideLangName","map","validateLanguageId","clear","fire","undefined","delete","LanguageConfigurationRegistry","getLanguageConfiguration","result","get","computeConfig","set","languageConfig","validLanguageId","Error","ResolvedLanguageConfiguration","customizedConfig","getCustomizedLanguageConfig","data","combineLanguageConfigurations","underlyingConfig","config","brackets","colorizedBracketPairs","getValue","overrideIdentifier","validateBracketPairs","Array","isArray","pair","p","LanguageConfigurationChangeEvent","LanguageConfigurationRegistryImpl","_entries","_onDidChange","register","configuration","priority","entries","ComposedLanguageConfiguration","disposable","dispose","getResolvedConfiguration","getIndentationRules","value","indentationRules","_getElectricCharacterSupport","electricCharacter","getElectricCharacters","electricCharacterSupport","onElectricCharacter","character","context","column","scopedLineTokens","firstCharOffset","getComments","comments","_getCharacterPairSupport","characterPair","getAutoClosingPairs","characterPairSupport","getAutoCloseBeforeSet","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED","getSurroundingPairs","shouldAutoClosePair","autoClosingPair","getWordDefinition","wordDefinition","getFoldingRules","foldingRules","getIndentRulesSupport","indentRulesSupport","getPrecedingValidLine","model","lineNumber","languageID","getLanguageIdAtPosition","lastLineNumber","resultLineNumber","text","getLineContent","shouldIgnore","test","getInheritIndentForLine","autoIndent","honorIntentialIndent","getLanguageId","indentation","action","precedingUnIgnoredLine","precedingUnIgnoredLineContent","shouldIncrease","shouldIndentNextLine","getLeadingWhitespace","Indent","line","shouldDecrease","previousLine","previousLineIndentMetadata","getIndentMetadata","stopLine","lineContent","j","getGoodIndentForLine","virtualModel","indentConverter","richEditSupport","indent","inheritLine","enterResult","onEnter","removeText","substring","indentAction","IndentOutdent","shiftIndent","Outdent","unshiftIndent","appendText","getIndentForEnter","range","forceTokenization","startLineNumber","lineTokens","getLineTokens","startColumn","scopedLineText","embeddedLanguage","beforeEnterText","substr","afterEnterText","isEmpty","endScopedLineTokens","getScopedLineTokens","endLineNumber","endColumn","beforeEnterResult","beforeEnterIndent","currentLineIndent","afterEnterAction","beforeEnter","afterEnter","afterEnterIndent","getIndentActionForType","ch","beforeTypeText","afterTypeText","getLineCount","getEnterAction","previousLineText","oneLineAboveScopedLineTokens","getIndentationAtPosition","lineText","columnNumber","getLineMaxColumn","_resolved","_order","entry","LanguageConfigurationContribution","push","splice","_resolve","sort","cmp","configs","wordPattern","onEnterRules","autoClosingPairs","surroundingPairs","autoCloseBefore","folding","__electricCharacterSupport","order","a","b","_brackets","_electricCharacter","_onEnterSupport","_handleComments","conf","commentRule","lineComment","lineCommentToken","blockComment","blockStart","blockEnd","blockCommentStartToken","blockCommentEndToken"],"mappings":"AAAA;AACA;AACA;AACA;AACA,IAAIA,UAAU,GAAI,QAAQ,KAAKA,UAAd,IAA6B,UAAUC,UAAV,EAAsBC,MAAtB,EAA8BC,GAA9B,EAAmCC,IAAnC,EAAyC;AACnF,MAAIC,CAAC,GAAGC,SAAS,CAACC,MAAlB;AAAA,MAA0BC,CAAC,GAAGH,CAAC,GAAG,CAAJ,GAAQH,MAAR,GAAiBE,IAAI,KAAK,IAAT,GAAgBA,IAAI,GAAGK,MAAM,CAACC,wBAAP,CAAgCR,MAAhC,EAAwCC,GAAxC,CAAvB,GAAsEC,IAArH;AAAA,MAA2HO,CAA3H;AACA,MAAI,OAAOC,OAAP,KAAmB,QAAnB,IAA+B,OAAOA,OAAO,CAACC,QAAf,KAA4B,UAA/D,EAA2EL,CAAC,GAAGI,OAAO,CAACC,QAAR,CAAiBZ,UAAjB,EAA6BC,MAA7B,EAAqCC,GAArC,EAA0CC,IAA1C,CAAJ,CAA3E,KACK,KAAK,IAAIU,CAAC,GAAGb,UAAU,CAACM,MAAX,GAAoB,CAAjC,EAAoCO,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C,EAAiD,IAAIH,CAAC,GAAGV,UAAU,CAACa,CAAD,CAAlB,EAAuBN,CAAC,GAAG,CAACH,CAAC,GAAG,CAAJ,GAAQM,CAAC,CAACH,CAAD,CAAT,GAAeH,CAAC,GAAG,CAAJ,GAAQM,CAAC,CAACT,MAAD,EAASC,GAAT,EAAcK,CAAd,CAAT,GAA4BG,CAAC,CAACT,MAAD,EAASC,GAAT,CAA7C,KAA+DK,CAAnE;AAC7E,SAAOH,CAAC,GAAG,CAAJ,IAASG,CAAT,IAAcC,MAAM,CAACM,cAAP,CAAsBb,MAAtB,EAA8BC,GAA9B,EAAmCK,CAAnC,CAAd,EAAqDA,CAA5D;AACH,CALD;;AAMA,IAAIQ,OAAO,GAAI,QAAQ,KAAKA,OAAd,IAA0B,UAAUC,UAAV,EAAsBC,SAAtB,EAAiC;AACrE,SAAO,UAAUhB,MAAV,EAAkBC,GAAlB,EAAuB;AAAEe,IAAAA,SAAS,CAAChB,MAAD,EAASC,GAAT,EAAcc,UAAd,CAAT;AAAqC,GAArE;AACH,CAFD;;AAGA,SAASE,OAAT,QAAwB,+BAAxB;AACA,SAASC,UAAT,EAAqBC,YAArB,QAAyC,mCAAzC;AACA,OAAO,KAAKC,OAAZ,MAAyB,iCAAzB;AACA,SAASC,mBAAT,EAA8BC,yBAA9B,QAA+D,wBAA/D;AACA,SAASC,YAAT,EAAuBC,gBAAvB,QAA+C,4BAA/C;AACA,SAASC,sBAAT,QAAuC,eAAvC;AACA,SAASC,oBAAT,QAAqC,6BAArC;AACA,SAASC,+BAAT,QAAgD,iCAAhD;AACA,SAASC,kBAAT,QAAmC,2BAAnC;AACA,SAASC,cAAT,QAA+B,uBAA/B;AACA,SAASC,gBAAT,QAAiC,gCAAjC;AACA,SAASC,eAAT,QAAgC,yDAAhC;AACA,SAASC,qBAAT,QAAsC,yDAAtC;AACA,SAASC,YAAT,QAA6B,4BAA7B;AACA,SAASC,iBAAT,QAAkC,sDAAlC;AACA,OAAO,MAAMC,uCAAN,CAA8C;AACjDC,EAAAA,WAAW,CAACC,UAAD,EAAa;AACpB,SAAKA,UAAL,GAAkBA,UAAlB;AACH;;AACDC,EAAAA,OAAO,CAACD,UAAD,EAAa;AAChB,WAAO,CAAC,KAAKA,UAAN,GAAmB,IAAnB,GAA0B,KAAKA,UAAL,KAAoBA,UAArD;AACH;;AANgD;AAQrD,OAAO,MAAME,6BAA6B,GAAGR,eAAe,CAAC,8BAAD,CAArD;AACP,IAAIS,4BAA4B,GAAG,MAAMA,4BAAN,SAA2CtB,UAA3C,CAAsD;AACrFkB,EAAAA,WAAW,CAACK,oBAAD,EAAuBC,WAAvB,EAAoC;AAC3C;AACA,SAAKD,oBAAL,GAA4BA,oBAA5B;AACA,SAAKC,WAAL,GAAmBA,WAAnB;AACA,SAAKC,kBAAL,GAA0B,KAAKC,SAAL,CAAe,IAAI3B,OAAJ,EAAf,CAA1B;AACA,SAAK4B,WAAL,GAAmB,KAAKF,kBAAL,CAAwBG,KAA3C;AACA,SAAKC,cAAL,GAAsB,IAAIC,GAAJ,EAAtB;AACA,UAAMC,kBAAkB,GAAG,IAAIC,GAAJ,CAAQ3C,MAAM,CAAC4C,MAAP,CAAcC,4BAAd,CAAR,CAA3B;;AACA,SAAKR,SAAL,CAAe,KAAKH,oBAAL,CAA0BY,wBAA1B,CAAoDC,CAAD,IAAO;AACrE,YAAMC,mBAAmB,GAAGD,CAAC,CAACE,MAAF,CAASC,IAAT,CAAcC,IAAd,CAAoBC,CAAD,IAAOV,kBAAkB,CAACW,GAAnB,CAAuBD,CAAvB,CAA1B,CAA5B;AACA,YAAME,kBAAkB,GAAGP,CAAC,CAACE,MAAF,CAASM,SAAT,CACtBC,MADsB,CACf;AAAA,YAAC,CAACC,gBAAD,EAAmBP,IAAnB,CAAD;AAAA,eAA8BA,IAAI,CAACC,IAAL,CAAWC,CAAD,IAAOV,kBAAkB,CAACW,GAAnB,CAAuBD,CAAvB,CAAjB,CAA9B;AAAA,OADe,EAEtBM,GAFsB,CAElB;AAAA,YAAC,CAACD,gBAAD,CAAD;AAAA,eAAwB,KAAKtB,WAAL,CAAiBwB,kBAAjB,CAAoCF,gBAApC,CAAxB;AAAA,OAFkB,CAA3B;;AAGA,UAAIT,mBAAJ,EAAyB;AACrB,aAAKR,cAAL,CAAoBoB,KAApB;AACA,aAAKxB,kBAAL,CAAwByB,IAAxB,CAA6B,IAAIjC,uCAAJ,CAA4CkC,SAA5C,CAA7B;AACH,OAHD,MAIK;AACD,aAAK,MAAMhC,UAAX,IAAyBwB,kBAAzB,EAA6C;AACzC,cAAIxB,UAAJ,EAAgB;AACZ,iBAAKU,cAAL,CAAoBuB,MAApB,CAA2BjC,UAA3B;AACA,iBAAKM,kBAAL,CAAwByB,IAAxB,CAA6B,IAAIjC,uCAAJ,CAA4CE,UAA5C,CAA7B;AACH;AACJ;AACJ;AACJ,KAjBc,CAAf;;AAkBA,SAAKO,SAAL,CAAe2B,6BAA6B,CAAC1B,WAA9B,CAA2CS,CAAD,IAAO;AAC5D,WAAKP,cAAL,CAAoBuB,MAApB,CAA2BhB,CAAC,CAACjB,UAA7B;AACA,WAAKM,kBAAL,CAAwByB,IAAxB,CAA6B,IAAIjC,uCAAJ,CAA4CmB,CAAC,CAACjB,UAA9C,CAA7B;AACH,KAHc,CAAf;AAIH;;AACDmC,EAAAA,wBAAwB,CAACnC,UAAD,EAAa;AACjC,QAAIoC,MAAM,GAAG,KAAK1B,cAAL,CAAoB2B,GAApB,CAAwBrC,UAAxB,CAAb;;AACA,QAAI,CAACoC,MAAL,EAAa;AACTA,MAAAA,MAAM,GAAGE,aAAa,CAACtC,UAAD,EAAa,KAAKI,oBAAlB,EAAwC,KAAKC,WAA7C,CAAtB;AACA,WAAKK,cAAL,CAAoB6B,GAApB,CAAwBvC,UAAxB,EAAoCoC,MAApC;AACH;;AACD,WAAOA,MAAP;AACH;;AAvCoF,CAAzF;AAyCAjC,4BAA4B,GAAG1C,UAAU,CAAC,CACtCgB,OAAO,CAAC,CAAD,EAAIkB,qBAAJ,CAD+B,EAEtClB,OAAO,CAAC,CAAD,EAAImB,YAAJ,CAF+B,CAAD,EAGtCO,4BAHsC,CAAzC;AAIA,SAASA,4BAAT;;AACA,SAASmC,aAAT,CAAuBtC,UAAvB,EAAmCI,oBAAnC,EAAyDC,WAAzD,EAAsE;AAClE,MAAImC,cAAc,GAAGN,6BAA6B,CAACC,wBAA9B,CAAuDnC,UAAvD,CAArB;;AACA,MAAI,CAACwC,cAAL,EAAqB;AACjB,UAAMC,eAAe,GAAGpC,WAAW,CAACwB,kBAAZ,CAA+B7B,UAA/B,CAAxB;;AACA,QAAI,CAACyC,eAAL,EAAsB;AAClB,YAAM,IAAIC,KAAJ,CAAU,uBAAV,CAAN;AACH;;AACDF,IAAAA,cAAc,GAAG,IAAIG,6BAAJ,CAAkCF,eAAlC,EAAmD,EAAnD,CAAjB;AACH;;AACD,QAAMG,gBAAgB,GAAGC,2BAA2B,CAACL,cAAc,CAACxC,UAAhB,EAA4BI,oBAA5B,CAApD;AACA,QAAM0C,IAAI,GAAGC,6BAA6B,CAAC,CAACP,cAAc,CAACQ,gBAAhB,EAAkCJ,gBAAlC,CAAD,CAA1C;AACA,QAAMK,MAAM,GAAG,IAAIN,6BAAJ,CAAkCH,cAAc,CAACxC,UAAjD,EAA6D8C,IAA7D,CAAf;AACA,SAAOG,MAAP;AACH;;AACD,MAAMlC,4BAA4B,GAAG;AACjCmC,EAAAA,QAAQ,EAAE,0BADuB;AAEjCC,EAAAA,qBAAqB,EAAE;AAFU,CAArC;;AAIA,SAASN,2BAAT,CAAqC7C,UAArC,EAAiDI,oBAAjD,EAAuE;AACnE,QAAM8C,QAAQ,GAAG9C,oBAAoB,CAACgD,QAArB,CAA8BrC,4BAA4B,CAACmC,QAA3D,EAAqE;AAClFG,IAAAA,kBAAkB,EAAErD;AAD8D,GAArE,CAAjB;AAGA,QAAMmD,qBAAqB,GAAG/C,oBAAoB,CAACgD,QAArB,CAA8BrC,4BAA4B,CAACoC,qBAA3D,EAAkF;AAC5GE,IAAAA,kBAAkB,EAAErD;AADwF,GAAlF,CAA9B;AAGA,SAAO;AACHkD,IAAAA,QAAQ,EAAEI,oBAAoB,CAACJ,QAAD,CAD3B;AAEHC,IAAAA,qBAAqB,EAAEG,oBAAoB,CAACH,qBAAD;AAFxC,GAAP;AAIH;;AACD,SAASG,oBAAT,CAA8BR,IAA9B,EAAoC;AAChC,MAAI,CAACS,KAAK,CAACC,OAAN,CAAcV,IAAd,CAAL,EAA0B;AACtB,WAAOd,SAAP;AACH;;AACD,SAAOc,IAAI,CAAClB,GAAL,CAAS6B,IAAI,IAAI;AACpB,QAAI,CAACF,KAAK,CAACC,OAAN,CAAcC,IAAd,CAAD,IAAwBA,IAAI,CAACzF,MAAL,KAAgB,CAA5C,EAA+C;AAC3C,aAAOgE,SAAP;AACH;;AACD,WAAO,CAACyB,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,CAAP;AACH,GALM,EAKJ/B,MALI,CAKIgC,CAAD,IAAO,CAAC,CAACA,CALZ,CAAP;AAMH;;AACD,OAAO,MAAMC,gCAAN,CAAuC;AAC1C5D,EAAAA,WAAW,CAACC,UAAD,EAAa;AACpB,SAAKA,UAAL,GAAkBA,UAAlB;AACH;;AAHyC;AAK9C,OAAO,MAAM4D,iCAAN,CAAwC;AAC3C7D,EAAAA,WAAW,GAAG;AACV,SAAK8D,QAAL,GAAgB,IAAIlD,GAAJ,EAAhB;AACA,SAAKmD,YAAL,GAAoB,IAAIlF,OAAJ,EAApB;AACA,SAAK4B,WAAL,GAAmB,KAAKsD,YAAL,CAAkBrD,KAArC;AACH;AACD;AACJ;AACA;;;AACIsD,EAAAA,QAAQ,CAAC/D,UAAD,EAAagE,aAAb,EAA0C;AAAA,QAAdC,QAAc,uEAAH,CAAG;;AAC9C,QAAIC,OAAO,GAAG,KAAKL,QAAL,CAAcxB,GAAd,CAAkBrC,UAAlB,CAAd;;AACA,QAAI,CAACkE,OAAL,EAAc;AACVA,MAAAA,OAAO,GAAG,IAAIC,6BAAJ,CAAkCnE,UAAlC,CAAV;;AACA,WAAK6D,QAAL,CAActB,GAAd,CAAkBvC,UAAlB,EAA8BkE,OAA9B;AACH;;AACD,UAAME,UAAU,GAAGF,OAAO,CAACH,QAAR,CAAiBC,aAAjB,EAAgCC,QAAhC,CAAnB;;AACA,SAAKH,YAAL,CAAkB/B,IAAlB,CAAuB,IAAI4B,gCAAJ,CAAqC3D,UAArC,CAAvB;;AACA,WAAOlB,YAAY,CAAC,MAAM;AACtBsF,MAAAA,UAAU,CAACC,OAAX;;AACA,WAAKP,YAAL,CAAkB/B,IAAlB,CAAuB,IAAI4B,gCAAJ,CAAqC3D,UAArC,CAAvB;AACH,KAHkB,CAAnB;AAIH;;AACDmC,EAAAA,wBAAwB,CAACnC,UAAD,EAAa;AACjC,QAAIkE,OAAO,GAAG,KAAKL,QAAL,CAAcxB,GAAd,CAAkBrC,UAAlB,CAAd;;AACA,WAAO,CAACkE,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACI,wBAAR,EAAnD,KAA0F,IAAjG;AACH;;AACDC,EAAAA,mBAAmB,CAACvE,UAAD,EAAa;AAC5B,UAAMwE,KAAK,GAAG,KAAKrC,wBAAL,CAA8BnC,UAA9B,CAAd;AACA,WAAOwE,KAAK,GAAGA,KAAK,CAACC,gBAAN,IAA0B,IAA7B,GAAoC,IAAhD;AACH,GA7B0C,CA8B3C;;;AACAC,EAAAA,4BAA4B,CAAC1E,UAAD,EAAa;AACrC,QAAIwE,KAAK,GAAG,KAAKrC,wBAAL,CAA8BnC,UAA9B,CAAZ;;AACA,QAAI,CAACwE,KAAL,EAAY;AACR,aAAO,IAAP;AACH;;AACD,WAAOA,KAAK,CAACG,iBAAN,IAA2B,IAAlC;AACH;;AACDC,EAAAA,qBAAqB,CAAC5E,UAAD,EAAa;AAC9B,QAAI6E,wBAAwB,GAAG,KAAKH,4BAAL,CAAkC1E,UAAlC,CAA/B;;AACA,QAAI,CAAC6E,wBAAL,EAA+B;AAC3B,aAAO,EAAP;AACH;;AACD,WAAOA,wBAAwB,CAACD,qBAAzB,EAAP;AACH;AACD;AACJ;AACA;;;AACIE,EAAAA,mBAAmB,CAACC,SAAD,EAAYC,OAAZ,EAAqBC,MAArB,EAA6B;AAC5C,QAAIC,gBAAgB,GAAG9F,sBAAsB,CAAC4F,OAAD,EAAUC,MAAM,GAAG,CAAnB,CAA7C;;AACA,QAAIJ,wBAAwB,GAAG,KAAKH,4BAAL,CAAkCQ,gBAAgB,CAAClF,UAAnD,CAA/B;;AACA,QAAI,CAAC6E,wBAAL,EAA+B;AAC3B,aAAO,IAAP;AACH;;AACD,WAAOA,wBAAwB,CAACC,mBAAzB,CAA6CC,SAA7C,EAAwDG,gBAAxD,EAA0ED,MAAM,GAAGC,gBAAgB,CAACC,eAApG,CAAP;AACH,GAvD0C,CAwD3C;;;AACAC,EAAAA,WAAW,CAACpF,UAAD,EAAa;AACpB,QAAIwE,KAAK,GAAG,KAAKrC,wBAAL,CAA8BnC,UAA9B,CAAZ;;AACA,QAAI,CAACwE,KAAL,EAAY;AACR,aAAO,IAAP;AACH;;AACD,WAAOA,KAAK,CAACa,QAAN,IAAkB,IAAzB;AACH,GA/D0C,CAgE3C;;;AACAC,EAAAA,wBAAwB,CAACtF,UAAD,EAAa;AACjC,QAAIwE,KAAK,GAAG,KAAKrC,wBAAL,CAA8BnC,UAA9B,CAAZ;;AACA,QAAI,CAACwE,KAAL,EAAY;AACR,aAAO,IAAP;AACH;;AACD,WAAOA,KAAK,CAACe,aAAN,IAAuB,IAA9B;AACH;;AACDC,EAAAA,mBAAmB,CAACxF,UAAD,EAAa;AAC5B,UAAMyF,oBAAoB,GAAG,KAAKH,wBAAL,CAA8BtF,UAA9B,CAA7B;;AACA,WAAO,IAAIb,gBAAJ,CAAqBsG,oBAAoB,GAAGA,oBAAoB,CAACD,mBAArB,EAAH,GAAgD,EAAzF,CAAP;AACH;;AACDE,EAAAA,qBAAqB,CAAC1F,UAAD,EAAa;AAC9B,QAAIyF,oBAAoB,GAAG,KAAKH,wBAAL,CAA8BtF,UAA9B,CAA3B;;AACA,QAAI,CAACyF,oBAAL,EAA2B;AACvB,aAAOpG,oBAAoB,CAACsG,yCAA5B;AACH;;AACD,WAAOF,oBAAoB,CAACC,qBAArB,EAAP;AACH;;AACDE,EAAAA,mBAAmB,CAAC5F,UAAD,EAAa;AAC5B,QAAIyF,oBAAoB,GAAG,KAAKH,wBAAL,CAA8BtF,UAA9B,CAA3B;;AACA,QAAI,CAACyF,oBAAL,EAA2B;AACvB,aAAO,EAAP;AACH;;AACD,WAAOA,oBAAoB,CAACG,mBAArB,EAAP;AACH;;AACDC,EAAAA,mBAAmB,CAACC,eAAD,EAAkBd,OAAlB,EAA2BC,MAA3B,EAAmC;AAClD,UAAMC,gBAAgB,GAAG9F,sBAAsB,CAAC4F,OAAD,EAAUC,MAAM,GAAG,CAAnB,CAA/C;AACA,WAAO5F,oBAAoB,CAACwG,mBAArB,CAAyCC,eAAzC,EAA0DZ,gBAA1D,EAA4ED,MAAM,GAAGC,gBAAgB,CAACC,eAAtG,CAAP;AACH,GA7F0C,CA8F3C;;;AACAY,EAAAA,iBAAiB,CAAC/F,UAAD,EAAa;AAC1B,QAAIwE,KAAK,GAAG,KAAKrC,wBAAL,CAA8BnC,UAA9B,CAAZ;;AACA,QAAI,CAACwE,KAAL,EAAY;AACR,aAAOvF,yBAAyB,CAAC,IAAD,CAAhC;AACH;;AACD,WAAOA,yBAAyB,CAACuF,KAAK,CAACwB,cAAN,IAAwB,IAAzB,CAAhC;AACH;;AACDC,EAAAA,eAAe,CAACjG,UAAD,EAAa;AACxB,QAAIwE,KAAK,GAAG,KAAKrC,wBAAL,CAA8BnC,UAA9B,CAAZ;;AACA,QAAI,CAACwE,KAAL,EAAY;AACR,aAAO,EAAP;AACH;;AACD,WAAOA,KAAK,CAAC0B,YAAb;AACH,GA5G0C,CA6G3C;;;AACAC,EAAAA,qBAAqB,CAACnG,UAAD,EAAa;AAC9B,QAAIwE,KAAK,GAAG,KAAKrC,wBAAL,CAA8BnC,UAA9B,CAAZ;;AACA,QAAI,CAACwE,KAAL,EAAY;AACR,aAAO,IAAP;AACH;;AACD,WAAOA,KAAK,CAAC4B,kBAAN,IAA4B,IAAnC;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,qBAAqB,CAACC,KAAD,EAAQC,UAAR,EAAoBH,kBAApB,EAAwC;AACzD,QAAII,UAAU,GAAGF,KAAK,CAACG,uBAAN,CAA8BF,UAA9B,EAA0C,CAA1C,CAAjB;;AACA,QAAIA,UAAU,GAAG,CAAjB,EAAoB;AAChB,UAAIG,cAAJ;AACA,UAAIC,gBAAgB,GAAG,CAAC,CAAxB;;AACA,WAAKD,cAAc,GAAGH,UAAU,GAAG,CAAnC,EAAsCG,cAAc,IAAI,CAAxD,EAA2DA,cAAc,EAAzE,EAA6E;AACzE,YAAIJ,KAAK,CAACG,uBAAN,CAA8BC,cAA9B,EAA8C,CAA9C,MAAqDF,UAAzD,EAAqE;AACjE,iBAAOG,gBAAP;AACH;;AACD,YAAIC,IAAI,GAAGN,KAAK,CAACO,cAAN,CAAqBH,cAArB,CAAX;;AACA,YAAIN,kBAAkB,CAACU,YAAnB,CAAgCF,IAAhC,KAAyC,QAAQG,IAAR,CAAaH,IAAb,CAAzC,IAA+DA,IAAI,KAAK,EAA5E,EAAgF;AAC5ED,UAAAA,gBAAgB,GAAGD,cAAnB;AACA;AACH;;AACD,eAAOA,cAAP;AACH;AACJ;;AACD,WAAO,CAAC,CAAR;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIM,EAAAA,uBAAuB,CAACC,UAAD,EAAaX,KAAb,EAAoBC,UAApB,EAA6D;AAAA,QAA7BW,oBAA6B,uEAAN,IAAM;;AAChF,QAAID,UAAU,GAAG;AAAE;AAAnB,MAA+B;AAC3B,aAAO,IAAP;AACH;;AACD,UAAMb,kBAAkB,GAAG,KAAKD,qBAAL,CAA2BG,KAAK,CAACa,aAAN,EAA3B,CAA3B;;AACA,QAAI,CAACf,kBAAL,EAAyB;AACrB,aAAO,IAAP;AACH;;AACD,QAAIG,UAAU,IAAI,CAAlB,EAAqB;AACjB,aAAO;AACHa,QAAAA,WAAW,EAAE,EADV;AAEHC,QAAAA,MAAM,EAAE;AAFL,OAAP;AAIH;;AACD,UAAMC,sBAAsB,GAAG,KAAKjB,qBAAL,CAA2BC,KAA3B,EAAkCC,UAAlC,EAA8CH,kBAA9C,CAA/B;;AACA,QAAIkB,sBAAsB,GAAG,CAA7B,EAAgC;AAC5B,aAAO,IAAP;AACH,KAFD,MAGK,IAAIA,sBAAsB,GAAG,CAA7B,EAAgC;AACjC,aAAO;AACHF,QAAAA,WAAW,EAAE,EADV;AAEHC,QAAAA,MAAM,EAAE;AAFL,OAAP;AAIH;;AACD,UAAME,6BAA6B,GAAGjB,KAAK,CAACO,cAAN,CAAqBS,sBAArB,CAAtC;;AACA,QAAIlB,kBAAkB,CAACoB,cAAnB,CAAkCD,6BAAlC,KAAoEnB,kBAAkB,CAACqB,oBAAnB,CAAwCF,6BAAxC,CAAxE,EAAgJ;AAC5I,aAAO;AACHH,QAAAA,WAAW,EAAErI,OAAO,CAAC2I,oBAAR,CAA6BH,6BAA7B,CADV;AAEHF,QAAAA,MAAM,EAAEnI,YAAY,CAACyI,MAFlB;AAGHC,QAAAA,IAAI,EAAEN;AAHH,OAAP;AAKH,KAND,MAOK,IAAIlB,kBAAkB,CAACyB,cAAnB,CAAkCN,6BAAlC,CAAJ,EAAsE;AACvE,aAAO;AACHH,QAAAA,WAAW,EAAErI,OAAO,CAAC2I,oBAAR,CAA6BH,6BAA7B,CADV;AAEHF,QAAAA,MAAM,EAAE,IAFL;AAGHO,QAAAA,IAAI,EAAEN;AAHH,OAAP;AAKH,KANI,MAOA;AACD;AACA;AACA;AACA;AACA;AACA,UAAIA,sBAAsB,KAAK,CAA/B,EAAkC;AAC9B,eAAO;AACHF,UAAAA,WAAW,EAAErI,OAAO,CAAC2I,oBAAR,CAA6BpB,KAAK,CAACO,cAAN,CAAqBS,sBAArB,CAA7B,CADV;AAEHD,UAAAA,MAAM,EAAE,IAFL;AAGHO,UAAAA,IAAI,EAAEN;AAHH,SAAP;AAKH;;AACD,YAAMQ,YAAY,GAAGR,sBAAsB,GAAG,CAA9C;AACA,YAAMS,0BAA0B,GAAG3B,kBAAkB,CAAC4B,iBAAnB,CAAqC1B,KAAK,CAACO,cAAN,CAAqBiB,YAArB,CAArC,CAAnC;;AACA,UAAI,EAAEC,0BAA0B,IAAI;AAAE;AAAF,QAAwB;AAAE;AAA9B,OAA5B,KACCA,0BAA0B,GAAG;AAAE;AADpC,QACiE;AAC7D,YAAIE,QAAQ,GAAG,CAAf;;AACA,aAAK,IAAI1J,CAAC,GAAGuJ,YAAY,GAAG,CAA5B,EAA+BvJ,CAAC,GAAG,CAAnC,EAAsCA,CAAC,EAAvC,EAA2C;AACvC,cAAI6H,kBAAkB,CAACqB,oBAAnB,CAAwCnB,KAAK,CAACO,cAAN,CAAqBtI,CAArB,CAAxC,CAAJ,EAAsE;AAClE;AACH;;AACD0J,UAAAA,QAAQ,GAAG1J,CAAX;AACA;AACH;;AACD,eAAO;AACH6I,UAAAA,WAAW,EAAErI,OAAO,CAAC2I,oBAAR,CAA6BpB,KAAK,CAACO,cAAN,CAAqBoB,QAAQ,GAAG,CAAhC,CAA7B,CADV;AAEHZ,UAAAA,MAAM,EAAE,IAFL;AAGHO,UAAAA,IAAI,EAAEK,QAAQ,GAAG;AAHd,SAAP;AAKH;;AACD,UAAIf,oBAAJ,EAA0B;AACtB,eAAO;AACHE,UAAAA,WAAW,EAAErI,OAAO,CAAC2I,oBAAR,CAA6BpB,KAAK,CAACO,cAAN,CAAqBS,sBAArB,CAA7B,CADV;AAEHD,UAAAA,MAAM,EAAE,IAFL;AAGHO,UAAAA,IAAI,EAAEN;AAHH,SAAP;AAKH,OAND,MAOK;AACD;AACA,aAAK,IAAI/I,CAAC,GAAG+I,sBAAb,EAAqC/I,CAAC,GAAG,CAAzC,EAA4CA,CAAC,EAA7C,EAAiD;AAC7C,gBAAM2J,WAAW,GAAG5B,KAAK,CAACO,cAAN,CAAqBtI,CAArB,CAApB;;AACA,cAAI6H,kBAAkB,CAACoB,cAAnB,CAAkCU,WAAlC,CAAJ,EAAoD;AAChD,mBAAO;AACHd,cAAAA,WAAW,EAAErI,OAAO,CAAC2I,oBAAR,CAA6BQ,WAA7B,CADV;AAEHb,cAAAA,MAAM,EAAEnI,YAAY,CAACyI,MAFlB;AAGHC,cAAAA,IAAI,EAAErJ;AAHH,aAAP;AAKH,WAND,MAOK,IAAI6H,kBAAkB,CAACqB,oBAAnB,CAAwCS,WAAxC,CAAJ,EAA0D;AAC3D,gBAAID,QAAQ,GAAG,CAAf;;AACA,iBAAK,IAAIE,CAAC,GAAG5J,CAAC,GAAG,CAAjB,EAAoB4J,CAAC,GAAG,CAAxB,EAA2BA,CAAC,EAA5B,EAAgC;AAC5B,kBAAI/B,kBAAkB,CAACqB,oBAAnB,CAAwCnB,KAAK,CAACO,cAAN,CAAqBtI,CAArB,CAAxC,CAAJ,EAAsE;AAClE;AACH;;AACD0J,cAAAA,QAAQ,GAAGE,CAAX;AACA;AACH;;AACD,mBAAO;AACHf,cAAAA,WAAW,EAAErI,OAAO,CAAC2I,oBAAR,CAA6BpB,KAAK,CAACO,cAAN,CAAqBoB,QAAQ,GAAG,CAAhC,CAA7B,CADV;AAEHZ,cAAAA,MAAM,EAAE,IAFL;AAGHO,cAAAA,IAAI,EAAEK,QAAQ,GAAG;AAHd,aAAP;AAKH,WAdI,MAeA,IAAI7B,kBAAkB,CAACyB,cAAnB,CAAkCK,WAAlC,CAAJ,EAAoD;AACrD,mBAAO;AACHd,cAAAA,WAAW,EAAErI,OAAO,CAAC2I,oBAAR,CAA6BQ,WAA7B,CADV;AAEHb,cAAAA,MAAM,EAAE,IAFL;AAGHO,cAAAA,IAAI,EAAErJ;AAHH,aAAP;AAKH;AACJ;;AACD,eAAO;AACH6I,UAAAA,WAAW,EAAErI,OAAO,CAAC2I,oBAAR,CAA6BpB,KAAK,CAACO,cAAN,CAAqB,CAArB,CAA7B,CADV;AAEHQ,UAAAA,MAAM,EAAE,IAFL;AAGHO,UAAAA,IAAI,EAAE;AAHH,SAAP;AAKH;AACJ;AACJ;;AACDQ,EAAAA,oBAAoB,CAACnB,UAAD,EAAaoB,YAAb,EAA2BrI,UAA3B,EAAuCuG,UAAvC,EAAmD+B,eAAnD,EAAoE;AACpF,QAAIrB,UAAU,GAAG;AAAE;AAAnB,MAA+B;AAC3B,aAAO,IAAP;AACH;;AACD,UAAMsB,eAAe,GAAG,KAAKpG,wBAAL,CAA8BnC,UAA9B,CAAxB;;AACA,QAAI,CAACuI,eAAL,EAAsB;AAClB,aAAO,IAAP;AACH;;AACD,UAAMnC,kBAAkB,GAAG,KAAKD,qBAAL,CAA2BnG,UAA3B,CAA3B;;AACA,QAAI,CAACoG,kBAAL,EAAyB;AACrB,aAAO,IAAP;AACH;;AACD,UAAMoC,MAAM,GAAG,KAAKxB,uBAAL,CAA6BC,UAA7B,EAAyCoB,YAAzC,EAAuD9B,UAAvD,CAAf;AACA,UAAM2B,WAAW,GAAGG,YAAY,CAACxB,cAAb,CAA4BN,UAA5B,CAApB;;AACA,QAAIiC,MAAJ,EAAY;AACR,YAAMC,WAAW,GAAGD,MAAM,CAACZ,IAA3B;;AACA,UAAIa,WAAW,KAAKzG,SAApB,EAA+B;AAC3B,cAAM0G,WAAW,GAAGH,eAAe,CAACI,OAAhB,CAAwB1B,UAAxB,EAAoC,EAApC,EAAwCoB,YAAY,CAACxB,cAAb,CAA4B4B,WAA5B,CAAxC,EAAkF,EAAlF,CAApB;;AACA,YAAIC,WAAJ,EAAiB;AACb,cAAItB,WAAW,GAAGrI,OAAO,CAAC2I,oBAAR,CAA6BW,YAAY,CAACxB,cAAb,CAA4B4B,WAA5B,CAA7B,CAAlB;;AACA,cAAIC,WAAW,CAACE,UAAhB,EAA4B;AACxBxB,YAAAA,WAAW,GAAGA,WAAW,CAACyB,SAAZ,CAAsB,CAAtB,EAAyBzB,WAAW,CAACpJ,MAAZ,GAAqB0K,WAAW,CAACE,UAA1D,CAAd;AACH;;AACD,cAAKF,WAAW,CAACI,YAAZ,KAA6B5J,YAAY,CAACyI,MAA3C,IACCe,WAAW,CAACI,YAAZ,KAA6B5J,YAAY,CAAC6J,aAD/C,EAC+D;AAC3D3B,YAAAA,WAAW,GAAGkB,eAAe,CAACU,WAAhB,CAA4B5B,WAA5B,CAAd;AACH,WAHD,MAIK,IAAIsB,WAAW,CAACI,YAAZ,KAA6B5J,YAAY,CAAC+J,OAA9C,EAAuD;AACxD7B,YAAAA,WAAW,GAAGkB,eAAe,CAACY,aAAhB,CAA8B9B,WAA9B,CAAd;AACH;;AACD,cAAIhB,kBAAkB,CAACyB,cAAnB,CAAkCK,WAAlC,CAAJ,EAAoD;AAChDd,YAAAA,WAAW,GAAGkB,eAAe,CAACY,aAAhB,CAA8B9B,WAA9B,CAAd;AACH;;AACD,cAAIsB,WAAW,CAACS,UAAhB,EAA4B;AACxB/B,YAAAA,WAAW,IAAIsB,WAAW,CAACS,UAA3B;AACH;;AACD,iBAAOpK,OAAO,CAAC2I,oBAAR,CAA6BN,WAA7B,CAAP;AACH;AACJ;;AACD,UAAIhB,kBAAkB,CAACyB,cAAnB,CAAkCK,WAAlC,CAAJ,EAAoD;AAChD,YAAIM,MAAM,CAACnB,MAAP,KAAkBnI,YAAY,CAACyI,MAAnC,EAA2C;AACvC,iBAAOa,MAAM,CAACpB,WAAd;AACH,SAFD,MAGK;AACD,iBAAOkB,eAAe,CAACY,aAAhB,CAA8BV,MAAM,CAACpB,WAArC,CAAP;AACH;AACJ,OAPD,MAQK;AACD,YAAIoB,MAAM,CAACnB,MAAP,KAAkBnI,YAAY,CAACyI,MAAnC,EAA2C;AACvC,iBAAOW,eAAe,CAACU,WAAhB,CAA4BR,MAAM,CAACpB,WAAnC,CAAP;AACH,SAFD,MAGK;AACD,iBAAOoB,MAAM,CAACpB,WAAd;AACH;AACJ;AACJ;;AACD,WAAO,IAAP;AACH;;AACDgC,EAAAA,iBAAiB,CAACnC,UAAD,EAAaX,KAAb,EAAoB+C,KAApB,EAA2Bf,eAA3B,EAA4C;AACzD,QAAIrB,UAAU,GAAG;AAAE;AAAnB,MAA+B;AAC3B,aAAO,IAAP;AACH;;AACDX,IAAAA,KAAK,CAACgD,iBAAN,CAAwBD,KAAK,CAACE,eAA9B;AACA,UAAMC,UAAU,GAAGlD,KAAK,CAACmD,aAAN,CAAoBJ,KAAK,CAACE,eAA1B,CAAnB;AACA,UAAMrE,gBAAgB,GAAG9F,sBAAsB,CAACoK,UAAD,EAAaH,KAAK,CAACK,WAAN,GAAoB,CAAjC,CAA/C;AACA,UAAMC,cAAc,GAAGzE,gBAAgB,CAAC2B,cAAjB,EAAvB;AACA,QAAI+C,gBAAgB,GAAG,KAAvB;AACA,QAAIC,eAAJ;;AACA,QAAI3E,gBAAgB,CAACC,eAAjB,GAAmC,CAAnC,IAAwCqE,UAAU,CAACrC,aAAX,CAAyB,CAAzB,MAAgCjC,gBAAgB,CAAClF,UAA7F,EAAyG;AACrG;AACA4J,MAAAA,gBAAgB,GAAG,IAAnB,CAFqG,CAE5E;;AACzBC,MAAAA,eAAe,GAAGF,cAAc,CAACG,MAAf,CAAsB,CAAtB,EAAyBT,KAAK,CAACK,WAAN,GAAoB,CAApB,GAAwBxE,gBAAgB,CAACC,eAAlE,CAAlB;AACH,KAJD,MAKK;AACD0E,MAAAA,eAAe,GAAGL,UAAU,CAAC3C,cAAX,GAA4BgC,SAA5B,CAAsC,CAAtC,EAAyCQ,KAAK,CAACK,WAAN,GAAoB,CAA7D,CAAlB;AACH;;AACD,QAAIK,cAAJ;;AACA,QAAIV,KAAK,CAACW,OAAN,EAAJ,EAAqB;AACjBD,MAAAA,cAAc,GAAGJ,cAAc,CAACG,MAAf,CAAsBT,KAAK,CAACK,WAAN,GAAoB,CAApB,GAAwBxE,gBAAgB,CAACC,eAA/D,CAAjB;AACH,KAFD,MAGK;AACD,YAAM8E,mBAAmB,GAAG,KAAKC,mBAAL,CAAyB5D,KAAzB,EAAgC+C,KAAK,CAACc,aAAtC,EAAqDd,KAAK,CAACe,SAA3D,CAA5B;AACAL,MAAAA,cAAc,GAAGE,mBAAmB,CAACpD,cAApB,GAAqCiD,MAArC,CAA4CT,KAAK,CAACe,SAAN,GAAkB,CAAlB,GAAsBlF,gBAAgB,CAACC,eAAnF,CAAjB;AACH;;AACD,UAAMiB,kBAAkB,GAAG,KAAKD,qBAAL,CAA2BjB,gBAAgB,CAAClF,UAA5C,CAA3B;;AACA,QAAI,CAACoG,kBAAL,EAAyB;AACrB,aAAO,IAAP;AACH;;AACD,UAAMiE,iBAAiB,GAAGR,eAA1B;AACA,UAAMS,iBAAiB,GAAGvL,OAAO,CAAC2I,oBAAR,CAA6BmC,eAA7B,CAA1B;AACA,UAAMxB,YAAY,GAAG;AACjBoB,MAAAA,aAAa,EAAGlD,UAAD,IAAgB;AAC3B,eAAOD,KAAK,CAACmD,aAAN,CAAoBlD,UAApB,CAAP;AACH,OAHgB;AAIjBY,MAAAA,aAAa,EAAE,MAAM;AACjB,eAAOb,KAAK,CAACa,aAAN,EAAP;AACH,OANgB;AAOjBV,MAAAA,uBAAuB,EAAE,CAACF,UAAD,EAAatB,MAAb,KAAwB;AAC7C,eAAOqB,KAAK,CAACG,uBAAN,CAA8BF,UAA9B,EAA0CtB,MAA1C,CAAP;AACH,OATgB;AAUjB4B,MAAAA,cAAc,EAAGN,UAAD,IAAgB;AAC5B,YAAIA,UAAU,KAAK8C,KAAK,CAACE,eAAzB,EAA0C;AACtC,iBAAOc,iBAAP;AACH,SAFD,MAGK;AACD,iBAAO/D,KAAK,CAACO,cAAN,CAAqBN,UAArB,CAAP;AACH;AACJ;AAjBgB,KAArB;AAmBA,UAAMgE,iBAAiB,GAAGxL,OAAO,CAAC2I,oBAAR,CAA6B8B,UAAU,CAAC3C,cAAX,EAA7B,CAA1B;AACA,UAAM2D,gBAAgB,GAAG,KAAKxD,uBAAL,CAA6BC,UAA7B,EAAyCoB,YAAzC,EAAuDgB,KAAK,CAACE,eAAN,GAAwB,CAA/E,CAAzB;;AACA,QAAI,CAACiB,gBAAL,EAAuB;AACnB,YAAMC,WAAW,GAAGb,gBAAgB,GAAGW,iBAAH,GAAuBD,iBAA3D;AACA,aAAO;AACHG,QAAAA,WAAW,EAAEA,WADV;AAEHC,QAAAA,UAAU,EAAED;AAFT,OAAP;AAIH;;AACD,QAAIE,gBAAgB,GAAGf,gBAAgB,GAAGW,iBAAH,GAAuBC,gBAAgB,CAACpD,WAA/E;;AACA,QAAIoD,gBAAgB,CAACnD,MAAjB,KAA4BnI,YAAY,CAACyI,MAA7C,EAAqD;AACjDgD,MAAAA,gBAAgB,GAAGrC,eAAe,CAACU,WAAhB,CAA4B2B,gBAA5B,CAAnB;AACH;;AACD,QAAIvE,kBAAkB,CAACyB,cAAnB,CAAkCkC,cAAlC,CAAJ,EAAuD;AACnDY,MAAAA,gBAAgB,GAAGrC,eAAe,CAACY,aAAhB,CAA8ByB,gBAA9B,CAAnB;AACH;;AACD,WAAO;AACHF,MAAAA,WAAW,EAAEb,gBAAgB,GAAGW,iBAAH,GAAuBD,iBADjD;AAEHI,MAAAA,UAAU,EAAEC;AAFT,KAAP;AAIH;AACD;AACJ;AACA;AACA;;;AACIC,EAAAA,sBAAsB,CAAC3D,UAAD,EAAaX,KAAb,EAAoB+C,KAApB,EAA2BwB,EAA3B,EAA+BvC,eAA/B,EAAgD;AAClE,QAAIrB,UAAU,GAAG;AAAE;AAAnB,MAA+B;AAC3B,aAAO,IAAP;AACH;;AACD,UAAM/B,gBAAgB,GAAG,KAAKgF,mBAAL,CAAyB5D,KAAzB,EAAgC+C,KAAK,CAACE,eAAtC,EAAuDF,KAAK,CAACK,WAA7D,CAAzB;;AACA,QAAIxE,gBAAgB,CAACC,eAArB,EAAsC;AAClC;AACA,aAAO,IAAP;AACH;;AACD,UAAMiB,kBAAkB,GAAG,KAAKD,qBAAL,CAA2BjB,gBAAgB,CAAClF,UAA5C,CAA3B;;AACA,QAAI,CAACoG,kBAAL,EAAyB;AACrB,aAAO,IAAP;AACH;;AACD,UAAMuD,cAAc,GAAGzE,gBAAgB,CAAC2B,cAAjB,EAAvB;AACA,UAAMiE,cAAc,GAAGnB,cAAc,CAACG,MAAf,CAAsB,CAAtB,EAAyBT,KAAK,CAACK,WAAN,GAAoB,CAApB,GAAwBxE,gBAAgB,CAACC,eAAlE,CAAvB,CAdkE,CAelE;;AACA,QAAI4F,aAAJ;;AACA,QAAI1B,KAAK,CAACW,OAAN,EAAJ,EAAqB;AACjBe,MAAAA,aAAa,GAAGpB,cAAc,CAACG,MAAf,CAAsBT,KAAK,CAACK,WAAN,GAAoB,CAApB,GAAwBxE,gBAAgB,CAACC,eAA/D,CAAhB;AACH,KAFD,MAGK;AACD,YAAM8E,mBAAmB,GAAG,KAAKC,mBAAL,CAAyB5D,KAAzB,EAAgC+C,KAAK,CAACc,aAAtC,EAAqDd,KAAK,CAACe,SAA3D,CAA5B;AACAW,MAAAA,aAAa,GAAGd,mBAAmB,CAACpD,cAApB,GAAqCiD,MAArC,CAA4CT,KAAK,CAACe,SAAN,GAAkB,CAAlB,GAAsBlF,gBAAgB,CAACC,eAAnF,CAAhB;AACH,KAvBiE,CAwBlE;AACA;;;AACA,QAAI,CAACiB,kBAAkB,CAACyB,cAAnB,CAAkCiD,cAAc,GAAGC,aAAnD,CAAD,IAAsE3E,kBAAkB,CAACyB,cAAnB,CAAkCiD,cAAc,GAAGD,EAAjB,GAAsBE,aAAxD,CAA1E,EAAkJ;AAC9I;AACA;AACA,YAAM9M,CAAC,GAAG,KAAK+I,uBAAL,CAA6BC,UAA7B,EAAyCX,KAAzC,EAAgD+C,KAAK,CAACE,eAAtD,EAAuE,KAAvE,CAAV;;AACA,UAAI,CAACtL,CAAL,EAAQ;AACJ,eAAO,IAAP;AACH;;AACD,UAAImJ,WAAW,GAAGnJ,CAAC,CAACmJ,WAApB;;AACA,UAAInJ,CAAC,CAACoJ,MAAF,KAAanI,YAAY,CAACyI,MAA9B,EAAsC;AAClCP,QAAAA,WAAW,GAAGkB,eAAe,CAACY,aAAhB,CAA8B9B,WAA9B,CAAd;AACH;;AACD,aAAOA,WAAP;AACH;;AACD,WAAO,IAAP;AACH;;AACDY,EAAAA,iBAAiB,CAAC1B,KAAD,EAAQC,UAAR,EAAoB;AACjC,UAAMH,kBAAkB,GAAG,KAAKD,qBAAL,CAA2BG,KAAK,CAACa,aAAN,EAA3B,CAA3B;;AACA,QAAI,CAACf,kBAAL,EAAyB;AACrB,aAAO,IAAP;AACH;;AACD,QAAIG,UAAU,GAAG,CAAb,IAAkBA,UAAU,GAAGD,KAAK,CAAC0E,YAAN,EAAnC,EAAyD;AACrD,aAAO,IAAP;AACH;;AACD,WAAO5E,kBAAkB,CAAC4B,iBAAnB,CAAqC1B,KAAK,CAACO,cAAN,CAAqBN,UAArB,CAArC,CAAP;AACH,GA1c0C,CA2c3C;AACA;;;AACA0E,EAAAA,cAAc,CAAChE,UAAD,EAAaX,KAAb,EAAoB+C,KAApB,EAA2B;AACrC,UAAMnE,gBAAgB,GAAG,KAAKgF,mBAAL,CAAyB5D,KAAzB,EAAgC+C,KAAK,CAACE,eAAtC,EAAuDF,KAAK,CAACK,WAA7D,CAAzB;AACA,UAAMnB,eAAe,GAAG,KAAKpG,wBAAL,CAA8B+C,gBAAgB,CAAClF,UAA/C,CAAxB;;AACA,QAAI,CAACuI,eAAL,EAAsB;AAClB,aAAO,IAAP;AACH;;AACD,UAAMoB,cAAc,GAAGzE,gBAAgB,CAAC2B,cAAjB,EAAvB;AACA,UAAMgD,eAAe,GAAGF,cAAc,CAACG,MAAf,CAAsB,CAAtB,EAAyBT,KAAK,CAACK,WAAN,GAAoB,CAApB,GAAwBxE,gBAAgB,CAACC,eAAlE,CAAxB,CAPqC,CAQrC;;AACA,QAAI4E,cAAJ;;AACA,QAAIV,KAAK,CAACW,OAAN,EAAJ,EAAqB;AACjBD,MAAAA,cAAc,GAAGJ,cAAc,CAACG,MAAf,CAAsBT,KAAK,CAACK,WAAN,GAAoB,CAApB,GAAwBxE,gBAAgB,CAACC,eAA/D,CAAjB;AACH,KAFD,MAGK;AACD,YAAM8E,mBAAmB,GAAG,KAAKC,mBAAL,CAAyB5D,KAAzB,EAAgC+C,KAAK,CAACc,aAAtC,EAAqDd,KAAK,CAACe,SAA3D,CAA5B;AACAL,MAAAA,cAAc,GAAGE,mBAAmB,CAACpD,cAApB,GAAqCiD,MAArC,CAA4CT,KAAK,CAACe,SAAN,GAAkB,CAAlB,GAAsBlF,gBAAgB,CAACC,eAAnF,CAAjB;AACH;;AACD,QAAI+F,gBAAgB,GAAG,EAAvB;;AACA,QAAI7B,KAAK,CAACE,eAAN,GAAwB,CAAxB,IAA6BrE,gBAAgB,CAACC,eAAjB,KAAqC,CAAtE,EAAyE;AACrE;AACA,YAAMgG,4BAA4B,GAAG,KAAKjB,mBAAL,CAAyB5D,KAAzB,EAAgC+C,KAAK,CAACE,eAAN,GAAwB,CAAxD,CAArC;;AACA,UAAI4B,4BAA4B,CAACnL,UAA7B,KAA4CkF,gBAAgB,CAAClF,UAAjE,EAA6E;AACzE;AACAkL,QAAAA,gBAAgB,GAAGC,4BAA4B,CAACtE,cAA7B,EAAnB;AACH;AACJ;;AACD,UAAM6B,WAAW,GAAGH,eAAe,CAACI,OAAhB,CAAwB1B,UAAxB,EAAoCiE,gBAApC,EAAsDrB,eAAtD,EAAuEE,cAAvE,CAApB;;AACA,QAAI,CAACrB,WAAL,EAAkB;AACd,aAAO,IAAP;AACH;;AACD,UAAMI,YAAY,GAAGJ,WAAW,CAACI,YAAjC;AACA,QAAIK,UAAU,GAAGT,WAAW,CAACS,UAA7B;AACA,UAAMP,UAAU,GAAGF,WAAW,CAACE,UAAZ,IAA0B,CAA7C,CAhCqC,CAiCrC;;AACA,QAAI,CAACO,UAAL,EAAiB;AACb,UAAKL,YAAY,KAAK5J,YAAY,CAACyI,MAA/B,IACCmB,YAAY,KAAK5J,YAAY,CAAC6J,aADnC,EACmD;AAC/CI,QAAAA,UAAU,GAAG,IAAb;AACH,OAHD,MAIK;AACDA,QAAAA,UAAU,GAAG,EAAb;AACH;AACJ,KARD,MASK,IAAIL,YAAY,KAAK5J,YAAY,CAACyI,MAAlC,EAA0C;AAC3CwB,MAAAA,UAAU,GAAG,OAAOA,UAApB;AACH;;AACD,QAAI/B,WAAW,GAAG,KAAKgE,wBAAL,CAA8B9E,KAA9B,EAAqC+C,KAAK,CAACE,eAA3C,EAA4DF,KAAK,CAACK,WAAlE,CAAlB;;AACA,QAAId,UAAJ,EAAgB;AACZxB,MAAAA,WAAW,GAAGA,WAAW,CAACyB,SAAZ,CAAsB,CAAtB,EAAyBzB,WAAW,CAACpJ,MAAZ,GAAqB4K,UAA9C,CAAd;AACH;;AACD,WAAO;AACHE,MAAAA,YAAY,EAAEA,YADX;AAEHK,MAAAA,UAAU,EAAEA,UAFT;AAGHP,MAAAA,UAAU,EAAEA,UAHT;AAIHxB,MAAAA,WAAW,EAAEA;AAJV,KAAP;AAMH;;AACDgE,EAAAA,wBAAwB,CAAC9E,KAAD,EAAQC,UAAR,EAAoBtB,MAApB,EAA4B;AAChD,UAAMoG,QAAQ,GAAG/E,KAAK,CAACO,cAAN,CAAqBN,UAArB,CAAjB;AACA,QAAIa,WAAW,GAAGrI,OAAO,CAAC2I,oBAAR,CAA6B2D,QAA7B,CAAlB;;AACA,QAAIjE,WAAW,CAACpJ,MAAZ,GAAqBiH,MAAM,GAAG,CAAlC,EAAqC;AACjCmC,MAAAA,WAAW,GAAGA,WAAW,CAACyB,SAAZ,CAAsB,CAAtB,EAAyB5D,MAAM,GAAG,CAAlC,CAAd;AACH;;AACD,WAAOmC,WAAP;AACH;;AACD8C,EAAAA,mBAAmB,CAAC5D,KAAD,EAAQC,UAAR,EAAoB+E,YAApB,EAAkC;AACjDhF,IAAAA,KAAK,CAACgD,iBAAN,CAAwB/C,UAAxB;AACA,UAAMiD,UAAU,GAAGlD,KAAK,CAACmD,aAAN,CAAoBlD,UAApB,CAAnB;AACA,UAAMtB,MAAM,GAAI,OAAOqG,YAAP,KAAwB,WAAxB,GAAsChF,KAAK,CAACiF,gBAAN,CAAuBhF,UAAvB,IAAqC,CAA3E,GAA+E+E,YAAY,GAAG,CAA9G;AACA,WAAOlM,sBAAsB,CAACoK,UAAD,EAAavE,MAAb,CAA7B;AACH;;AAnhB0C;AAqhB/C,OAAO,MAAM/C,6BAA6B,GAAG,IAAI0B,iCAAJ,EAAtC;;AACP,MAAMO,6BAAN,CAAoC;AAChCpE,EAAAA,WAAW,CAACC,UAAD,EAAa;AACpB,SAAKA,UAAL,GAAkBA,UAAlB;AACA,SAAKwL,SAAL,GAAiB,IAAjB;AACA,SAAK3H,QAAL,GAAgB,EAAhB;AACA,SAAK4H,MAAL,GAAc,CAAd;AACA,SAAKD,SAAL,GAAiB,IAAjB;AACH;;AACDzH,EAAAA,QAAQ,CAACC,aAAD,EAAgBC,QAAhB,EAA0B;AAC9B,UAAMyH,KAAK,GAAG,IAAIC,iCAAJ,CAAsC3H,aAAtC,EAAqDC,QAArD,EAA+D,EAAE,KAAKwH,MAAtE,CAAd;;AACA,SAAK5H,QAAL,CAAc+H,IAAd,CAAmBF,KAAnB;;AACA,SAAKF,SAAL,GAAiB,IAAjB;AACA,WAAO1M,YAAY,CAAC,MAAM;AACtB,WAAK,IAAIP,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKsF,QAAL,CAAc7F,MAAlC,EAA0CO,CAAC,EAA3C,EAA+C;AAC3C,YAAI,KAAKsF,QAAL,CAActF,CAAd,MAAqBmN,KAAzB,EAAgC;AAC5B,eAAK7H,QAAL,CAAcgI,MAAd,CAAqBtN,CAArB,EAAwB,CAAxB;;AACA,eAAKiN,SAAL,GAAiB,IAAjB;AACA;AACH;AACJ;AACJ,KARkB,CAAnB;AASH;;AACDlH,EAAAA,wBAAwB,GAAG;AACvB,QAAI,CAAC,KAAKkH,SAAV,EAAqB;AACjB,YAAMvI,MAAM,GAAG,KAAK6I,QAAL,EAAf;;AACA,UAAI7I,MAAJ,EAAY;AACR,aAAKuI,SAAL,GAAiB,IAAI7I,6BAAJ,CAAkC,KAAK3C,UAAvC,EAAmDiD,MAAnD,CAAjB;AACH;AACJ;;AACD,WAAO,KAAKuI,SAAZ;AACH;;AACDM,EAAAA,QAAQ,GAAG;AACP,QAAI,KAAKjI,QAAL,CAAc7F,MAAd,KAAyB,CAA7B,EAAgC;AAC5B,aAAO,IAAP;AACH;;AACD,SAAK6F,QAAL,CAAckI,IAAd,CAAmBJ,iCAAiC,CAACK,GAArD;;AACA,WAAOjJ,6BAA6B,CAAC,KAAKc,QAAL,CAAcjC,GAAd,CAAkBX,CAAC,IAAIA,CAAC,CAAC+C,aAAzB,CAAD,CAApC;AACH;;AArC+B;;AAuCpC,SAASjB,6BAAT,CAAuCkJ,OAAvC,EAAgD;AAC5C,MAAI7J,MAAM,GAAG;AACTiD,IAAAA,QAAQ,EAAErD,SADD;AAETkB,IAAAA,QAAQ,EAAElB,SAFD;AAGTkK,IAAAA,WAAW,EAAElK,SAHJ;AAITyC,IAAAA,gBAAgB,EAAEzC,SAJT;AAKTmK,IAAAA,YAAY,EAAEnK,SALL;AAMToK,IAAAA,gBAAgB,EAAEpK,SANT;AAOTqK,IAAAA,gBAAgB,EAAErK,SAPT;AAQTsK,IAAAA,eAAe,EAAEtK,SARR;AASTuK,IAAAA,OAAO,EAAEvK,SATA;AAUTmB,IAAAA,qBAAqB,EAAEnB,SAVd;AAWTwK,IAAAA,0BAA0B,EAAExK;AAXnB,GAAb;;AAaA,OAAK,MAAM0J,KAAX,IAAoBO,OAApB,EAA6B;AACzB7J,IAAAA,MAAM,GAAG;AACLiD,MAAAA,QAAQ,EAAEqG,KAAK,CAACrG,QAAN,IAAkBjD,MAAM,CAACiD,QAD9B;AAELnC,MAAAA,QAAQ,EAAEwI,KAAK,CAACxI,QAAN,IAAkBd,MAAM,CAACc,QAF9B;AAGLgJ,MAAAA,WAAW,EAAER,KAAK,CAACQ,WAAN,IAAqB9J,MAAM,CAAC8J,WAHpC;AAILzH,MAAAA,gBAAgB,EAAEiH,KAAK,CAACjH,gBAAN,IAA0BrC,MAAM,CAACqC,gBAJ9C;AAKL0H,MAAAA,YAAY,EAAET,KAAK,CAACS,YAAN,IAAsB/J,MAAM,CAAC+J,YALtC;AAMLC,MAAAA,gBAAgB,EAAEV,KAAK,CAACU,gBAAN,IAA0BhK,MAAM,CAACgK,gBAN9C;AAOLC,MAAAA,gBAAgB,EAAEX,KAAK,CAACW,gBAAN,IAA0BjK,MAAM,CAACiK,gBAP9C;AAQLC,MAAAA,eAAe,EAAEZ,KAAK,CAACY,eAAN,IAAyBlK,MAAM,CAACkK,eAR5C;AASLC,MAAAA,OAAO,EAAEb,KAAK,CAACa,OAAN,IAAiBnK,MAAM,CAACmK,OAT5B;AAULpJ,MAAAA,qBAAqB,EAAEuI,KAAK,CAACvI,qBAAN,IAA+Bf,MAAM,CAACe,qBAVxD;AAWLqJ,MAAAA,0BAA0B,EAAEd,KAAK,CAACc,0BAAN,IAAoCpK,MAAM,CAACoK;AAXlE,KAAT;AAaH;;AACD,SAAOpK,MAAP;AACH;;AACD,MAAMuJ,iCAAN,CAAwC;AACpC5L,EAAAA,WAAW,CAACiE,aAAD,EAAgBC,QAAhB,EAA0BwI,KAA1B,EAAiC;AACxC,SAAKzI,aAAL,GAAqBA,aAArB;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKwI,KAAL,GAAaA,KAAb;AACH;;AACS,SAAHT,GAAG,CAACU,CAAD,EAAIC,CAAJ,EAAO;AACb,QAAID,CAAC,CAACzI,QAAF,KAAe0I,CAAC,CAAC1I,QAArB,EAA+B;AAC3B;AACA,aAAOyI,CAAC,CAACD,KAAF,GAAUE,CAAC,CAACF,KAAnB;AACH,KAJY,CAKb;;;AACA,WAAOC,CAAC,CAACzI,QAAF,GAAa0I,CAAC,CAAC1I,QAAtB;AACH;;AAbmC;AAexC;AACA;AACA;;;AACA,OAAO,MAAMtB,6BAAN,CAAoC;AACvC5C,EAAAA,WAAW,CAACC,UAAD,EAAagD,gBAAb,EAA+B;AACtC,SAAKhD,UAAL,GAAkBA,UAAlB;AACA,SAAKgD,gBAAL,GAAwBA,gBAAxB;AACA,SAAK4J,SAAL,GAAiB,IAAjB;AACA,SAAKC,kBAAL,GAA0B,IAA1B;AACA,SAAKC,eAAL,GACI,KAAK9J,gBAAL,CAAsBE,QAAtB,IACI,KAAKF,gBAAL,CAAsByB,gBAD1B,IAEI,KAAKzB,gBAAL,CAAsBmJ,YAF1B,GAGM,IAAI3M,cAAJ,CAAmB,KAAKwD,gBAAxB,CAHN,GAIM,IALV;AAMA,SAAKqC,QAAL,GAAgB1C,6BAA6B,CAACoK,eAA9B,CAA8C,KAAK/J,gBAAnD,CAAhB;AACA,SAAKuC,aAAL,GAAqB,IAAIlG,oBAAJ,CAAyB,KAAK2D,gBAA9B,CAArB;AACA,SAAKgD,cAAL,GAAsB,KAAKhD,gBAAL,CAAsBkJ,WAAtB,IAAqClN,mBAA3D;AACA,SAAKyF,gBAAL,GAAwB,KAAKzB,gBAAL,CAAsByB,gBAA9C;;AACA,QAAI,KAAKzB,gBAAL,CAAsByB,gBAA1B,EAA4C;AACxC,WAAK2B,kBAAL,GAA0B,IAAI7G,kBAAJ,CAAuB,KAAKyD,gBAAL,CAAsByB,gBAA7C,CAA1B;AACH,KAFD,MAGK;AACD,WAAK2B,kBAAL,GAA0B,IAA1B;AACH;;AACD,SAAKF,YAAL,GAAoB,KAAKlD,gBAAL,CAAsBuJ,OAAtB,IAAiC,EAArD;AACH;;AACDxG,EAAAA,iBAAiB,GAAG;AAChB,WAAO9G,yBAAyB,CAAC,KAAK+G,cAAN,CAAhC;AACH;;AACW,MAAR9C,QAAQ,GAAG;AACX,QAAI,CAAC,KAAK0J,SAAN,IAAmB,KAAK5J,gBAAL,CAAsBE,QAA7C,EAAuD;AACnD,WAAK0J,SAAL,GAAiB,IAAInN,gBAAJ,CAAqB,KAAKO,UAA1B,EAAsC,KAAKgD,gBAAL,CAAsBE,QAA5D,CAAjB;AACH;;AACD,WAAO,KAAK0J,SAAZ;AACH;;AACoB,MAAjBjI,iBAAiB,GAAG;AACpB,QAAI,CAAC,KAAKkI,kBAAV,EAA8B;AAC1B,WAAKA,kBAAL,GAA0B,IAAIvN,+BAAJ,CAAoC,KAAK4D,QAAzC,CAA1B;AACH;;AACD,WAAO,KAAK2J,kBAAZ;AACH;;AACDlE,EAAAA,OAAO,CAAC1B,UAAD,EAAaiE,gBAAb,EAA+BrB,eAA/B,EAAgDE,cAAhD,EAAgE;AACnE,QAAI,CAAC,KAAK+C,eAAV,EAA2B;AACvB,aAAO,IAAP;AACH;;AACD,WAAO,KAAKA,eAAL,CAAqBnE,OAArB,CAA6B1B,UAA7B,EAAyCiE,gBAAzC,EAA2DrB,eAA3D,EAA4EE,cAA5E,CAAP;AACH;;AACqB,SAAfgD,eAAe,CAACC,IAAD,EAAO;AACzB,QAAIC,WAAW,GAAGD,IAAI,CAAC3H,QAAvB;;AACA,QAAI,CAAC4H,WAAL,EAAkB;AACd,aAAO,IAAP;AACH,KAJwB,CAKzB;;;AACA,QAAI5H,QAAQ,GAAG,EAAf;;AACA,QAAI4H,WAAW,CAACC,WAAhB,EAA6B;AACzB7H,MAAAA,QAAQ,CAAC8H,gBAAT,GAA4BF,WAAW,CAACC,WAAxC;AACH;;AACD,QAAID,WAAW,CAACG,YAAhB,EAA8B;AAC1B,UAAI,CAACC,UAAD,EAAaC,QAAb,IAAyBL,WAAW,CAACG,YAAzC;AACA/H,MAAAA,QAAQ,CAACkI,sBAAT,GAAkCF,UAAlC;AACAhI,MAAAA,QAAQ,CAACmI,oBAAT,GAAgCF,QAAhC;AACH;;AACD,WAAOjI,QAAP;AACH;;AA7DsC;AA+D3CxF,iBAAiB,CAACK,6BAAD,EAAgCC,4BAAhC,CAAjB","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../model/wordHelper.js';\nimport { IndentAction, AutoClosingPairs } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { IModeService } from '../services/modeService.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nexport class LanguageConfigurationServiceChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n    affects(languageId) {\n        return !this.languageId ? true : this.languageId === languageId;\n    }\n}\nexport const ILanguageConfigurationService = createDecorator('languageConfigurationService');\nlet LanguageConfigurationService = class LanguageConfigurationService extends Disposable {\n    constructor(configurationService, modeService) {\n        super();\n        this.configurationService = configurationService;\n        this.modeService = modeService;\n        this.onDidChangeEmitter = this._register(new Emitter());\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.configurations = new Map();\n        const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));\n        this._register(this.configurationService.onDidChangeConfiguration((e) => {\n            const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));\n            const localConfigChanged = e.change.overrides\n                .filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k)))\n                .map(([overrideLangName]) => this.modeService.validateLanguageId(overrideLangName));\n            if (globalConfigChanged) {\n                this.configurations.clear();\n                this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));\n            }\n            else {\n                for (const languageId of localConfigChanged) {\n                    if (languageId) {\n                        this.configurations.delete(languageId);\n                        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));\n                    }\n                }\n            }\n        }));\n        this._register(LanguageConfigurationRegistry.onDidChange((e) => {\n            this.configurations.delete(e.languageId);\n            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));\n        }));\n    }\n    getLanguageConfiguration(languageId) {\n        let result = this.configurations.get(languageId);\n        if (!result) {\n            result = computeConfig(languageId, this.configurationService, this.modeService);\n            this.configurations.set(languageId, result);\n        }\n        return result;\n    }\n};\nLanguageConfigurationService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, IModeService)\n], LanguageConfigurationService);\nexport { LanguageConfigurationService };\nfunction computeConfig(languageId, configurationService, modeService) {\n    let languageConfig = LanguageConfigurationRegistry.getLanguageConfiguration(languageId);\n    if (!languageConfig) {\n        const validLanguageId = modeService.validateLanguageId(languageId);\n        if (!validLanguageId) {\n            throw new Error('Unexpected languageId');\n        }\n        languageConfig = new ResolvedLanguageConfiguration(validLanguageId, {});\n    }\n    const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);\n    const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);\n    const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);\n    return config;\n}\nconst customizedLanguageConfigKeys = {\n    brackets: 'editor.language.brackets',\n    colorizedBracketPairs: 'editor.language.colorizedBracketPairs'\n};\nfunction getCustomizedLanguageConfig(languageId, configurationService) {\n    const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {\n        overrideIdentifier: languageId,\n    });\n    const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {\n        overrideIdentifier: languageId,\n    });\n    return {\n        brackets: validateBracketPairs(brackets),\n        colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs),\n    };\n}\nfunction validateBracketPairs(data) {\n    if (!Array.isArray(data)) {\n        return undefined;\n    }\n    return data.map(pair => {\n        if (!Array.isArray(pair) || pair.length !== 2) {\n            return undefined;\n        }\n        return [pair[0], pair[1]];\n    }).filter((p) => !!p);\n}\nexport class LanguageConfigurationChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n}\nexport class LanguageConfigurationRegistryImpl {\n    constructor() {\n        this._entries = new Map();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    /**\n     * @param priority Use a higher number for higher priority\n     */\n    register(languageId, configuration, priority = 0) {\n        let entries = this._entries.get(languageId);\n        if (!entries) {\n            entries = new ComposedLanguageConfiguration(languageId);\n            this._entries.set(languageId, entries);\n        }\n        const disposable = entries.register(configuration, priority);\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        return toDisposable(() => {\n            disposable.dispose();\n            this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        });\n    }\n    getLanguageConfiguration(languageId) {\n        let entries = this._entries.get(languageId);\n        return (entries === null || entries === void 0 ? void 0 : entries.getResolvedConfiguration()) || null;\n    }\n    getIndentationRules(languageId) {\n        const value = this.getLanguageConfiguration(languageId);\n        return value ? value.indentationRules || null : null;\n    }\n    // begin electricCharacter\n    _getElectricCharacterSupport(languageId) {\n        let value = this.getLanguageConfiguration(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.electricCharacter || null;\n    }\n    getElectricCharacters(languageId) {\n        let electricCharacterSupport = this._getElectricCharacterSupport(languageId);\n        if (!electricCharacterSupport) {\n            return [];\n        }\n        return electricCharacterSupport.getElectricCharacters();\n    }\n    /**\n     * Should return opening bracket type to match indentation with\n     */\n    onElectricCharacter(character, context, column) {\n        let scopedLineTokens = createScopedLineTokens(context, column - 1);\n        let electricCharacterSupport = this._getElectricCharacterSupport(scopedLineTokens.languageId);\n        if (!electricCharacterSupport) {\n            return null;\n        }\n        return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n    }\n    // end electricCharacter\n    getComments(languageId) {\n        let value = this.getLanguageConfiguration(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.comments || null;\n    }\n    // begin characterPair\n    _getCharacterPairSupport(languageId) {\n        let value = this.getLanguageConfiguration(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.characterPair || null;\n    }\n    getAutoClosingPairs(languageId) {\n        const characterPairSupport = this._getCharacterPairSupport(languageId);\n        return new AutoClosingPairs(characterPairSupport ? characterPairSupport.getAutoClosingPairs() : []);\n    }\n    getAutoCloseBeforeSet(languageId) {\n        let characterPairSupport = this._getCharacterPairSupport(languageId);\n        if (!characterPairSupport) {\n            return CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;\n        }\n        return characterPairSupport.getAutoCloseBeforeSet();\n    }\n    getSurroundingPairs(languageId) {\n        let characterPairSupport = this._getCharacterPairSupport(languageId);\n        if (!characterPairSupport) {\n            return [];\n        }\n        return characterPairSupport.getSurroundingPairs();\n    }\n    shouldAutoClosePair(autoClosingPair, context, column) {\n        const scopedLineTokens = createScopedLineTokens(context, column - 1);\n        return CharacterPairSupport.shouldAutoClosePair(autoClosingPair, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n    }\n    // end characterPair\n    getWordDefinition(languageId) {\n        let value = this.getLanguageConfiguration(languageId);\n        if (!value) {\n            return ensureValidWordDefinition(null);\n        }\n        return ensureValidWordDefinition(value.wordDefinition || null);\n    }\n    getFoldingRules(languageId) {\n        let value = this.getLanguageConfiguration(languageId);\n        if (!value) {\n            return {};\n        }\n        return value.foldingRules;\n    }\n    // begin Indent Rules\n    getIndentRulesSupport(languageId) {\n        let value = this.getLanguageConfiguration(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.indentRulesSupport || null;\n    }\n    /**\n     * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.\n     * Result:\n     * -1: run into the boundary of embedded languages\n     * 0: every line above are invalid\n     * else: nearest preceding line of the same language\n     */\n    getPrecedingValidLine(model, lineNumber, indentRulesSupport) {\n        let languageID = model.getLanguageIdAtPosition(lineNumber, 0);\n        if (lineNumber > 1) {\n            let lastLineNumber;\n            let resultLineNumber = -1;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                if (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageID) {\n                    return resultLineNumber;\n                }\n                let text = model.getLineContent(lastLineNumber);\n                if (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n                    resultLineNumber = lastLineNumber;\n                    continue;\n                }\n                return lastLineNumber;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Get inherited indentation from above lines.\n     * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n     * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n     * 3. If this line doesn't match any indent rules\n     *   a. check whether the line above it matches indentNextLinePattern\n     *   b. If not, the indent level of this line is the result\n     *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n     * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n     *\n     * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n     */\n    getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = true) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageId());\n        if (!indentRulesSupport) {\n            return null;\n        }\n        if (lineNumber <= 1) {\n            return {\n                indentation: '',\n                action: null\n            };\n        }\n        const precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n        if (precedingUnIgnoredLine < 0) {\n            return null;\n        }\n        else if (precedingUnIgnoredLine < 1) {\n            return {\n                indentation: '',\n                action: null\n            };\n        }\n        const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n        if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n            return {\n                indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n                action: IndentAction.Indent,\n                line: precedingUnIgnoredLine\n            };\n        }\n        else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n            return {\n                indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        else {\n            // precedingUnIgnoredLine can not be ignored.\n            // it doesn't increase indent of following lines\n            // it doesn't increase just next line\n            // so current line is not affect by precedingUnIgnoredLine\n            // and then we should get a correct inheritted indentation from above lines\n            if (precedingUnIgnoredLine === 1) {\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                    action: null,\n                    line: precedingUnIgnoredLine\n                };\n            }\n            const previousLine = precedingUnIgnoredLine - 1;\n            const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n            if (!(previousLineIndentMetadata & (1 /* INCREASE_MASK */ | 2 /* DECREASE_MASK */)) &&\n                (previousLineIndentMetadata & 4 /* INDENT_NEXTLINE_MASK */)) {\n                let stopLine = 0;\n                for (let i = previousLine - 1; i > 0; i--) {\n                    if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                        continue;\n                    }\n                    stopLine = i;\n                    break;\n                }\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                    action: null,\n                    line: stopLine + 1\n                };\n            }\n            if (honorIntentialIndent) {\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                    action: null,\n                    line: precedingUnIgnoredLine\n                };\n            }\n            else {\n                // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n                for (let i = precedingUnIgnoredLine; i > 0; i--) {\n                    const lineContent = model.getLineContent(i);\n                    if (indentRulesSupport.shouldIncrease(lineContent)) {\n                        return {\n                            indentation: strings.getLeadingWhitespace(lineContent),\n                            action: IndentAction.Indent,\n                            line: i\n                        };\n                    }\n                    else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n                        let stopLine = 0;\n                        for (let j = i - 1; j > 0; j--) {\n                            if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                                continue;\n                            }\n                            stopLine = j;\n                            break;\n                        }\n                        return {\n                            indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                            action: null,\n                            line: stopLine + 1\n                        };\n                    }\n                    else if (indentRulesSupport.shouldDecrease(lineContent)) {\n                        return {\n                            indentation: strings.getLeadingWhitespace(lineContent),\n                            action: null,\n                            line: i\n                        };\n                    }\n                }\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n                    action: null,\n                    line: 1\n                };\n            }\n        }\n    }\n    getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        const richEditSupport = this.getLanguageConfiguration(languageId);\n        if (!richEditSupport) {\n            return null;\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(languageId);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        const indent = this.getInheritIndentForLine(autoIndent, virtualModel, lineNumber);\n        const lineContent = virtualModel.getLineContent(lineNumber);\n        if (indent) {\n            const inheritLine = indent.line;\n            if (inheritLine !== undefined) {\n                const enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n                if (enterResult) {\n                    let indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n                    if (enterResult.removeText) {\n                        indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n                    }\n                    if ((enterResult.indentAction === IndentAction.Indent) ||\n                        (enterResult.indentAction === IndentAction.IndentOutdent)) {\n                        indentation = indentConverter.shiftIndent(indentation);\n                    }\n                    else if (enterResult.indentAction === IndentAction.Outdent) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (indentRulesSupport.shouldDecrease(lineContent)) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (enterResult.appendText) {\n                        indentation += enterResult.appendText;\n                    }\n                    return strings.getLeadingWhitespace(indentation);\n                }\n            }\n            if (indentRulesSupport.shouldDecrease(lineContent)) {\n                if (indent.action === IndentAction.Indent) {\n                    return indent.indentation;\n                }\n                else {\n                    return indentConverter.unshiftIndent(indent.indentation);\n                }\n            }\n            else {\n                if (indent.action === IndentAction.Indent) {\n                    return indentConverter.shiftIndent(indent.indentation);\n                }\n                else {\n                    return indent.indentation;\n                }\n            }\n        }\n        return null;\n    }\n    getIndentForEnter(autoIndent, model, range, indentConverter) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        model.forceTokenization(range.startLineNumber);\n        const lineTokens = model.getLineTokens(range.startLineNumber);\n        const scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n        const scopedLineText = scopedLineTokens.getLineContent();\n        let embeddedLanguage = false;\n        let beforeEnterText;\n        if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n            // we are in the embeded language content\n            embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n            beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n        }\n        let afterEnterText;\n        if (range.isEmpty()) {\n            afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n            afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        const beforeEnterResult = beforeEnterText;\n        const beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n        const virtualModel = {\n            getLineTokens: (lineNumber) => {\n                return model.getLineTokens(lineNumber);\n            },\n            getLanguageId: () => {\n                return model.getLanguageId();\n            },\n            getLanguageIdAtPosition: (lineNumber, column) => {\n                return model.getLanguageIdAtPosition(lineNumber, column);\n            },\n            getLineContent: (lineNumber) => {\n                if (lineNumber === range.startLineNumber) {\n                    return beforeEnterResult;\n                }\n                else {\n                    return model.getLineContent(lineNumber);\n                }\n            }\n        };\n        const currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n        const afterEnterAction = this.getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1);\n        if (!afterEnterAction) {\n            const beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n            return {\n                beforeEnter: beforeEnter,\n                afterEnter: beforeEnter\n            };\n        }\n        let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n        if (afterEnterAction.action === IndentAction.Indent) {\n            afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n        }\n        if (indentRulesSupport.shouldDecrease(afterEnterText)) {\n            afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n        }\n        return {\n            beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n            afterEnter: afterEnterIndent\n        };\n    }\n    /**\n     * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n     * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n     */\n    getIndentActionForType(autoIndent, model, range, ch, indentConverter) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n        if (scopedLineTokens.firstCharOffset) {\n            // this line has mixed languages and indentation rules will not work\n            return null;\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        const scopedLineText = scopedLineTokens.getLineContent();\n        const beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        // selection support\n        let afterTypeText;\n        if (range.isEmpty()) {\n            afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n            afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n        // Users might change the indentation by purpose and we should honor that instead of readjusting.\n        if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n            // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n            // 1. Get inherited indent action\n            const r = this.getInheritIndentForLine(autoIndent, model, range.startLineNumber, false);\n            if (!r) {\n                return null;\n            }\n            let indentation = r.indentation;\n            if (r.action !== IndentAction.Indent) {\n                indentation = indentConverter.unshiftIndent(indentation);\n            }\n            return indentation;\n        }\n        return null;\n    }\n    getIndentMetadata(model, lineNumber) {\n        const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageId());\n        if (!indentRulesSupport) {\n            return null;\n        }\n        if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n            return null;\n        }\n        return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n    }\n    // end Indent Rules\n    // begin onEnter\n    getEnterAction(autoIndent, model, range) {\n        const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n        const richEditSupport = this.getLanguageConfiguration(scopedLineTokens.languageId);\n        if (!richEditSupport) {\n            return null;\n        }\n        const scopedLineText = scopedLineTokens.getLineContent();\n        const beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        // selection support\n        let afterEnterText;\n        if (range.isEmpty()) {\n            afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n            afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        let previousLineText = '';\n        if (range.startLineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\n            // This is not the first line and the entire line belongs to this mode\n            const oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber - 1);\n            if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\n                // The line above ends with text belonging to the same mode\n                previousLineText = oneLineAboveScopedLineTokens.getLineContent();\n            }\n        }\n        const enterResult = richEditSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n        if (!enterResult) {\n            return null;\n        }\n        const indentAction = enterResult.indentAction;\n        let appendText = enterResult.appendText;\n        const removeText = enterResult.removeText || 0;\n        // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\n        if (!appendText) {\n            if ((indentAction === IndentAction.Indent) ||\n                (indentAction === IndentAction.IndentOutdent)) {\n                appendText = '\\t';\n            }\n            else {\n                appendText = '';\n            }\n        }\n        else if (indentAction === IndentAction.Indent) {\n            appendText = '\\t' + appendText;\n        }\n        let indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        if (removeText) {\n            indentation = indentation.substring(0, indentation.length - removeText);\n        }\n        return {\n            indentAction: indentAction,\n            appendText: appendText,\n            removeText: removeText,\n            indentation: indentation\n        };\n    }\n    getIndentationAtPosition(model, lineNumber, column) {\n        const lineText = model.getLineContent(lineNumber);\n        let indentation = strings.getLeadingWhitespace(lineText);\n        if (indentation.length > column - 1) {\n            indentation = indentation.substring(0, column - 1);\n        }\n        return indentation;\n    }\n    getScopedLineTokens(model, lineNumber, columnNumber) {\n        model.forceTokenization(lineNumber);\n        const lineTokens = model.getLineTokens(lineNumber);\n        const column = (typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1);\n        return createScopedLineTokens(lineTokens, column);\n    }\n}\nexport const LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();\nclass ComposedLanguageConfiguration {\n    constructor(languageId) {\n        this.languageId = languageId;\n        this._resolved = null;\n        this._entries = [];\n        this._order = 0;\n        this._resolved = null;\n    }\n    register(configuration, priority) {\n        const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);\n        this._entries.push(entry);\n        this._resolved = null;\n        return toDisposable(() => {\n            for (let i = 0; i < this._entries.length; i++) {\n                if (this._entries[i] === entry) {\n                    this._entries.splice(i, 1);\n                    this._resolved = null;\n                    break;\n                }\n            }\n        });\n    }\n    getResolvedConfiguration() {\n        if (!this._resolved) {\n            const config = this._resolve();\n            if (config) {\n                this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);\n            }\n        }\n        return this._resolved;\n    }\n    _resolve() {\n        if (this._entries.length === 0) {\n            return null;\n        }\n        this._entries.sort(LanguageConfigurationContribution.cmp);\n        return combineLanguageConfigurations(this._entries.map(e => e.configuration));\n    }\n}\nfunction combineLanguageConfigurations(configs) {\n    let result = {\n        comments: undefined,\n        brackets: undefined,\n        wordPattern: undefined,\n        indentationRules: undefined,\n        onEnterRules: undefined,\n        autoClosingPairs: undefined,\n        surroundingPairs: undefined,\n        autoCloseBefore: undefined,\n        folding: undefined,\n        colorizedBracketPairs: undefined,\n        __electricCharacterSupport: undefined,\n    };\n    for (const entry of configs) {\n        result = {\n            comments: entry.comments || result.comments,\n            brackets: entry.brackets || result.brackets,\n            wordPattern: entry.wordPattern || result.wordPattern,\n            indentationRules: entry.indentationRules || result.indentationRules,\n            onEnterRules: entry.onEnterRules || result.onEnterRules,\n            autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,\n            surroundingPairs: entry.surroundingPairs || result.surroundingPairs,\n            autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,\n            folding: entry.folding || result.folding,\n            colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,\n            __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport,\n        };\n    }\n    return result;\n}\nclass LanguageConfigurationContribution {\n    constructor(configuration, priority, order) {\n        this.configuration = configuration;\n        this.priority = priority;\n        this.order = order;\n    }\n    static cmp(a, b) {\n        if (a.priority === b.priority) {\n            // higher order last\n            return a.order - b.order;\n        }\n        // higher priority last\n        return a.priority - b.priority;\n    }\n}\n/**\n * Immutable.\n*/\nexport class ResolvedLanguageConfiguration {\n    constructor(languageId, underlyingConfig) {\n        this.languageId = languageId;\n        this.underlyingConfig = underlyingConfig;\n        this._brackets = null;\n        this._electricCharacter = null;\n        this._onEnterSupport =\n            this.underlyingConfig.brackets ||\n                this.underlyingConfig.indentationRules ||\n                this.underlyingConfig.onEnterRules\n                ? new OnEnterSupport(this.underlyingConfig)\n                : null;\n        this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);\n        this.characterPair = new CharacterPairSupport(this.underlyingConfig);\n        this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;\n        this.indentationRules = this.underlyingConfig.indentationRules;\n        if (this.underlyingConfig.indentationRules) {\n            this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);\n        }\n        else {\n            this.indentRulesSupport = null;\n        }\n        this.foldingRules = this.underlyingConfig.folding || {};\n    }\n    getWordDefinition() {\n        return ensureValidWordDefinition(this.wordDefinition);\n    }\n    get brackets() {\n        if (!this._brackets && this.underlyingConfig.brackets) {\n            this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);\n        }\n        return this._brackets;\n    }\n    get electricCharacter() {\n        if (!this._electricCharacter) {\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n        }\n        return this._electricCharacter;\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        if (!this._onEnterSupport) {\n            return null;\n        }\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    }\n    static _handleComments(conf) {\n        let commentRule = conf.comments;\n        if (!commentRule) {\n            return null;\n        }\n        // comment configuration\n        let comments = {};\n        if (commentRule.lineComment) {\n            comments.lineCommentToken = commentRule.lineComment;\n        }\n        if (commentRule.blockComment) {\n            let [blockStart, blockEnd] = commentRule.blockComment;\n            comments.blockCommentStartToken = blockStart;\n            comments.blockCommentEndToken = blockEnd;\n        }\n        return comments;\n    }\n}\nregisterSingleton(ILanguageConfigurationService, LanguageConfigurationService);\n"]},"metadata":{},"sourceType":"module"}