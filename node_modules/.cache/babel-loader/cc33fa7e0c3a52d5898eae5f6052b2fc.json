{"ast":null,"code":"import { onUnexpectedError } from './errors.js';\nimport { combinedDisposable, Disposable, DisposableStore, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\nexport var Event;\n\n(function (Event) {\n  Event.None = () => Disposable.None;\n  /**\n   * Given an event, returns another event which only fires once.\n   */\n\n\n  function once(event) {\n    return function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      // we need this, in case the event fires during the listener call\n      let didFire = false;\n      let result;\n      result = event(e => {\n        if (didFire) {\n          return;\n        } else if (result) {\n          result.dispose();\n        } else {\n          didFire = true;\n        }\n\n        return listener.call(thisArgs, e);\n      }, null, disposables);\n\n      if (didFire) {\n        result.dispose();\n      }\n\n      return result;\n    };\n  }\n\n  Event.once = once;\n  /**\n   * @deprecated DO NOT use, this leaks memory\n   */\n\n  function map(event, map) {\n    return snapshot(function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(i => listener.call(thisArgs, map(i)), null, disposables);\n    });\n  }\n\n  Event.map = map;\n  /**\n   * @deprecated DO NOT use, this leaks memory\n   */\n\n  function forEach(event, each) {\n    return snapshot(function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(i => {\n        each(i);\n        listener.call(thisArgs, i);\n      }, null, disposables);\n    });\n  }\n\n  Event.forEach = forEach;\n\n  function filter(event, filter) {\n    return snapshot(function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(e => filter(e) && listener.call(thisArgs, e), null, disposables);\n    });\n  }\n\n  Event.filter = filter;\n  /**\n   * Given an event, returns the same event but typed as `Event<void>`.\n   */\n\n  function signal(event) {\n    return event;\n  }\n\n  Event.signal = signal;\n\n  function any() {\n    for (var _len = arguments.length, events = new Array(_len), _key = 0; _key < _len; _key++) {\n      events[_key] = arguments[_key];\n    }\n\n    return function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n    };\n  }\n\n  Event.any = any;\n  /**\n   * @deprecated DO NOT use, this leaks memory\n   */\n\n  function reduce(event, merge, initial) {\n    let output = initial;\n    return map(event, e => {\n      output = merge(output, e);\n      return output;\n    });\n  }\n\n  Event.reduce = reduce;\n  /**\n   * @deprecated DO NOT use, this leaks memory\n   */\n\n  function snapshot(event) {\n    let listener;\n    const emitter = new Emitter({\n      onFirstListenerAdd() {\n        listener = event(emitter.fire, emitter);\n      },\n\n      onLastListenerRemove() {\n        listener.dispose();\n      }\n\n    });\n    return emitter.event;\n  }\n  /**\n   * @deprecated DO NOT use, this leaks memory\n   */\n\n\n  function debounce(event, merge) {\n    let delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n    let leading = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let leakWarningThreshold = arguments.length > 4 ? arguments[4] : undefined;\n    let subscription;\n    let output = undefined;\n    let handle = undefined;\n    let numDebouncedCalls = 0;\n    const emitter = new Emitter({\n      leakWarningThreshold,\n\n      onFirstListenerAdd() {\n        subscription = event(cur => {\n          numDebouncedCalls++;\n          output = merge(output, cur);\n\n          if (leading && !handle) {\n            emitter.fire(output);\n            output = undefined;\n          }\n\n          clearTimeout(handle);\n          handle = setTimeout(() => {\n            const _output = output;\n            output = undefined;\n            handle = undefined;\n\n            if (!leading || numDebouncedCalls > 1) {\n              emitter.fire(_output);\n            }\n\n            numDebouncedCalls = 0;\n          }, delay);\n        });\n      },\n\n      onLastListenerRemove() {\n        subscription.dispose();\n      }\n\n    });\n    return emitter.event;\n  }\n\n  Event.debounce = debounce;\n  /**\n   * @deprecated DO NOT use, this leaks memory\n   */\n\n  function latch(event) {\n    let equals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (a, b) => a === b;\n    let firstCall = true;\n    let cache;\n    return filter(event, value => {\n      const shouldEmit = firstCall || !equals(value, cache);\n      firstCall = false;\n      cache = value;\n      return shouldEmit;\n    });\n  }\n\n  Event.latch = latch;\n  /**\n   * @deprecated DO NOT use, this leaks memory\n   */\n\n  function split(event, isT) {\n    return [Event.filter(event, isT), Event.filter(event, e => !isT(e))];\n  }\n\n  Event.split = split;\n  /**\n   * @deprecated DO NOT use, this leaks memory\n   */\n\n  function buffer(event) {\n    let nextTick = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    let _buffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    let buffer = _buffer.slice();\n\n    let listener = event(e => {\n      if (buffer) {\n        buffer.push(e);\n      } else {\n        emitter.fire(e);\n      }\n    });\n\n    const flush = () => {\n      if (buffer) {\n        buffer.forEach(e => emitter.fire(e));\n      }\n\n      buffer = null;\n    };\n\n    const emitter = new Emitter({\n      onFirstListenerAdd() {\n        if (!listener) {\n          listener = event(e => emitter.fire(e));\n        }\n      },\n\n      onFirstListenerDidAdd() {\n        if (buffer) {\n          if (nextTick) {\n            setTimeout(flush);\n          } else {\n            flush();\n          }\n        }\n      },\n\n      onLastListenerRemove() {\n        if (listener) {\n          listener.dispose();\n        }\n\n        listener = null;\n      }\n\n    });\n    return emitter.event;\n  }\n\n  Event.buffer = buffer;\n\n  class ChainableEvent {\n    constructor(event) {\n      this.event = event;\n    }\n\n    map(fn) {\n      return new ChainableEvent(map(this.event, fn));\n    }\n\n    forEach(fn) {\n      return new ChainableEvent(forEach(this.event, fn));\n    }\n\n    filter(fn) {\n      return new ChainableEvent(filter(this.event, fn));\n    }\n\n    reduce(merge, initial) {\n      return new ChainableEvent(reduce(this.event, merge, initial));\n    }\n\n    latch() {\n      return new ChainableEvent(latch(this.event));\n    }\n\n    debounce(merge) {\n      let delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n      let leading = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      let leakWarningThreshold = arguments.length > 3 ? arguments[3] : undefined;\n      return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));\n    }\n\n    on(listener, thisArgs, disposables) {\n      return this.event(listener, thisArgs, disposables);\n    }\n\n    once(listener, thisArgs, disposables) {\n      return once(this.event)(listener, thisArgs, disposables);\n    }\n\n  }\n  /**\n   * @deprecated DO NOT use, this leaks memory\n   */\n\n\n  function chain(event) {\n    return new ChainableEvent(event);\n  }\n\n  Event.chain = chain;\n\n  function fromNodeEventEmitter(emitter, eventName) {\n    let map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : id => id;\n\n    const fn = function () {\n      return result.fire(map(...arguments));\n    };\n\n    const onFirstListenerAdd = () => emitter.on(eventName, fn);\n\n    const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n\n    const result = new Emitter({\n      onFirstListenerAdd,\n      onLastListenerRemove\n    });\n    return result.event;\n  }\n\n  Event.fromNodeEventEmitter = fromNodeEventEmitter;\n\n  function fromDOMEventEmitter(emitter, eventName) {\n    let map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : id => id;\n\n    const fn = function () {\n      return result.fire(map(...arguments));\n    };\n\n    const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n\n    const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n\n    const result = new Emitter({\n      onFirstListenerAdd,\n      onLastListenerRemove\n    });\n    return result.event;\n  }\n\n  Event.fromDOMEventEmitter = fromDOMEventEmitter;\n\n  function toPromise(event) {\n    return new Promise(resolve => once(event)(resolve));\n  }\n\n  Event.toPromise = toPromise;\n})(Event || (Event = {}));\n\nclass EventProfiling {\n  constructor(name) {\n    this._listenerCount = 0;\n    this._invocationCount = 0;\n    this._elapsedOverall = 0;\n    this._name = `${name}_${EventProfiling._idPool++}`;\n  }\n\n  start(listenerCount) {\n    this._stopWatch = new StopWatch(true);\n    this._listenerCount = listenerCount;\n  }\n\n  stop() {\n    if (this._stopWatch) {\n      const elapsed = this._stopWatch.elapsed();\n\n      this._elapsedOverall += elapsed;\n      this._invocationCount += 1;\n      console.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`);\n      this._stopWatch = undefined;\n    }\n  }\n\n}\n\nEventProfiling._idPool = 0;\n\nlet _globalLeakWarningThreshold = -1;\n\nclass LeakageMonitor {\n  constructor(customThreshold) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Math.random().toString(18).slice(2, 5);\n    this.customThreshold = customThreshold;\n    this.name = name;\n    this._warnCountdown = 0;\n  }\n\n  dispose() {\n    if (this._stacks) {\n      this._stacks.clear();\n    }\n  }\n\n  check(listenerCount) {\n    let threshold = _globalLeakWarningThreshold;\n\n    if (typeof this.customThreshold === 'number') {\n      threshold = this.customThreshold;\n    }\n\n    if (threshold <= 0 || listenerCount < threshold) {\n      return undefined;\n    }\n\n    if (!this._stacks) {\n      this._stacks = new Map();\n    }\n\n    const stack = new Error().stack.split('\\n').slice(3).join('\\n');\n    const count = this._stacks.get(stack) || 0;\n\n    this._stacks.set(stack, count + 1);\n\n    this._warnCountdown -= 1;\n\n    if (this._warnCountdown <= 0) {\n      // only warn on first exceed and then every time the limit\n      // is exceeded by 50% again\n      this._warnCountdown = threshold * 0.5; // find most frequent listener and print warning\n\n      let topStack;\n      let topCount = 0;\n\n      for (const [stack, count] of this._stacks) {\n        if (!topStack || topCount < count) {\n          topStack = stack;\n          topCount = count;\n        }\n      }\n\n      console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n      console.warn(topStack);\n    }\n\n    return () => {\n      const count = this._stacks.get(stack) || 0;\n\n      this._stacks.set(stack, count - 1);\n    };\n  }\n\n}\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\n\n\nexport class Emitter {\n  constructor(options) {\n    var _a;\n\n    this._disposed = false;\n    this._options = options;\n    this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;\n    this._perfMon = ((_a = this._options) === null || _a === void 0 ? void 0 : _a._profName) ? new EventProfiling(this._options._profName) : undefined;\n  }\n  /**\n   * For the public to allow to subscribe\n   * to events from this Emitter\n   */\n\n\n  get event() {\n    if (!this._event) {\n      this._event = (listener, thisArgs, disposables) => {\n        var _a;\n\n        if (!this._listeners) {\n          this._listeners = new LinkedList();\n        }\n\n        const firstListener = this._listeners.isEmpty();\n\n        if (firstListener && this._options && this._options.onFirstListenerAdd) {\n          this._options.onFirstListenerAdd(this);\n        }\n\n        const remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\n\n        if (firstListener && this._options && this._options.onFirstListenerDidAdd) {\n          this._options.onFirstListenerDidAdd(this);\n        }\n\n        if (this._options && this._options.onListenerDidAdd) {\n          this._options.onListenerDidAdd(this, listener, thisArgs);\n        } // check and record this emitter for potential leakage\n\n\n        const removeMonitor = (_a = this._leakageMon) === null || _a === void 0 ? void 0 : _a.check(this._listeners.size);\n        const result = toDisposable(() => {\n          if (removeMonitor) {\n            removeMonitor();\n          }\n\n          if (!this._disposed) {\n            remove();\n\n            if (this._options && this._options.onLastListenerRemove) {\n              const hasListeners = this._listeners && !this._listeners.isEmpty();\n\n              if (!hasListeners) {\n                this._options.onLastListenerRemove(this);\n              }\n            }\n          }\n        });\n\n        if (disposables instanceof DisposableStore) {\n          disposables.add(result);\n        } else if (Array.isArray(disposables)) {\n          disposables.push(result);\n        }\n\n        return result;\n      };\n    }\n\n    return this._event;\n  }\n  /**\n   * To be kept private to fire an event to\n   * subscribers\n   */\n\n\n  fire(event) {\n    var _a, _b;\n\n    if (this._listeners) {\n      // put all [listener,event]-pairs into delivery queue\n      // then emit all event. an inner/nested event might be\n      // the driver of this\n      if (!this._deliveryQueue) {\n        this._deliveryQueue = new LinkedList();\n      }\n\n      for (let listener of this._listeners) {\n        this._deliveryQueue.push([listener, event]);\n      } // start/stop performance insight collection\n\n\n      (_a = this._perfMon) === null || _a === void 0 ? void 0 : _a.start(this._deliveryQueue.size);\n\n      while (this._deliveryQueue.size > 0) {\n        const [listener, event] = this._deliveryQueue.shift();\n\n        try {\n          if (typeof listener === 'function') {\n            listener.call(undefined, event);\n          } else {\n            listener[0].call(listener[1], event);\n          }\n        } catch (e) {\n          onUnexpectedError(e);\n        }\n      }\n\n      (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();\n    }\n  }\n\n  dispose() {\n    var _a, _b, _c, _d, _e;\n\n    if (!this._disposed) {\n      this._disposed = true;\n      (_a = this._listeners) === null || _a === void 0 ? void 0 : _a.clear();\n      (_b = this._deliveryQueue) === null || _b === void 0 ? void 0 : _b.clear();\n      (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onLastListenerRemove) === null || _d === void 0 ? void 0 : _d.call(_c);\n      (_e = this._leakageMon) === null || _e === void 0 ? void 0 : _e.dispose();\n    }\n  }\n\n}\nexport class PauseableEmitter extends Emitter {\n  constructor(options) {\n    super(options);\n    this._isPaused = 0;\n    this._eventQueue = new LinkedList();\n    this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n  }\n\n  pause() {\n    this._isPaused++;\n  }\n\n  resume() {\n    if (this._isPaused !== 0 && --this._isPaused === 0) {\n      if (this._mergeFn) {\n        // use the merge function to create a single composite\n        // event. make a copy in case firing pauses this emitter\n        const events = Array.from(this._eventQueue);\n\n        this._eventQueue.clear();\n\n        super.fire(this._mergeFn(events));\n      } else {\n        // no merging, fire each event individually and test\n        // that this emitter isn't paused halfway through\n        while (!this._isPaused && this._eventQueue.size !== 0) {\n          super.fire(this._eventQueue.shift());\n        }\n      }\n    }\n  }\n\n  fire(event) {\n    if (this._listeners) {\n      if (this._isPaused !== 0) {\n        this._eventQueue.push(event);\n      } else {\n        super.fire(event);\n      }\n    }\n  }\n\n}\nexport class DebounceEmitter extends PauseableEmitter {\n  constructor(options) {\n    var _a;\n\n    super(options);\n    this._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;\n  }\n\n  fire(event) {\n    if (!this._handle) {\n      this.pause();\n      this._handle = setTimeout(() => {\n        this._handle = undefined;\n        this.resume();\n      }, this._delay);\n    }\n\n    super.fire(event);\n  }\n\n}\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\n\nexport class EventBufferer {\n  constructor() {\n    this.buffers = [];\n  }\n\n  wrapEvent(event) {\n    return (listener, thisArgs, disposables) => {\n      return event(i => {\n        const buffer = this.buffers[this.buffers.length - 1];\n\n        if (buffer) {\n          buffer.push(() => listener.call(thisArgs, i));\n        } else {\n          listener.call(thisArgs, i);\n        }\n      }, undefined, disposables);\n    };\n  }\n\n  bufferEvents(fn) {\n    const buffer = [];\n    this.buffers.push(buffer);\n    const r = fn();\n    this.buffers.pop();\n    buffer.forEach(flush => flush());\n    return r;\n  }\n\n}\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\n\nexport class Relay {\n  constructor() {\n    this.listening = false;\n    this.inputEvent = Event.None;\n    this.inputEventListener = Disposable.None;\n    this.emitter = new Emitter({\n      onFirstListenerDidAdd: () => {\n        this.listening = true;\n        this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n      },\n      onLastListenerRemove: () => {\n        this.listening = false;\n        this.inputEventListener.dispose();\n      }\n    });\n    this.event = this.emitter.event;\n  }\n\n  set input(event) {\n    this.inputEvent = event;\n\n    if (this.listening) {\n      this.inputEventListener.dispose();\n      this.inputEventListener = event(this.emitter.fire, this.emitter);\n    }\n  }\n\n  dispose() {\n    this.inputEventListener.dispose();\n    this.emitter.dispose();\n  }\n\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/base/common/event.js"],"names":["onUnexpectedError","combinedDisposable","Disposable","DisposableStore","toDisposable","LinkedList","StopWatch","Event","None","once","event","listener","thisArgs","disposables","didFire","result","e","dispose","call","map","snapshot","i","forEach","each","filter","signal","any","events","reduce","merge","initial","output","emitter","Emitter","onFirstListenerAdd","fire","onLastListenerRemove","debounce","delay","leading","leakWarningThreshold","subscription","undefined","handle","numDebouncedCalls","cur","clearTimeout","setTimeout","_output","latch","equals","a","b","firstCall","cache","value","shouldEmit","split","isT","buffer","nextTick","_buffer","slice","push","flush","onFirstListenerDidAdd","ChainableEvent","constructor","fn","on","chain","fromNodeEventEmitter","eventName","id","removeListener","fromDOMEventEmitter","addEventListener","removeEventListener","toPromise","Promise","resolve","EventProfiling","name","_listenerCount","_invocationCount","_elapsedOverall","_name","_idPool","start","listenerCount","_stopWatch","stop","elapsed","console","info","toFixed","_globalLeakWarningThreshold","LeakageMonitor","customThreshold","Math","random","toString","_warnCountdown","_stacks","clear","check","threshold","Map","stack","Error","join","count","get","set","topStack","topCount","warn","options","_a","_disposed","_options","_leakageMon","_perfMon","_profName","_event","_listeners","firstListener","isEmpty","remove","onListenerDidAdd","removeMonitor","size","hasListeners","add","Array","isArray","_b","_deliveryQueue","shift","_c","_d","_e","PauseableEmitter","_isPaused","_eventQueue","_mergeFn","pause","resume","from","DebounceEmitter","_delay","_handle","EventBufferer","buffers","wrapEvent","length","bufferEvents","r","pop","Relay","listening","inputEvent","inputEventListener","input"],"mappings":"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","sourcesContent":["import { onUnexpectedError } from './errors.js';\nimport { combinedDisposable, Disposable, DisposableStore, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\nexport var Event;\n(function (Event) {\n    Event.None = () => Disposable.None;\n    /**\n     * Given an event, returns another event which only fires once.\n     */\n    function once(event) {\n        return (listener, thisArgs = null, disposables) => {\n            // we need this, in case the event fires during the listener call\n            let didFire = false;\n            let result;\n            result = event(e => {\n                if (didFire) {\n                    return;\n                }\n                else if (result) {\n                    result.dispose();\n                }\n                else {\n                    didFire = true;\n                }\n                return listener.call(thisArgs, e);\n            }, null, disposables);\n            if (didFire) {\n                result.dispose();\n            }\n            return result;\n        };\n    }\n    Event.once = once;\n    /**\n     * @deprecated DO NOT use, this leaks memory\n     */\n    function map(event, map) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables));\n    }\n    Event.map = map;\n    /**\n     * @deprecated DO NOT use, this leaks memory\n     */\n    function forEach(event, each) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables));\n    }\n    Event.forEach = forEach;\n    function filter(event, filter) {\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables));\n    }\n    Event.filter = filter;\n    /**\n     * Given an event, returns the same event but typed as `Event<void>`.\n     */\n    function signal(event) {\n        return event;\n    }\n    Event.signal = signal;\n    function any(...events) {\n        return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n    }\n    Event.any = any;\n    /**\n     * @deprecated DO NOT use, this leaks memory\n     */\n    function reduce(event, merge, initial) {\n        let output = initial;\n        return map(event, e => {\n            output = merge(output, e);\n            return output;\n        });\n    }\n    Event.reduce = reduce;\n    /**\n     * @deprecated DO NOT use, this leaks memory\n     */\n    function snapshot(event) {\n        let listener;\n        const emitter = new Emitter({\n            onFirstListenerAdd() {\n                listener = event(emitter.fire, emitter);\n            },\n            onLastListenerRemove() {\n                listener.dispose();\n            }\n        });\n        return emitter.event;\n    }\n    /**\n     * @deprecated DO NOT use, this leaks memory\n     */\n    function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold) {\n        let subscription;\n        let output = undefined;\n        let handle = undefined;\n        let numDebouncedCalls = 0;\n        const emitter = new Emitter({\n            leakWarningThreshold,\n            onFirstListenerAdd() {\n                subscription = event(cur => {\n                    numDebouncedCalls++;\n                    output = merge(output, cur);\n                    if (leading && !handle) {\n                        emitter.fire(output);\n                        output = undefined;\n                    }\n                    clearTimeout(handle);\n                    handle = setTimeout(() => {\n                        const _output = output;\n                        output = undefined;\n                        handle = undefined;\n                        if (!leading || numDebouncedCalls > 1) {\n                            emitter.fire(_output);\n                        }\n                        numDebouncedCalls = 0;\n                    }, delay);\n                });\n            },\n            onLastListenerRemove() {\n                subscription.dispose();\n            }\n        });\n        return emitter.event;\n    }\n    Event.debounce = debounce;\n    /**\n     * @deprecated DO NOT use, this leaks memory\n     */\n    function latch(event, equals = (a, b) => a === b) {\n        let firstCall = true;\n        let cache;\n        return filter(event, value => {\n            const shouldEmit = firstCall || !equals(value, cache);\n            firstCall = false;\n            cache = value;\n            return shouldEmit;\n        });\n    }\n    Event.latch = latch;\n    /**\n     * @deprecated DO NOT use, this leaks memory\n     */\n    function split(event, isT) {\n        return [\n            Event.filter(event, isT),\n            Event.filter(event, e => !isT(e)),\n        ];\n    }\n    Event.split = split;\n    /**\n     * @deprecated DO NOT use, this leaks memory\n     */\n    function buffer(event, nextTick = false, _buffer = []) {\n        let buffer = _buffer.slice();\n        let listener = event(e => {\n            if (buffer) {\n                buffer.push(e);\n            }\n            else {\n                emitter.fire(e);\n            }\n        });\n        const flush = () => {\n            if (buffer) {\n                buffer.forEach(e => emitter.fire(e));\n            }\n            buffer = null;\n        };\n        const emitter = new Emitter({\n            onFirstListenerAdd() {\n                if (!listener) {\n                    listener = event(e => emitter.fire(e));\n                }\n            },\n            onFirstListenerDidAdd() {\n                if (buffer) {\n                    if (nextTick) {\n                        setTimeout(flush);\n                    }\n                    else {\n                        flush();\n                    }\n                }\n            },\n            onLastListenerRemove() {\n                if (listener) {\n                    listener.dispose();\n                }\n                listener = null;\n            }\n        });\n        return emitter.event;\n    }\n    Event.buffer = buffer;\n    class ChainableEvent {\n        constructor(event) {\n            this.event = event;\n        }\n        map(fn) {\n            return new ChainableEvent(map(this.event, fn));\n        }\n        forEach(fn) {\n            return new ChainableEvent(forEach(this.event, fn));\n        }\n        filter(fn) {\n            return new ChainableEvent(filter(this.event, fn));\n        }\n        reduce(merge, initial) {\n            return new ChainableEvent(reduce(this.event, merge, initial));\n        }\n        latch() {\n            return new ChainableEvent(latch(this.event));\n        }\n        debounce(merge, delay = 100, leading = false, leakWarningThreshold) {\n            return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));\n        }\n        on(listener, thisArgs, disposables) {\n            return this.event(listener, thisArgs, disposables);\n        }\n        once(listener, thisArgs, disposables) {\n            return once(this.event)(listener, thisArgs, disposables);\n        }\n    }\n    /**\n     * @deprecated DO NOT use, this leaks memory\n     */\n    function chain(event) {\n        return new ChainableEvent(event);\n    }\n    Event.chain = chain;\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\n    function toPromise(event) {\n        return new Promise(resolve => once(event)(resolve));\n    }\n    Event.toPromise = toPromise;\n})(Event || (Event = {}));\nclass EventProfiling {\n    constructor(name) {\n        this._listenerCount = 0;\n        this._invocationCount = 0;\n        this._elapsedOverall = 0;\n        this._name = `${name}_${EventProfiling._idPool++}`;\n    }\n    start(listenerCount) {\n        this._stopWatch = new StopWatch(true);\n        this._listenerCount = listenerCount;\n    }\n    stop() {\n        if (this._stopWatch) {\n            const elapsed = this._stopWatch.elapsed();\n            this._elapsedOverall += elapsed;\n            this._invocationCount += 1;\n            console.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`);\n            this._stopWatch = undefined;\n        }\n    }\n}\nEventProfiling._idPool = 0;\nlet _globalLeakWarningThreshold = -1;\nclass LeakageMonitor {\n    constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {\n        this.customThreshold = customThreshold;\n        this.name = name;\n        this._warnCountdown = 0;\n    }\n    dispose() {\n        if (this._stacks) {\n            this._stacks.clear();\n        }\n    }\n    check(listenerCount) {\n        let threshold = _globalLeakWarningThreshold;\n        if (typeof this.customThreshold === 'number') {\n            threshold = this.customThreshold;\n        }\n        if (threshold <= 0 || listenerCount < threshold) {\n            return undefined;\n        }\n        if (!this._stacks) {\n            this._stacks = new Map();\n        }\n        const stack = new Error().stack.split('\\n').slice(3).join('\\n');\n        const count = (this._stacks.get(stack) || 0);\n        this._stacks.set(stack, count + 1);\n        this._warnCountdown -= 1;\n        if (this._warnCountdown <= 0) {\n            // only warn on first exceed and then every time the limit\n            // is exceeded by 50% again\n            this._warnCountdown = threshold * 0.5;\n            // find most frequent listener and print warning\n            let topStack;\n            let topCount = 0;\n            for (const [stack, count] of this._stacks) {\n                if (!topStack || topCount < count) {\n                    topStack = stack;\n                    topCount = count;\n                }\n            }\n            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n            console.warn(topStack);\n        }\n        return () => {\n            const count = (this._stacks.get(stack) || 0);\n            this._stacks.set(stack, count - 1);\n        };\n    }\n}\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nexport class Emitter {\n    constructor(options) {\n        var _a;\n        this._disposed = false;\n        this._options = options;\n        this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;\n        this._perfMon = ((_a = this._options) === null || _a === void 0 ? void 0 : _a._profName) ? new EventProfiling(this._options._profName) : undefined;\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        if (!this._event) {\n            this._event = (listener, thisArgs, disposables) => {\n                var _a;\n                if (!this._listeners) {\n                    this._listeners = new LinkedList();\n                }\n                const firstListener = this._listeners.isEmpty();\n                if (firstListener && this._options && this._options.onFirstListenerAdd) {\n                    this._options.onFirstListenerAdd(this);\n                }\n                const remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\n                if (firstListener && this._options && this._options.onFirstListenerDidAdd) {\n                    this._options.onFirstListenerDidAdd(this);\n                }\n                if (this._options && this._options.onListenerDidAdd) {\n                    this._options.onListenerDidAdd(this, listener, thisArgs);\n                }\n                // check and record this emitter for potential leakage\n                const removeMonitor = (_a = this._leakageMon) === null || _a === void 0 ? void 0 : _a.check(this._listeners.size);\n                const result = toDisposable(() => {\n                    if (removeMonitor) {\n                        removeMonitor();\n                    }\n                    if (!this._disposed) {\n                        remove();\n                        if (this._options && this._options.onLastListenerRemove) {\n                            const hasListeners = (this._listeners && !this._listeners.isEmpty());\n                            if (!hasListeners) {\n                                this._options.onLastListenerRemove(this);\n                            }\n                        }\n                    }\n                });\n                if (disposables instanceof DisposableStore) {\n                    disposables.add(result);\n                }\n                else if (Array.isArray(disposables)) {\n                    disposables.push(result);\n                }\n                return result;\n            };\n        }\n        return this._event;\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        var _a, _b;\n        if (this._listeners) {\n            // put all [listener,event]-pairs into delivery queue\n            // then emit all event. an inner/nested event might be\n            // the driver of this\n            if (!this._deliveryQueue) {\n                this._deliveryQueue = new LinkedList();\n            }\n            for (let listener of this._listeners) {\n                this._deliveryQueue.push([listener, event]);\n            }\n            // start/stop performance insight collection\n            (_a = this._perfMon) === null || _a === void 0 ? void 0 : _a.start(this._deliveryQueue.size);\n            while (this._deliveryQueue.size > 0) {\n                const [listener, event] = this._deliveryQueue.shift();\n                try {\n                    if (typeof listener === 'function') {\n                        listener.call(undefined, event);\n                    }\n                    else {\n                        listener[0].call(listener[1], event);\n                    }\n                }\n                catch (e) {\n                    onUnexpectedError(e);\n                }\n            }\n            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();\n        }\n    }\n    dispose() {\n        var _a, _b, _c, _d, _e;\n        if (!this._disposed) {\n            this._disposed = true;\n            (_a = this._listeners) === null || _a === void 0 ? void 0 : _a.clear();\n            (_b = this._deliveryQueue) === null || _b === void 0 ? void 0 : _b.clear();\n            (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onLastListenerRemove) === null || _d === void 0 ? void 0 : _d.call(_c);\n            (_e = this._leakageMon) === null || _e === void 0 ? void 0 : _e.dispose();\n        }\n    }\n}\nexport class PauseableEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._isPaused = 0;\n        this._eventQueue = new LinkedList();\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    }\n    pause() {\n        this._isPaused++;\n    }\n    resume() {\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\n            if (this._mergeFn) {\n                // use the merge function to create a single composite\n                // event. make a copy in case firing pauses this emitter\n                const events = Array.from(this._eventQueue);\n                this._eventQueue.clear();\n                super.fire(this._mergeFn(events));\n            }\n            else {\n                // no merging, fire each event individually and test\n                // that this emitter isn't paused halfway through\n                while (!this._isPaused && this._eventQueue.size !== 0) {\n                    super.fire(this._eventQueue.shift());\n                }\n            }\n        }\n    }\n    fire(event) {\n        if (this._listeners) {\n            if (this._isPaused !== 0) {\n                this._eventQueue.push(event);\n            }\n            else {\n                super.fire(event);\n            }\n        }\n    }\n}\nexport class DebounceEmitter extends PauseableEmitter {\n    constructor(options) {\n        var _a;\n        super(options);\n        this._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;\n    }\n    fire(event) {\n        if (!this._handle) {\n            this.pause();\n            this._handle = setTimeout(() => {\n                this._handle = undefined;\n                this.resume();\n            }, this._delay);\n        }\n        super.fire(event);\n    }\n}\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n    constructor() {\n        this.buffers = [];\n    }\n    wrapEvent(event) {\n        return (listener, thisArgs, disposables) => {\n            return event(i => {\n                const buffer = this.buffers[this.buffers.length - 1];\n                if (buffer) {\n                    buffer.push(() => listener.call(thisArgs, i));\n                }\n                else {\n                    listener.call(thisArgs, i);\n                }\n            }, undefined, disposables);\n        };\n    }\n    bufferEvents(fn) {\n        const buffer = [];\n        this.buffers.push(buffer);\n        const r = fn();\n        this.buffers.pop();\n        buffer.forEach(flush => flush());\n        return r;\n    }\n}\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay {\n    constructor() {\n        this.listening = false;\n        this.inputEvent = Event.None;\n        this.inputEventListener = Disposable.None;\n        this.emitter = new Emitter({\n            onFirstListenerDidAdd: () => {\n                this.listening = true;\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n            },\n            onLastListenerRemove: () => {\n                this.listening = false;\n                this.inputEventListener.dispose();\n            }\n        });\n        this.event = this.emitter.event;\n    }\n    set input(event) {\n        this.inputEvent = event;\n        if (this.listening) {\n            this.inputEventListener.dispose();\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\n        }\n    }\n    dispose() {\n        this.inputEventListener.dispose();\n        this.emitter.dispose();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}