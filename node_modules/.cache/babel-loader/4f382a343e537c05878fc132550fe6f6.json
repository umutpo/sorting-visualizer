{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../modes.js';\nexport class LineTokens {\n  constructor(tokens, text, decoder) {\n    this._lineTokensBrand = undefined;\n    this._tokens = tokens;\n    this._tokensCount = this._tokens.length >>> 1;\n    this._text = text;\n    this._languageIdCodec = decoder;\n  }\n\n  static createEmpty(lineContent, decoder) {\n    const defaultMetadata = LineTokens.defaultTokenMetadata;\n    const tokens = new Uint32Array(2);\n    tokens[0] = lineContent.length;\n    tokens[1] = defaultMetadata;\n    return new LineTokens(tokens, lineContent, decoder);\n  }\n\n  equals(other) {\n    if (other instanceof LineTokens) {\n      return this.slicedEquals(other, 0, this._tokensCount);\n    }\n\n    return false;\n  }\n\n  slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n    if (this._text !== other._text) {\n      return false;\n    }\n\n    if (this._tokensCount !== other._tokensCount) {\n      return false;\n    }\n\n    const from = sliceFromTokenIndex << 1;\n    const to = from + (sliceTokenCount << 1);\n\n    for (let i = from; i < to; i++) {\n      if (this._tokens[i] !== other._tokens[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getLineContent() {\n    return this._text;\n  }\n\n  getCount() {\n    return this._tokensCount;\n  }\n\n  getStartOffset(tokenIndex) {\n    if (tokenIndex > 0) {\n      return this._tokens[tokenIndex - 1 << 1];\n    }\n\n    return 0;\n  }\n\n  getMetadata(tokenIndex) {\n    const metadata = this._tokens[(tokenIndex << 1) + 1];\n    return metadata;\n  }\n\n  getLanguageId(tokenIndex) {\n    const metadata = this._tokens[(tokenIndex << 1) + 1];\n    const languageId = TokenMetadata.getLanguageId(metadata);\n    return this._languageIdCodec.decodeLanguageId(languageId);\n  }\n\n  getStandardTokenType(tokenIndex) {\n    const metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getTokenType(metadata);\n  }\n\n  getForeground(tokenIndex) {\n    const metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getForeground(metadata);\n  }\n\n  getClassName(tokenIndex) {\n    const metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getClassNameFromMetadata(metadata);\n  }\n\n  getInlineStyle(tokenIndex, colorMap) {\n    const metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n  }\n\n  getEndOffset(tokenIndex) {\n    return this._tokens[tokenIndex << 1];\n  }\n  /**\n   * Find the token containing offset `offset`.\n   * @param offset The search offset\n   * @return The index of the token containing the offset.\n   */\n\n\n  findTokenIndexAtOffset(offset) {\n    return LineTokens.findIndexInTokensArray(this._tokens, offset);\n  }\n\n  inflate() {\n    return this;\n  }\n\n  sliceAndInflate(startOffset, endOffset, deltaOffset) {\n    return new SlicedLineTokens(this, startOffset, endOffset, deltaOffset);\n  }\n\n  static convertToEndOffset(tokens, lineTextLength) {\n    const tokenCount = tokens.length >>> 1;\n    const lastTokenIndex = tokenCount - 1;\n\n    for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n      tokens[tokenIndex << 1] = tokens[tokenIndex + 1 << 1];\n    }\n\n    tokens[lastTokenIndex << 1] = lineTextLength;\n  }\n\n  static findIndexInTokensArray(tokens, desiredIndex) {\n    if (tokens.length <= 2) {\n      return 0;\n    }\n\n    let low = 0;\n    let high = (tokens.length >>> 1) - 1;\n\n    while (low < high) {\n      const mid = low + Math.floor((high - low) / 2);\n      const endOffset = tokens[mid << 1];\n\n      if (endOffset === desiredIndex) {\n        return mid + 1;\n      } else if (endOffset < desiredIndex) {\n        low = mid + 1;\n      } else if (endOffset > desiredIndex) {\n        high = mid;\n      }\n    }\n\n    return low;\n  }\n  /**\n   * @pure\n   * @param insertTokens Must be sorted by offset.\n  */\n\n\n  withInserted(insertTokens) {\n    if (insertTokens.length === 0) {\n      return this;\n    }\n\n    let nextOriginalTokenIdx = 0;\n    let nextInsertTokenIdx = 0;\n    let text = '';\n    const newTokens = new Array();\n    let originalEndOffset = 0;\n\n    while (true) {\n      let nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n      let nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n\n      if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n        // original token ends before next insert token\n        text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n        const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n        newTokens.push(text.length, metadata);\n        nextOriginalTokenIdx++;\n        originalEndOffset = nextOriginalTokenEndOffset;\n      } else if (nextInsertToken) {\n        if (nextInsertToken.offset > originalEndOffset) {\n          // insert token is in the middle of the next token.\n          text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n          const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n          newTokens.push(text.length, metadata);\n          originalEndOffset = nextInsertToken.offset;\n        }\n\n        text += nextInsertToken.text;\n        newTokens.push(text.length, nextInsertToken.tokenMetadata);\n        nextInsertTokenIdx++;\n      } else {\n        break;\n      }\n    }\n\n    return new LineTokens(new Uint32Array(newTokens), text, this._languageIdCodec);\n  }\n\n}\nLineTokens.defaultTokenMetadata = (0\n/* None */\n<< 11\n/* FONT_STYLE_OFFSET */\n| 1\n/* DefaultForeground */\n<< 14\n/* FOREGROUND_OFFSET */\n| 2\n/* DefaultBackground */\n<< 23\n/* BACKGROUND_OFFSET */\n) >>> 0;\nexport class SlicedLineTokens {\n  constructor(source, startOffset, endOffset, deltaOffset) {\n    this._source = source;\n    this._startOffset = startOffset;\n    this._endOffset = endOffset;\n    this._deltaOffset = deltaOffset;\n    this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n    this._tokensCount = 0;\n\n    for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n      const tokenStartOffset = source.getStartOffset(i);\n\n      if (tokenStartOffset >= endOffset) {\n        break;\n      }\n\n      this._tokensCount++;\n    }\n  }\n\n  equals(other) {\n    if (other instanceof SlicedLineTokens) {\n      return this._startOffset === other._startOffset && this._endOffset === other._endOffset && this._deltaOffset === other._deltaOffset && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount);\n    }\n\n    return false;\n  }\n\n  getCount() {\n    return this._tokensCount;\n  }\n\n  getForeground(tokenIndex) {\n    return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n  }\n\n  getEndOffset(tokenIndex) {\n    const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n\n    return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n  }\n\n  getClassName(tokenIndex) {\n    return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n  }\n\n  getInlineStyle(tokenIndex, colorMap) {\n    return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n  }\n\n  findTokenIndexAtOffset(offset) {\n    return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n  }\n\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/common/core/lineTokens.js"],"names":["TokenMetadata","LineTokens","constructor","tokens","text","decoder","_lineTokensBrand","undefined","_tokens","_tokensCount","length","_text","_languageIdCodec","createEmpty","lineContent","defaultMetadata","defaultTokenMetadata","Uint32Array","equals","other","slicedEquals","sliceFromTokenIndex","sliceTokenCount","from","to","i","getLineContent","getCount","getStartOffset","tokenIndex","getMetadata","metadata","getLanguageId","languageId","decodeLanguageId","getStandardTokenType","getTokenType","getForeground","getClassName","getClassNameFromMetadata","getInlineStyle","colorMap","getInlineStyleFromMetadata","getEndOffset","findTokenIndexAtOffset","offset","findIndexInTokensArray","inflate","sliceAndInflate","startOffset","endOffset","deltaOffset","SlicedLineTokens","convertToEndOffset","lineTextLength","tokenCount","lastTokenIndex","desiredIndex","low","high","mid","Math","floor","withInserted","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","Array","originalEndOffset","nextOriginalTokenEndOffset","nextInsertToken","substring","push","tokenMetadata","source","_source","_startOffset","_endOffset","_deltaOffset","_firstTokenIndex","len","tokenStartOffset","tokenEndOffset","min"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../modes.js';\nexport class LineTokens {\n    constructor(tokens, text, decoder) {\n        this._lineTokensBrand = undefined;\n        this._tokens = tokens;\n        this._tokensCount = (this._tokens.length >>> 1);\n        this._text = text;\n        this._languageIdCodec = decoder;\n    }\n    static createEmpty(lineContent, decoder) {\n        const defaultMetadata = LineTokens.defaultTokenMetadata;\n        const tokens = new Uint32Array(2);\n        tokens[0] = lineContent.length;\n        tokens[1] = defaultMetadata;\n        return new LineTokens(tokens, lineContent, decoder);\n    }\n    equals(other) {\n        if (other instanceof LineTokens) {\n            return this.slicedEquals(other, 0, this._tokensCount);\n        }\n        return false;\n    }\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n        if (this._text !== other._text) {\n            return false;\n        }\n        if (this._tokensCount !== other._tokensCount) {\n            return false;\n        }\n        const from = (sliceFromTokenIndex << 1);\n        const to = from + (sliceTokenCount << 1);\n        for (let i = from; i < to; i++) {\n            if (this._tokens[i] !== other._tokens[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getLineContent() {\n        return this._text;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStartOffset(tokenIndex) {\n        if (tokenIndex > 0) {\n            return this._tokens[(tokenIndex - 1) << 1];\n        }\n        return 0;\n    }\n    getMetadata(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return metadata;\n    }\n    getLanguageId(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        const languageId = TokenMetadata.getLanguageId(metadata);\n        return this._languageIdCodec.decodeLanguageId(languageId);\n    }\n    getStandardTokenType(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getTokenType(metadata);\n    }\n    getForeground(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getForeground(metadata);\n    }\n    getClassName(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n    getEndOffset(tokenIndex) {\n        return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n    findTokenIndexAtOffset(offset) {\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n    inflate() {\n        return this;\n    }\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\n        return new SlicedLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n    static convertToEndOffset(tokens, lineTextLength) {\n        const tokenCount = (tokens.length >>> 1);\n        const lastTokenIndex = tokenCount - 1;\n        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n        }\n        tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n    static findIndexInTokensArray(tokens, desiredIndex) {\n        if (tokens.length <= 2) {\n            return 0;\n        }\n        let low = 0;\n        let high = (tokens.length >>> 1) - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const endOffset = tokens[(mid << 1)];\n            if (endOffset === desiredIndex) {\n                return mid + 1;\n            }\n            else if (endOffset < desiredIndex) {\n                low = mid + 1;\n            }\n            else if (endOffset > desiredIndex) {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    /**\n     * @pure\n     * @param insertTokens Must be sorted by offset.\n    */\n    withInserted(insertTokens) {\n        if (insertTokens.length === 0) {\n            return this;\n        }\n        let nextOriginalTokenIdx = 0;\n        let nextInsertTokenIdx = 0;\n        let text = '';\n        const newTokens = new Array();\n        let originalEndOffset = 0;\n        while (true) {\n            let nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n            let nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n            if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n                // original token ends before next insert token\n                text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n                const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                newTokens.push(text.length, metadata);\n                nextOriginalTokenIdx++;\n                originalEndOffset = nextOriginalTokenEndOffset;\n            }\n            else if (nextInsertToken) {\n                if (nextInsertToken.offset > originalEndOffset) {\n                    // insert token is in the middle of the next token.\n                    text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n                    const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                    newTokens.push(text.length, metadata);\n                    originalEndOffset = nextInsertToken.offset;\n                }\n                text += nextInsertToken.text;\n                newTokens.push(text.length, nextInsertToken.tokenMetadata);\n                nextInsertTokenIdx++;\n            }\n            else {\n                break;\n            }\n        }\n        return new LineTokens(new Uint32Array(newTokens), text, this._languageIdCodec);\n    }\n}\nLineTokens.defaultTokenMetadata = ((0 /* None */ << 11 /* FONT_STYLE_OFFSET */)\n    | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)\n    | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;\nexport class SlicedLineTokens {\n    constructor(source, startOffset, endOffset, deltaOffset) {\n        this._source = source;\n        this._startOffset = startOffset;\n        this._endOffset = endOffset;\n        this._deltaOffset = deltaOffset;\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n        this._tokensCount = 0;\n        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n            const tokenStartOffset = source.getStartOffset(i);\n            if (tokenStartOffset >= endOffset) {\n                break;\n            }\n            this._tokensCount++;\n        }\n    }\n    equals(other) {\n        if (other instanceof SlicedLineTokens) {\n            return (this._startOffset === other._startOffset\n                && this._endOffset === other._endOffset\n                && this._deltaOffset === other._deltaOffset\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\n        }\n        return false;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getForeground(tokenIndex) {\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n    getEndOffset(tokenIndex) {\n        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n    getClassName(tokenIndex) {\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}