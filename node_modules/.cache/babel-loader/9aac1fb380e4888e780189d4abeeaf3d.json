{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ElementsDragAndDropData } from '../list/listView.js';\nimport { ComposedTreeDelegate } from './abstractTree.js';\nimport { getVisibleState, isFilterResult } from './indexTreeModel.js';\nimport { CompressibleObjectTree, ObjectTree } from './objectTree.js';\nimport { TreeError, WeakMapper } from './tree.js';\nimport { treeItemLoadingIcon } from './treeIcons.js';\nimport { createCancelablePromise, Promises, timeout } from '../../../common/async.js';\nimport { isPromiseCanceledError, onUnexpectedError } from '../../../common/errors.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nimport { DisposableStore, dispose } from '../../../common/lifecycle.js';\n\nfunction createAsyncDataTreeNode(props) {\n  return Object.assign(Object.assign({}, props), {\n    children: [],\n    refreshPromise: undefined,\n    stale: true,\n    slow: false,\n    collapsedByDefault: undefined\n  });\n}\n\nfunction isAncestor(ancestor, descendant) {\n  if (!descendant.parent) {\n    return false;\n  } else if (descendant.parent === ancestor) {\n    return true;\n  } else {\n    return isAncestor(ancestor, descendant.parent);\n  }\n}\n\nfunction intersects(node, other) {\n  return node === other || isAncestor(node, other) || isAncestor(other, node);\n}\n\nclass AsyncDataTreeNodeWrapper {\n  constructor(node) {\n    this.node = node;\n  }\n\n  get element() {\n    return this.node.element.element;\n  }\n\n  get children() {\n    return this.node.children.map(node => new AsyncDataTreeNodeWrapper(node));\n  }\n\n  get depth() {\n    return this.node.depth;\n  }\n\n  get visibleChildrenCount() {\n    return this.node.visibleChildrenCount;\n  }\n\n  get visibleChildIndex() {\n    return this.node.visibleChildIndex;\n  }\n\n  get collapsible() {\n    return this.node.collapsible;\n  }\n\n  get collapsed() {\n    return this.node.collapsed;\n  }\n\n  get visible() {\n    return this.node.visible;\n  }\n\n  get filterData() {\n    return this.node.filterData;\n  }\n\n}\n\nclass AsyncDataTreeRenderer {\n  constructor(renderer, nodeMapper, onDidChangeTwistieState) {\n    this.renderer = renderer;\n    this.nodeMapper = nodeMapper;\n    this.onDidChangeTwistieState = onDidChangeTwistieState;\n    this.renderedNodes = new Map();\n    this.templateId = renderer.templateId;\n  }\n\n  renderTemplate(container) {\n    const templateData = this.renderer.renderTemplate(container);\n    return {\n      templateData\n    };\n  }\n\n  renderElement(node, index, templateData, height) {\n    this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n  }\n\n  renderTwistie(element, twistieElement) {\n    if (element.slow) {\n      twistieElement.classList.add(...treeItemLoadingIcon.classNamesArray);\n      return true;\n    } else {\n      twistieElement.classList.remove(...treeItemLoadingIcon.classNamesArray);\n      return false;\n    }\n  }\n\n  disposeElement(node, index, templateData, height) {\n    if (this.renderer.disposeElement) {\n      this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n    }\n  }\n\n  disposeTemplate(templateData) {\n    this.renderer.disposeTemplate(templateData.templateData);\n  }\n\n  dispose() {\n    this.renderedNodes.clear();\n  }\n\n}\n\nfunction asTreeEvent(e) {\n  return {\n    browserEvent: e.browserEvent,\n    elements: e.elements.map(e => e.element)\n  };\n}\n\nfunction asTreeMouseEvent(e) {\n  return {\n    browserEvent: e.browserEvent,\n    element: e.element && e.element.element,\n    target: e.target\n  };\n}\n\nclass AsyncDataTreeElementsDragAndDropData extends ElementsDragAndDropData {\n  constructor(data) {\n    super(data.elements.map(node => node.element));\n    this.data = data;\n  }\n\n}\n\nfunction asAsyncDataTreeDragAndDropData(data) {\n  if (data instanceof ElementsDragAndDropData) {\n    return new AsyncDataTreeElementsDragAndDropData(data);\n  }\n\n  return data;\n}\n\nclass AsyncDataTreeNodeListDragAndDrop {\n  constructor(dnd) {\n    this.dnd = dnd;\n  }\n\n  getDragURI(node) {\n    return this.dnd.getDragURI(node.element);\n  }\n\n  getDragLabel(nodes, originalEvent) {\n    if (this.dnd.getDragLabel) {\n      return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);\n    }\n\n    return undefined;\n  }\n\n  onDragStart(data, originalEvent) {\n    if (this.dnd.onDragStart) {\n      this.dnd.onDragStart(asAsyncDataTreeDragAndDropData(data), originalEvent);\n    }\n  }\n\n  onDragOver(data, targetNode, targetIndex, originalEvent) {\n    let raw = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    return this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n  }\n\n  drop(data, targetNode, targetIndex, originalEvent) {\n    this.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n  }\n\n  onDragEnd(originalEvent) {\n    if (this.dnd.onDragEnd) {\n      this.dnd.onDragEnd(originalEvent);\n    }\n  }\n\n}\n\nfunction asObjectTreeOptions(options) {\n  return options && Object.assign(Object.assign({}, options), {\n    collapseByDefault: true,\n    identityProvider: options.identityProvider && {\n      getId(el) {\n        return options.identityProvider.getId(el.element);\n      }\n\n    },\n    dnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd),\n    multipleSelectionController: options.multipleSelectionController && {\n      isSelectionSingleChangeEvent(e) {\n        return options.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), {\n          element: e.element\n        }));\n      },\n\n      isSelectionRangeChangeEvent(e) {\n        return options.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), {\n          element: e.element\n        }));\n      }\n\n    },\n    accessibilityProvider: options.accessibilityProvider && Object.assign(Object.assign({}, options.accessibilityProvider), {\n      getPosInSet: undefined,\n      getSetSize: undefined,\n      getRole: options.accessibilityProvider.getRole ? el => {\n        return options.accessibilityProvider.getRole(el.element);\n      } : () => 'treeitem',\n      isChecked: options.accessibilityProvider.isChecked ? e => {\n        var _a;\n\n        return !!((_a = options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.isChecked(e.element));\n      } : undefined,\n\n      getAriaLabel(e) {\n        return options.accessibilityProvider.getAriaLabel(e.element);\n      },\n\n      getWidgetAriaLabel() {\n        return options.accessibilityProvider.getWidgetAriaLabel();\n      },\n\n      getWidgetRole: options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree',\n      getAriaLevel: options.accessibilityProvider.getAriaLevel && (node => {\n        return options.accessibilityProvider.getAriaLevel(node.element);\n      }),\n      getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n        return options.accessibilityProvider.getActiveDescendantId(node.element);\n      })\n    }),\n    filter: options.filter && {\n      filter(e, parentVisibility) {\n        return options.filter.filter(e.element, parentVisibility);\n      }\n\n    },\n    keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, options.keyboardNavigationLabelProvider), {\n      getKeyboardNavigationLabel(e) {\n        return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);\n      }\n\n    }),\n    sorter: undefined,\n    expandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : typeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : e => options.expandOnlyOnTwistieClick(e.element),\n    additionalScrollHeight: options.additionalScrollHeight\n  });\n}\n\nfunction dfs(node, fn) {\n  fn(node);\n  node.children.forEach(child => dfs(child, fn));\n}\n\nexport class AsyncDataTree {\n  constructor(user, container, delegate, renderers, dataSource) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    this.user = user;\n    this.dataSource = dataSource;\n    this.nodes = new Map();\n    this.subTreeRefreshPromises = new Map();\n    this.refreshPromises = new Map();\n    this._onDidRender = new Emitter();\n    this._onDidChangeNodeSlowState = new Emitter();\n    this.nodeMapper = new WeakMapper(node => new AsyncDataTreeNodeWrapper(node));\n    this.disposables = new DisposableStore();\n    this.identityProvider = options.identityProvider;\n    this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n    this.sorter = options.sorter;\n    this.collapseByDefault = options.collapseByDefault;\n    this.tree = this.createTree(user, container, delegate, renderers, options);\n    this.root = createAsyncDataTreeNode({\n      element: undefined,\n      parent: null,\n      hasChildren: true\n    });\n\n    if (this.identityProvider) {\n      this.root = Object.assign(Object.assign({}, this.root), {\n        id: null\n      });\n    }\n\n    this.nodes.set(null, this.root);\n    this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);\n  }\n\n  get onDidChangeFocus() {\n    return Event.map(this.tree.onDidChangeFocus, asTreeEvent);\n  }\n\n  get onDidChangeSelection() {\n    return Event.map(this.tree.onDidChangeSelection, asTreeEvent);\n  }\n\n  get onMouseDblClick() {\n    return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent);\n  }\n\n  get onPointer() {\n    return Event.map(this.tree.onPointer, asTreeMouseEvent);\n  }\n\n  get onDidFocus() {\n    return this.tree.onDidFocus;\n  }\n\n  get onDidDispose() {\n    return this.tree.onDidDispose;\n  }\n\n  createTree(user, container, delegate, renderers, options) {\n    const objectTreeDelegate = new ComposedTreeDelegate(delegate);\n    const objectTreeRenderers = renderers.map(r => new AsyncDataTreeRenderer(r, this.nodeMapper, this._onDidChangeNodeSlowState.event));\n    const objectTreeOptions = asObjectTreeOptions(options) || {};\n    return new ObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n  }\n\n  updateOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.tree.updateOptions(options);\n  } // Widget\n\n\n  getHTMLElement() {\n    return this.tree.getHTMLElement();\n  }\n\n  get scrollTop() {\n    return this.tree.scrollTop;\n  }\n\n  set scrollTop(scrollTop) {\n    this.tree.scrollTop = scrollTop;\n  }\n\n  domFocus() {\n    this.tree.domFocus();\n  }\n\n  layout(height, width) {\n    this.tree.layout(height, width);\n  }\n\n  style(styles) {\n    this.tree.style(styles);\n  } // Model\n\n\n  getInput() {\n    return this.root.element;\n  }\n\n  setInput(input, viewState) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.refreshPromises.forEach(promise => promise.cancel());\n      this.refreshPromises.clear();\n      this.root.element = input;\n      const viewStateContext = viewState && {\n        viewState,\n        focus: [],\n        selection: []\n      };\n      yield this._updateChildren(input, true, false, viewStateContext);\n\n      if (viewStateContext) {\n        this.tree.setFocus(viewStateContext.focus);\n        this.tree.setSelection(viewStateContext.selection);\n      }\n\n      if (viewState && typeof viewState.scrollTop === 'number') {\n        this.scrollTop = viewState.scrollTop;\n      }\n    });\n  }\n\n  _updateChildren() {\n    let element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.root.element;\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let rerender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let viewStateContext = arguments.length > 3 ? arguments[3] : undefined;\n    let options = arguments.length > 4 ? arguments[4] : undefined;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof this.root.element === 'undefined') {\n        throw new TreeError(this.user, 'Tree input not set');\n      }\n\n      if (this.root.refreshPromise) {\n        yield this.root.refreshPromise;\n        yield Event.toPromise(this._onDidRender.event);\n      }\n\n      const node = this.getDataNode(element);\n      yield this.refreshAndRenderNode(node, recursive, viewStateContext, options);\n\n      if (rerender) {\n        try {\n          this.tree.rerender(node);\n        } catch (_a) {// missing nodes are fine, this could've resulted from\n          // parallel refresh calls, removing `node` altogether\n        }\n      }\n    });\n  } // View\n\n\n  rerender(element) {\n    if (element === undefined || element === this.root.element) {\n      this.tree.rerender();\n      return;\n    }\n\n    const node = this.getDataNode(element);\n    this.tree.rerender(node);\n  }\n\n  collapse(element) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const node = this.getDataNode(element);\n    return this.tree.collapse(node === this.root ? null : node, recursive);\n  }\n\n  expand(element) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof this.root.element === 'undefined') {\n        throw new TreeError(this.user, 'Tree input not set');\n      }\n\n      if (this.root.refreshPromise) {\n        yield this.root.refreshPromise;\n        yield Event.toPromise(this._onDidRender.event);\n      }\n\n      const node = this.getDataNode(element);\n\n      if (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {\n        return false;\n      }\n\n      if (node.refreshPromise) {\n        yield this.root.refreshPromise;\n        yield Event.toPromise(this._onDidRender.event);\n      }\n\n      if (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {\n        return false;\n      }\n\n      const result = this.tree.expand(node === this.root ? null : node, recursive);\n\n      if (node.refreshPromise) {\n        yield this.root.refreshPromise;\n        yield Event.toPromise(this._onDidRender.event);\n      }\n\n      return result;\n    });\n  }\n\n  setSelection(elements, browserEvent) {\n    const nodes = elements.map(e => this.getDataNode(e));\n    this.tree.setSelection(nodes, browserEvent);\n  }\n\n  getSelection() {\n    const nodes = this.tree.getSelection();\n    return nodes.map(n => n.element);\n  }\n\n  setFocus(elements, browserEvent) {\n    const nodes = elements.map(e => this.getDataNode(e));\n    this.tree.setFocus(nodes, browserEvent);\n  }\n\n  getFocus() {\n    const nodes = this.tree.getFocus();\n    return nodes.map(n => n.element);\n  }\n\n  reveal(element, relativeTop) {\n    this.tree.reveal(this.getDataNode(element), relativeTop);\n  } // Implementation\n\n\n  getDataNode(element) {\n    const node = this.nodes.get(element === this.root.element ? null : element);\n\n    if (!node) {\n      throw new TreeError(this.user, `Data tree node not found: ${element}`);\n    }\n\n    return node;\n  }\n\n  refreshAndRenderNode(node, recursive, viewStateContext, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.refreshNode(node, recursive, viewStateContext);\n      this.render(node, viewStateContext, options);\n    });\n  }\n\n  refreshNode(node, recursive, viewStateContext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let result;\n      this.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {\n        if (!result && intersects(refreshNode, node)) {\n          result = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));\n        }\n      });\n\n      if (result) {\n        return result;\n      }\n\n      return this.doRefreshSubTree(node, recursive, viewStateContext);\n    });\n  }\n\n  doRefreshSubTree(node, recursive, viewStateContext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let done;\n      node.refreshPromise = new Promise(c => done = c);\n      this.subTreeRefreshPromises.set(node, node.refreshPromise);\n      node.refreshPromise.finally(() => {\n        node.refreshPromise = undefined;\n        this.subTreeRefreshPromises.delete(node);\n      });\n\n      try {\n        const childrenToRefresh = yield this.doRefreshNode(node, recursive, viewStateContext);\n        node.stale = false;\n        yield Promises.settled(childrenToRefresh.map(child => this.doRefreshSubTree(child, recursive, viewStateContext)));\n      } finally {\n        done();\n      }\n    });\n  }\n\n  doRefreshNode(node, recursive, viewStateContext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      node.hasChildren = !!this.dataSource.hasChildren(node.element);\n      let childrenPromise;\n\n      if (!node.hasChildren) {\n        childrenPromise = Promise.resolve(Iterable.empty());\n      } else {\n        const slowTimeout = timeout(800);\n        slowTimeout.then(() => {\n          node.slow = true;\n\n          this._onDidChangeNodeSlowState.fire(node);\n        }, _ => null);\n        childrenPromise = this.doGetChildren(node).finally(() => slowTimeout.cancel());\n      }\n\n      try {\n        const children = yield childrenPromise;\n        return this.setChildren(node, children, recursive, viewStateContext);\n      } catch (err) {\n        if (node !== this.root && this.tree.hasElement(node)) {\n          this.tree.collapse(node);\n        }\n\n        if (isPromiseCanceledError(err)) {\n          return [];\n        }\n\n        throw err;\n      } finally {\n        if (node.slow) {\n          node.slow = false;\n\n          this._onDidChangeNodeSlowState.fire(node);\n        }\n      }\n    });\n  }\n\n  doGetChildren(node) {\n    let result = this.refreshPromises.get(node);\n\n    if (result) {\n      return result;\n    }\n\n    result = createCancelablePromise(() => __awaiter(this, void 0, void 0, function* () {\n      const children = yield this.dataSource.getChildren(node.element);\n      return this.processChildren(children);\n    }));\n    this.refreshPromises.set(node, result);\n    return result.finally(() => {\n      this.refreshPromises.delete(node);\n    });\n  }\n\n  _onDidChangeCollapseState(_ref) {\n    let {\n      node,\n      deep\n    } = _ref;\n\n    if (node.element === null) {\n      return;\n    }\n\n    if (!node.collapsed && node.element.stale) {\n      if (deep) {\n        this.collapse(node.element.element);\n      } else {\n        this.refreshAndRenderNode(node.element, false).catch(onUnexpectedError);\n      }\n    }\n  }\n\n  setChildren(node, childrenElementsIterable, recursive, viewStateContext) {\n    const childrenElements = [...childrenElementsIterable]; // perf: if the node was and still is a leaf, avoid all this hassle\n\n    if (node.children.length === 0 && childrenElements.length === 0) {\n      return [];\n    }\n\n    const nodesToForget = new Map();\n    const childrenTreeNodesById = new Map();\n\n    for (const child of node.children) {\n      nodesToForget.set(child.element, child);\n\n      if (this.identityProvider) {\n        const collapsed = this.tree.isCollapsed(child);\n        childrenTreeNodesById.set(child.id, {\n          node: child,\n          collapsed\n        });\n      }\n    }\n\n    const childrenToRefresh = [];\n    const children = childrenElements.map(element => {\n      const hasChildren = !!this.dataSource.hasChildren(element);\n\n      if (!this.identityProvider) {\n        const asyncDataTreeNode = createAsyncDataTreeNode({\n          element,\n          parent: node,\n          hasChildren\n        });\n\n        if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n          asyncDataTreeNode.collapsedByDefault = false;\n          childrenToRefresh.push(asyncDataTreeNode);\n        }\n\n        return asyncDataTreeNode;\n      }\n\n      const id = this.identityProvider.getId(element).toString();\n      const result = childrenTreeNodesById.get(id);\n\n      if (result) {\n        const asyncDataTreeNode = result.node;\n        nodesToForget.delete(asyncDataTreeNode.element);\n        this.nodes.delete(asyncDataTreeNode.element);\n        this.nodes.set(element, asyncDataTreeNode);\n        asyncDataTreeNode.element = element;\n        asyncDataTreeNode.hasChildren = hasChildren;\n\n        if (recursive) {\n          if (result.collapsed) {\n            asyncDataTreeNode.children.forEach(node => dfs(node, node => this.nodes.delete(node.element)));\n            asyncDataTreeNode.children.splice(0, asyncDataTreeNode.children.length);\n            asyncDataTreeNode.stale = true;\n          } else {\n            childrenToRefresh.push(asyncDataTreeNode);\n          }\n        } else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n          asyncDataTreeNode.collapsedByDefault = false;\n          childrenToRefresh.push(asyncDataTreeNode);\n        }\n\n        return asyncDataTreeNode;\n      }\n\n      const childAsyncDataTreeNode = createAsyncDataTreeNode({\n        element,\n        parent: node,\n        id,\n        hasChildren\n      });\n\n      if (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {\n        viewStateContext.focus.push(childAsyncDataTreeNode);\n      }\n\n      if (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {\n        viewStateContext.selection.push(childAsyncDataTreeNode);\n      }\n\n      if (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {\n        childrenToRefresh.push(childAsyncDataTreeNode);\n      } else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n        childAsyncDataTreeNode.collapsedByDefault = false;\n        childrenToRefresh.push(childAsyncDataTreeNode);\n      }\n\n      return childAsyncDataTreeNode;\n    });\n\n    for (const node of nodesToForget.values()) {\n      dfs(node, node => this.nodes.delete(node.element));\n    }\n\n    for (const child of children) {\n      this.nodes.set(child.element, child);\n    }\n\n    node.children.splice(0, node.children.length, ...children); // TODO@joao this doesn't take filter into account\n\n    if (node !== this.root && this.autoExpandSingleChildren && children.length === 1 && childrenToRefresh.length === 0) {\n      children[0].collapsedByDefault = false;\n      childrenToRefresh.push(children[0]);\n    }\n\n    return childrenToRefresh;\n  }\n\n  render(node, viewStateContext, options) {\n    const children = node.children.map(node => this.asTreeElement(node, viewStateContext));\n    const objectTreeOptions = options && Object.assign(Object.assign({}, options), {\n      diffIdentityProvider: options.diffIdentityProvider && {\n        getId(node) {\n          return options.diffIdentityProvider.getId(node.element);\n        }\n\n      }\n    });\n    this.tree.setChildren(node === this.root ? null : node, children, objectTreeOptions);\n\n    if (node !== this.root) {\n      this.tree.setCollapsible(node, node.hasChildren);\n    }\n\n    this._onDidRender.fire();\n  }\n\n  asTreeElement(node, viewStateContext) {\n    if (node.stale) {\n      return {\n        element: node,\n        collapsible: node.hasChildren,\n        collapsed: true\n      };\n    }\n\n    let collapsed;\n\n    if (viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1) {\n      collapsed = false;\n    } else {\n      collapsed = node.collapsedByDefault;\n    }\n\n    node.collapsedByDefault = undefined;\n    return {\n      element: node,\n      children: node.hasChildren ? Iterable.map(node.children, child => this.asTreeElement(child, viewStateContext)) : [],\n      collapsible: node.hasChildren,\n      collapsed\n    };\n  }\n\n  processChildren(children) {\n    if (this.sorter) {\n      children = [...children].sort(this.sorter.compare.bind(this.sorter));\n    }\n\n    return children;\n  }\n\n  dispose() {\n    this.disposables.dispose();\n  }\n\n}\n\nclass CompressibleAsyncDataTreeNodeWrapper {\n  constructor(node) {\n    this.node = node;\n  }\n\n  get element() {\n    return {\n      elements: this.node.element.elements.map(e => e.element),\n      incompressible: this.node.element.incompressible\n    };\n  }\n\n  get children() {\n    return this.node.children.map(node => new CompressibleAsyncDataTreeNodeWrapper(node));\n  }\n\n  get depth() {\n    return this.node.depth;\n  }\n\n  get visibleChildrenCount() {\n    return this.node.visibleChildrenCount;\n  }\n\n  get visibleChildIndex() {\n    return this.node.visibleChildIndex;\n  }\n\n  get collapsible() {\n    return this.node.collapsible;\n  }\n\n  get collapsed() {\n    return this.node.collapsed;\n  }\n\n  get visible() {\n    return this.node.visible;\n  }\n\n  get filterData() {\n    return this.node.filterData;\n  }\n\n}\n\nclass CompressibleAsyncDataTreeRenderer {\n  constructor(renderer, nodeMapper, compressibleNodeMapperProvider, onDidChangeTwistieState) {\n    this.renderer = renderer;\n    this.nodeMapper = nodeMapper;\n    this.compressibleNodeMapperProvider = compressibleNodeMapperProvider;\n    this.onDidChangeTwistieState = onDidChangeTwistieState;\n    this.renderedNodes = new Map();\n    this.disposables = [];\n    this.templateId = renderer.templateId;\n  }\n\n  renderTemplate(container) {\n    const templateData = this.renderer.renderTemplate(container);\n    return {\n      templateData\n    };\n  }\n\n  renderElement(node, index, templateData, height) {\n    this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n  }\n\n  renderCompressedElements(node, index, templateData, height) {\n    this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\n  }\n\n  renderTwistie(element, twistieElement) {\n    if (element.slow) {\n      twistieElement.classList.add(...treeItemLoadingIcon.classNamesArray);\n      return true;\n    } else {\n      twistieElement.classList.remove(...treeItemLoadingIcon.classNamesArray);\n      return false;\n    }\n  }\n\n  disposeElement(node, index, templateData, height) {\n    if (this.renderer.disposeElement) {\n      this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n    }\n  }\n\n  disposeCompressedElements(node, index, templateData, height) {\n    if (this.renderer.disposeCompressedElements) {\n      this.renderer.disposeCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\n    }\n  }\n\n  disposeTemplate(templateData) {\n    this.renderer.disposeTemplate(templateData.templateData);\n  }\n\n  dispose() {\n    this.renderedNodes.clear();\n    this.disposables = dispose(this.disposables);\n  }\n\n}\n\nfunction asCompressibleObjectTreeOptions(options) {\n  const objectTreeOptions = options && asObjectTreeOptions(options);\n  return objectTreeOptions && Object.assign(Object.assign({}, objectTreeOptions), {\n    keyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, objectTreeOptions.keyboardNavigationLabelProvider), {\n      getCompressedNodeKeyboardNavigationLabel(els) {\n        return options.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(els.map(e => e.element));\n      }\n\n    })\n  });\n}\n\nexport class CompressibleAsyncDataTree extends AsyncDataTree {\n  constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource) {\n    let options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n    super(user, container, virtualDelegate, renderers, dataSource, options);\n    this.compressionDelegate = compressionDelegate;\n    this.compressibleNodeMapper = new WeakMapper(node => new CompressibleAsyncDataTreeNodeWrapper(node));\n    this.filter = options.filter;\n  }\n\n  createTree(user, container, delegate, renderers, options) {\n    const objectTreeDelegate = new ComposedTreeDelegate(delegate);\n    const objectTreeRenderers = renderers.map(r => new CompressibleAsyncDataTreeRenderer(r, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event));\n    const objectTreeOptions = asCompressibleObjectTreeOptions(options) || {};\n    return new CompressibleObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n  }\n\n  asTreeElement(node, viewStateContext) {\n    return Object.assign({\n      incompressible: this.compressionDelegate.isIncompressible(node.element)\n    }, super.asTreeElement(node, viewStateContext));\n  }\n\n  updateOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.tree.updateOptions(options);\n  }\n\n  render(node, viewStateContext) {\n    if (!this.identityProvider) {\n      return super.render(node, viewStateContext);\n    } // Preserve traits across compressions. Hacky but does the trick.\n    // This is hard to fix properly since it requires rewriting the traits\n    // across trees and lists. Let's just keep it this way for now.\n\n\n    const getId = element => this.identityProvider.getId(element).toString();\n\n    const getUncompressedIds = nodes => {\n      const result = new Set();\n\n      for (const node of nodes) {\n        const compressedNode = this.tree.getCompressedTreeNode(node === this.root ? null : node);\n\n        if (!compressedNode.element) {\n          continue;\n        }\n\n        for (const node of compressedNode.element.elements) {\n          result.add(getId(node.element));\n        }\n      }\n\n      return result;\n    };\n\n    const oldSelection = getUncompressedIds(this.tree.getSelection());\n    const oldFocus = getUncompressedIds(this.tree.getFocus());\n    super.render(node, viewStateContext);\n    const selection = this.getSelection();\n    let didChangeSelection = false;\n    const focus = this.getFocus();\n    let didChangeFocus = false;\n\n    const visit = node => {\n      const compressedNode = node.element;\n\n      if (compressedNode) {\n        for (let i = 0; i < compressedNode.elements.length; i++) {\n          const id = getId(compressedNode.elements[i].element);\n          const element = compressedNode.elements[compressedNode.elements.length - 1].element; // github.com/microsoft/vscode/issues/85938\n\n          if (oldSelection.has(id) && selection.indexOf(element) === -1) {\n            selection.push(element);\n            didChangeSelection = true;\n          }\n\n          if (oldFocus.has(id) && focus.indexOf(element) === -1) {\n            focus.push(element);\n            didChangeFocus = true;\n          }\n        }\n      }\n\n      node.children.forEach(visit);\n    };\n\n    visit(this.tree.getCompressedTreeNode(node === this.root ? null : node));\n\n    if (didChangeSelection) {\n      this.setSelection(selection);\n    }\n\n    if (didChangeFocus) {\n      this.setFocus(focus);\n    }\n  } // For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work\n  // and we have to filter everything beforehand\n  // Related to #85193 and #85835\n\n\n  processChildren(children) {\n    if (this.filter) {\n      children = Iterable.filter(children, e => {\n        const result = this.filter.filter(e, 1\n        /* Visible */\n        );\n        const visibility = getVisibility(result);\n\n        if (visibility === 2\n        /* Recurse */\n        ) {\n          throw new Error('Recursive tree visibility not supported in async data compressed trees');\n        }\n\n        return visibility === 1\n        /* Visible */\n        ;\n      });\n    }\n\n    return super.processChildren(children);\n  }\n\n}\n\nfunction getVisibility(filterResult) {\n  if (typeof filterResult === 'boolean') {\n    return filterResult ? 1\n    /* Visible */\n    : 0\n    /* Hidden */\n    ;\n  } else if (isFilterResult(filterResult)) {\n    return getVisibleState(filterResult.visibility);\n  } else {\n    return getVisibleState(filterResult);\n  }\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/base/browser/ui/tree/asyncDataTree.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","ElementsDragAndDropData","ComposedTreeDelegate","getVisibleState","isFilterResult","CompressibleObjectTree","ObjectTree","TreeError","WeakMapper","treeItemLoadingIcon","createCancelablePromise","Promises","timeout","isPromiseCanceledError","onUnexpectedError","Emitter","Event","Iterable","DisposableStore","dispose","createAsyncDataTreeNode","props","Object","assign","children","refreshPromise","undefined","stale","slow","collapsedByDefault","isAncestor","ancestor","descendant","parent","intersects","node","other","AsyncDataTreeNodeWrapper","constructor","element","map","depth","visibleChildrenCount","visibleChildIndex","collapsible","collapsed","visible","filterData","AsyncDataTreeRenderer","renderer","nodeMapper","onDidChangeTwistieState","renderedNodes","Map","templateId","renderTemplate","container","templateData","renderElement","index","height","renderTwistie","twistieElement","classList","add","classNamesArray","remove","disposeElement","disposeTemplate","clear","asTreeEvent","browserEvent","elements","asTreeMouseEvent","target","AsyncDataTreeElementsDragAndDropData","data","asAsyncDataTreeDragAndDropData","AsyncDataTreeNodeListDragAndDrop","dnd","getDragURI","getDragLabel","nodes","originalEvent","onDragStart","onDragOver","targetNode","targetIndex","raw","drop","onDragEnd","asObjectTreeOptions","options","collapseByDefault","identityProvider","getId","el","multipleSelectionController","isSelectionSingleChangeEvent","isSelectionRangeChangeEvent","accessibilityProvider","getPosInSet","getSetSize","getRole","isChecked","_a","getAriaLabel","getWidgetAriaLabel","getWidgetRole","getAriaLevel","getActiveDescendantId","filter","parentVisibility","keyboardNavigationLabelProvider","getKeyboardNavigationLabel","sorter","expandOnlyOnTwistieClick","additionalScrollHeight","dfs","fn","forEach","child","AsyncDataTree","user","delegate","renderers","dataSource","subTreeRefreshPromises","refreshPromises","_onDidRender","_onDidChangeNodeSlowState","disposables","autoExpandSingleChildren","tree","createTree","root","hasChildren","id","set","onDidChangeCollapseState","_onDidChangeCollapseState","onDidChangeFocus","onDidChangeSelection","onMouseDblClick","onPointer","onDidFocus","onDidDispose","objectTreeDelegate","objectTreeRenderers","r","event","objectTreeOptions","updateOptions","getHTMLElement","scrollTop","domFocus","layout","width","style","styles","getInput","setInput","input","viewState","promise","cancel","viewStateContext","focus","selection","_updateChildren","setFocus","setSelection","recursive","rerender","toPromise","getDataNode","refreshAndRenderNode","collapse","expand","hasElement","isCollapsible","isCollapsed","getSelection","n","getFocus","reveal","relativeTop","get","refreshNode","render","doRefreshSubTree","c","finally","delete","childrenToRefresh","doRefreshNode","settled","childrenPromise","empty","slowTimeout","fire","_","doGetChildren","setChildren","err","getChildren","processChildren","deep","catch","childrenElementsIterable","childrenElements","length","nodesToForget","childrenTreeNodesById","asyncDataTreeNode","push","toString","splice","childAsyncDataTreeNode","indexOf","expanded","values","asTreeElement","diffIdentityProvider","setCollapsible","sort","compare","bind","CompressibleAsyncDataTreeNodeWrapper","incompressible","CompressibleAsyncDataTreeRenderer","compressibleNodeMapperProvider","renderCompressedElements","disposeCompressedElements","asCompressibleObjectTreeOptions","getCompressedNodeKeyboardNavigationLabel","els","CompressibleAsyncDataTree","virtualDelegate","compressionDelegate","compressibleNodeMapper","isIncompressible","getUncompressedIds","Set","compressedNode","getCompressedTreeNode","oldSelection","oldFocus","didChangeSelection","didChangeFocus","visit","i","has","visibility","getVisibility","Error","filterResult"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ElementsDragAndDropData } from '../list/listView.js';\nimport { ComposedTreeDelegate } from './abstractTree.js';\nimport { getVisibleState, isFilterResult } from './indexTreeModel.js';\nimport { CompressibleObjectTree, ObjectTree } from './objectTree.js';\nimport { TreeError, WeakMapper } from './tree.js';\nimport { treeItemLoadingIcon } from './treeIcons.js';\nimport { createCancelablePromise, Promises, timeout } from '../../../common/async.js';\nimport { isPromiseCanceledError, onUnexpectedError } from '../../../common/errors.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nimport { DisposableStore, dispose } from '../../../common/lifecycle.js';\nfunction createAsyncDataTreeNode(props) {\n    return Object.assign(Object.assign({}, props), { children: [], refreshPromise: undefined, stale: true, slow: false, collapsedByDefault: undefined });\n}\nfunction isAncestor(ancestor, descendant) {\n    if (!descendant.parent) {\n        return false;\n    }\n    else if (descendant.parent === ancestor) {\n        return true;\n    }\n    else {\n        return isAncestor(ancestor, descendant.parent);\n    }\n}\nfunction intersects(node, other) {\n    return node === other || isAncestor(node, other) || isAncestor(other, node);\n}\nclass AsyncDataTreeNodeWrapper {\n    constructor(node) {\n        this.node = node;\n    }\n    get element() { return this.node.element.element; }\n    get children() { return this.node.children.map(node => new AsyncDataTreeNodeWrapper(node)); }\n    get depth() { return this.node.depth; }\n    get visibleChildrenCount() { return this.node.visibleChildrenCount; }\n    get visibleChildIndex() { return this.node.visibleChildIndex; }\n    get collapsible() { return this.node.collapsible; }\n    get collapsed() { return this.node.collapsed; }\n    get visible() { return this.node.visible; }\n    get filterData() { return this.node.filterData; }\n}\nclass AsyncDataTreeRenderer {\n    constructor(renderer, nodeMapper, onDidChangeTwistieState) {\n        this.renderer = renderer;\n        this.nodeMapper = nodeMapper;\n        this.onDidChangeTwistieState = onDidChangeTwistieState;\n        this.renderedNodes = new Map();\n        this.templateId = renderer.templateId;\n    }\n    renderTemplate(container) {\n        const templateData = this.renderer.renderTemplate(container);\n        return { templateData };\n    }\n    renderElement(node, index, templateData, height) {\n        this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n    }\n    renderTwistie(element, twistieElement) {\n        if (element.slow) {\n            twistieElement.classList.add(...treeItemLoadingIcon.classNamesArray);\n            return true;\n        }\n        else {\n            twistieElement.classList.remove(...treeItemLoadingIcon.classNamesArray);\n            return false;\n        }\n    }\n    disposeElement(node, index, templateData, height) {\n        if (this.renderer.disposeElement) {\n            this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n        }\n    }\n    disposeTemplate(templateData) {\n        this.renderer.disposeTemplate(templateData.templateData);\n    }\n    dispose() {\n        this.renderedNodes.clear();\n    }\n}\nfunction asTreeEvent(e) {\n    return {\n        browserEvent: e.browserEvent,\n        elements: e.elements.map(e => e.element)\n    };\n}\nfunction asTreeMouseEvent(e) {\n    return {\n        browserEvent: e.browserEvent,\n        element: e.element && e.element.element,\n        target: e.target\n    };\n}\nclass AsyncDataTreeElementsDragAndDropData extends ElementsDragAndDropData {\n    constructor(data) {\n        super(data.elements.map(node => node.element));\n        this.data = data;\n    }\n}\nfunction asAsyncDataTreeDragAndDropData(data) {\n    if (data instanceof ElementsDragAndDropData) {\n        return new AsyncDataTreeElementsDragAndDropData(data);\n    }\n    return data;\n}\nclass AsyncDataTreeNodeListDragAndDrop {\n    constructor(dnd) {\n        this.dnd = dnd;\n    }\n    getDragURI(node) {\n        return this.dnd.getDragURI(node.element);\n    }\n    getDragLabel(nodes, originalEvent) {\n        if (this.dnd.getDragLabel) {\n            return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);\n        }\n        return undefined;\n    }\n    onDragStart(data, originalEvent) {\n        if (this.dnd.onDragStart) {\n            this.dnd.onDragStart(asAsyncDataTreeDragAndDropData(data), originalEvent);\n        }\n    }\n    onDragOver(data, targetNode, targetIndex, originalEvent, raw = true) {\n        return this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n    }\n    drop(data, targetNode, targetIndex, originalEvent) {\n        this.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n    }\n    onDragEnd(originalEvent) {\n        if (this.dnd.onDragEnd) {\n            this.dnd.onDragEnd(originalEvent);\n        }\n    }\n}\nfunction asObjectTreeOptions(options) {\n    return options && Object.assign(Object.assign({}, options), { collapseByDefault: true, identityProvider: options.identityProvider && {\n            getId(el) {\n                return options.identityProvider.getId(el.element);\n            }\n        }, dnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd), multipleSelectionController: options.multipleSelectionController && {\n            isSelectionSingleChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));\n            },\n            isSelectionRangeChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));\n            }\n        }, accessibilityProvider: options.accessibilityProvider && Object.assign(Object.assign({}, options.accessibilityProvider), { getPosInSet: undefined, getSetSize: undefined, getRole: options.accessibilityProvider.getRole ? (el) => {\n                return options.accessibilityProvider.getRole(el.element);\n            } : () => 'treeitem', isChecked: options.accessibilityProvider.isChecked ? (e) => {\n                var _a;\n                return !!((_a = options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.isChecked(e.element));\n            } : undefined, getAriaLabel(e) {\n                return options.accessibilityProvider.getAriaLabel(e.element);\n            },\n            getWidgetAriaLabel() {\n                return options.accessibilityProvider.getWidgetAriaLabel();\n            }, getWidgetRole: options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree', getAriaLevel: options.accessibilityProvider.getAriaLevel && (node => {\n                return options.accessibilityProvider.getAriaLevel(node.element);\n            }), getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n                return options.accessibilityProvider.getActiveDescendantId(node.element);\n            }) }), filter: options.filter && {\n            filter(e, parentVisibility) {\n                return options.filter.filter(e.element, parentVisibility);\n            }\n        }, keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, options.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(e) {\n                return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);\n            } }), sorter: undefined, expandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : (typeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : (e => options.expandOnlyOnTwistieClick(e.element))), additionalScrollHeight: options.additionalScrollHeight });\n}\nfunction dfs(node, fn) {\n    fn(node);\n    node.children.forEach(child => dfs(child, fn));\n}\nexport class AsyncDataTree {\n    constructor(user, container, delegate, renderers, dataSource, options = {}) {\n        this.user = user;\n        this.dataSource = dataSource;\n        this.nodes = new Map();\n        this.subTreeRefreshPromises = new Map();\n        this.refreshPromises = new Map();\n        this._onDidRender = new Emitter();\n        this._onDidChangeNodeSlowState = new Emitter();\n        this.nodeMapper = new WeakMapper(node => new AsyncDataTreeNodeWrapper(node));\n        this.disposables = new DisposableStore();\n        this.identityProvider = options.identityProvider;\n        this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n        this.sorter = options.sorter;\n        this.collapseByDefault = options.collapseByDefault;\n        this.tree = this.createTree(user, container, delegate, renderers, options);\n        this.root = createAsyncDataTreeNode({\n            element: undefined,\n            parent: null,\n            hasChildren: true\n        });\n        if (this.identityProvider) {\n            this.root = Object.assign(Object.assign({}, this.root), { id: null });\n        }\n        this.nodes.set(null, this.root);\n        this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);\n    }\n    get onDidChangeFocus() { return Event.map(this.tree.onDidChangeFocus, asTreeEvent); }\n    get onDidChangeSelection() { return Event.map(this.tree.onDidChangeSelection, asTreeEvent); }\n    get onMouseDblClick() { return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent); }\n    get onPointer() { return Event.map(this.tree.onPointer, asTreeMouseEvent); }\n    get onDidFocus() { return this.tree.onDidFocus; }\n    get onDidDispose() { return this.tree.onDidDispose; }\n    createTree(user, container, delegate, renderers, options) {\n        const objectTreeDelegate = new ComposedTreeDelegate(delegate);\n        const objectTreeRenderers = renderers.map(r => new AsyncDataTreeRenderer(r, this.nodeMapper, this._onDidChangeNodeSlowState.event));\n        const objectTreeOptions = asObjectTreeOptions(options) || {};\n        return new ObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n    }\n    updateOptions(options = {}) {\n        this.tree.updateOptions(options);\n    }\n    // Widget\n    getHTMLElement() {\n        return this.tree.getHTMLElement();\n    }\n    get scrollTop() {\n        return this.tree.scrollTop;\n    }\n    set scrollTop(scrollTop) {\n        this.tree.scrollTop = scrollTop;\n    }\n    domFocus() {\n        this.tree.domFocus();\n    }\n    layout(height, width) {\n        this.tree.layout(height, width);\n    }\n    style(styles) {\n        this.tree.style(styles);\n    }\n    // Model\n    getInput() {\n        return this.root.element;\n    }\n    setInput(input, viewState) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.refreshPromises.forEach(promise => promise.cancel());\n            this.refreshPromises.clear();\n            this.root.element = input;\n            const viewStateContext = viewState && { viewState, focus: [], selection: [] };\n            yield this._updateChildren(input, true, false, viewStateContext);\n            if (viewStateContext) {\n                this.tree.setFocus(viewStateContext.focus);\n                this.tree.setSelection(viewStateContext.selection);\n            }\n            if (viewState && typeof viewState.scrollTop === 'number') {\n                this.scrollTop = viewState.scrollTop;\n            }\n        });\n    }\n    _updateChildren(element = this.root.element, recursive = true, rerender = false, viewStateContext, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.root.element === 'undefined') {\n                throw new TreeError(this.user, 'Tree input not set');\n            }\n            if (this.root.refreshPromise) {\n                yield this.root.refreshPromise;\n                yield Event.toPromise(this._onDidRender.event);\n            }\n            const node = this.getDataNode(element);\n            yield this.refreshAndRenderNode(node, recursive, viewStateContext, options);\n            if (rerender) {\n                try {\n                    this.tree.rerender(node);\n                }\n                catch (_a) {\n                    // missing nodes are fine, this could've resulted from\n                    // parallel refresh calls, removing `node` altogether\n                }\n            }\n        });\n    }\n    // View\n    rerender(element) {\n        if (element === undefined || element === this.root.element) {\n            this.tree.rerender();\n            return;\n        }\n        const node = this.getDataNode(element);\n        this.tree.rerender(node);\n    }\n    collapse(element, recursive = false) {\n        const node = this.getDataNode(element);\n        return this.tree.collapse(node === this.root ? null : node, recursive);\n    }\n    expand(element, recursive = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.root.element === 'undefined') {\n                throw new TreeError(this.user, 'Tree input not set');\n            }\n            if (this.root.refreshPromise) {\n                yield this.root.refreshPromise;\n                yield Event.toPromise(this._onDidRender.event);\n            }\n            const node = this.getDataNode(element);\n            if (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {\n                return false;\n            }\n            if (node.refreshPromise) {\n                yield this.root.refreshPromise;\n                yield Event.toPromise(this._onDidRender.event);\n            }\n            if (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {\n                return false;\n            }\n            const result = this.tree.expand(node === this.root ? null : node, recursive);\n            if (node.refreshPromise) {\n                yield this.root.refreshPromise;\n                yield Event.toPromise(this._onDidRender.event);\n            }\n            return result;\n        });\n    }\n    setSelection(elements, browserEvent) {\n        const nodes = elements.map(e => this.getDataNode(e));\n        this.tree.setSelection(nodes, browserEvent);\n    }\n    getSelection() {\n        const nodes = this.tree.getSelection();\n        return nodes.map(n => n.element);\n    }\n    setFocus(elements, browserEvent) {\n        const nodes = elements.map(e => this.getDataNode(e));\n        this.tree.setFocus(nodes, browserEvent);\n    }\n    getFocus() {\n        const nodes = this.tree.getFocus();\n        return nodes.map(n => n.element);\n    }\n    reveal(element, relativeTop) {\n        this.tree.reveal(this.getDataNode(element), relativeTop);\n    }\n    // Implementation\n    getDataNode(element) {\n        const node = this.nodes.get((element === this.root.element ? null : element));\n        if (!node) {\n            throw new TreeError(this.user, `Data tree node not found: ${element}`);\n        }\n        return node;\n    }\n    refreshAndRenderNode(node, recursive, viewStateContext, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.refreshNode(node, recursive, viewStateContext);\n            this.render(node, viewStateContext, options);\n        });\n    }\n    refreshNode(node, recursive, viewStateContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let result;\n            this.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {\n                if (!result && intersects(refreshNode, node)) {\n                    result = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));\n                }\n            });\n            if (result) {\n                return result;\n            }\n            return this.doRefreshSubTree(node, recursive, viewStateContext);\n        });\n    }\n    doRefreshSubTree(node, recursive, viewStateContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let done;\n            node.refreshPromise = new Promise(c => done = c);\n            this.subTreeRefreshPromises.set(node, node.refreshPromise);\n            node.refreshPromise.finally(() => {\n                node.refreshPromise = undefined;\n                this.subTreeRefreshPromises.delete(node);\n            });\n            try {\n                const childrenToRefresh = yield this.doRefreshNode(node, recursive, viewStateContext);\n                node.stale = false;\n                yield Promises.settled(childrenToRefresh.map(child => this.doRefreshSubTree(child, recursive, viewStateContext)));\n            }\n            finally {\n                done();\n            }\n        });\n    }\n    doRefreshNode(node, recursive, viewStateContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            node.hasChildren = !!this.dataSource.hasChildren(node.element);\n            let childrenPromise;\n            if (!node.hasChildren) {\n                childrenPromise = Promise.resolve(Iterable.empty());\n            }\n            else {\n                const slowTimeout = timeout(800);\n                slowTimeout.then(() => {\n                    node.slow = true;\n                    this._onDidChangeNodeSlowState.fire(node);\n                }, _ => null);\n                childrenPromise = this.doGetChildren(node)\n                    .finally(() => slowTimeout.cancel());\n            }\n            try {\n                const children = yield childrenPromise;\n                return this.setChildren(node, children, recursive, viewStateContext);\n            }\n            catch (err) {\n                if (node !== this.root && this.tree.hasElement(node)) {\n                    this.tree.collapse(node);\n                }\n                if (isPromiseCanceledError(err)) {\n                    return [];\n                }\n                throw err;\n            }\n            finally {\n                if (node.slow) {\n                    node.slow = false;\n                    this._onDidChangeNodeSlowState.fire(node);\n                }\n            }\n        });\n    }\n    doGetChildren(node) {\n        let result = this.refreshPromises.get(node);\n        if (result) {\n            return result;\n        }\n        result = createCancelablePromise(() => __awaiter(this, void 0, void 0, function* () {\n            const children = yield this.dataSource.getChildren(node.element);\n            return this.processChildren(children);\n        }));\n        this.refreshPromises.set(node, result);\n        return result.finally(() => { this.refreshPromises.delete(node); });\n    }\n    _onDidChangeCollapseState({ node, deep }) {\n        if (node.element === null) {\n            return;\n        }\n        if (!node.collapsed && node.element.stale) {\n            if (deep) {\n                this.collapse(node.element.element);\n            }\n            else {\n                this.refreshAndRenderNode(node.element, false)\n                    .catch(onUnexpectedError);\n            }\n        }\n    }\n    setChildren(node, childrenElementsIterable, recursive, viewStateContext) {\n        const childrenElements = [...childrenElementsIterable];\n        // perf: if the node was and still is a leaf, avoid all this hassle\n        if (node.children.length === 0 && childrenElements.length === 0) {\n            return [];\n        }\n        const nodesToForget = new Map();\n        const childrenTreeNodesById = new Map();\n        for (const child of node.children) {\n            nodesToForget.set(child.element, child);\n            if (this.identityProvider) {\n                const collapsed = this.tree.isCollapsed(child);\n                childrenTreeNodesById.set(child.id, { node: child, collapsed });\n            }\n        }\n        const childrenToRefresh = [];\n        const children = childrenElements.map(element => {\n            const hasChildren = !!this.dataSource.hasChildren(element);\n            if (!this.identityProvider) {\n                const asyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, hasChildren });\n                if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n                    asyncDataTreeNode.collapsedByDefault = false;\n                    childrenToRefresh.push(asyncDataTreeNode);\n                }\n                return asyncDataTreeNode;\n            }\n            const id = this.identityProvider.getId(element).toString();\n            const result = childrenTreeNodesById.get(id);\n            if (result) {\n                const asyncDataTreeNode = result.node;\n                nodesToForget.delete(asyncDataTreeNode.element);\n                this.nodes.delete(asyncDataTreeNode.element);\n                this.nodes.set(element, asyncDataTreeNode);\n                asyncDataTreeNode.element = element;\n                asyncDataTreeNode.hasChildren = hasChildren;\n                if (recursive) {\n                    if (result.collapsed) {\n                        asyncDataTreeNode.children.forEach(node => dfs(node, node => this.nodes.delete(node.element)));\n                        asyncDataTreeNode.children.splice(0, asyncDataTreeNode.children.length);\n                        asyncDataTreeNode.stale = true;\n                    }\n                    else {\n                        childrenToRefresh.push(asyncDataTreeNode);\n                    }\n                }\n                else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n                    asyncDataTreeNode.collapsedByDefault = false;\n                    childrenToRefresh.push(asyncDataTreeNode);\n                }\n                return asyncDataTreeNode;\n            }\n            const childAsyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, id, hasChildren });\n            if (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {\n                viewStateContext.focus.push(childAsyncDataTreeNode);\n            }\n            if (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {\n                viewStateContext.selection.push(childAsyncDataTreeNode);\n            }\n            if (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {\n                childrenToRefresh.push(childAsyncDataTreeNode);\n            }\n            else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n                childAsyncDataTreeNode.collapsedByDefault = false;\n                childrenToRefresh.push(childAsyncDataTreeNode);\n            }\n            return childAsyncDataTreeNode;\n        });\n        for (const node of nodesToForget.values()) {\n            dfs(node, node => this.nodes.delete(node.element));\n        }\n        for (const child of children) {\n            this.nodes.set(child.element, child);\n        }\n        node.children.splice(0, node.children.length, ...children);\n        // TODO@joao this doesn't take filter into account\n        if (node !== this.root && this.autoExpandSingleChildren && children.length === 1 && childrenToRefresh.length === 0) {\n            children[0].collapsedByDefault = false;\n            childrenToRefresh.push(children[0]);\n        }\n        return childrenToRefresh;\n    }\n    render(node, viewStateContext, options) {\n        const children = node.children.map(node => this.asTreeElement(node, viewStateContext));\n        const objectTreeOptions = options && Object.assign(Object.assign({}, options), { diffIdentityProvider: options.diffIdentityProvider && {\n                getId(node) {\n                    return options.diffIdentityProvider.getId(node.element);\n                }\n            } });\n        this.tree.setChildren(node === this.root ? null : node, children, objectTreeOptions);\n        if (node !== this.root) {\n            this.tree.setCollapsible(node, node.hasChildren);\n        }\n        this._onDidRender.fire();\n    }\n    asTreeElement(node, viewStateContext) {\n        if (node.stale) {\n            return {\n                element: node,\n                collapsible: node.hasChildren,\n                collapsed: true\n            };\n        }\n        let collapsed;\n        if (viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1) {\n            collapsed = false;\n        }\n        else {\n            collapsed = node.collapsedByDefault;\n        }\n        node.collapsedByDefault = undefined;\n        return {\n            element: node,\n            children: node.hasChildren ? Iterable.map(node.children, child => this.asTreeElement(child, viewStateContext)) : [],\n            collapsible: node.hasChildren,\n            collapsed\n        };\n    }\n    processChildren(children) {\n        if (this.sorter) {\n            children = [...children].sort(this.sorter.compare.bind(this.sorter));\n        }\n        return children;\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n}\nclass CompressibleAsyncDataTreeNodeWrapper {\n    constructor(node) {\n        this.node = node;\n    }\n    get element() {\n        return {\n            elements: this.node.element.elements.map(e => e.element),\n            incompressible: this.node.element.incompressible\n        };\n    }\n    get children() { return this.node.children.map(node => new CompressibleAsyncDataTreeNodeWrapper(node)); }\n    get depth() { return this.node.depth; }\n    get visibleChildrenCount() { return this.node.visibleChildrenCount; }\n    get visibleChildIndex() { return this.node.visibleChildIndex; }\n    get collapsible() { return this.node.collapsible; }\n    get collapsed() { return this.node.collapsed; }\n    get visible() { return this.node.visible; }\n    get filterData() { return this.node.filterData; }\n}\nclass CompressibleAsyncDataTreeRenderer {\n    constructor(renderer, nodeMapper, compressibleNodeMapperProvider, onDidChangeTwistieState) {\n        this.renderer = renderer;\n        this.nodeMapper = nodeMapper;\n        this.compressibleNodeMapperProvider = compressibleNodeMapperProvider;\n        this.onDidChangeTwistieState = onDidChangeTwistieState;\n        this.renderedNodes = new Map();\n        this.disposables = [];\n        this.templateId = renderer.templateId;\n    }\n    renderTemplate(container) {\n        const templateData = this.renderer.renderTemplate(container);\n        return { templateData };\n    }\n    renderElement(node, index, templateData, height) {\n        this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n    }\n    renderCompressedElements(node, index, templateData, height) {\n        this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\n    }\n    renderTwistie(element, twistieElement) {\n        if (element.slow) {\n            twistieElement.classList.add(...treeItemLoadingIcon.classNamesArray);\n            return true;\n        }\n        else {\n            twistieElement.classList.remove(...treeItemLoadingIcon.classNamesArray);\n            return false;\n        }\n    }\n    disposeElement(node, index, templateData, height) {\n        if (this.renderer.disposeElement) {\n            this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n        }\n    }\n    disposeCompressedElements(node, index, templateData, height) {\n        if (this.renderer.disposeCompressedElements) {\n            this.renderer.disposeCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\n        }\n    }\n    disposeTemplate(templateData) {\n        this.renderer.disposeTemplate(templateData.templateData);\n    }\n    dispose() {\n        this.renderedNodes.clear();\n        this.disposables = dispose(this.disposables);\n    }\n}\nfunction asCompressibleObjectTreeOptions(options) {\n    const objectTreeOptions = options && asObjectTreeOptions(options);\n    return objectTreeOptions && Object.assign(Object.assign({}, objectTreeOptions), { keyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, objectTreeOptions.keyboardNavigationLabelProvider), { getCompressedNodeKeyboardNavigationLabel(els) {\n                return options.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(els.map(e => e.element));\n            } }) });\n}\nexport class CompressibleAsyncDataTree extends AsyncDataTree {\n    constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, options = {}) {\n        super(user, container, virtualDelegate, renderers, dataSource, options);\n        this.compressionDelegate = compressionDelegate;\n        this.compressibleNodeMapper = new WeakMapper(node => new CompressibleAsyncDataTreeNodeWrapper(node));\n        this.filter = options.filter;\n    }\n    createTree(user, container, delegate, renderers, options) {\n        const objectTreeDelegate = new ComposedTreeDelegate(delegate);\n        const objectTreeRenderers = renderers.map(r => new CompressibleAsyncDataTreeRenderer(r, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event));\n        const objectTreeOptions = asCompressibleObjectTreeOptions(options) || {};\n        return new CompressibleObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n    }\n    asTreeElement(node, viewStateContext) {\n        return Object.assign({ incompressible: this.compressionDelegate.isIncompressible(node.element) }, super.asTreeElement(node, viewStateContext));\n    }\n    updateOptions(options = {}) {\n        this.tree.updateOptions(options);\n    }\n    render(node, viewStateContext) {\n        if (!this.identityProvider) {\n            return super.render(node, viewStateContext);\n        }\n        // Preserve traits across compressions. Hacky but does the trick.\n        // This is hard to fix properly since it requires rewriting the traits\n        // across trees and lists. Let's just keep it this way for now.\n        const getId = (element) => this.identityProvider.getId(element).toString();\n        const getUncompressedIds = (nodes) => {\n            const result = new Set();\n            for (const node of nodes) {\n                const compressedNode = this.tree.getCompressedTreeNode(node === this.root ? null : node);\n                if (!compressedNode.element) {\n                    continue;\n                }\n                for (const node of compressedNode.element.elements) {\n                    result.add(getId(node.element));\n                }\n            }\n            return result;\n        };\n        const oldSelection = getUncompressedIds(this.tree.getSelection());\n        const oldFocus = getUncompressedIds(this.tree.getFocus());\n        super.render(node, viewStateContext);\n        const selection = this.getSelection();\n        let didChangeSelection = false;\n        const focus = this.getFocus();\n        let didChangeFocus = false;\n        const visit = (node) => {\n            const compressedNode = node.element;\n            if (compressedNode) {\n                for (let i = 0; i < compressedNode.elements.length; i++) {\n                    const id = getId(compressedNode.elements[i].element);\n                    const element = compressedNode.elements[compressedNode.elements.length - 1].element;\n                    // github.com/microsoft/vscode/issues/85938\n                    if (oldSelection.has(id) && selection.indexOf(element) === -1) {\n                        selection.push(element);\n                        didChangeSelection = true;\n                    }\n                    if (oldFocus.has(id) && focus.indexOf(element) === -1) {\n                        focus.push(element);\n                        didChangeFocus = true;\n                    }\n                }\n            }\n            node.children.forEach(visit);\n        };\n        visit(this.tree.getCompressedTreeNode(node === this.root ? null : node));\n        if (didChangeSelection) {\n            this.setSelection(selection);\n        }\n        if (didChangeFocus) {\n            this.setFocus(focus);\n        }\n    }\n    // For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work\n    // and we have to filter everything beforehand\n    // Related to #85193 and #85835\n    processChildren(children) {\n        if (this.filter) {\n            children = Iterable.filter(children, e => {\n                const result = this.filter.filter(e, 1 /* Visible */);\n                const visibility = getVisibility(result);\n                if (visibility === 2 /* Recurse */) {\n                    throw new Error('Recursive tree visibility not supported in async data compressed trees');\n                }\n                return visibility === 1 /* Visible */;\n            });\n        }\n        return super.processChildren(children);\n    }\n}\nfunction getVisibility(filterResult) {\n    if (typeof filterResult === 'boolean') {\n        return filterResult ? 1 /* Visible */ : 0 /* Hidden */;\n    }\n    else if (isFilterResult(filterResult)) {\n        return getVisibleState(filterResult.visibility);\n    }\n    else {\n        return getVisibleState(filterResult);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}