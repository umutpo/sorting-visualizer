{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n  constructor(map) {\n    this.map = map;\n    this.hasRegExp = false;\n    this._regExpGlobal = null;\n  }\n\n  static createFromLanguage(configuration, denseKeyProvider) {\n    function getId(languageId, openingText) {\n      return denseKeyProvider.getKey(`${languageId}:::${openingText}`);\n    }\n\n    const brackets = configuration.characterPair.getColorizedBrackets();\n    const closingBrackets = new Map();\n    const openingBrackets = new Set();\n\n    for (const [openingText, closingText] of brackets) {\n      openingBrackets.add(openingText);\n      let info = closingBrackets.get(closingText);\n      const openingTextId = getId(configuration.languageId, openingText);\n\n      if (!info) {\n        info = {\n          openingBrackets: SmallImmutableSet.getEmpty(),\n          first: openingTextId\n        };\n        closingBrackets.set(closingText, info);\n      }\n\n      info.openingBrackets = info.openingBrackets.add(openingTextId, identityKeyProvider);\n    }\n\n    const map = new Map();\n\n    for (const [closingText, info] of closingBrackets) {\n      const length = toLength(0, closingText.length);\n      map.set(closingText, new Token(length, 2\n      /* ClosingBracket */\n      , info.first, info.openingBrackets, BracketAstNode.create(length)));\n    }\n\n    for (const openingText of openingBrackets) {\n      const length = toLength(0, openingText.length);\n      const openingTextId = getId(configuration.languageId, openingText);\n      map.set(openingText, new Token(length, 1\n      /* OpeningBracket */\n      , openingTextId, SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider), BracketAstNode.create(length)));\n    }\n\n    return new BracketTokens(map);\n  }\n\n  getRegExpStr() {\n    if (this.isEmpty) {\n      return null;\n    } else {\n      const keys = [...this.map.keys()];\n      keys.sort();\n      keys.reverse();\n      return keys.map(k => prepareBracketForRegExp(k)).join('|');\n    }\n  }\n  /**\n   * Returns null if there is no such regexp (because there are no brackets).\n  */\n\n\n  get regExpGlobal() {\n    if (!this.hasRegExp) {\n      const regExpStr = this.getRegExpStr();\n      this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'g') : null;\n      this.hasRegExp = true;\n    }\n\n    return this._regExpGlobal;\n  }\n\n  getToken(value) {\n    return this.map.get(value);\n  }\n\n  get isEmpty() {\n    return this.map.size === 0;\n  }\n\n}\n\nfunction prepareBracketForRegExp(str) {\n  const escaped = escapeRegExpCharacters(str); // This bracket pair uses letters like e.g. \"begin\" - \"end\" (see https://github.com/microsoft/vscode/issues/132162)\n\n  const needsWordBoundaries = /^[\\w ]+$/.test(str);\n  return needsWordBoundaries ? `\\\\b${escaped}\\\\b` : escaped;\n}\n\nexport class LanguageAgnosticBracketTokens {\n  constructor(denseKeyProvider, getLanguageConfiguration) {\n    this.denseKeyProvider = denseKeyProvider;\n    this.getLanguageConfiguration = getLanguageConfiguration;\n    this.languageIdToBracketTokens = new Map();\n  }\n\n  didLanguageChange(languageId) {\n    const existing = this.languageIdToBracketTokens.get(languageId);\n\n    if (!existing) {\n      return false;\n    }\n\n    const newRegExpStr = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider).getRegExpStr();\n    return existing.getRegExpStr() !== newRegExpStr;\n  }\n\n  getSingleLanguageBracketTokens(languageId) {\n    let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n\n    if (!singleLanguageBracketTokens) {\n      singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n      this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n    }\n\n    return singleLanguageBracketTokens;\n  }\n\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairs/impl/brackets.js"],"names":["escapeRegExpCharacters","BracketAstNode","toLength","identityKeyProvider","SmallImmutableSet","Token","BracketTokens","constructor","map","hasRegExp","_regExpGlobal","createFromLanguage","configuration","denseKeyProvider","getId","languageId","openingText","getKey","brackets","characterPair","getColorizedBrackets","closingBrackets","Map","openingBrackets","Set","closingText","add","info","get","openingTextId","getEmpty","first","set","length","create","getRegExpStr","isEmpty","keys","sort","reverse","k","prepareBracketForRegExp","join","regExpGlobal","regExpStr","RegExp","getToken","value","size","str","escaped","needsWordBoundaries","test","LanguageAgnosticBracketTokens","getLanguageConfiguration","languageIdToBracketTokens","didLanguageChange","existing","newRegExpStr","getSingleLanguageBracketTokens","singleLanguageBracketTokens"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n    constructor(map) {\n        this.map = map;\n        this.hasRegExp = false;\n        this._regExpGlobal = null;\n    }\n    static createFromLanguage(configuration, denseKeyProvider) {\n        function getId(languageId, openingText) {\n            return denseKeyProvider.getKey(`${languageId}:::${openingText}`);\n        }\n        const brackets = configuration.characterPair.getColorizedBrackets();\n        const closingBrackets = new Map();\n        const openingBrackets = new Set();\n        for (const [openingText, closingText] of brackets) {\n            openingBrackets.add(openingText);\n            let info = closingBrackets.get(closingText);\n            const openingTextId = getId(configuration.languageId, openingText);\n            if (!info) {\n                info = { openingBrackets: SmallImmutableSet.getEmpty(), first: openingTextId };\n                closingBrackets.set(closingText, info);\n            }\n            info.openingBrackets = info.openingBrackets.add(openingTextId, identityKeyProvider);\n        }\n        const map = new Map();\n        for (const [closingText, info] of closingBrackets) {\n            const length = toLength(0, closingText.length);\n            map.set(closingText, new Token(length, 2 /* ClosingBracket */, info.first, info.openingBrackets, BracketAstNode.create(length)));\n        }\n        for (const openingText of openingBrackets) {\n            const length = toLength(0, openingText.length);\n            const openingTextId = getId(configuration.languageId, openingText);\n            map.set(openingText, new Token(length, 1 /* OpeningBracket */, openingTextId, SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider), BracketAstNode.create(length)));\n        }\n        return new BracketTokens(map);\n    }\n    getRegExpStr() {\n        if (this.isEmpty) {\n            return null;\n        }\n        else {\n            const keys = [...this.map.keys()];\n            keys.sort();\n            keys.reverse();\n            return keys.map(k => prepareBracketForRegExp(k)).join('|');\n        }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n    get regExpGlobal() {\n        if (!this.hasRegExp) {\n            const regExpStr = this.getRegExpStr();\n            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'g') : null;\n            this.hasRegExp = true;\n        }\n        return this._regExpGlobal;\n    }\n    getToken(value) {\n        return this.map.get(value);\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\nfunction prepareBracketForRegExp(str) {\n    const escaped = escapeRegExpCharacters(str);\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\" (see https://github.com/microsoft/vscode/issues/132162)\n    const needsWordBoundaries = (/^[\\w ]+$/.test(str));\n    return (needsWordBoundaries ? `\\\\b${escaped}\\\\b` : escaped);\n}\nexport class LanguageAgnosticBracketTokens {\n    constructor(denseKeyProvider, getLanguageConfiguration) {\n        this.denseKeyProvider = denseKeyProvider;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.languageIdToBracketTokens = new Map();\n    }\n    didLanguageChange(languageId) {\n        const existing = this.languageIdToBracketTokens.get(languageId);\n        if (!existing) {\n            return false;\n        }\n        const newRegExpStr = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider).getRegExpStr();\n        return existing.getRegExpStr() !== newRegExpStr;\n    }\n    getSingleLanguageBracketTokens(languageId) {\n        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n        if (!singleLanguageBracketTokens) {\n            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n        }\n        return singleLanguageBracketTokens;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}