{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorState, SingleCursorState } from './cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\n/**\n * Represents a single cursor.\n*/\n\nexport class Cursor {\n  constructor(context) {\n    this._selTrackedRange = null;\n    this._trackSelection = true;\n\n    this._setState(context, new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(1, 1), 0), new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(1, 1), 0));\n  }\n\n  dispose(context) {\n    this._removeTrackedRange(context);\n  }\n\n  startTrackingSelection(context) {\n    this._trackSelection = true;\n\n    this._updateTrackedRange(context);\n  }\n\n  stopTrackingSelection(context) {\n    this._trackSelection = false;\n\n    this._removeTrackedRange(context);\n  }\n\n  _updateTrackedRange(context) {\n    if (!this._trackSelection) {\n      // don't track the selection\n      return;\n    }\n\n    this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, 0\n    /* AlwaysGrowsWhenTypingAtEdges */\n    );\n  }\n\n  _removeTrackedRange(context) {\n    this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, 0\n    /* AlwaysGrowsWhenTypingAtEdges */\n    );\n  }\n\n  asCursorState() {\n    return new CursorState(this.modelState, this.viewState);\n  }\n\n  readSelectionFromMarkers(context) {\n    const range = context.model._getTrackedRange(this._selTrackedRange);\n\n    if (this.modelState.selection.getDirection() === 0\n    /* LTR */\n    ) {\n      return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n\n    return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n  }\n\n  ensureValidState(context) {\n    this._setState(context, this.modelState, this.viewState);\n  }\n\n  setState(context, modelState, viewState) {\n    this._setState(context, modelState, viewState);\n  }\n\n  static _validatePositionWithCache(viewModel, position, cacheInput, cacheOutput) {\n    if (position.equals(cacheInput)) {\n      return cacheOutput;\n    }\n\n    return viewModel.normalizePosition(position, 2\n    /* None */\n    );\n  }\n\n  static _validateViewState(viewModel, viewState) {\n    const position = viewState.position;\n    const sStartPosition = viewState.selectionStart.getStartPosition();\n    const sEndPosition = viewState.selectionStart.getEndPosition();\n    const validPosition = viewModel.normalizePosition(position, 2\n    /* None */\n    );\n\n    const validSStartPosition = this._validatePositionWithCache(viewModel, sStartPosition, position, validPosition);\n\n    const validSEndPosition = this._validatePositionWithCache(viewModel, sEndPosition, sStartPosition, validSStartPosition);\n\n    if (position.equals(validPosition) && sStartPosition.equals(validSStartPosition) && sEndPosition.equals(validSEndPosition)) {\n      // fast path: the state is valid\n      return viewState;\n    }\n\n    return new SingleCursorState(Range.fromPositions(validSStartPosition, validSEndPosition), viewState.selectionStartLeftoverVisibleColumns + sStartPosition.column - validSStartPosition.column, validPosition, viewState.leftoverVisibleColumns + position.column - validPosition.column);\n  }\n\n  _setState(context, modelState, viewState) {\n    if (viewState) {\n      viewState = Cursor._validateViewState(context.viewModel, viewState);\n    }\n\n    if (!modelState) {\n      if (!viewState) {\n        return;\n      } // We only have the view state => compute the model state\n\n\n      const selectionStart = context.model.validateRange(context.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart));\n      const position = context.model.validatePosition(context.coordinatesConverter.convertViewPositionToModelPosition(viewState.position));\n      modelState = new SingleCursorState(selectionStart, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n    } else {\n      // Validate new model state\n      const selectionStart = context.model.validateRange(modelState.selectionStart);\n      const selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n      const position = context.model.validatePosition(modelState.position);\n      const leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n      modelState = new SingleCursorState(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n    }\n\n    if (!viewState) {\n      // We only have the model state => compute the view state\n      const viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n      const viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n      const viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n      const viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);\n      viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n    } else {\n      // Validate new view state\n      const viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n      const viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);\n      viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n    }\n\n    this.modelState = modelState;\n    this.viewState = viewState;\n\n    this._updateTrackedRange(context);\n  }\n\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/common/controller/oneCursor.js"],"names":["CursorState","SingleCursorState","Position","Range","Selection","Cursor","constructor","context","_selTrackedRange","_trackSelection","_setState","dispose","_removeTrackedRange","startTrackingSelection","_updateTrackedRange","stopTrackingSelection","model","_setTrackedRange","modelState","selection","asCursorState","viewState","readSelectionFromMarkers","range","_getTrackedRange","getDirection","startLineNumber","startColumn","endLineNumber","endColumn","ensureValidState","setState","_validatePositionWithCache","viewModel","position","cacheInput","cacheOutput","equals","normalizePosition","_validateViewState","sStartPosition","selectionStart","getStartPosition","sEndPosition","getEndPosition","validPosition","validSStartPosition","validSEndPosition","fromPositions","selectionStartLeftoverVisibleColumns","column","leftoverVisibleColumns","validateRange","coordinatesConverter","convertViewRangeToModelRange","validatePosition","convertViewPositionToModelPosition","equalsRange","viewSelectionStart1","convertModelPositionToViewPosition","viewSelectionStart2","viewSelectionStart","lineNumber","viewPosition","validateViewRange","validateViewPosition"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,WAAT,EAAsBC,iBAAtB,QAA+C,mBAA/C;AACA,SAASC,QAAT,QAAyB,qBAAzB;AACA,SAASC,KAAT,QAAsB,kBAAtB;AACA,SAASC,SAAT,QAA0B,sBAA1B;AACA;AACA;AACA;;AACA,OAAO,MAAMC,MAAN,CAAa;AAChBC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACjB,SAAKC,gBAAL,GAAwB,IAAxB;AACA,SAAKC,eAAL,GAAuB,IAAvB;;AACA,SAAKC,SAAL,CAAeH,OAAf,EAAwB,IAAIN,iBAAJ,CAAsB,IAAIE,KAAJ,CAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,CAAtB,EAA6C,CAA7C,EAAgD,IAAID,QAAJ,CAAa,CAAb,EAAgB,CAAhB,CAAhD,EAAoE,CAApE,CAAxB,EAAgG,IAAID,iBAAJ,CAAsB,IAAIE,KAAJ,CAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,CAAtB,EAA6C,CAA7C,EAAgD,IAAID,QAAJ,CAAa,CAAb,EAAgB,CAAhB,CAAhD,EAAoE,CAApE,CAAhG;AACH;;AACDS,EAAAA,OAAO,CAACJ,OAAD,EAAU;AACb,SAAKK,mBAAL,CAAyBL,OAAzB;AACH;;AACDM,EAAAA,sBAAsB,CAACN,OAAD,EAAU;AAC5B,SAAKE,eAAL,GAAuB,IAAvB;;AACA,SAAKK,mBAAL,CAAyBP,OAAzB;AACH;;AACDQ,EAAAA,qBAAqB,CAACR,OAAD,EAAU;AAC3B,SAAKE,eAAL,GAAuB,KAAvB;;AACA,SAAKG,mBAAL,CAAyBL,OAAzB;AACH;;AACDO,EAAAA,mBAAmB,CAACP,OAAD,EAAU;AACzB,QAAI,CAAC,KAAKE,eAAV,EAA2B;AACvB;AACA;AACH;;AACD,SAAKD,gBAAL,GAAwBD,OAAO,CAACS,KAAR,CAAcC,gBAAd,CAA+B,KAAKT,gBAApC,EAAsD,KAAKU,UAAL,CAAgBC,SAAtE,EAAiF;AAAE;AAAnF,KAAxB;AACH;;AACDP,EAAAA,mBAAmB,CAACL,OAAD,EAAU;AACzB,SAAKC,gBAAL,GAAwBD,OAAO,CAACS,KAAR,CAAcC,gBAAd,CAA+B,KAAKT,gBAApC,EAAsD,IAAtD,EAA4D;AAAE;AAA9D,KAAxB;AACH;;AACDY,EAAAA,aAAa,GAAG;AACZ,WAAO,IAAIpB,WAAJ,CAAgB,KAAKkB,UAArB,EAAiC,KAAKG,SAAtC,CAAP;AACH;;AACDC,EAAAA,wBAAwB,CAACf,OAAD,EAAU;AAC9B,UAAMgB,KAAK,GAAGhB,OAAO,CAACS,KAAR,CAAcQ,gBAAd,CAA+B,KAAKhB,gBAApC,CAAd;;AACA,QAAI,KAAKU,UAAL,CAAgBC,SAAhB,CAA0BM,YAA1B,OAA6C;AAAE;AAAnD,MAA8D;AAC1D,aAAO,IAAIrB,SAAJ,CAAcmB,KAAK,CAACG,eAApB,EAAqCH,KAAK,CAACI,WAA3C,EAAwDJ,KAAK,CAACK,aAA9D,EAA6EL,KAAK,CAACM,SAAnF,CAAP;AACH;;AACD,WAAO,IAAIzB,SAAJ,CAAcmB,KAAK,CAACK,aAApB,EAAmCL,KAAK,CAACM,SAAzC,EAAoDN,KAAK,CAACG,eAA1D,EAA2EH,KAAK,CAACI,WAAjF,CAAP;AACH;;AACDG,EAAAA,gBAAgB,CAACvB,OAAD,EAAU;AACtB,SAAKG,SAAL,CAAeH,OAAf,EAAwB,KAAKW,UAA7B,EAAyC,KAAKG,SAA9C;AACH;;AACDU,EAAAA,QAAQ,CAACxB,OAAD,EAAUW,UAAV,EAAsBG,SAAtB,EAAiC;AACrC,SAAKX,SAAL,CAAeH,OAAf,EAAwBW,UAAxB,EAAoCG,SAApC;AACH;;AACgC,SAA1BW,0BAA0B,CAACC,SAAD,EAAYC,QAAZ,EAAsBC,UAAtB,EAAkCC,WAAlC,EAA+C;AAC5E,QAAIF,QAAQ,CAACG,MAAT,CAAgBF,UAAhB,CAAJ,EAAiC;AAC7B,aAAOC,WAAP;AACH;;AACD,WAAOH,SAAS,CAACK,iBAAV,CAA4BJ,QAA5B,EAAsC;AAAE;AAAxC,KAAP;AACH;;AACwB,SAAlBK,kBAAkB,CAACN,SAAD,EAAYZ,SAAZ,EAAuB;AAC5C,UAAMa,QAAQ,GAAGb,SAAS,CAACa,QAA3B;AACA,UAAMM,cAAc,GAAGnB,SAAS,CAACoB,cAAV,CAAyBC,gBAAzB,EAAvB;AACA,UAAMC,YAAY,GAAGtB,SAAS,CAACoB,cAAV,CAAyBG,cAAzB,EAArB;AACA,UAAMC,aAAa,GAAGZ,SAAS,CAACK,iBAAV,CAA4BJ,QAA5B,EAAsC;AAAE;AAAxC,KAAtB;;AACA,UAAMY,mBAAmB,GAAG,KAAKd,0BAAL,CAAgCC,SAAhC,EAA2CO,cAA3C,EAA2DN,QAA3D,EAAqEW,aAArE,CAA5B;;AACA,UAAME,iBAAiB,GAAG,KAAKf,0BAAL,CAAgCC,SAAhC,EAA2CU,YAA3C,EAAyDH,cAAzD,EAAyEM,mBAAzE,CAA1B;;AACA,QAAIZ,QAAQ,CAACG,MAAT,CAAgBQ,aAAhB,KAAkCL,cAAc,CAACH,MAAf,CAAsBS,mBAAtB,CAAlC,IAAgFH,YAAY,CAACN,MAAb,CAAoBU,iBAApB,CAApF,EAA4H;AACxH;AACA,aAAO1B,SAAP;AACH;;AACD,WAAO,IAAIpB,iBAAJ,CAAsBE,KAAK,CAAC6C,aAAN,CAAoBF,mBAApB,EAAyCC,iBAAzC,CAAtB,EAAmF1B,SAAS,CAAC4B,oCAAV,GAAiDT,cAAc,CAACU,MAAhE,GAAyEJ,mBAAmB,CAACI,MAAhL,EAAwLL,aAAxL,EAAuMxB,SAAS,CAAC8B,sBAAV,GAAmCjB,QAAQ,CAACgB,MAA5C,GAAqDL,aAAa,CAACK,MAA1Q,CAAP;AACH;;AACDxC,EAAAA,SAAS,CAACH,OAAD,EAAUW,UAAV,EAAsBG,SAAtB,EAAiC;AACtC,QAAIA,SAAJ,EAAe;AACXA,MAAAA,SAAS,GAAGhB,MAAM,CAACkC,kBAAP,CAA0BhC,OAAO,CAAC0B,SAAlC,EAA6CZ,SAA7C,CAAZ;AACH;;AACD,QAAI,CAACH,UAAL,EAAiB;AACb,UAAI,CAACG,SAAL,EAAgB;AACZ;AACH,OAHY,CAIb;;;AACA,YAAMoB,cAAc,GAAGlC,OAAO,CAACS,KAAR,CAAcoC,aAAd,CAA4B7C,OAAO,CAAC8C,oBAAR,CAA6BC,4BAA7B,CAA0DjC,SAAS,CAACoB,cAApE,CAA5B,CAAvB;AACA,YAAMP,QAAQ,GAAG3B,OAAO,CAACS,KAAR,CAAcuC,gBAAd,CAA+BhD,OAAO,CAAC8C,oBAAR,CAA6BG,kCAA7B,CAAgEnC,SAAS,CAACa,QAA1E,CAA/B,CAAjB;AACAhB,MAAAA,UAAU,GAAG,IAAIjB,iBAAJ,CAAsBwC,cAAtB,EAAsCpB,SAAS,CAAC4B,oCAAhD,EAAsFf,QAAtF,EAAgGb,SAAS,CAAC8B,sBAA1G,CAAb;AACH,KARD,MASK;AACD;AACA,YAAMV,cAAc,GAAGlC,OAAO,CAACS,KAAR,CAAcoC,aAAd,CAA4BlC,UAAU,CAACuB,cAAvC,CAAvB;AACA,YAAMQ,oCAAoC,GAAG/B,UAAU,CAACuB,cAAX,CAA0BgB,WAA1B,CAAsChB,cAAtC,IAAwDvB,UAAU,CAAC+B,oCAAnE,GAA0G,CAAvJ;AACA,YAAMf,QAAQ,GAAG3B,OAAO,CAACS,KAAR,CAAcuC,gBAAd,CAA+BrC,UAAU,CAACgB,QAA1C,CAAjB;AACA,YAAMiB,sBAAsB,GAAGjC,UAAU,CAACgB,QAAX,CAAoBG,MAApB,CAA2BH,QAA3B,IAAuChB,UAAU,CAACiC,sBAAlD,GAA2E,CAA1G;AACAjC,MAAAA,UAAU,GAAG,IAAIjB,iBAAJ,CAAsBwC,cAAtB,EAAsCQ,oCAAtC,EAA4Ef,QAA5E,EAAsFiB,sBAAtF,CAAb;AACH;;AACD,QAAI,CAAC9B,SAAL,EAAgB;AACZ;AACA,YAAMqC,mBAAmB,GAAGnD,OAAO,CAAC8C,oBAAR,CAA6BM,kCAA7B,CAAgE,IAAIzD,QAAJ,CAAagB,UAAU,CAACuB,cAAX,CAA0Bf,eAAvC,EAAwDR,UAAU,CAACuB,cAAX,CAA0Bd,WAAlF,CAAhE,CAA5B;AACA,YAAMiC,mBAAmB,GAAGrD,OAAO,CAAC8C,oBAAR,CAA6BM,kCAA7B,CAAgE,IAAIzD,QAAJ,CAAagB,UAAU,CAACuB,cAAX,CAA0Bb,aAAvC,EAAsDV,UAAU,CAACuB,cAAX,CAA0BZ,SAAhF,CAAhE,CAA5B;AACA,YAAMgC,kBAAkB,GAAG,IAAI1D,KAAJ,CAAUuD,mBAAmB,CAACI,UAA9B,EAA0CJ,mBAAmB,CAACR,MAA9D,EAAsEU,mBAAmB,CAACE,UAA1F,EAAsGF,mBAAmB,CAACV,MAA1H,CAA3B;AACA,YAAMa,YAAY,GAAGxD,OAAO,CAAC8C,oBAAR,CAA6BM,kCAA7B,CAAgEzC,UAAU,CAACgB,QAA3E,CAArB;AACAb,MAAAA,SAAS,GAAG,IAAIpB,iBAAJ,CAAsB4D,kBAAtB,EAA0C3C,UAAU,CAAC+B,oCAArD,EAA2Fc,YAA3F,EAAyG7C,UAAU,CAACiC,sBAApH,CAAZ;AACH,KAPD,MAQK;AACD;AACA,YAAMU,kBAAkB,GAAGtD,OAAO,CAAC8C,oBAAR,CAA6BW,iBAA7B,CAA+C3C,SAAS,CAACoB,cAAzD,EAAyEvB,UAAU,CAACuB,cAApF,CAA3B;AACA,YAAMsB,YAAY,GAAGxD,OAAO,CAAC8C,oBAAR,CAA6BY,oBAA7B,CAAkD5C,SAAS,CAACa,QAA5D,EAAsEhB,UAAU,CAACgB,QAAjF,CAArB;AACAb,MAAAA,SAAS,GAAG,IAAIpB,iBAAJ,CAAsB4D,kBAAtB,EAA0C3C,UAAU,CAAC+B,oCAArD,EAA2Fc,YAA3F,EAAyG7C,UAAU,CAACiC,sBAApH,CAAZ;AACH;;AACD,SAAKjC,UAAL,GAAkBA,UAAlB;AACA,SAAKG,SAAL,GAAiBA,SAAjB;;AACA,SAAKP,mBAAL,CAAyBP,OAAzB;AACH;;AApGe","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorState, SingleCursorState } from './cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\n/**\n * Represents a single cursor.\n*/\nexport class Cursor {\n    constructor(context) {\n        this._selTrackedRange = null;\n        this._trackSelection = true;\n        this._setState(context, new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(1, 1), 0), new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(1, 1), 0));\n    }\n    dispose(context) {\n        this._removeTrackedRange(context);\n    }\n    startTrackingSelection(context) {\n        this._trackSelection = true;\n        this._updateTrackedRange(context);\n    }\n    stopTrackingSelection(context) {\n        this._trackSelection = false;\n        this._removeTrackedRange(context);\n    }\n    _updateTrackedRange(context) {\n        if (!this._trackSelection) {\n            // don't track the selection\n            return;\n        }\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, 0 /* AlwaysGrowsWhenTypingAtEdges */);\n    }\n    _removeTrackedRange(context) {\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, 0 /* AlwaysGrowsWhenTypingAtEdges */);\n    }\n    asCursorState() {\n        return new CursorState(this.modelState, this.viewState);\n    }\n    readSelectionFromMarkers(context) {\n        const range = context.model._getTrackedRange(this._selTrackedRange);\n        if (this.modelState.selection.getDirection() === 0 /* LTR */) {\n            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n        }\n        return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n    }\n    ensureValidState(context) {\n        this._setState(context, this.modelState, this.viewState);\n    }\n    setState(context, modelState, viewState) {\n        this._setState(context, modelState, viewState);\n    }\n    static _validatePositionWithCache(viewModel, position, cacheInput, cacheOutput) {\n        if (position.equals(cacheInput)) {\n            return cacheOutput;\n        }\n        return viewModel.normalizePosition(position, 2 /* None */);\n    }\n    static _validateViewState(viewModel, viewState) {\n        const position = viewState.position;\n        const sStartPosition = viewState.selectionStart.getStartPosition();\n        const sEndPosition = viewState.selectionStart.getEndPosition();\n        const validPosition = viewModel.normalizePosition(position, 2 /* None */);\n        const validSStartPosition = this._validatePositionWithCache(viewModel, sStartPosition, position, validPosition);\n        const validSEndPosition = this._validatePositionWithCache(viewModel, sEndPosition, sStartPosition, validSStartPosition);\n        if (position.equals(validPosition) && sStartPosition.equals(validSStartPosition) && sEndPosition.equals(validSEndPosition)) {\n            // fast path: the state is valid\n            return viewState;\n        }\n        return new SingleCursorState(Range.fromPositions(validSStartPosition, validSEndPosition), viewState.selectionStartLeftoverVisibleColumns + sStartPosition.column - validSStartPosition.column, validPosition, viewState.leftoverVisibleColumns + position.column - validPosition.column);\n    }\n    _setState(context, modelState, viewState) {\n        if (viewState) {\n            viewState = Cursor._validateViewState(context.viewModel, viewState);\n        }\n        if (!modelState) {\n            if (!viewState) {\n                return;\n            }\n            // We only have the view state => compute the model state\n            const selectionStart = context.model.validateRange(context.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart));\n            const position = context.model.validatePosition(context.coordinatesConverter.convertViewPositionToModelPosition(viewState.position));\n            modelState = new SingleCursorState(selectionStart, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new model state\n            const selectionStart = context.model.validateRange(modelState.selectionStart);\n            const selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n            const position = context.model.validatePosition(modelState.position);\n            const leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n            modelState = new SingleCursorState(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n        }\n        if (!viewState) {\n            // We only have the model state => compute the view state\n            const viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n            const viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n            const viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n            const viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new view state\n            const viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n            const viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        this.modelState = modelState;\n        this.viewState = viewState;\n        this._updateTrackedRange(context);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}