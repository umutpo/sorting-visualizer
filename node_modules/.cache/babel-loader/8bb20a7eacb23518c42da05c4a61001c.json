{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a;\n\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Configuration } from '../config/configuration.js';\nimport { LineBreakData } from '../../common/viewModel/viewModel.js';\nimport { LineInjectedText } from '../../common/model/textModelEvents.js';\nconst ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy('domLineBreaksComputer', {\n  createHTML: value => value\n});\nexport class DOMLineBreaksComputerFactory {\n  static create() {\n    return new DOMLineBreaksComputerFactory();\n  }\n\n  constructor() {}\n\n  createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent) {\n    tabSize = tabSize | 0; //@perf\n\n    wrappingColumn = +wrappingColumn; //@perf\n\n    let requests = [];\n    let injectedTexts = [];\n    return {\n      addRequest: (lineText, injectedText, previousLineBreakData) => {\n        requests.push(lineText);\n        injectedTexts.push(injectedText);\n      },\n      finalize: () => {\n        return createLineBreaks(requests, fontInfo, tabSize, wrappingColumn, wrappingIndent, injectedTexts);\n      }\n    };\n  }\n\n}\n\nfunction createLineBreaks(requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent, injectedTextsPerLine) {\n  var _a;\n\n  function createEmptyLineBreakWithPossiblyInjectedText(requestIdx) {\n    const injectedTexts = injectedTextsPerLine[requestIdx];\n\n    if (injectedTexts) {\n      const lineText = LineInjectedText.applyInjectedText(requests[requestIdx], injectedTexts);\n      const injectionOptions = injectedTexts.map(t => t.options);\n      const injectionOffsets = injectedTexts.map(text => text.column - 1); // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n      // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n\n      return new LineBreakData([lineText.length], [], 0, injectionOffsets, injectionOptions);\n    } else {\n      return null;\n    }\n  }\n\n  if (firstLineBreakColumn === -1) {\n    const result = [];\n\n    for (let i = 0, len = requests.length; i < len; i++) {\n      result[i] = createEmptyLineBreakWithPossiblyInjectedText(i);\n    }\n\n    return result;\n  }\n\n  const overallWidth = Math.round(firstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth);\n  const additionalIndent = wrappingIndent === 3\n  /* DeepIndent */\n  ? 2 : wrappingIndent === 2\n  /* Indent */\n  ? 1 : 0;\n  const additionalIndentSize = Math.round(tabSize * additionalIndent);\n  const additionalIndentLength = Math.ceil(fontInfo.spaceWidth * additionalIndentSize);\n  const containerDomNode = document.createElement('div');\n  Configuration.applyFontInfoSlow(containerDomNode, fontInfo);\n  const sb = createStringBuilder(10000);\n  const firstNonWhitespaceIndices = [];\n  const wrappedTextIndentLengths = [];\n  const renderLineContents = [];\n  const allCharOffsets = [];\n  const allVisibleColumns = [];\n\n  for (let i = 0; i < requests.length; i++) {\n    const lineContent = LineInjectedText.applyInjectedText(requests[i], injectedTextsPerLine[i]);\n    let firstNonWhitespaceIndex = 0;\n    let wrappedTextIndentLength = 0;\n    let width = overallWidth;\n\n    if (wrappingIndent !== 0\n    /* None */\n    ) {\n      firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n\n      if (firstNonWhitespaceIndex === -1) {\n        // all whitespace line\n        firstNonWhitespaceIndex = 0;\n      } else {\n        // Track existing indent\n        for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n          const charWidth = lineContent.charCodeAt(i) === 9\n          /* Tab */\n          ? tabSize - wrappedTextIndentLength % tabSize : 1;\n          wrappedTextIndentLength += charWidth;\n        }\n\n        const indentWidth = Math.ceil(fontInfo.spaceWidth * wrappedTextIndentLength); // Force sticking to beginning of line if no character would fit except for the indentation\n\n        if (indentWidth + fontInfo.typicalFullwidthCharacterWidth > overallWidth) {\n          firstNonWhitespaceIndex = 0;\n          wrappedTextIndentLength = 0;\n        } else {\n          width = overallWidth - indentWidth;\n        }\n      }\n    }\n\n    const renderLineContent = lineContent.substr(firstNonWhitespaceIndex);\n    const tmp = renderLine(renderLineContent, wrappedTextIndentLength, tabSize, width, sb, additionalIndentLength);\n    firstNonWhitespaceIndices[i] = firstNonWhitespaceIndex;\n    wrappedTextIndentLengths[i] = wrappedTextIndentLength;\n    renderLineContents[i] = renderLineContent;\n    allCharOffsets[i] = tmp[0];\n    allVisibleColumns[i] = tmp[1];\n  }\n\n  const html = sb.build();\n  const trustedhtml = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(html)) !== null && _a !== void 0 ? _a : html;\n  containerDomNode.innerHTML = trustedhtml;\n  containerDomNode.style.position = 'absolute';\n  containerDomNode.style.top = '10000';\n  containerDomNode.style.wordWrap = 'break-word';\n  document.body.appendChild(containerDomNode);\n  let range = document.createRange();\n  const lineDomNodes = Array.prototype.slice.call(containerDomNode.children, 0);\n  let result = [];\n\n  for (let i = 0; i < requests.length; i++) {\n    const lineDomNode = lineDomNodes[i];\n    const breakOffsets = readLineBreaks(range, lineDomNode, renderLineContents[i], allCharOffsets[i]);\n\n    if (breakOffsets === null) {\n      result[i] = createEmptyLineBreakWithPossiblyInjectedText(i);\n      continue;\n    }\n\n    const firstNonWhitespaceIndex = firstNonWhitespaceIndices[i];\n    const wrappedTextIndentLength = wrappedTextIndentLengths[i] + additionalIndentSize;\n    const visibleColumns = allVisibleColumns[i];\n    const breakOffsetsVisibleColumn = [];\n\n    for (let j = 0, len = breakOffsets.length; j < len; j++) {\n      breakOffsetsVisibleColumn[j] = visibleColumns[breakOffsets[j]];\n    }\n\n    if (firstNonWhitespaceIndex !== 0) {\n      // All break offsets are relative to the renderLineContent, make them absolute again\n      for (let j = 0, len = breakOffsets.length; j < len; j++) {\n        breakOffsets[j] += firstNonWhitespaceIndex;\n      }\n    }\n\n    let injectionOptions;\n    let injectionOffsets;\n    const curInjectedTexts = injectedTextsPerLine[i];\n\n    if (curInjectedTexts) {\n      injectionOptions = curInjectedTexts.map(t => t.options);\n      injectionOffsets = curInjectedTexts.map(text => text.column - 1);\n    } else {\n      injectionOptions = null;\n      injectionOffsets = null;\n    }\n\n    result[i] = new LineBreakData(breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength, injectionOffsets, injectionOptions);\n  }\n\n  document.body.removeChild(containerDomNode);\n  return result;\n}\n\nfunction renderLine(lineContent, initialVisibleColumn, tabSize, width, sb, wrappingIndentLength) {\n  if (wrappingIndentLength !== 0) {\n    let hangingOffset = String(wrappingIndentLength);\n    sb.appendASCIIString('<div style=\"text-indent: -');\n    sb.appendASCIIString(hangingOffset);\n    sb.appendASCIIString('px; padding-left: ');\n    sb.appendASCIIString(hangingOffset);\n    sb.appendASCIIString('px; box-sizing: border-box; width:');\n  } else {\n    sb.appendASCIIString('<div style=\"width:');\n  }\n\n  sb.appendASCIIString(String(width));\n  sb.appendASCIIString('px;\">'); // if (containsRTL) {\n  // \tsb.appendASCIIString('\" dir=\"ltr');\n  // }\n\n  const len = lineContent.length;\n  let visibleColumn = initialVisibleColumn;\n  let charOffset = 0;\n  let charOffsets = [];\n  let visibleColumns = [];\n  let nextCharCode = 0 < len ? lineContent.charCodeAt(0) : 0\n  /* Null */\n  ;\n  sb.appendASCIIString('<span>');\n\n  for (let charIndex = 0; charIndex < len; charIndex++) {\n    if (charIndex !== 0 && charIndex % 16384\n    /* SPAN_MODULO_LIMIT */\n    === 0) {\n      sb.appendASCIIString('</span><span>');\n    }\n\n    charOffsets[charIndex] = charOffset;\n    visibleColumns[charIndex] = visibleColumn;\n    const charCode = nextCharCode;\n    nextCharCode = charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0\n    /* Null */\n    ;\n    let producedCharacters = 1;\n    let charWidth = 1;\n\n    switch (charCode) {\n      case 9\n      /* Tab */\n      :\n        producedCharacters = tabSize - visibleColumn % tabSize;\n        charWidth = producedCharacters;\n\n        for (let space = 1; space <= producedCharacters; space++) {\n          if (space < producedCharacters) {\n            sb.write1(0xA0); // &nbsp;\n          } else {\n            sb.appendASCII(32\n            /* Space */\n            );\n          }\n        }\n\n        break;\n\n      case 32\n      /* Space */\n      :\n        if (nextCharCode === 32\n        /* Space */\n        ) {\n          sb.write1(0xA0); // &nbsp;\n        } else {\n          sb.appendASCII(32\n          /* Space */\n          );\n        }\n\n        break;\n\n      case 60\n      /* LessThan */\n      :\n        sb.appendASCIIString('&lt;');\n        break;\n\n      case 62\n      /* GreaterThan */\n      :\n        sb.appendASCIIString('&gt;');\n        break;\n\n      case 38\n      /* Ampersand */\n      :\n        sb.appendASCIIString('&amp;');\n        break;\n\n      case 0\n      /* Null */\n      :\n        sb.appendASCIIString('&#00;');\n        break;\n\n      case 65279\n      /* UTF8_BOM */\n      :\n      case 8232\n      /* LINE_SEPARATOR */\n      :\n      case 8233\n      /* PARAGRAPH_SEPARATOR */\n      :\n      case 133\n      /* NEXT_LINE */\n      :\n        sb.write1(0xFFFD);\n        break;\n\n      default:\n        if (strings.isFullWidthCharacter(charCode)) {\n          charWidth++;\n        }\n\n        if (charCode < 32) {\n          sb.write1(9216 + charCode);\n        } else {\n          sb.write1(charCode);\n        }\n\n    }\n\n    charOffset += producedCharacters;\n    visibleColumn += charWidth;\n  }\n\n  sb.appendASCIIString('</span>');\n  charOffsets[lineContent.length] = charOffset;\n  visibleColumns[lineContent.length] = visibleColumn;\n  sb.appendASCIIString('</div>');\n  return [charOffsets, visibleColumns];\n}\n\nfunction readLineBreaks(range, lineDomNode, lineContent, charOffsets) {\n  if (lineContent.length <= 1) {\n    return null;\n  }\n\n  const spans = Array.prototype.slice.call(lineDomNode.children, 0);\n  const breakOffsets = [];\n\n  try {\n    discoverBreaks(range, spans, charOffsets, 0, null, lineContent.length - 1, null, breakOffsets);\n  } catch (err) {\n    console.log(err);\n    return null;\n  }\n\n  if (breakOffsets.length === 0) {\n    return null;\n  }\n\n  breakOffsets.push(lineContent.length);\n  return breakOffsets;\n}\n\nfunction discoverBreaks(range, spans, charOffsets, low, lowRects, high, highRects, result) {\n  if (low === high) {\n    return;\n  }\n\n  lowRects = lowRects || readClientRect(range, spans, charOffsets[low], charOffsets[low + 1]);\n  highRects = highRects || readClientRect(range, spans, charOffsets[high], charOffsets[high + 1]);\n\n  if (Math.abs(lowRects[0].top - highRects[0].top) <= 0.1) {\n    // same line\n    return;\n  } // there is at least one line break between these two offsets\n\n\n  if (low + 1 === high) {\n    // the two characters are adjacent, so the line break must be exactly between them\n    result.push(high);\n    return;\n  }\n\n  const mid = low + (high - low) / 2 | 0;\n  const midRects = readClientRect(range, spans, charOffsets[mid], charOffsets[mid + 1]);\n  discoverBreaks(range, spans, charOffsets, low, lowRects, mid, midRects, result);\n  discoverBreaks(range, spans, charOffsets, mid, midRects, high, highRects, result);\n}\n\nfunction readClientRect(range, spans, startOffset, endOffset) {\n  range.setStart(spans[startOffset / 16384\n  /* SPAN_MODULO_LIMIT */\n  | 0].firstChild, startOffset % 16384\n  /* SPAN_MODULO_LIMIT */\n  );\n  range.setEnd(spans[endOffset / 16384\n  /* SPAN_MODULO_LIMIT */\n  | 0].firstChild, endOffset % 16384\n  /* SPAN_MODULO_LIMIT */\n  );\n  return range.getClientRects();\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/browser/view/domLineBreaksComputer.js"],"names":["_a","createStringBuilder","strings","Configuration","LineBreakData","LineInjectedText","ttPolicy","window","trustedTypes","createPolicy","createHTML","value","DOMLineBreaksComputerFactory","create","constructor","createLineBreaksComputer","fontInfo","tabSize","wrappingColumn","wrappingIndent","requests","injectedTexts","addRequest","lineText","injectedText","previousLineBreakData","push","finalize","createLineBreaks","firstLineBreakColumn","injectedTextsPerLine","createEmptyLineBreakWithPossiblyInjectedText","requestIdx","applyInjectedText","injectionOptions","map","t","options","injectionOffsets","text","column","length","result","i","len","overallWidth","Math","round","typicalHalfwidthCharacterWidth","additionalIndent","additionalIndentSize","additionalIndentLength","ceil","spaceWidth","containerDomNode","document","createElement","applyFontInfoSlow","sb","firstNonWhitespaceIndices","wrappedTextIndentLengths","renderLineContents","allCharOffsets","allVisibleColumns","lineContent","firstNonWhitespaceIndex","wrappedTextIndentLength","width","charWidth","charCodeAt","indentWidth","typicalFullwidthCharacterWidth","renderLineContent","substr","tmp","renderLine","html","build","trustedhtml","innerHTML","style","position","top","wordWrap","body","appendChild","range","createRange","lineDomNodes","Array","prototype","slice","call","children","lineDomNode","breakOffsets","readLineBreaks","visibleColumns","breakOffsetsVisibleColumn","j","curInjectedTexts","removeChild","initialVisibleColumn","wrappingIndentLength","hangingOffset","String","appendASCIIString","visibleColumn","charOffset","charOffsets","nextCharCode","charIndex","charCode","producedCharacters","space","write1","appendASCII","isFullWidthCharacter","spans","discoverBreaks","err","console","log","low","lowRects","high","highRects","readClientRect","abs","mid","midRects","startOffset","endOffset","setStart","firstChild","setEnd","getClientRects"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a;\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Configuration } from '../config/configuration.js';\nimport { LineBreakData } from '../../common/viewModel/viewModel.js';\nimport { LineInjectedText } from '../../common/model/textModelEvents.js';\nconst ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy('domLineBreaksComputer', { createHTML: value => value });\nexport class DOMLineBreaksComputerFactory {\n    static create() {\n        return new DOMLineBreaksComputerFactory();\n    }\n    constructor() {\n    }\n    createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent) {\n        tabSize = tabSize | 0; //@perf\n        wrappingColumn = +wrappingColumn; //@perf\n        let requests = [];\n        let injectedTexts = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                requests.push(lineText);\n                injectedTexts.push(injectedText);\n            },\n            finalize: () => {\n                return createLineBreaks(requests, fontInfo, tabSize, wrappingColumn, wrappingIndent, injectedTexts);\n            }\n        };\n    }\n}\nfunction createLineBreaks(requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent, injectedTextsPerLine) {\n    var _a;\n    function createEmptyLineBreakWithPossiblyInjectedText(requestIdx) {\n        const injectedTexts = injectedTextsPerLine[requestIdx];\n        if (injectedTexts) {\n            const lineText = LineInjectedText.applyInjectedText(requests[requestIdx], injectedTexts);\n            const injectionOptions = injectedTexts.map(t => t.options);\n            const injectionOffsets = injectedTexts.map(text => text.column - 1);\n            // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n            // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n            return new LineBreakData([lineText.length], [], 0, injectionOffsets, injectionOptions);\n        }\n        else {\n            return null;\n        }\n    }\n    if (firstLineBreakColumn === -1) {\n        const result = [];\n        for (let i = 0, len = requests.length; i < len; i++) {\n            result[i] = createEmptyLineBreakWithPossiblyInjectedText(i);\n        }\n        return result;\n    }\n    const overallWidth = Math.round(firstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth);\n    const additionalIndent = (wrappingIndent === 3 /* DeepIndent */ ? 2 : wrappingIndent === 2 /* Indent */ ? 1 : 0);\n    const additionalIndentSize = Math.round(tabSize * additionalIndent);\n    const additionalIndentLength = Math.ceil(fontInfo.spaceWidth * additionalIndentSize);\n    const containerDomNode = document.createElement('div');\n    Configuration.applyFontInfoSlow(containerDomNode, fontInfo);\n    const sb = createStringBuilder(10000);\n    const firstNonWhitespaceIndices = [];\n    const wrappedTextIndentLengths = [];\n    const renderLineContents = [];\n    const allCharOffsets = [];\n    const allVisibleColumns = [];\n    for (let i = 0; i < requests.length; i++) {\n        const lineContent = LineInjectedText.applyInjectedText(requests[i], injectedTextsPerLine[i]);\n        let firstNonWhitespaceIndex = 0;\n        let wrappedTextIndentLength = 0;\n        let width = overallWidth;\n        if (wrappingIndent !== 0 /* None */) {\n            firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n            if (firstNonWhitespaceIndex === -1) {\n                // all whitespace line\n                firstNonWhitespaceIndex = 0;\n            }\n            else {\n                // Track existing indent\n                for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n                    const charWidth = (lineContent.charCodeAt(i) === 9 /* Tab */\n                        ? (tabSize - (wrappedTextIndentLength % tabSize))\n                        : 1);\n                    wrappedTextIndentLength += charWidth;\n                }\n                const indentWidth = Math.ceil(fontInfo.spaceWidth * wrappedTextIndentLength);\n                // Force sticking to beginning of line if no character would fit except for the indentation\n                if (indentWidth + fontInfo.typicalFullwidthCharacterWidth > overallWidth) {\n                    firstNonWhitespaceIndex = 0;\n                    wrappedTextIndentLength = 0;\n                }\n                else {\n                    width = overallWidth - indentWidth;\n                }\n            }\n        }\n        const renderLineContent = lineContent.substr(firstNonWhitespaceIndex);\n        const tmp = renderLine(renderLineContent, wrappedTextIndentLength, tabSize, width, sb, additionalIndentLength);\n        firstNonWhitespaceIndices[i] = firstNonWhitespaceIndex;\n        wrappedTextIndentLengths[i] = wrappedTextIndentLength;\n        renderLineContents[i] = renderLineContent;\n        allCharOffsets[i] = tmp[0];\n        allVisibleColumns[i] = tmp[1];\n    }\n    const html = sb.build();\n    const trustedhtml = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(html)) !== null && _a !== void 0 ? _a : html;\n    containerDomNode.innerHTML = trustedhtml;\n    containerDomNode.style.position = 'absolute';\n    containerDomNode.style.top = '10000';\n    containerDomNode.style.wordWrap = 'break-word';\n    document.body.appendChild(containerDomNode);\n    let range = document.createRange();\n    const lineDomNodes = Array.prototype.slice.call(containerDomNode.children, 0);\n    let result = [];\n    for (let i = 0; i < requests.length; i++) {\n        const lineDomNode = lineDomNodes[i];\n        const breakOffsets = readLineBreaks(range, lineDomNode, renderLineContents[i], allCharOffsets[i]);\n        if (breakOffsets === null) {\n            result[i] = createEmptyLineBreakWithPossiblyInjectedText(i);\n            continue;\n        }\n        const firstNonWhitespaceIndex = firstNonWhitespaceIndices[i];\n        const wrappedTextIndentLength = wrappedTextIndentLengths[i] + additionalIndentSize;\n        const visibleColumns = allVisibleColumns[i];\n        const breakOffsetsVisibleColumn = [];\n        for (let j = 0, len = breakOffsets.length; j < len; j++) {\n            breakOffsetsVisibleColumn[j] = visibleColumns[breakOffsets[j]];\n        }\n        if (firstNonWhitespaceIndex !== 0) {\n            // All break offsets are relative to the renderLineContent, make them absolute again\n            for (let j = 0, len = breakOffsets.length; j < len; j++) {\n                breakOffsets[j] += firstNonWhitespaceIndex;\n            }\n        }\n        let injectionOptions;\n        let injectionOffsets;\n        const curInjectedTexts = injectedTextsPerLine[i];\n        if (curInjectedTexts) {\n            injectionOptions = curInjectedTexts.map(t => t.options);\n            injectionOffsets = curInjectedTexts.map(text => text.column - 1);\n        }\n        else {\n            injectionOptions = null;\n            injectionOffsets = null;\n        }\n        result[i] = new LineBreakData(breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength, injectionOffsets, injectionOptions);\n    }\n    document.body.removeChild(containerDomNode);\n    return result;\n}\nfunction renderLine(lineContent, initialVisibleColumn, tabSize, width, sb, wrappingIndentLength) {\n    if (wrappingIndentLength !== 0) {\n        let hangingOffset = String(wrappingIndentLength);\n        sb.appendASCIIString('<div style=\"text-indent: -');\n        sb.appendASCIIString(hangingOffset);\n        sb.appendASCIIString('px; padding-left: ');\n        sb.appendASCIIString(hangingOffset);\n        sb.appendASCIIString('px; box-sizing: border-box; width:');\n    }\n    else {\n        sb.appendASCIIString('<div style=\"width:');\n    }\n    sb.appendASCIIString(String(width));\n    sb.appendASCIIString('px;\">');\n    // if (containsRTL) {\n    // \tsb.appendASCIIString('\" dir=\"ltr');\n    // }\n    const len = lineContent.length;\n    let visibleColumn = initialVisibleColumn;\n    let charOffset = 0;\n    let charOffsets = [];\n    let visibleColumns = [];\n    let nextCharCode = (0 < len ? lineContent.charCodeAt(0) : 0 /* Null */);\n    sb.appendASCIIString('<span>');\n    for (let charIndex = 0; charIndex < len; charIndex++) {\n        if (charIndex !== 0 && charIndex % 16384 /* SPAN_MODULO_LIMIT */ === 0) {\n            sb.appendASCIIString('</span><span>');\n        }\n        charOffsets[charIndex] = charOffset;\n        visibleColumns[charIndex] = visibleColumn;\n        const charCode = nextCharCode;\n        nextCharCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */);\n        let producedCharacters = 1;\n        let charWidth = 1;\n        switch (charCode) {\n            case 9 /* Tab */:\n                producedCharacters = (tabSize - (visibleColumn % tabSize));\n                charWidth = producedCharacters;\n                for (let space = 1; space <= producedCharacters; space++) {\n                    if (space < producedCharacters) {\n                        sb.write1(0xA0); // &nbsp;\n                    }\n                    else {\n                        sb.appendASCII(32 /* Space */);\n                    }\n                }\n                break;\n            case 32 /* Space */:\n                if (nextCharCode === 32 /* Space */) {\n                    sb.write1(0xA0); // &nbsp;\n                }\n                else {\n                    sb.appendASCII(32 /* Space */);\n                }\n                break;\n            case 60 /* LessThan */:\n                sb.appendASCIIString('&lt;');\n                break;\n            case 62 /* GreaterThan */:\n                sb.appendASCIIString('&gt;');\n                break;\n            case 38 /* Ampersand */:\n                sb.appendASCIIString('&amp;');\n                break;\n            case 0 /* Null */:\n                sb.appendASCIIString('&#00;');\n                break;\n            case 65279 /* UTF8_BOM */:\n            case 8232 /* LINE_SEPARATOR */:\n            case 8233 /* PARAGRAPH_SEPARATOR */:\n            case 133 /* NEXT_LINE */:\n                sb.write1(0xFFFD);\n                break;\n            default:\n                if (strings.isFullWidthCharacter(charCode)) {\n                    charWidth++;\n                }\n                if (charCode < 32) {\n                    sb.write1(9216 + charCode);\n                }\n                else {\n                    sb.write1(charCode);\n                }\n        }\n        charOffset += producedCharacters;\n        visibleColumn += charWidth;\n    }\n    sb.appendASCIIString('</span>');\n    charOffsets[lineContent.length] = charOffset;\n    visibleColumns[lineContent.length] = visibleColumn;\n    sb.appendASCIIString('</div>');\n    return [charOffsets, visibleColumns];\n}\nfunction readLineBreaks(range, lineDomNode, lineContent, charOffsets) {\n    if (lineContent.length <= 1) {\n        return null;\n    }\n    const spans = Array.prototype.slice.call(lineDomNode.children, 0);\n    const breakOffsets = [];\n    try {\n        discoverBreaks(range, spans, charOffsets, 0, null, lineContent.length - 1, null, breakOffsets);\n    }\n    catch (err) {\n        console.log(err);\n        return null;\n    }\n    if (breakOffsets.length === 0) {\n        return null;\n    }\n    breakOffsets.push(lineContent.length);\n    return breakOffsets;\n}\nfunction discoverBreaks(range, spans, charOffsets, low, lowRects, high, highRects, result) {\n    if (low === high) {\n        return;\n    }\n    lowRects = lowRects || readClientRect(range, spans, charOffsets[low], charOffsets[low + 1]);\n    highRects = highRects || readClientRect(range, spans, charOffsets[high], charOffsets[high + 1]);\n    if (Math.abs(lowRects[0].top - highRects[0].top) <= 0.1) {\n        // same line\n        return;\n    }\n    // there is at least one line break between these two offsets\n    if (low + 1 === high) {\n        // the two characters are adjacent, so the line break must be exactly between them\n        result.push(high);\n        return;\n    }\n    const mid = low + ((high - low) / 2) | 0;\n    const midRects = readClientRect(range, spans, charOffsets[mid], charOffsets[mid + 1]);\n    discoverBreaks(range, spans, charOffsets, low, lowRects, mid, midRects, result);\n    discoverBreaks(range, spans, charOffsets, mid, midRects, high, highRects, result);\n}\nfunction readClientRect(range, spans, startOffset, endOffset) {\n    range.setStart(spans[(startOffset / 16384 /* SPAN_MODULO_LIMIT */) | 0].firstChild, startOffset % 16384 /* SPAN_MODULO_LIMIT */);\n    range.setEnd(spans[(endOffset / 16384 /* SPAN_MODULO_LIMIT */) | 0].firstChild, endOffset % 16384 /* SPAN_MODULO_LIMIT */);\n    return range.getClientRects();\n}\n"]},"metadata":{},"sourceType":"module"}