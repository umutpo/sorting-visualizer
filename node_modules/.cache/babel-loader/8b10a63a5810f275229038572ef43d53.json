{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../../base/browser/browser.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport { RangeUtil } from './rangeUtil.js';\nimport { FloatHorizontalRange, VisibleRanges } from '../../../common/view/renderingContext.js';\nimport { LineDecoration } from '../../../common/viewLayout/lineDecorations.js';\nimport { RenderLineInput, renderViewLine, LineRange, DomPosition } from '../../../common/viewLayout/viewLineRenderer.js';\nimport { ColorScheme } from '../../../../platform/theme/common/theme.js';\nimport { EditorFontLigatures } from '../../../common/config/editorOptions.js';\n\nconst canUseFastRenderedViewLine = function () {\n  if (platform.isNative) {\n    // In VSCode we know very well when the zoom level changes\n    return true;\n  }\n\n  if (platform.isLinux || browser.isFirefox || browser.isSafari) {\n    // On Linux, it appears that zooming affects char widths (in pixels), which is unexpected.\n    // --\n    // Even though we read character widths correctly, having read them at a specific zoom level\n    // does not mean they are the same at the current zoom level.\n    // --\n    // This could be improved if we ever figure out how to get an event when browsers zoom,\n    // but until then we have to stick with reading client rects.\n    // --\n    // The same has been observed with Firefox on Windows7\n    // --\n    // The same has been oversved with Safari\n    return false;\n  }\n\n  return true;\n}();\n\nlet monospaceAssumptionsAreValid = true;\nexport class DomReadingContext {\n  constructor(domNode, endNode) {\n    this._domNode = domNode;\n    this._clientRectDeltaLeft = 0;\n    this._clientRectDeltaLeftRead = false;\n    this.endNode = endNode;\n  }\n\n  get clientRectDeltaLeft() {\n    if (!this._clientRectDeltaLeftRead) {\n      this._clientRectDeltaLeftRead = true;\n      this._clientRectDeltaLeft = this._domNode.getBoundingClientRect().left;\n    }\n\n    return this._clientRectDeltaLeft;\n  }\n\n}\nexport class ViewLineOptions {\n  constructor(config, themeType) {\n    this.themeType = themeType;\n    const options = config.options;\n    const fontInfo = options.get(43\n    /* fontInfo */\n    );\n    this.renderWhitespace = options.get(87\n    /* renderWhitespace */\n    );\n    this.renderControlCharacters = options.get(82\n    /* renderControlCharacters */\n    );\n    this.spaceWidth = fontInfo.spaceWidth;\n    this.middotWidth = fontInfo.middotWidth;\n    this.wsmiddotWidth = fontInfo.wsmiddotWidth;\n    this.useMonospaceOptimizations = fontInfo.isMonospace && !options.get(29\n    /* disableMonospaceOptimizations */\n    );\n    this.canUseHalfwidthRightwardsArrow = fontInfo.canUseHalfwidthRightwardsArrow;\n    this.lineHeight = options.get(58\n    /* lineHeight */\n    );\n    this.stopRenderingLineAfter = options.get(104\n    /* stopRenderingLineAfter */\n    );\n    this.fontLigatures = options.get(44\n    /* fontLigatures */\n    );\n  }\n\n  equals(other) {\n    return this.themeType === other.themeType && this.renderWhitespace === other.renderWhitespace && this.renderControlCharacters === other.renderControlCharacters && this.spaceWidth === other.spaceWidth && this.middotWidth === other.middotWidth && this.wsmiddotWidth === other.wsmiddotWidth && this.useMonospaceOptimizations === other.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow && this.lineHeight === other.lineHeight && this.stopRenderingLineAfter === other.stopRenderingLineAfter && this.fontLigatures === other.fontLigatures;\n  }\n\n}\nexport class ViewLine {\n  constructor(options) {\n    this._options = options;\n    this._isMaybeInvalid = true;\n    this._renderedViewLine = null;\n  } // --- begin IVisibleLineData\n\n\n  getDomNode() {\n    if (this._renderedViewLine && this._renderedViewLine.domNode) {\n      return this._renderedViewLine.domNode.domNode;\n    }\n\n    return null;\n  }\n\n  setDomNode(domNode) {\n    if (this._renderedViewLine) {\n      this._renderedViewLine.domNode = createFastDomNode(domNode);\n    } else {\n      throw new Error('I have no rendered view line to set the dom node to...');\n    }\n  }\n\n  onContentChanged() {\n    this._isMaybeInvalid = true;\n  }\n\n  onTokensChanged() {\n    this._isMaybeInvalid = true;\n  }\n\n  onDecorationsChanged() {\n    this._isMaybeInvalid = true;\n  }\n\n  onOptionsChanged(newOptions) {\n    this._isMaybeInvalid = true;\n    this._options = newOptions;\n  }\n\n  onSelectionChanged() {\n    if (this._options.themeType === ColorScheme.HIGH_CONTRAST || this._options.renderWhitespace === 'selection') {\n      this._isMaybeInvalid = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  renderLine(lineNumber, deltaTop, viewportData, sb) {\n    if (this._isMaybeInvalid === false) {\n      // it appears that nothing relevant has changed\n      return false;\n    }\n\n    this._isMaybeInvalid = false;\n    const lineData = viewportData.getViewLineRenderingData(lineNumber);\n    const options = this._options;\n    const actualInlineDecorations = LineDecoration.filter(lineData.inlineDecorations, lineNumber, lineData.minColumn, lineData.maxColumn); // Only send selection information when needed for rendering whitespace\n\n    let selectionsOnLine = null;\n\n    if (options.themeType === ColorScheme.HIGH_CONTRAST || this._options.renderWhitespace === 'selection') {\n      const selections = viewportData.selections;\n\n      for (const selection of selections) {\n        if (selection.endLineNumber < lineNumber || selection.startLineNumber > lineNumber) {\n          // Selection does not intersect line\n          continue;\n        }\n\n        const startColumn = selection.startLineNumber === lineNumber ? selection.startColumn : lineData.minColumn;\n        const endColumn = selection.endLineNumber === lineNumber ? selection.endColumn : lineData.maxColumn;\n\n        if (startColumn < endColumn) {\n          if (options.themeType === ColorScheme.HIGH_CONTRAST || this._options.renderWhitespace !== 'selection') {\n            actualInlineDecorations.push(new LineDecoration(startColumn, endColumn, 'inline-selected-text', 0\n            /* Regular */\n            ));\n          } else {\n            if (!selectionsOnLine) {\n              selectionsOnLine = [];\n            }\n\n            selectionsOnLine.push(new LineRange(startColumn - 1, endColumn - 1));\n          }\n        }\n      }\n    }\n\n    const renderLineInput = new RenderLineInput(options.useMonospaceOptimizations, options.canUseHalfwidthRightwardsArrow, lineData.content, lineData.continuesWithWrappedLine, lineData.isBasicASCII, lineData.containsRTL, lineData.minColumn - 1, lineData.tokens, actualInlineDecorations, lineData.tabSize, lineData.startVisibleColumn, options.spaceWidth, options.middotWidth, options.wsmiddotWidth, options.stopRenderingLineAfter, options.renderWhitespace, options.renderControlCharacters, options.fontLigatures !== EditorFontLigatures.OFF, selectionsOnLine);\n\n    if (this._renderedViewLine && this._renderedViewLine.input.equals(renderLineInput)) {\n      // no need to do anything, we have the same render input\n      return false;\n    }\n\n    sb.appendASCIIString('<div style=\"top:');\n    sb.appendASCIIString(String(deltaTop));\n    sb.appendASCIIString('px;height:');\n    sb.appendASCIIString(String(this._options.lineHeight));\n    sb.appendASCIIString('px;\" class=\"');\n    sb.appendASCIIString(ViewLine.CLASS_NAME);\n    sb.appendASCIIString('\">');\n    const output = renderViewLine(renderLineInput, sb);\n    sb.appendASCIIString('</div>');\n    let renderedViewLine = null;\n\n    if (monospaceAssumptionsAreValid && canUseFastRenderedViewLine && lineData.isBasicASCII && options.useMonospaceOptimizations && output.containsForeignElements === 0\n    /* None */\n    ) {\n      if (lineData.content.length < 300 && renderLineInput.lineTokens.getCount() < 100) {\n        // Browser rounding errors have been observed in Chrome and IE, so using the fast\n        // view line only for short lines. Please test before removing the length check...\n        // ---\n        // Another rounding error has been observed on Linux in VSCode, where <span> width\n        // rounding errors add up to an observable large number...\n        // ---\n        // Also see another example of rounding errors on Windows in\n        // https://github.com/microsoft/vscode/issues/33178\n        renderedViewLine = new FastRenderedViewLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping);\n      }\n    }\n\n    if (!renderedViewLine) {\n      renderedViewLine = createRenderedLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping, output.containsRTL, output.containsForeignElements);\n    }\n\n    this._renderedViewLine = renderedViewLine;\n    return true;\n  }\n\n  layoutLine(lineNumber, deltaTop) {\n    if (this._renderedViewLine && this._renderedViewLine.domNode) {\n      this._renderedViewLine.domNode.setTop(deltaTop);\n\n      this._renderedViewLine.domNode.setHeight(this._options.lineHeight);\n    }\n  } // --- end IVisibleLineData\n\n\n  getWidth() {\n    if (!this._renderedViewLine) {\n      return 0;\n    }\n\n    return this._renderedViewLine.getWidth();\n  }\n\n  getWidthIsFast() {\n    if (!this._renderedViewLine) {\n      return true;\n    }\n\n    return this._renderedViewLine.getWidthIsFast();\n  }\n\n  needsMonospaceFontCheck() {\n    if (!this._renderedViewLine) {\n      return false;\n    }\n\n    return this._renderedViewLine instanceof FastRenderedViewLine;\n  }\n\n  monospaceAssumptionsAreValid() {\n    if (!this._renderedViewLine) {\n      return monospaceAssumptionsAreValid;\n    }\n\n    if (this._renderedViewLine instanceof FastRenderedViewLine) {\n      return this._renderedViewLine.monospaceAssumptionsAreValid();\n    }\n\n    return monospaceAssumptionsAreValid;\n  }\n\n  onMonospaceAssumptionsInvalidated() {\n    if (this._renderedViewLine && this._renderedViewLine instanceof FastRenderedViewLine) {\n      this._renderedViewLine = this._renderedViewLine.toSlowRenderedLine();\n    }\n  }\n\n  getVisibleRangesForRange(lineNumber, startColumn, endColumn, context) {\n    if (!this._renderedViewLine) {\n      return null;\n    }\n\n    startColumn = startColumn | 0; // @perf\n\n    endColumn = endColumn | 0; // @perf\n\n    startColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, startColumn));\n    endColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, endColumn));\n    const stopRenderingLineAfter = this._renderedViewLine.input.stopRenderingLineAfter | 0; // @perf\n\n    let outsideRenderedLine = false;\n\n    if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1 && endColumn > stopRenderingLineAfter + 1) {\n      // This range is obviously not visible\n      outsideRenderedLine = true;\n    }\n\n    if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1) {\n      startColumn = stopRenderingLineAfter + 1;\n    }\n\n    if (stopRenderingLineAfter !== -1 && endColumn > stopRenderingLineAfter + 1) {\n      endColumn = stopRenderingLineAfter + 1;\n    }\n\n    const horizontalRanges = this._renderedViewLine.getVisibleRangesForRange(lineNumber, startColumn, endColumn, context);\n\n    if (horizontalRanges && horizontalRanges.length > 0) {\n      return new VisibleRanges(outsideRenderedLine, horizontalRanges);\n    }\n\n    return null;\n  }\n\n  getColumnOfNodeOffset(lineNumber, spanNode, offset) {\n    if (!this._renderedViewLine) {\n      return 1;\n    }\n\n    return this._renderedViewLine.getColumnOfNodeOffset(lineNumber, spanNode, offset);\n  }\n\n}\nViewLine.CLASS_NAME = 'view-line';\n/**\n * A rendered line which is guaranteed to contain only regular ASCII and is rendered with a monospace font.\n */\n\nclass FastRenderedViewLine {\n  constructor(domNode, renderLineInput, characterMapping) {\n    this.domNode = domNode;\n    this.input = renderLineInput;\n    this._characterMapping = characterMapping;\n    this._charWidth = renderLineInput.spaceWidth;\n  }\n\n  getWidth() {\n    return Math.round(this._getCharPosition(this._characterMapping.length));\n  }\n\n  getWidthIsFast() {\n    return true;\n  }\n\n  monospaceAssumptionsAreValid() {\n    if (!this.domNode) {\n      return monospaceAssumptionsAreValid;\n    }\n\n    const expectedWidth = this.getWidth();\n    const actualWidth = this.domNode.domNode.firstChild.offsetWidth;\n\n    if (Math.abs(expectedWidth - actualWidth) >= 2) {\n      // more than 2px off\n      console.warn(`monospace assumptions have been violated, therefore disabling monospace optimizations!`);\n      monospaceAssumptionsAreValid = false;\n    }\n\n    return monospaceAssumptionsAreValid;\n  }\n\n  toSlowRenderedLine() {\n    return createRenderedLine(this.domNode, this.input, this._characterMapping, false, 0\n    /* None */\n    );\n  }\n\n  getVisibleRangesForRange(lineNumber, startColumn, endColumn, context) {\n    const startPosition = this._getCharPosition(startColumn);\n\n    const endPosition = this._getCharPosition(endColumn);\n\n    return [new FloatHorizontalRange(startPosition, endPosition - startPosition)];\n  }\n\n  _getCharPosition(column) {\n    const charOffset = this._characterMapping.getAbsoluteOffset(column);\n\n    return this._charWidth * charOffset;\n  }\n\n  getColumnOfNodeOffset(lineNumber, spanNode, offset) {\n    const spanNodeTextContentLength = spanNode.textContent.length;\n    let spanIndex = -1;\n\n    while (spanNode) {\n      spanNode = spanNode.previousSibling;\n      spanIndex++;\n    }\n\n    return this._characterMapping.getColumn(new DomPosition(spanIndex, offset), spanNodeTextContentLength);\n  }\n\n}\n/**\n * Every time we render a line, we save what we have rendered in an instance of this class.\n */\n\n\nclass RenderedViewLine {\n  constructor(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n    this.domNode = domNode;\n    this.input = renderLineInput;\n    this._characterMapping = characterMapping;\n    this._isWhitespaceOnly = /^\\s*$/.test(renderLineInput.lineContent);\n    this._containsForeignElements = containsForeignElements;\n    this._cachedWidth = -1;\n    this._pixelOffsetCache = null;\n\n    if (!containsRTL || this._characterMapping.length === 0\n    /* the line is empty */\n    ) {\n      this._pixelOffsetCache = new Float32Array(Math.max(2, this._characterMapping.length + 1));\n\n      for (let column = 0, len = this._characterMapping.length; column <= len; column++) {\n        this._pixelOffsetCache[column] = -1;\n      }\n    }\n  } // --- Reading from the DOM methods\n\n\n  _getReadingTarget(myDomNode) {\n    return myDomNode.domNode.firstChild;\n  }\n  /**\n   * Width of the line in pixels\n   */\n\n\n  getWidth() {\n    if (!this.domNode) {\n      return 0;\n    }\n\n    if (this._cachedWidth === -1) {\n      this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth;\n    }\n\n    return this._cachedWidth;\n  }\n\n  getWidthIsFast() {\n    if (this._cachedWidth === -1) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Visible ranges for a model range\n   */\n\n\n  getVisibleRangesForRange(lineNumber, startColumn, endColumn, context) {\n    if (!this.domNode) {\n      return null;\n    }\n\n    if (this._pixelOffsetCache !== null) {\n      // the text is LTR\n      const startOffset = this._readPixelOffset(this.domNode, lineNumber, startColumn, context);\n\n      if (startOffset === -1) {\n        return null;\n      }\n\n      const endOffset = this._readPixelOffset(this.domNode, lineNumber, endColumn, context);\n\n      if (endOffset === -1) {\n        return null;\n      }\n\n      return [new FloatHorizontalRange(startOffset, endOffset - startOffset)];\n    }\n\n    return this._readVisibleRangesForRange(this.domNode, lineNumber, startColumn, endColumn, context);\n  }\n\n  _readVisibleRangesForRange(domNode, lineNumber, startColumn, endColumn, context) {\n    if (startColumn === endColumn) {\n      const pixelOffset = this._readPixelOffset(domNode, lineNumber, startColumn, context);\n\n      if (pixelOffset === -1) {\n        return null;\n      } else {\n        return [new FloatHorizontalRange(pixelOffset, 0)];\n      }\n    } else {\n      return this._readRawVisibleRangesForRange(domNode, startColumn, endColumn, context);\n    }\n  }\n\n  _readPixelOffset(domNode, lineNumber, column, context) {\n    if (this._characterMapping.length === 0) {\n      // This line has no content\n      if (this._containsForeignElements === 0\n      /* None */\n      ) {\n        // We can assume the line is really empty\n        return 0;\n      }\n\n      if (this._containsForeignElements === 2\n      /* After */\n      ) {\n        // We have foreign elements after the (empty) line\n        return 0;\n      }\n\n      if (this._containsForeignElements === 1\n      /* Before */\n      ) {\n        // We have foreign elements before the (empty) line\n        return this.getWidth();\n      } // We have foreign elements before & after the (empty) line\n\n\n      const readingTarget = this._getReadingTarget(domNode);\n\n      if (readingTarget.firstChild) {\n        return readingTarget.firstChild.offsetWidth;\n      } else {\n        return 0;\n      }\n    }\n\n    if (this._pixelOffsetCache !== null) {\n      // the text is LTR\n      const cachedPixelOffset = this._pixelOffsetCache[column];\n\n      if (cachedPixelOffset !== -1) {\n        return cachedPixelOffset;\n      }\n\n      const result = this._actualReadPixelOffset(domNode, lineNumber, column, context);\n\n      this._pixelOffsetCache[column] = result;\n      return result;\n    }\n\n    return this._actualReadPixelOffset(domNode, lineNumber, column, context);\n  }\n\n  _actualReadPixelOffset(domNode, lineNumber, column, context) {\n    if (this._characterMapping.length === 0) {\n      // This line has no content\n      const r = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), 0, 0, 0, 0, context.clientRectDeltaLeft, context.endNode);\n\n      if (!r || r.length === 0) {\n        return -1;\n      }\n\n      return r[0].left;\n    }\n\n    if (column === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0\n    /* None */\n    ) {\n      // This branch helps in the case of whitespace only lines which have a width set\n      return this.getWidth();\n    }\n\n    const domPosition = this._characterMapping.getDomPosition(column);\n\n    const r = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), domPosition.partIndex, domPosition.charIndex, domPosition.partIndex, domPosition.charIndex, context.clientRectDeltaLeft, context.endNode);\n\n    if (!r || r.length === 0) {\n      return -1;\n    }\n\n    const result = r[0].left;\n\n    if (this.input.isBasicASCII) {\n      const charOffset = this._characterMapping.getAbsoluteOffset(column);\n\n      const expectedResult = Math.round(this.input.spaceWidth * charOffset);\n\n      if (Math.abs(expectedResult - result) <= 1) {\n        return expectedResult;\n      }\n    }\n\n    return result;\n  }\n\n  _readRawVisibleRangesForRange(domNode, startColumn, endColumn, context) {\n    if (startColumn === 1 && endColumn === this._characterMapping.length) {\n      // This branch helps IE with bidi text & gives a performance boost to other browsers when reading visible ranges for an entire line\n      return [new FloatHorizontalRange(0, this.getWidth())];\n    }\n\n    const startDomPosition = this._characterMapping.getDomPosition(startColumn);\n\n    const endDomPosition = this._characterMapping.getDomPosition(endColumn);\n\n    return RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), startDomPosition.partIndex, startDomPosition.charIndex, endDomPosition.partIndex, endDomPosition.charIndex, context.clientRectDeltaLeft, context.endNode);\n  }\n  /**\n   * Returns the column for the text found at a specific offset inside a rendered dom node\n   */\n\n\n  getColumnOfNodeOffset(lineNumber, spanNode, offset) {\n    const spanNodeTextContentLength = spanNode.textContent.length;\n    let spanIndex = -1;\n\n    while (spanNode) {\n      spanNode = spanNode.previousSibling;\n      spanIndex++;\n    }\n\n    return this._characterMapping.getColumn(new DomPosition(spanIndex, offset), spanNodeTextContentLength);\n  }\n\n}\n\nclass WebKitRenderedViewLine extends RenderedViewLine {\n  _readVisibleRangesForRange(domNode, lineNumber, startColumn, endColumn, context) {\n    const output = super._readVisibleRangesForRange(domNode, lineNumber, startColumn, endColumn, context);\n\n    if (!output || output.length === 0 || startColumn === endColumn || startColumn === 1 && endColumn === this._characterMapping.length) {\n      return output;\n    } // WebKit is buggy and returns an expanded range (to contain words in some cases)\n    // The last client rect is enlarged (I think)\n\n\n    if (!this.input.containsRTL) {\n      // This is an attempt to patch things up\n      // Find position of last column\n      const endPixelOffset = this._readPixelOffset(domNode, lineNumber, endColumn, context);\n\n      if (endPixelOffset !== -1) {\n        const lastRange = output[output.length - 1];\n\n        if (lastRange.left < endPixelOffset) {\n          // Trim down the width of the last visible range to not go after the last column's position\n          lastRange.width = endPixelOffset - lastRange.left;\n        }\n      }\n    }\n\n    return output;\n  }\n\n}\n\nconst createRenderedLine = function () {\n  if (browser.isWebKit) {\n    return createWebKitRenderedLine;\n  }\n\n  return createNormalRenderedLine;\n}();\n\nfunction createWebKitRenderedLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n  return new WebKitRenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements);\n}\n\nfunction createNormalRenderedLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n  return new RenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements);\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lines/viewLine.js"],"names":["browser","createFastDomNode","platform","RangeUtil","FloatHorizontalRange","VisibleRanges","LineDecoration","RenderLineInput","renderViewLine","LineRange","DomPosition","ColorScheme","EditorFontLigatures","canUseFastRenderedViewLine","isNative","isLinux","isFirefox","isSafari","monospaceAssumptionsAreValid","DomReadingContext","constructor","domNode","endNode","_domNode","_clientRectDeltaLeft","_clientRectDeltaLeftRead","clientRectDeltaLeft","getBoundingClientRect","left","ViewLineOptions","config","themeType","options","fontInfo","get","renderWhitespace","renderControlCharacters","spaceWidth","middotWidth","wsmiddotWidth","useMonospaceOptimizations","isMonospace","canUseHalfwidthRightwardsArrow","lineHeight","stopRenderingLineAfter","fontLigatures","equals","other","ViewLine","_options","_isMaybeInvalid","_renderedViewLine","getDomNode","setDomNode","Error","onContentChanged","onTokensChanged","onDecorationsChanged","onOptionsChanged","newOptions","onSelectionChanged","HIGH_CONTRAST","renderLine","lineNumber","deltaTop","viewportData","sb","lineData","getViewLineRenderingData","actualInlineDecorations","filter","inlineDecorations","minColumn","maxColumn","selectionsOnLine","selections","selection","endLineNumber","startLineNumber","startColumn","endColumn","push","renderLineInput","content","continuesWithWrappedLine","isBasicASCII","containsRTL","tokens","tabSize","startVisibleColumn","OFF","input","appendASCIIString","String","CLASS_NAME","output","renderedViewLine","containsForeignElements","length","lineTokens","getCount","FastRenderedViewLine","characterMapping","createRenderedLine","layoutLine","setTop","setHeight","getWidth","getWidthIsFast","needsMonospaceFontCheck","onMonospaceAssumptionsInvalidated","toSlowRenderedLine","getVisibleRangesForRange","context","Math","min","lineContent","max","outsideRenderedLine","horizontalRanges","getColumnOfNodeOffset","spanNode","offset","_characterMapping","_charWidth","round","_getCharPosition","expectedWidth","actualWidth","firstChild","offsetWidth","abs","console","warn","startPosition","endPosition","column","charOffset","getAbsoluteOffset","spanNodeTextContentLength","textContent","spanIndex","previousSibling","getColumn","RenderedViewLine","_isWhitespaceOnly","test","_containsForeignElements","_cachedWidth","_pixelOffsetCache","Float32Array","len","_getReadingTarget","myDomNode","startOffset","_readPixelOffset","endOffset","_readVisibleRangesForRange","pixelOffset","_readRawVisibleRangesForRange","readingTarget","cachedPixelOffset","result","_actualReadPixelOffset","r","readHorizontalRanges","domPosition","getDomPosition","partIndex","charIndex","expectedResult","startDomPosition","endDomPosition","WebKitRenderedViewLine","endPixelOffset","lastRange","width","isWebKit","createWebKitRenderedLine","createNormalRenderedLine"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../../base/browser/browser.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport { RangeUtil } from './rangeUtil.js';\nimport { FloatHorizontalRange, VisibleRanges } from '../../../common/view/renderingContext.js';\nimport { LineDecoration } from '../../../common/viewLayout/lineDecorations.js';\nimport { RenderLineInput, renderViewLine, LineRange, DomPosition } from '../../../common/viewLayout/viewLineRenderer.js';\nimport { ColorScheme } from '../../../../platform/theme/common/theme.js';\nimport { EditorFontLigatures } from '../../../common/config/editorOptions.js';\nconst canUseFastRenderedViewLine = (function () {\n    if (platform.isNative) {\n        // In VSCode we know very well when the zoom level changes\n        return true;\n    }\n    if (platform.isLinux || browser.isFirefox || browser.isSafari) {\n        // On Linux, it appears that zooming affects char widths (in pixels), which is unexpected.\n        // --\n        // Even though we read character widths correctly, having read them at a specific zoom level\n        // does not mean they are the same at the current zoom level.\n        // --\n        // This could be improved if we ever figure out how to get an event when browsers zoom,\n        // but until then we have to stick with reading client rects.\n        // --\n        // The same has been observed with Firefox on Windows7\n        // --\n        // The same has been oversved with Safari\n        return false;\n    }\n    return true;\n})();\nlet monospaceAssumptionsAreValid = true;\nexport class DomReadingContext {\n    constructor(domNode, endNode) {\n        this._domNode = domNode;\n        this._clientRectDeltaLeft = 0;\n        this._clientRectDeltaLeftRead = false;\n        this.endNode = endNode;\n    }\n    get clientRectDeltaLeft() {\n        if (!this._clientRectDeltaLeftRead) {\n            this._clientRectDeltaLeftRead = true;\n            this._clientRectDeltaLeft = this._domNode.getBoundingClientRect().left;\n        }\n        return this._clientRectDeltaLeft;\n    }\n}\nexport class ViewLineOptions {\n    constructor(config, themeType) {\n        this.themeType = themeType;\n        const options = config.options;\n        const fontInfo = options.get(43 /* fontInfo */);\n        this.renderWhitespace = options.get(87 /* renderWhitespace */);\n        this.renderControlCharacters = options.get(82 /* renderControlCharacters */);\n        this.spaceWidth = fontInfo.spaceWidth;\n        this.middotWidth = fontInfo.middotWidth;\n        this.wsmiddotWidth = fontInfo.wsmiddotWidth;\n        this.useMonospaceOptimizations = (fontInfo.isMonospace\n            && !options.get(29 /* disableMonospaceOptimizations */));\n        this.canUseHalfwidthRightwardsArrow = fontInfo.canUseHalfwidthRightwardsArrow;\n        this.lineHeight = options.get(58 /* lineHeight */);\n        this.stopRenderingLineAfter = options.get(104 /* stopRenderingLineAfter */);\n        this.fontLigatures = options.get(44 /* fontLigatures */);\n    }\n    equals(other) {\n        return (this.themeType === other.themeType\n            && this.renderWhitespace === other.renderWhitespace\n            && this.renderControlCharacters === other.renderControlCharacters\n            && this.spaceWidth === other.spaceWidth\n            && this.middotWidth === other.middotWidth\n            && this.wsmiddotWidth === other.wsmiddotWidth\n            && this.useMonospaceOptimizations === other.useMonospaceOptimizations\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n            && this.lineHeight === other.lineHeight\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\n            && this.fontLigatures === other.fontLigatures);\n    }\n}\nexport class ViewLine {\n    constructor(options) {\n        this._options = options;\n        this._isMaybeInvalid = true;\n        this._renderedViewLine = null;\n    }\n    // --- begin IVisibleLineData\n    getDomNode() {\n        if (this._renderedViewLine && this._renderedViewLine.domNode) {\n            return this._renderedViewLine.domNode.domNode;\n        }\n        return null;\n    }\n    setDomNode(domNode) {\n        if (this._renderedViewLine) {\n            this._renderedViewLine.domNode = createFastDomNode(domNode);\n        }\n        else {\n            throw new Error('I have no rendered view line to set the dom node to...');\n        }\n    }\n    onContentChanged() {\n        this._isMaybeInvalid = true;\n    }\n    onTokensChanged() {\n        this._isMaybeInvalid = true;\n    }\n    onDecorationsChanged() {\n        this._isMaybeInvalid = true;\n    }\n    onOptionsChanged(newOptions) {\n        this._isMaybeInvalid = true;\n        this._options = newOptions;\n    }\n    onSelectionChanged() {\n        if (this._options.themeType === ColorScheme.HIGH_CONTRAST || this._options.renderWhitespace === 'selection') {\n            this._isMaybeInvalid = true;\n            return true;\n        }\n        return false;\n    }\n    renderLine(lineNumber, deltaTop, viewportData, sb) {\n        if (this._isMaybeInvalid === false) {\n            // it appears that nothing relevant has changed\n            return false;\n        }\n        this._isMaybeInvalid = false;\n        const lineData = viewportData.getViewLineRenderingData(lineNumber);\n        const options = this._options;\n        const actualInlineDecorations = LineDecoration.filter(lineData.inlineDecorations, lineNumber, lineData.minColumn, lineData.maxColumn);\n        // Only send selection information when needed for rendering whitespace\n        let selectionsOnLine = null;\n        if (options.themeType === ColorScheme.HIGH_CONTRAST || this._options.renderWhitespace === 'selection') {\n            const selections = viewportData.selections;\n            for (const selection of selections) {\n                if (selection.endLineNumber < lineNumber || selection.startLineNumber > lineNumber) {\n                    // Selection does not intersect line\n                    continue;\n                }\n                const startColumn = (selection.startLineNumber === lineNumber ? selection.startColumn : lineData.minColumn);\n                const endColumn = (selection.endLineNumber === lineNumber ? selection.endColumn : lineData.maxColumn);\n                if (startColumn < endColumn) {\n                    if (options.themeType === ColorScheme.HIGH_CONTRAST || this._options.renderWhitespace !== 'selection') {\n                        actualInlineDecorations.push(new LineDecoration(startColumn, endColumn, 'inline-selected-text', 0 /* Regular */));\n                    }\n                    else {\n                        if (!selectionsOnLine) {\n                            selectionsOnLine = [];\n                        }\n                        selectionsOnLine.push(new LineRange(startColumn - 1, endColumn - 1));\n                    }\n                }\n            }\n        }\n        const renderLineInput = new RenderLineInput(options.useMonospaceOptimizations, options.canUseHalfwidthRightwardsArrow, lineData.content, lineData.continuesWithWrappedLine, lineData.isBasicASCII, lineData.containsRTL, lineData.minColumn - 1, lineData.tokens, actualInlineDecorations, lineData.tabSize, lineData.startVisibleColumn, options.spaceWidth, options.middotWidth, options.wsmiddotWidth, options.stopRenderingLineAfter, options.renderWhitespace, options.renderControlCharacters, options.fontLigatures !== EditorFontLigatures.OFF, selectionsOnLine);\n        if (this._renderedViewLine && this._renderedViewLine.input.equals(renderLineInput)) {\n            // no need to do anything, we have the same render input\n            return false;\n        }\n        sb.appendASCIIString('<div style=\"top:');\n        sb.appendASCIIString(String(deltaTop));\n        sb.appendASCIIString('px;height:');\n        sb.appendASCIIString(String(this._options.lineHeight));\n        sb.appendASCIIString('px;\" class=\"');\n        sb.appendASCIIString(ViewLine.CLASS_NAME);\n        sb.appendASCIIString('\">');\n        const output = renderViewLine(renderLineInput, sb);\n        sb.appendASCIIString('</div>');\n        let renderedViewLine = null;\n        if (monospaceAssumptionsAreValid && canUseFastRenderedViewLine && lineData.isBasicASCII && options.useMonospaceOptimizations && output.containsForeignElements === 0 /* None */) {\n            if (lineData.content.length < 300 && renderLineInput.lineTokens.getCount() < 100) {\n                // Browser rounding errors have been observed in Chrome and IE, so using the fast\n                // view line only for short lines. Please test before removing the length check...\n                // ---\n                // Another rounding error has been observed on Linux in VSCode, where <span> width\n                // rounding errors add up to an observable large number...\n                // ---\n                // Also see another example of rounding errors on Windows in\n                // https://github.com/microsoft/vscode/issues/33178\n                renderedViewLine = new FastRenderedViewLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping);\n            }\n        }\n        if (!renderedViewLine) {\n            renderedViewLine = createRenderedLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping, output.containsRTL, output.containsForeignElements);\n        }\n        this._renderedViewLine = renderedViewLine;\n        return true;\n    }\n    layoutLine(lineNumber, deltaTop) {\n        if (this._renderedViewLine && this._renderedViewLine.domNode) {\n            this._renderedViewLine.domNode.setTop(deltaTop);\n            this._renderedViewLine.domNode.setHeight(this._options.lineHeight);\n        }\n    }\n    // --- end IVisibleLineData\n    getWidth() {\n        if (!this._renderedViewLine) {\n            return 0;\n        }\n        return this._renderedViewLine.getWidth();\n    }\n    getWidthIsFast() {\n        if (!this._renderedViewLine) {\n            return true;\n        }\n        return this._renderedViewLine.getWidthIsFast();\n    }\n    needsMonospaceFontCheck() {\n        if (!this._renderedViewLine) {\n            return false;\n        }\n        return (this._renderedViewLine instanceof FastRenderedViewLine);\n    }\n    monospaceAssumptionsAreValid() {\n        if (!this._renderedViewLine) {\n            return monospaceAssumptionsAreValid;\n        }\n        if (this._renderedViewLine instanceof FastRenderedViewLine) {\n            return this._renderedViewLine.monospaceAssumptionsAreValid();\n        }\n        return monospaceAssumptionsAreValid;\n    }\n    onMonospaceAssumptionsInvalidated() {\n        if (this._renderedViewLine && this._renderedViewLine instanceof FastRenderedViewLine) {\n            this._renderedViewLine = this._renderedViewLine.toSlowRenderedLine();\n        }\n    }\n    getVisibleRangesForRange(lineNumber, startColumn, endColumn, context) {\n        if (!this._renderedViewLine) {\n            return null;\n        }\n        startColumn = startColumn | 0; // @perf\n        endColumn = endColumn | 0; // @perf\n        startColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, startColumn));\n        endColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, endColumn));\n        const stopRenderingLineAfter = this._renderedViewLine.input.stopRenderingLineAfter | 0; // @perf\n        let outsideRenderedLine = false;\n        if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1 && endColumn > stopRenderingLineAfter + 1) {\n            // This range is obviously not visible\n            outsideRenderedLine = true;\n        }\n        if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1) {\n            startColumn = stopRenderingLineAfter + 1;\n        }\n        if (stopRenderingLineAfter !== -1 && endColumn > stopRenderingLineAfter + 1) {\n            endColumn = stopRenderingLineAfter + 1;\n        }\n        const horizontalRanges = this._renderedViewLine.getVisibleRangesForRange(lineNumber, startColumn, endColumn, context);\n        if (horizontalRanges && horizontalRanges.length > 0) {\n            return new VisibleRanges(outsideRenderedLine, horizontalRanges);\n        }\n        return null;\n    }\n    getColumnOfNodeOffset(lineNumber, spanNode, offset) {\n        if (!this._renderedViewLine) {\n            return 1;\n        }\n        return this._renderedViewLine.getColumnOfNodeOffset(lineNumber, spanNode, offset);\n    }\n}\nViewLine.CLASS_NAME = 'view-line';\n/**\n * A rendered line which is guaranteed to contain only regular ASCII and is rendered with a monospace font.\n */\nclass FastRenderedViewLine {\n    constructor(domNode, renderLineInput, characterMapping) {\n        this.domNode = domNode;\n        this.input = renderLineInput;\n        this._characterMapping = characterMapping;\n        this._charWidth = renderLineInput.spaceWidth;\n    }\n    getWidth() {\n        return Math.round(this._getCharPosition(this._characterMapping.length));\n    }\n    getWidthIsFast() {\n        return true;\n    }\n    monospaceAssumptionsAreValid() {\n        if (!this.domNode) {\n            return monospaceAssumptionsAreValid;\n        }\n        const expectedWidth = this.getWidth();\n        const actualWidth = this.domNode.domNode.firstChild.offsetWidth;\n        if (Math.abs(expectedWidth - actualWidth) >= 2) {\n            // more than 2px off\n            console.warn(`monospace assumptions have been violated, therefore disabling monospace optimizations!`);\n            monospaceAssumptionsAreValid = false;\n        }\n        return monospaceAssumptionsAreValid;\n    }\n    toSlowRenderedLine() {\n        return createRenderedLine(this.domNode, this.input, this._characterMapping, false, 0 /* None */);\n    }\n    getVisibleRangesForRange(lineNumber, startColumn, endColumn, context) {\n        const startPosition = this._getCharPosition(startColumn);\n        const endPosition = this._getCharPosition(endColumn);\n        return [new FloatHorizontalRange(startPosition, endPosition - startPosition)];\n    }\n    _getCharPosition(column) {\n        const charOffset = this._characterMapping.getAbsoluteOffset(column);\n        return this._charWidth * charOffset;\n    }\n    getColumnOfNodeOffset(lineNumber, spanNode, offset) {\n        const spanNodeTextContentLength = spanNode.textContent.length;\n        let spanIndex = -1;\n        while (spanNode) {\n            spanNode = spanNode.previousSibling;\n            spanIndex++;\n        }\n        return this._characterMapping.getColumn(new DomPosition(spanIndex, offset), spanNodeTextContentLength);\n    }\n}\n/**\n * Every time we render a line, we save what we have rendered in an instance of this class.\n */\nclass RenderedViewLine {\n    constructor(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n        this.domNode = domNode;\n        this.input = renderLineInput;\n        this._characterMapping = characterMapping;\n        this._isWhitespaceOnly = /^\\s*$/.test(renderLineInput.lineContent);\n        this._containsForeignElements = containsForeignElements;\n        this._cachedWidth = -1;\n        this._pixelOffsetCache = null;\n        if (!containsRTL || this._characterMapping.length === 0 /* the line is empty */) {\n            this._pixelOffsetCache = new Float32Array(Math.max(2, this._characterMapping.length + 1));\n            for (let column = 0, len = this._characterMapping.length; column <= len; column++) {\n                this._pixelOffsetCache[column] = -1;\n            }\n        }\n    }\n    // --- Reading from the DOM methods\n    _getReadingTarget(myDomNode) {\n        return myDomNode.domNode.firstChild;\n    }\n    /**\n     * Width of the line in pixels\n     */\n    getWidth() {\n        if (!this.domNode) {\n            return 0;\n        }\n        if (this._cachedWidth === -1) {\n            this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth;\n        }\n        return this._cachedWidth;\n    }\n    getWidthIsFast() {\n        if (this._cachedWidth === -1) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Visible ranges for a model range\n     */\n    getVisibleRangesForRange(lineNumber, startColumn, endColumn, context) {\n        if (!this.domNode) {\n            return null;\n        }\n        if (this._pixelOffsetCache !== null) {\n            // the text is LTR\n            const startOffset = this._readPixelOffset(this.domNode, lineNumber, startColumn, context);\n            if (startOffset === -1) {\n                return null;\n            }\n            const endOffset = this._readPixelOffset(this.domNode, lineNumber, endColumn, context);\n            if (endOffset === -1) {\n                return null;\n            }\n            return [new FloatHorizontalRange(startOffset, endOffset - startOffset)];\n        }\n        return this._readVisibleRangesForRange(this.domNode, lineNumber, startColumn, endColumn, context);\n    }\n    _readVisibleRangesForRange(domNode, lineNumber, startColumn, endColumn, context) {\n        if (startColumn === endColumn) {\n            const pixelOffset = this._readPixelOffset(domNode, lineNumber, startColumn, context);\n            if (pixelOffset === -1) {\n                return null;\n            }\n            else {\n                return [new FloatHorizontalRange(pixelOffset, 0)];\n            }\n        }\n        else {\n            return this._readRawVisibleRangesForRange(domNode, startColumn, endColumn, context);\n        }\n    }\n    _readPixelOffset(domNode, lineNumber, column, context) {\n        if (this._characterMapping.length === 0) {\n            // This line has no content\n            if (this._containsForeignElements === 0 /* None */) {\n                // We can assume the line is really empty\n                return 0;\n            }\n            if (this._containsForeignElements === 2 /* After */) {\n                // We have foreign elements after the (empty) line\n                return 0;\n            }\n            if (this._containsForeignElements === 1 /* Before */) {\n                // We have foreign elements before the (empty) line\n                return this.getWidth();\n            }\n            // We have foreign elements before & after the (empty) line\n            const readingTarget = this._getReadingTarget(domNode);\n            if (readingTarget.firstChild) {\n                return readingTarget.firstChild.offsetWidth;\n            }\n            else {\n                return 0;\n            }\n        }\n        if (this._pixelOffsetCache !== null) {\n            // the text is LTR\n            const cachedPixelOffset = this._pixelOffsetCache[column];\n            if (cachedPixelOffset !== -1) {\n                return cachedPixelOffset;\n            }\n            const result = this._actualReadPixelOffset(domNode, lineNumber, column, context);\n            this._pixelOffsetCache[column] = result;\n            return result;\n        }\n        return this._actualReadPixelOffset(domNode, lineNumber, column, context);\n    }\n    _actualReadPixelOffset(domNode, lineNumber, column, context) {\n        if (this._characterMapping.length === 0) {\n            // This line has no content\n            const r = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), 0, 0, 0, 0, context.clientRectDeltaLeft, context.endNode);\n            if (!r || r.length === 0) {\n                return -1;\n            }\n            return r[0].left;\n        }\n        if (column === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0 /* None */) {\n            // This branch helps in the case of whitespace only lines which have a width set\n            return this.getWidth();\n        }\n        const domPosition = this._characterMapping.getDomPosition(column);\n        const r = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), domPosition.partIndex, domPosition.charIndex, domPosition.partIndex, domPosition.charIndex, context.clientRectDeltaLeft, context.endNode);\n        if (!r || r.length === 0) {\n            return -1;\n        }\n        const result = r[0].left;\n        if (this.input.isBasicASCII) {\n            const charOffset = this._characterMapping.getAbsoluteOffset(column);\n            const expectedResult = Math.round(this.input.spaceWidth * charOffset);\n            if (Math.abs(expectedResult - result) <= 1) {\n                return expectedResult;\n            }\n        }\n        return result;\n    }\n    _readRawVisibleRangesForRange(domNode, startColumn, endColumn, context) {\n        if (startColumn === 1 && endColumn === this._characterMapping.length) {\n            // This branch helps IE with bidi text & gives a performance boost to other browsers when reading visible ranges for an entire line\n            return [new FloatHorizontalRange(0, this.getWidth())];\n        }\n        const startDomPosition = this._characterMapping.getDomPosition(startColumn);\n        const endDomPosition = this._characterMapping.getDomPosition(endColumn);\n        return RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), startDomPosition.partIndex, startDomPosition.charIndex, endDomPosition.partIndex, endDomPosition.charIndex, context.clientRectDeltaLeft, context.endNode);\n    }\n    /**\n     * Returns the column for the text found at a specific offset inside a rendered dom node\n     */\n    getColumnOfNodeOffset(lineNumber, spanNode, offset) {\n        const spanNodeTextContentLength = spanNode.textContent.length;\n        let spanIndex = -1;\n        while (spanNode) {\n            spanNode = spanNode.previousSibling;\n            spanIndex++;\n        }\n        return this._characterMapping.getColumn(new DomPosition(spanIndex, offset), spanNodeTextContentLength);\n    }\n}\nclass WebKitRenderedViewLine extends RenderedViewLine {\n    _readVisibleRangesForRange(domNode, lineNumber, startColumn, endColumn, context) {\n        const output = super._readVisibleRangesForRange(domNode, lineNumber, startColumn, endColumn, context);\n        if (!output || output.length === 0 || startColumn === endColumn || (startColumn === 1 && endColumn === this._characterMapping.length)) {\n            return output;\n        }\n        // WebKit is buggy and returns an expanded range (to contain words in some cases)\n        // The last client rect is enlarged (I think)\n        if (!this.input.containsRTL) {\n            // This is an attempt to patch things up\n            // Find position of last column\n            const endPixelOffset = this._readPixelOffset(domNode, lineNumber, endColumn, context);\n            if (endPixelOffset !== -1) {\n                const lastRange = output[output.length - 1];\n                if (lastRange.left < endPixelOffset) {\n                    // Trim down the width of the last visible range to not go after the last column's position\n                    lastRange.width = endPixelOffset - lastRange.left;\n                }\n            }\n        }\n        return output;\n    }\n}\nconst createRenderedLine = (function () {\n    if (browser.isWebKit) {\n        return createWebKitRenderedLine;\n    }\n    return createNormalRenderedLine;\n})();\nfunction createWebKitRenderedLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n    return new WebKitRenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements);\n}\nfunction createNormalRenderedLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n    return new RenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements);\n}\n"]},"metadata":{},"sourceType":"module"}