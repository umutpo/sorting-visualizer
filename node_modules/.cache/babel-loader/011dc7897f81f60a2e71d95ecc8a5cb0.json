{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IndexTreeModel } from './indexTreeModel.js';\nimport { TreeError } from './tree.js';\nimport { Iterable } from '../../../common/iterator.js';\nexport class ObjectTreeModel {\n  constructor(user, list) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.user = user;\n    this.rootRef = null;\n    this.nodes = new Map();\n    this.nodesByIdentity = new Map();\n    this.model = new IndexTreeModel(user, list, null, options);\n    this.onDidSplice = this.model.onDidSplice;\n    this.onDidChangeCollapseState = this.model.onDidChangeCollapseState;\n    this.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount;\n\n    if (options.sorter) {\n      this.sorter = {\n        compare(a, b) {\n          return options.sorter.compare(a.element, b.element);\n        }\n\n      };\n    }\n\n    this.identityProvider = options.identityProvider;\n  }\n\n  setChildren(element) {\n    let children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Iterable.empty();\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const location = this.getElementLocation(element);\n\n    this._setChildren(location, this.preserveCollapseState(children), options);\n  }\n\n  _setChildren(location) {\n    let children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Iterable.empty();\n    let options = arguments.length > 2 ? arguments[2] : undefined;\n    const insertedElements = new Set();\n    const insertedElementIds = new Set();\n\n    const onDidCreateNode = node => {\n      var _a;\n\n      if (node.element === null) {\n        return;\n      }\n\n      const tnode = node;\n      insertedElements.add(tnode.element);\n      this.nodes.set(tnode.element, tnode);\n\n      if (this.identityProvider) {\n        const id = this.identityProvider.getId(tnode.element).toString();\n        insertedElementIds.add(id);\n        this.nodesByIdentity.set(id, tnode);\n      }\n\n      (_a = options.onDidCreateNode) === null || _a === void 0 ? void 0 : _a.call(options, tnode);\n    };\n\n    const onDidDeleteNode = node => {\n      var _a;\n\n      if (node.element === null) {\n        return;\n      }\n\n      const tnode = node;\n\n      if (!insertedElements.has(tnode.element)) {\n        this.nodes.delete(tnode.element);\n      }\n\n      if (this.identityProvider) {\n        const id = this.identityProvider.getId(tnode.element).toString();\n\n        if (!insertedElementIds.has(id)) {\n          this.nodesByIdentity.delete(id);\n        }\n      }\n\n      (_a = options.onDidDeleteNode) === null || _a === void 0 ? void 0 : _a.call(options, tnode);\n    };\n\n    this.model.splice([...location, 0], Number.MAX_VALUE, children, Object.assign(Object.assign({}, options), {\n      onDidCreateNode,\n      onDidDeleteNode\n    }));\n  }\n\n  preserveCollapseState() {\n    let elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Iterable.empty();\n\n    if (this.sorter) {\n      elements = [...elements].sort(this.sorter.compare.bind(this.sorter));\n    }\n\n    return Iterable.map(elements, treeElement => {\n      let node = this.nodes.get(treeElement.element);\n\n      if (!node && this.identityProvider) {\n        const id = this.identityProvider.getId(treeElement.element).toString();\n        node = this.nodesByIdentity.get(id);\n      }\n\n      if (!node) {\n        return Object.assign(Object.assign({}, treeElement), {\n          children: this.preserveCollapseState(treeElement.children)\n        });\n      }\n\n      const collapsible = typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : node.collapsible;\n      const collapsed = typeof treeElement.collapsed !== 'undefined' ? treeElement.collapsed : node.collapsed;\n      return Object.assign(Object.assign({}, treeElement), {\n        collapsible,\n        collapsed,\n        children: this.preserveCollapseState(treeElement.children)\n      });\n    });\n  }\n\n  rerender(element) {\n    const location = this.getElementLocation(element);\n    this.model.rerender(location);\n  }\n\n  has(element) {\n    return this.nodes.has(element);\n  }\n\n  getListIndex(element) {\n    const location = this.getElementLocation(element);\n    return this.model.getListIndex(location);\n  }\n\n  getListRenderCount(element) {\n    const location = this.getElementLocation(element);\n    return this.model.getListRenderCount(location);\n  }\n\n  isCollapsible(element) {\n    const location = this.getElementLocation(element);\n    return this.model.isCollapsible(location);\n  }\n\n  setCollapsible(element, collapsible) {\n    const location = this.getElementLocation(element);\n    return this.model.setCollapsible(location, collapsible);\n  }\n\n  isCollapsed(element) {\n    const location = this.getElementLocation(element);\n    return this.model.isCollapsed(location);\n  }\n\n  setCollapsed(element, collapsed, recursive) {\n    const location = this.getElementLocation(element);\n    return this.model.setCollapsed(location, collapsed, recursive);\n  }\n\n  expandTo(element) {\n    const location = this.getElementLocation(element);\n    this.model.expandTo(location);\n  }\n\n  refilter() {\n    this.model.refilter();\n  }\n\n  getNode() {\n    let element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    if (element === null) {\n      return this.model.getNode(this.model.rootRef);\n    }\n\n    const node = this.nodes.get(element);\n\n    if (!node) {\n      throw new TreeError(this.user, `Tree element not found: ${element}`);\n    }\n\n    return node;\n  }\n\n  getNodeLocation(node) {\n    return node.element;\n  }\n\n  getParentNodeLocation(element) {\n    if (element === null) {\n      throw new TreeError(this.user, `Invalid getParentNodeLocation call`);\n    }\n\n    const node = this.nodes.get(element);\n\n    if (!node) {\n      throw new TreeError(this.user, `Tree element not found: ${element}`);\n    }\n\n    const location = this.model.getNodeLocation(node);\n    const parentLocation = this.model.getParentNodeLocation(location);\n    const parent = this.model.getNode(parentLocation);\n    return parent.element;\n  }\n\n  getElementLocation(element) {\n    if (element === null) {\n      return [];\n    }\n\n    const node = this.nodes.get(element);\n\n    if (!node) {\n      throw new TreeError(this.user, `Tree element not found: ${element}`);\n    }\n\n    return this.model.getNodeLocation(node);\n  }\n\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/base/browser/ui/tree/objectTreeModel.js"],"names":["IndexTreeModel","TreeError","Iterable","ObjectTreeModel","constructor","user","list","options","rootRef","nodes","Map","nodesByIdentity","model","onDidSplice","onDidChangeCollapseState","onDidChangeRenderNodeCount","sorter","compare","a","b","element","identityProvider","setChildren","children","empty","location","getElementLocation","_setChildren","preserveCollapseState","insertedElements","Set","insertedElementIds","onDidCreateNode","node","_a","tnode","add","set","id","getId","toString","call","onDidDeleteNode","has","delete","splice","Number","MAX_VALUE","Object","assign","elements","sort","bind","map","treeElement","get","collapsible","collapsed","rerender","getListIndex","getListRenderCount","isCollapsible","setCollapsible","isCollapsed","setCollapsed","recursive","expandTo","refilter","getNode","getNodeLocation","getParentNodeLocation","parentLocation","parent"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IndexTreeModel } from './indexTreeModel.js';\nimport { TreeError } from './tree.js';\nimport { Iterable } from '../../../common/iterator.js';\nexport class ObjectTreeModel {\n    constructor(user, list, options = {}) {\n        this.user = user;\n        this.rootRef = null;\n        this.nodes = new Map();\n        this.nodesByIdentity = new Map();\n        this.model = new IndexTreeModel(user, list, null, options);\n        this.onDidSplice = this.model.onDidSplice;\n        this.onDidChangeCollapseState = this.model.onDidChangeCollapseState;\n        this.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount;\n        if (options.sorter) {\n            this.sorter = {\n                compare(a, b) {\n                    return options.sorter.compare(a.element, b.element);\n                }\n            };\n        }\n        this.identityProvider = options.identityProvider;\n    }\n    setChildren(element, children = Iterable.empty(), options = {}) {\n        const location = this.getElementLocation(element);\n        this._setChildren(location, this.preserveCollapseState(children), options);\n    }\n    _setChildren(location, children = Iterable.empty(), options) {\n        const insertedElements = new Set();\n        const insertedElementIds = new Set();\n        const onDidCreateNode = (node) => {\n            var _a;\n            if (node.element === null) {\n                return;\n            }\n            const tnode = node;\n            insertedElements.add(tnode.element);\n            this.nodes.set(tnode.element, tnode);\n            if (this.identityProvider) {\n                const id = this.identityProvider.getId(tnode.element).toString();\n                insertedElementIds.add(id);\n                this.nodesByIdentity.set(id, tnode);\n            }\n            (_a = options.onDidCreateNode) === null || _a === void 0 ? void 0 : _a.call(options, tnode);\n        };\n        const onDidDeleteNode = (node) => {\n            var _a;\n            if (node.element === null) {\n                return;\n            }\n            const tnode = node;\n            if (!insertedElements.has(tnode.element)) {\n                this.nodes.delete(tnode.element);\n            }\n            if (this.identityProvider) {\n                const id = this.identityProvider.getId(tnode.element).toString();\n                if (!insertedElementIds.has(id)) {\n                    this.nodesByIdentity.delete(id);\n                }\n            }\n            (_a = options.onDidDeleteNode) === null || _a === void 0 ? void 0 : _a.call(options, tnode);\n        };\n        this.model.splice([...location, 0], Number.MAX_VALUE, children, Object.assign(Object.assign({}, options), { onDidCreateNode, onDidDeleteNode }));\n    }\n    preserveCollapseState(elements = Iterable.empty()) {\n        if (this.sorter) {\n            elements = [...elements].sort(this.sorter.compare.bind(this.sorter));\n        }\n        return Iterable.map(elements, treeElement => {\n            let node = this.nodes.get(treeElement.element);\n            if (!node && this.identityProvider) {\n                const id = this.identityProvider.getId(treeElement.element).toString();\n                node = this.nodesByIdentity.get(id);\n            }\n            if (!node) {\n                return Object.assign(Object.assign({}, treeElement), { children: this.preserveCollapseState(treeElement.children) });\n            }\n            const collapsible = typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : node.collapsible;\n            const collapsed = typeof treeElement.collapsed !== 'undefined' ? treeElement.collapsed : node.collapsed;\n            return Object.assign(Object.assign({}, treeElement), { collapsible,\n                collapsed, children: this.preserveCollapseState(treeElement.children) });\n        });\n    }\n    rerender(element) {\n        const location = this.getElementLocation(element);\n        this.model.rerender(location);\n    }\n    has(element) {\n        return this.nodes.has(element);\n    }\n    getListIndex(element) {\n        const location = this.getElementLocation(element);\n        return this.model.getListIndex(location);\n    }\n    getListRenderCount(element) {\n        const location = this.getElementLocation(element);\n        return this.model.getListRenderCount(location);\n    }\n    isCollapsible(element) {\n        const location = this.getElementLocation(element);\n        return this.model.isCollapsible(location);\n    }\n    setCollapsible(element, collapsible) {\n        const location = this.getElementLocation(element);\n        return this.model.setCollapsible(location, collapsible);\n    }\n    isCollapsed(element) {\n        const location = this.getElementLocation(element);\n        return this.model.isCollapsed(location);\n    }\n    setCollapsed(element, collapsed, recursive) {\n        const location = this.getElementLocation(element);\n        return this.model.setCollapsed(location, collapsed, recursive);\n    }\n    expandTo(element) {\n        const location = this.getElementLocation(element);\n        this.model.expandTo(location);\n    }\n    refilter() {\n        this.model.refilter();\n    }\n    getNode(element = null) {\n        if (element === null) {\n            return this.model.getNode(this.model.rootRef);\n        }\n        const node = this.nodes.get(element);\n        if (!node) {\n            throw new TreeError(this.user, `Tree element not found: ${element}`);\n        }\n        return node;\n    }\n    getNodeLocation(node) {\n        return node.element;\n    }\n    getParentNodeLocation(element) {\n        if (element === null) {\n            throw new TreeError(this.user, `Invalid getParentNodeLocation call`);\n        }\n        const node = this.nodes.get(element);\n        if (!node) {\n            throw new TreeError(this.user, `Tree element not found: ${element}`);\n        }\n        const location = this.model.getNodeLocation(node);\n        const parentLocation = this.model.getParentNodeLocation(location);\n        const parent = this.model.getNode(parentLocation);\n        return parent.element;\n    }\n    getElementLocation(element) {\n        if (element === null) {\n            return [];\n        }\n        const node = this.nodes.get(element);\n        if (!node) {\n            throw new TreeError(this.user, `Tree element not found: ${element}`);\n        }\n        return this.model.getNodeLocation(node);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}