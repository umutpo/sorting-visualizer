{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './viewLines.css';\nimport * as platform from '../../../../base/common/platform.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { Configuration } from '../../config/configuration.js';\nimport { VisibleLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { DomReadingContext, ViewLine, ViewLineOptions } from './viewLine.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { LineVisibleRanges, HorizontalPosition, HorizontalRange } from '../../../common/view/renderingContext.js';\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../../base/browser/ui/mouseCursor/mouseCursor.js';\n\nclass LastRenderedData {\n  constructor() {\n    this._currentVisibleRange = new Range(1, 1, 1, 1);\n  }\n\n  getCurrentVisibleRange() {\n    return this._currentVisibleRange;\n  }\n\n  setCurrentVisibleRange(currentVisibleRange) {\n    this._currentVisibleRange = currentVisibleRange;\n  }\n\n}\n\nclass HorizontalRevealRangeRequest {\n  constructor(lineNumber, startColumn, endColumn, startScrollTop, stopScrollTop, scrollType) {\n    this.lineNumber = lineNumber;\n    this.startColumn = startColumn;\n    this.endColumn = endColumn;\n    this.startScrollTop = startScrollTop;\n    this.stopScrollTop = stopScrollTop;\n    this.scrollType = scrollType;\n    this.type = 'range';\n    this.minLineNumber = lineNumber;\n    this.maxLineNumber = lineNumber;\n  }\n\n}\n\nclass HorizontalRevealSelectionsRequest {\n  constructor(selections, startScrollTop, stopScrollTop, scrollType) {\n    this.selections = selections;\n    this.startScrollTop = startScrollTop;\n    this.stopScrollTop = stopScrollTop;\n    this.scrollType = scrollType;\n    this.type = 'selections';\n    let minLineNumber = selections[0].startLineNumber;\n    let maxLineNumber = selections[0].endLineNumber;\n\n    for (let i = 1, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      minLineNumber = Math.min(minLineNumber, selection.startLineNumber);\n      maxLineNumber = Math.max(maxLineNumber, selection.endLineNumber);\n    }\n\n    this.minLineNumber = minLineNumber;\n    this.maxLineNumber = maxLineNumber;\n  }\n\n}\n\nexport class ViewLines extends ViewPart {\n  constructor(context, linesContent) {\n    super(context);\n    this._linesContent = linesContent;\n    this._textRangeRestingSpot = document.createElement('div');\n    this._visibleLines = new VisibleLinesCollection(this);\n    this.domNode = this._visibleLines.domNode;\n    const conf = this._context.configuration;\n    const options = this._context.configuration.options;\n    const fontInfo = options.get(43\n    /* fontInfo */\n    );\n    const wrappingInfo = options.get(130\n    /* wrappingInfo */\n    );\n    this._lineHeight = options.get(58\n    /* lineHeight */\n    );\n    this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n    this._isViewportWrapping = wrappingInfo.isViewportWrapping;\n    this._revealHorizontalRightPadding = options.get(88\n    /* revealHorizontalRightPadding */\n    );\n    this._cursorSurroundingLines = options.get(25\n    /* cursorSurroundingLines */\n    );\n    this._cursorSurroundingLinesStyle = options.get(26\n    /* cursorSurroundingLinesStyle */\n    );\n    this._canUseLayerHinting = !options.get(28\n    /* disableLayerHinting */\n    );\n    this._viewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\n    PartFingerprints.write(this.domNode, 7\n    /* ViewLines */\n    );\n    this.domNode.setClassName(`view-lines ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);\n    Configuration.applyFontInfo(this.domNode, fontInfo); // --- width & height\n\n    this._maxLineWidth = 0;\n    this._asyncUpdateLineWidths = new RunOnceScheduler(() => {\n      this._updateLineWidthsSlow();\n    }, 200);\n    this._asyncCheckMonospaceFontAssumptions = new RunOnceScheduler(() => {\n      this._checkMonospaceFontAssumptions();\n    }, 2000);\n    this._lastRenderedData = new LastRenderedData();\n    this._horizontalRevealRequest = null;\n  }\n\n  dispose() {\n    this._asyncUpdateLineWidths.dispose();\n\n    this._asyncCheckMonospaceFontAssumptions.dispose();\n\n    super.dispose();\n  }\n\n  getDomNode() {\n    return this.domNode;\n  } // ---- begin IVisibleLinesHost\n\n\n  createVisibleLine() {\n    return new ViewLine(this._viewLineOptions);\n  } // ---- end IVisibleLinesHost\n  // ---- begin view event handlers\n\n\n  onConfigurationChanged(e) {\n    this._visibleLines.onConfigurationChanged(e);\n\n    if (e.hasChanged(130\n    /* wrappingInfo */\n    )) {\n      this._maxLineWidth = 0;\n    }\n\n    const options = this._context.configuration.options;\n    const fontInfo = options.get(43\n    /* fontInfo */\n    );\n    const wrappingInfo = options.get(130\n    /* wrappingInfo */\n    );\n    this._lineHeight = options.get(58\n    /* lineHeight */\n    );\n    this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n    this._isViewportWrapping = wrappingInfo.isViewportWrapping;\n    this._revealHorizontalRightPadding = options.get(88\n    /* revealHorizontalRightPadding */\n    );\n    this._cursorSurroundingLines = options.get(25\n    /* cursorSurroundingLines */\n    );\n    this._cursorSurroundingLinesStyle = options.get(26\n    /* cursorSurroundingLinesStyle */\n    );\n    this._canUseLayerHinting = !options.get(28\n    /* disableLayerHinting */\n    );\n    Configuration.applyFontInfo(this.domNode, fontInfo);\n\n    this._onOptionsMaybeChanged();\n\n    if (e.hasChanged(129\n    /* layoutInfo */\n    )) {\n      this._maxLineWidth = 0;\n    }\n\n    return true;\n  }\n\n  _onOptionsMaybeChanged() {\n    const conf = this._context.configuration;\n    const newViewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\n\n    if (!this._viewLineOptions.equals(newViewLineOptions)) {\n      this._viewLineOptions = newViewLineOptions;\n\n      const startLineNumber = this._visibleLines.getStartLineNumber();\n\n      const endLineNumber = this._visibleLines.getEndLineNumber();\n\n      for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n        const line = this._visibleLines.getVisibleLine(lineNumber);\n\n        line.onOptionsChanged(this._viewLineOptions);\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  onCursorStateChanged(e) {\n    const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n    const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n    let r = false;\n\n    for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n      r = this._visibleLines.getVisibleLine(lineNumber).onSelectionChanged() || r;\n    }\n\n    return r;\n  }\n\n  onDecorationsChanged(e) {\n    if (true\n    /*e.inlineDecorationsChanged*/\n    ) {\n      const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n      const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n      for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n        this._visibleLines.getVisibleLine(lineNumber).onDecorationsChanged();\n      }\n    }\n\n    return true;\n  }\n\n  onFlushed(e) {\n    const shouldRender = this._visibleLines.onFlushed(e);\n\n    this._maxLineWidth = 0;\n    return shouldRender;\n  }\n\n  onLinesChanged(e) {\n    return this._visibleLines.onLinesChanged(e);\n  }\n\n  onLinesDeleted(e) {\n    return this._visibleLines.onLinesDeleted(e);\n  }\n\n  onLinesInserted(e) {\n    return this._visibleLines.onLinesInserted(e);\n  }\n\n  onRevealRangeRequest(e) {\n    // Using the future viewport here in order to handle multiple\n    // incoming reveal range requests that might all desire to be animated\n    const desiredScrollTop = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.range, e.selections, e.verticalType);\n\n    if (desiredScrollTop === -1) {\n      // marker to abort the reveal range request\n      return false;\n    } // validate the new desired scroll top\n\n\n    let newScrollPosition = this._context.viewLayout.validateScrollPosition({\n      scrollTop: desiredScrollTop\n    });\n\n    if (e.revealHorizontal) {\n      if (e.range && e.range.startLineNumber !== e.range.endLineNumber) {\n        // Two or more lines? => scroll to base (That's how you see most of the two lines)\n        newScrollPosition = {\n          scrollTop: newScrollPosition.scrollTop,\n          scrollLeft: 0\n        };\n      } else if (e.range) {\n        // We don't necessarily know the horizontal offset of this range since the line might not be in the view...\n        this._horizontalRevealRequest = new HorizontalRevealRangeRequest(e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\n      } else if (e.selections && e.selections.length > 0) {\n        this._horizontalRevealRequest = new HorizontalRevealSelectionsRequest(e.selections, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\n      }\n    } else {\n      this._horizontalRevealRequest = null;\n    }\n\n    const scrollTopDelta = Math.abs(this._context.viewLayout.getCurrentScrollTop() - newScrollPosition.scrollTop);\n    const scrollType = scrollTopDelta <= this._lineHeight ? 1\n    /* Immediate */\n    : e.scrollType;\n\n    this._context.model.setScrollPosition(newScrollPosition, scrollType);\n\n    return true;\n  }\n\n  onScrollChanged(e) {\n    if (this._horizontalRevealRequest && e.scrollLeftChanged) {\n      // cancel any outstanding horizontal reveal request if someone else scrolls horizontally.\n      this._horizontalRevealRequest = null;\n    }\n\n    if (this._horizontalRevealRequest && e.scrollTopChanged) {\n      const min = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n      const max = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n\n      if (e.scrollTop < min || e.scrollTop > max) {\n        // cancel any outstanding horizontal reveal request if someone else scrolls vertically.\n        this._horizontalRevealRequest = null;\n      }\n    }\n\n    this.domNode.setWidth(e.scrollWidth);\n    return this._visibleLines.onScrollChanged(e) || true;\n  }\n\n  onTokensChanged(e) {\n    return this._visibleLines.onTokensChanged(e);\n  }\n\n  onZonesChanged(e) {\n    this._context.model.setMaxLineWidth(this._maxLineWidth);\n\n    return this._visibleLines.onZonesChanged(e);\n  }\n\n  onThemeChanged(e) {\n    return this._onOptionsMaybeChanged();\n  } // ---- end view event handlers\n  // ----------- HELPERS FOR OTHERS\n\n\n  getPositionFromDOMInfo(spanNode, offset) {\n    const viewLineDomNode = this._getViewLineDomNode(spanNode);\n\n    if (viewLineDomNode === null) {\n      // Couldn't find view line node\n      return null;\n    }\n\n    const lineNumber = this._getLineNumberFor(viewLineDomNode);\n\n    if (lineNumber === -1) {\n      // Couldn't find view line node\n      return null;\n    }\n\n    if (lineNumber < 1 || lineNumber > this._context.model.getLineCount()) {\n      // lineNumber is outside range\n      return null;\n    }\n\n    if (this._context.model.getLineMaxColumn(lineNumber) === 1) {\n      // Line is empty\n      return new Position(lineNumber, 1);\n    }\n\n    const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n    const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n    if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n      // Couldn't find line\n      return null;\n    }\n\n    let column = this._visibleLines.getVisibleLine(lineNumber).getColumnOfNodeOffset(lineNumber, spanNode, offset);\n\n    const minColumn = this._context.model.getLineMinColumn(lineNumber);\n\n    if (column < minColumn) {\n      column = minColumn;\n    }\n\n    return new Position(lineNumber, column);\n  }\n\n  _getViewLineDomNode(node) {\n    while (node && node.nodeType === 1) {\n      if (node.className === ViewLine.CLASS_NAME) {\n        return node;\n      }\n\n      node = node.parentElement;\n    }\n\n    return null;\n  }\n  /**\n   * @returns the line number of this view line dom node.\n   */\n\n\n  _getLineNumberFor(domNode) {\n    const startLineNumber = this._visibleLines.getStartLineNumber();\n\n    const endLineNumber = this._visibleLines.getEndLineNumber();\n\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const line = this._visibleLines.getVisibleLine(lineNumber);\n\n      if (domNode === line.getDomNode()) {\n        return lineNumber;\n      }\n    }\n\n    return -1;\n  }\n\n  getLineWidth(lineNumber) {\n    const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n    const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n    if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n      // Couldn't find line\n      return -1;\n    }\n\n    return this._visibleLines.getVisibleLine(lineNumber).getWidth();\n  }\n\n  linesVisibleRangesForRange(_range, includeNewLines) {\n    if (this.shouldRender()) {\n      // Cannot read from the DOM because it is dirty\n      // i.e. the model & the dom are out of sync, so I'd be reading something stale\n      return null;\n    }\n\n    const originalEndLineNumber = _range.endLineNumber;\n    const range = Range.intersectRanges(_range, this._lastRenderedData.getCurrentVisibleRange());\n\n    if (!range) {\n      return null;\n    }\n\n    let visibleRanges = [],\n        visibleRangesLen = 0;\n    const domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\n    let nextLineModelLineNumber = 0;\n\n    if (includeNewLines) {\n      nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(range.startLineNumber, 1)).lineNumber;\n    }\n\n    const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n    const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n    for (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n      if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n        continue;\n      }\n\n      const startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;\n      const endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);\n\n      const visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(lineNumber, startColumn, endColumn, domReadingContext);\n\n      if (!visibleRangesForLine) {\n        continue;\n      }\n\n      if (includeNewLines && lineNumber < originalEndLineNumber) {\n        const currentLineModelLineNumber = nextLineModelLineNumber;\n        nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber + 1, 1)).lineNumber;\n\n        if (currentLineModelLineNumber !== nextLineModelLineNumber) {\n          visibleRangesForLine.ranges[visibleRangesForLine.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth;\n        }\n      }\n\n      visibleRanges[visibleRangesLen++] = new LineVisibleRanges(visibleRangesForLine.outsideRenderedLine, lineNumber, HorizontalRange.from(visibleRangesForLine.ranges));\n    }\n\n    if (visibleRangesLen === 0) {\n      return null;\n    }\n\n    return visibleRanges;\n  }\n\n  _visibleRangesForLineRange(lineNumber, startColumn, endColumn) {\n    if (this.shouldRender()) {\n      // Cannot read from the DOM because it is dirty\n      // i.e. the model & the dom are out of sync, so I'd be reading something stale\n      return null;\n    }\n\n    if (lineNumber < this._visibleLines.getStartLineNumber() || lineNumber > this._visibleLines.getEndLineNumber()) {\n      return null;\n    }\n\n    return this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(lineNumber, startColumn, endColumn, new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot));\n  }\n\n  visibleRangeForPosition(position) {\n    const visibleRanges = this._visibleRangesForLineRange(position.lineNumber, position.column, position.column);\n\n    if (!visibleRanges) {\n      return null;\n    }\n\n    return new HorizontalPosition(visibleRanges.outsideRenderedLine, visibleRanges.ranges[0].left);\n  } // --- implementation\n\n\n  updateLineWidths() {\n    this._updateLineWidths(false);\n  }\n  /**\n   * Updates the max line width if it is fast to compute.\n   * Returns true if all lines were taken into account.\n   * Returns false if some lines need to be reevaluated (in a slow fashion).\n   */\n\n\n  _updateLineWidthsFast() {\n    return this._updateLineWidths(true);\n  }\n\n  _updateLineWidthsSlow() {\n    this._updateLineWidths(false);\n  }\n\n  _updateLineWidths(fast) {\n    const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n    const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n    let localMaxLineWidth = 1;\n    let allWidthsComputed = true;\n\n    for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n      const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n\n      if (fast && !visibleLine.getWidthIsFast()) {\n        // Cannot compute width in a fast way for this line\n        allWidthsComputed = false;\n        continue;\n      }\n\n      localMaxLineWidth = Math.max(localMaxLineWidth, visibleLine.getWidth());\n    }\n\n    if (allWidthsComputed && rendStartLineNumber === 1 && rendEndLineNumber === this._context.model.getLineCount()) {\n      // we know the max line width for all the lines\n      this._maxLineWidth = 0;\n    }\n\n    this._ensureMaxLineWidth(localMaxLineWidth);\n\n    return allWidthsComputed;\n  }\n\n  _checkMonospaceFontAssumptions() {\n    // Problems with monospace assumptions are more apparent for longer lines,\n    // as small rounding errors start to sum up, so we will select the longest\n    // line for a closer inspection\n    let longestLineNumber = -1;\n    let longestWidth = -1;\n\n    const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n    const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n    for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n      const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n\n      if (visibleLine.needsMonospaceFontCheck()) {\n        const lineWidth = visibleLine.getWidth();\n\n        if (lineWidth > longestWidth) {\n          longestWidth = lineWidth;\n          longestLineNumber = lineNumber;\n        }\n      }\n    }\n\n    if (longestLineNumber === -1) {\n      return;\n    }\n\n    if (!this._visibleLines.getVisibleLine(longestLineNumber).monospaceAssumptionsAreValid()) {\n      for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n        const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n\n        visibleLine.onMonospaceAssumptionsInvalidated();\n      }\n    }\n  }\n\n  prepareRender() {\n    throw new Error('Not supported');\n  }\n\n  render() {\n    throw new Error('Not supported');\n  }\n\n  renderText(viewportData) {\n    // (1) render lines - ensures lines are in the DOM\n    this._visibleLines.renderLines(viewportData);\n\n    this._lastRenderedData.setCurrentVisibleRange(viewportData.visibleRange);\n\n    this.domNode.setWidth(this._context.viewLayout.getScrollWidth());\n    this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1000000)); // (2) compute horizontal scroll position:\n    //  - this must happen after the lines are in the DOM since it might need a line that rendered just now\n    //  - it might change `scrollWidth` and `scrollLeft`\n\n    if (this._horizontalRevealRequest) {\n      const horizontalRevealRequest = this._horizontalRevealRequest; // Check that we have the line that contains the horizontal range in the viewport\n\n      if (viewportData.startLineNumber <= horizontalRevealRequest.minLineNumber && horizontalRevealRequest.maxLineNumber <= viewportData.endLineNumber) {\n        this._horizontalRevealRequest = null; // allow `visibleRangesForRange2` to work\n\n        this.onDidRender(); // compute new scroll position\n\n        const newScrollLeft = this._computeScrollLeftToReveal(horizontalRevealRequest);\n\n        if (newScrollLeft) {\n          if (!this._isViewportWrapping) {\n            // ensure `scrollWidth` is large enough\n            this._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset);\n          } // set `scrollLeft`\n\n\n          this._context.model.setScrollPosition({\n            scrollLeft: newScrollLeft.scrollLeft\n          }, horizontalRevealRequest.scrollType);\n        }\n      }\n    } // Update max line width (not so important, it is just so the horizontal scrollbar doesn't get too small)\n\n\n    if (!this._updateLineWidthsFast()) {\n      // Computing the width of some lines would be slow => delay it\n      this._asyncUpdateLineWidths.schedule();\n    }\n\n    if (platform.isLinux && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {\n      const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n      const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n      for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n        const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n\n        if (visibleLine.needsMonospaceFontCheck()) {\n          this._asyncCheckMonospaceFontAssumptions.schedule();\n\n          break;\n        }\n      }\n    } // (3) handle scrolling\n\n\n    this._linesContent.setLayerHinting(this._canUseLayerHinting);\n\n    this._linesContent.setContain('strict');\n\n    const adjustedScrollTop = this._context.viewLayout.getCurrentScrollTop() - viewportData.bigNumbersDelta;\n\n    this._linesContent.setTop(-adjustedScrollTop);\n\n    this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());\n  } // --- width\n\n\n  _ensureMaxLineWidth(lineWidth) {\n    const iLineWidth = Math.ceil(lineWidth);\n\n    if (this._maxLineWidth < iLineWidth) {\n      this._maxLineWidth = iLineWidth;\n\n      this._context.model.setMaxLineWidth(this._maxLineWidth);\n    }\n  }\n\n  _computeScrollTopToRevealRange(viewport, source, range, selections, verticalType) {\n    const viewportStartY = viewport.top;\n    const viewportHeight = viewport.height;\n    const viewportEndY = viewportStartY + viewportHeight;\n    let boxIsSingleRange;\n    let boxStartY;\n    let boxEndY; // Have a box that includes one extra line height (for the horizontal scrollbar)\n\n    if (selections && selections.length > 0) {\n      let minLineNumber = selections[0].startLineNumber;\n      let maxLineNumber = selections[0].endLineNumber;\n\n      for (let i = 1, len = selections.length; i < len; i++) {\n        const selection = selections[i];\n        minLineNumber = Math.min(minLineNumber, selection.startLineNumber);\n        maxLineNumber = Math.max(maxLineNumber, selection.endLineNumber);\n      }\n\n      boxIsSingleRange = false;\n      boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(minLineNumber);\n      boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(maxLineNumber) + this._lineHeight;\n    } else if (range) {\n      boxIsSingleRange = true;\n      boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.startLineNumber);\n      boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.endLineNumber) + this._lineHeight;\n    } else {\n      return -1;\n    }\n\n    const shouldIgnoreScrollOff = source === 'mouse' && this._cursorSurroundingLinesStyle === 'default';\n\n    if (!shouldIgnoreScrollOff) {\n      const context = Math.min(viewportHeight / this._lineHeight / 2, this._cursorSurroundingLines);\n      boxStartY -= context * this._lineHeight;\n      boxEndY += Math.max(0, context - 1) * this._lineHeight;\n    }\n\n    if (verticalType === 0\n    /* Simple */\n    || verticalType === 4\n    /* Bottom */\n    ) {\n      // Reveal one line more when the last line would be covered by the scrollbar - arrow down case or revealing a line explicitly at bottom\n      boxEndY += this._lineHeight;\n    }\n\n    let newScrollTop;\n\n    if (boxEndY - boxStartY > viewportHeight) {\n      // the box is larger than the viewport ... scroll to its top\n      if (!boxIsSingleRange) {\n        // do not reveal multiple cursors if there are more than fit the viewport\n        return -1;\n      }\n\n      newScrollTop = boxStartY;\n    } else if (verticalType === 5\n    /* NearTop */\n    || verticalType === 6\n    /* NearTopIfOutsideViewport */\n    ) {\n      if (verticalType === 6\n      /* NearTopIfOutsideViewport */\n      && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\n        // Box is already in the viewport... do nothing\n        newScrollTop = viewportStartY;\n      } else {\n        // We want a gap that is 20% of the viewport, but with a minimum of 5 lines\n        const desiredGapAbove = Math.max(5 * this._lineHeight, viewportHeight * 0.2); // Try to scroll just above the box with the desired gap\n\n        const desiredScrollTop = boxStartY - desiredGapAbove; // But ensure that the box is not pushed out of viewport\n\n        const minScrollTop = boxEndY - viewportHeight;\n        newScrollTop = Math.max(minScrollTop, desiredScrollTop);\n      }\n    } else if (verticalType === 1\n    /* Center */\n    || verticalType === 2\n    /* CenterIfOutsideViewport */\n    ) {\n      if (verticalType === 2\n      /* CenterIfOutsideViewport */\n      && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\n        // Box is already in the viewport... do nothing\n        newScrollTop = viewportStartY;\n      } else {\n        // Box is outside the viewport... center it\n        const boxMiddleY = (boxStartY + boxEndY) / 2;\n        newScrollTop = Math.max(0, boxMiddleY - viewportHeight / 2);\n      }\n    } else {\n      newScrollTop = this._computeMinimumScrolling(viewportStartY, viewportEndY, boxStartY, boxEndY, verticalType === 3\n      /* Top */\n      , verticalType === 4\n      /* Bottom */\n      );\n    }\n\n    return newScrollTop;\n  }\n\n  _computeScrollLeftToReveal(horizontalRevealRequest) {\n    const viewport = this._context.viewLayout.getCurrentViewport();\n\n    const viewportStartX = viewport.left;\n    const viewportEndX = viewportStartX + viewport.width;\n    let boxStartX = 1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    ;\n    let boxEndX = 0;\n\n    if (horizontalRevealRequest.type === 'range') {\n      const visibleRanges = this._visibleRangesForLineRange(horizontalRevealRequest.lineNumber, horizontalRevealRequest.startColumn, horizontalRevealRequest.endColumn);\n\n      if (!visibleRanges) {\n        return null;\n      }\n\n      for (const visibleRange of visibleRanges.ranges) {\n        boxStartX = Math.min(boxStartX, Math.round(visibleRange.left));\n        boxEndX = Math.max(boxEndX, Math.round(visibleRange.left + visibleRange.width));\n      }\n    } else {\n      for (const selection of horizontalRevealRequest.selections) {\n        if (selection.startLineNumber !== selection.endLineNumber) {\n          return null;\n        }\n\n        const visibleRanges = this._visibleRangesForLineRange(selection.startLineNumber, selection.startColumn, selection.endColumn);\n\n        if (!visibleRanges) {\n          return null;\n        }\n\n        for (const visibleRange of visibleRanges.ranges) {\n          boxStartX = Math.min(boxStartX, Math.round(visibleRange.left));\n          boxEndX = Math.max(boxEndX, Math.round(visibleRange.left + visibleRange.width));\n        }\n      }\n    }\n\n    boxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX);\n    boxEndX += this._revealHorizontalRightPadding;\n\n    if (horizontalRevealRequest.type === 'selections' && boxEndX - boxStartX > viewport.width) {\n      return null;\n    }\n\n    const newScrollLeft = this._computeMinimumScrolling(viewportStartX, viewportEndX, boxStartX, boxEndX);\n\n    return {\n      scrollLeft: newScrollLeft,\n      maxHorizontalOffset: boxEndX\n    };\n  }\n\n  _computeMinimumScrolling(viewportStart, viewportEnd, boxStart, boxEnd, revealAtStart, revealAtEnd) {\n    viewportStart = viewportStart | 0;\n    viewportEnd = viewportEnd | 0;\n    boxStart = boxStart | 0;\n    boxEnd = boxEnd | 0;\n    revealAtStart = !!revealAtStart;\n    revealAtEnd = !!revealAtEnd;\n    const viewportLength = viewportEnd - viewportStart;\n    const boxLength = boxEnd - boxStart;\n\n    if (boxLength < viewportLength) {\n      // The box would fit in the viewport\n      if (revealAtStart) {\n        return boxStart;\n      }\n\n      if (revealAtEnd) {\n        return Math.max(0, boxEnd - viewportLength);\n      }\n\n      if (boxStart < viewportStart) {\n        // The box is above the viewport\n        return boxStart;\n      } else if (boxEnd > viewportEnd) {\n        // The box is below the viewport\n        return Math.max(0, boxEnd - viewportLength);\n      }\n    } else {\n      // The box would not fit in the viewport\n      // Reveal the beginning of the box\n      return boxStart;\n    }\n\n    return viewportStart;\n  }\n\n}\n/**\n * Adds this amount of pixels to the right of lines (no-one wants to type near the edge of the viewport)\n */\n\nViewLines.HORIZONTAL_EXTRA_PX = 30;","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lines/viewLines.js"],"names":["platform","RunOnceScheduler","Configuration","VisibleLinesCollection","PartFingerprints","ViewPart","DomReadingContext","ViewLine","ViewLineOptions","Position","Range","LineVisibleRanges","HorizontalPosition","HorizontalRange","MOUSE_CURSOR_TEXT_CSS_CLASS_NAME","LastRenderedData","constructor","_currentVisibleRange","getCurrentVisibleRange","setCurrentVisibleRange","currentVisibleRange","HorizontalRevealRangeRequest","lineNumber","startColumn","endColumn","startScrollTop","stopScrollTop","scrollType","type","minLineNumber","maxLineNumber","HorizontalRevealSelectionsRequest","selections","startLineNumber","endLineNumber","i","len","length","selection","Math","min","max","ViewLines","context","linesContent","_linesContent","_textRangeRestingSpot","document","createElement","_visibleLines","domNode","conf","_context","configuration","options","fontInfo","get","wrappingInfo","_lineHeight","_typicalHalfwidthCharacterWidth","typicalHalfwidthCharacterWidth","_isViewportWrapping","isViewportWrapping","_revealHorizontalRightPadding","_cursorSurroundingLines","_cursorSurroundingLinesStyle","_canUseLayerHinting","_viewLineOptions","theme","write","setClassName","applyFontInfo","_maxLineWidth","_asyncUpdateLineWidths","_updateLineWidthsSlow","_asyncCheckMonospaceFontAssumptions","_checkMonospaceFontAssumptions","_lastRenderedData","_horizontalRevealRequest","dispose","getDomNode","createVisibleLine","onConfigurationChanged","e","hasChanged","_onOptionsMaybeChanged","newViewLineOptions","equals","getStartLineNumber","getEndLineNumber","line","getVisibleLine","onOptionsChanged","onCursorStateChanged","rendStartLineNumber","rendEndLineNumber","r","onSelectionChanged","onDecorationsChanged","onFlushed","shouldRender","onLinesChanged","onLinesDeleted","onLinesInserted","onRevealRangeRequest","desiredScrollTop","_computeScrollTopToRevealRange","viewLayout","getFutureViewport","source","range","verticalType","newScrollPosition","validateScrollPosition","scrollTop","revealHorizontal","scrollLeft","getCurrentScrollTop","scrollTopDelta","abs","model","setScrollPosition","onScrollChanged","scrollLeftChanged","scrollTopChanged","setWidth","scrollWidth","onTokensChanged","onZonesChanged","setMaxLineWidth","onThemeChanged","getPositionFromDOMInfo","spanNode","offset","viewLineDomNode","_getViewLineDomNode","_getLineNumberFor","getLineCount","getLineMaxColumn","column","getColumnOfNodeOffset","minColumn","getLineMinColumn","node","nodeType","className","CLASS_NAME","parentElement","getLineWidth","getWidth","linesVisibleRangesForRange","_range","includeNewLines","originalEndLineNumber","intersectRanges","visibleRanges","visibleRangesLen","domReadingContext","nextLineModelLineNumber","coordinatesConverter","convertViewPositionToModelPosition","visibleRangesForLine","getVisibleRangesForRange","currentLineModelLineNumber","ranges","width","outsideRenderedLine","from","_visibleRangesForLineRange","visibleRangeForPosition","position","left","updateLineWidths","_updateLineWidths","_updateLineWidthsFast","fast","localMaxLineWidth","allWidthsComputed","visibleLine","getWidthIsFast","_ensureMaxLineWidth","longestLineNumber","longestWidth","needsMonospaceFontCheck","lineWidth","monospaceAssumptionsAreValid","onMonospaceAssumptionsInvalidated","prepareRender","Error","render","renderText","viewportData","renderLines","visibleRange","getScrollWidth","setHeight","getScrollHeight","horizontalRevealRequest","onDidRender","newScrollLeft","_computeScrollLeftToReveal","maxHorizontalOffset","schedule","isLinux","isScheduled","setLayerHinting","setContain","adjustedScrollTop","bigNumbersDelta","setTop","setLeft","getCurrentScrollLeft","iLineWidth","ceil","viewport","viewportStartY","top","viewportHeight","height","viewportEndY","boxIsSingleRange","boxStartY","boxEndY","getVerticalOffsetForLineNumber","shouldIgnoreScrollOff","newScrollTop","desiredGapAbove","minScrollTop","boxMiddleY","_computeMinimumScrolling","getCurrentViewport","viewportStartX","viewportEndX","boxStartX","boxEndX","round","HORIZONTAL_EXTRA_PX","viewportStart","viewportEnd","boxStart","boxEnd","revealAtStart","revealAtEnd","viewportLength","boxLength"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './viewLines.css';\nimport * as platform from '../../../../base/common/platform.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { Configuration } from '../../config/configuration.js';\nimport { VisibleLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { DomReadingContext, ViewLine, ViewLineOptions } from './viewLine.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { LineVisibleRanges, HorizontalPosition, HorizontalRange } from '../../../common/view/renderingContext.js';\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../../base/browser/ui/mouseCursor/mouseCursor.js';\nclass LastRenderedData {\n    constructor() {\n        this._currentVisibleRange = new Range(1, 1, 1, 1);\n    }\n    getCurrentVisibleRange() {\n        return this._currentVisibleRange;\n    }\n    setCurrentVisibleRange(currentVisibleRange) {\n        this._currentVisibleRange = currentVisibleRange;\n    }\n}\nclass HorizontalRevealRangeRequest {\n    constructor(lineNumber, startColumn, endColumn, startScrollTop, stopScrollTop, scrollType) {\n        this.lineNumber = lineNumber;\n        this.startColumn = startColumn;\n        this.endColumn = endColumn;\n        this.startScrollTop = startScrollTop;\n        this.stopScrollTop = stopScrollTop;\n        this.scrollType = scrollType;\n        this.type = 'range';\n        this.minLineNumber = lineNumber;\n        this.maxLineNumber = lineNumber;\n    }\n}\nclass HorizontalRevealSelectionsRequest {\n    constructor(selections, startScrollTop, stopScrollTop, scrollType) {\n        this.selections = selections;\n        this.startScrollTop = startScrollTop;\n        this.stopScrollTop = stopScrollTop;\n        this.scrollType = scrollType;\n        this.type = 'selections';\n        let minLineNumber = selections[0].startLineNumber;\n        let maxLineNumber = selections[0].endLineNumber;\n        for (let i = 1, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            minLineNumber = Math.min(minLineNumber, selection.startLineNumber);\n            maxLineNumber = Math.max(maxLineNumber, selection.endLineNumber);\n        }\n        this.minLineNumber = minLineNumber;\n        this.maxLineNumber = maxLineNumber;\n    }\n}\nexport class ViewLines extends ViewPart {\n    constructor(context, linesContent) {\n        super(context);\n        this._linesContent = linesContent;\n        this._textRangeRestingSpot = document.createElement('div');\n        this._visibleLines = new VisibleLinesCollection(this);\n        this.domNode = this._visibleLines.domNode;\n        const conf = this._context.configuration;\n        const options = this._context.configuration.options;\n        const fontInfo = options.get(43 /* fontInfo */);\n        const wrappingInfo = options.get(130 /* wrappingInfo */);\n        this._lineHeight = options.get(58 /* lineHeight */);\n        this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this._isViewportWrapping = wrappingInfo.isViewportWrapping;\n        this._revealHorizontalRightPadding = options.get(88 /* revealHorizontalRightPadding */);\n        this._cursorSurroundingLines = options.get(25 /* cursorSurroundingLines */);\n        this._cursorSurroundingLinesStyle = options.get(26 /* cursorSurroundingLinesStyle */);\n        this._canUseLayerHinting = !options.get(28 /* disableLayerHinting */);\n        this._viewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\n        PartFingerprints.write(this.domNode, 7 /* ViewLines */);\n        this.domNode.setClassName(`view-lines ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);\n        Configuration.applyFontInfo(this.domNode, fontInfo);\n        // --- width & height\n        this._maxLineWidth = 0;\n        this._asyncUpdateLineWidths = new RunOnceScheduler(() => {\n            this._updateLineWidthsSlow();\n        }, 200);\n        this._asyncCheckMonospaceFontAssumptions = new RunOnceScheduler(() => {\n            this._checkMonospaceFontAssumptions();\n        }, 2000);\n        this._lastRenderedData = new LastRenderedData();\n        this._horizontalRevealRequest = null;\n    }\n    dispose() {\n        this._asyncUpdateLineWidths.dispose();\n        this._asyncCheckMonospaceFontAssumptions.dispose();\n        super.dispose();\n    }\n    getDomNode() {\n        return this.domNode;\n    }\n    // ---- begin IVisibleLinesHost\n    createVisibleLine() {\n        return new ViewLine(this._viewLineOptions);\n    }\n    // ---- end IVisibleLinesHost\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        this._visibleLines.onConfigurationChanged(e);\n        if (e.hasChanged(130 /* wrappingInfo */)) {\n            this._maxLineWidth = 0;\n        }\n        const options = this._context.configuration.options;\n        const fontInfo = options.get(43 /* fontInfo */);\n        const wrappingInfo = options.get(130 /* wrappingInfo */);\n        this._lineHeight = options.get(58 /* lineHeight */);\n        this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this._isViewportWrapping = wrappingInfo.isViewportWrapping;\n        this._revealHorizontalRightPadding = options.get(88 /* revealHorizontalRightPadding */);\n        this._cursorSurroundingLines = options.get(25 /* cursorSurroundingLines */);\n        this._cursorSurroundingLinesStyle = options.get(26 /* cursorSurroundingLinesStyle */);\n        this._canUseLayerHinting = !options.get(28 /* disableLayerHinting */);\n        Configuration.applyFontInfo(this.domNode, fontInfo);\n        this._onOptionsMaybeChanged();\n        if (e.hasChanged(129 /* layoutInfo */)) {\n            this._maxLineWidth = 0;\n        }\n        return true;\n    }\n    _onOptionsMaybeChanged() {\n        const conf = this._context.configuration;\n        const newViewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\n        if (!this._viewLineOptions.equals(newViewLineOptions)) {\n            this._viewLineOptions = newViewLineOptions;\n            const startLineNumber = this._visibleLines.getStartLineNumber();\n            const endLineNumber = this._visibleLines.getEndLineNumber();\n            for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n                const line = this._visibleLines.getVisibleLine(lineNumber);\n                line.onOptionsChanged(this._viewLineOptions);\n            }\n            return true;\n        }\n        return false;\n    }\n    onCursorStateChanged(e) {\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        let r = false;\n        for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n            r = this._visibleLines.getVisibleLine(lineNumber).onSelectionChanged() || r;\n        }\n        return r;\n    }\n    onDecorationsChanged(e) {\n        if (true /*e.inlineDecorationsChanged*/) {\n            const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n            const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n            for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n                this._visibleLines.getVisibleLine(lineNumber).onDecorationsChanged();\n            }\n        }\n        return true;\n    }\n    onFlushed(e) {\n        const shouldRender = this._visibleLines.onFlushed(e);\n        this._maxLineWidth = 0;\n        return shouldRender;\n    }\n    onLinesChanged(e) {\n        return this._visibleLines.onLinesChanged(e);\n    }\n    onLinesDeleted(e) {\n        return this._visibleLines.onLinesDeleted(e);\n    }\n    onLinesInserted(e) {\n        return this._visibleLines.onLinesInserted(e);\n    }\n    onRevealRangeRequest(e) {\n        // Using the future viewport here in order to handle multiple\n        // incoming reveal range requests that might all desire to be animated\n        const desiredScrollTop = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.range, e.selections, e.verticalType);\n        if (desiredScrollTop === -1) {\n            // marker to abort the reveal range request\n            return false;\n        }\n        // validate the new desired scroll top\n        let newScrollPosition = this._context.viewLayout.validateScrollPosition({ scrollTop: desiredScrollTop });\n        if (e.revealHorizontal) {\n            if (e.range && e.range.startLineNumber !== e.range.endLineNumber) {\n                // Two or more lines? => scroll to base (That's how you see most of the two lines)\n                newScrollPosition = {\n                    scrollTop: newScrollPosition.scrollTop,\n                    scrollLeft: 0\n                };\n            }\n            else if (e.range) {\n                // We don't necessarily know the horizontal offset of this range since the line might not be in the view...\n                this._horizontalRevealRequest = new HorizontalRevealRangeRequest(e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\n            }\n            else if (e.selections && e.selections.length > 0) {\n                this._horizontalRevealRequest = new HorizontalRevealSelectionsRequest(e.selections, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\n            }\n        }\n        else {\n            this._horizontalRevealRequest = null;\n        }\n        const scrollTopDelta = Math.abs(this._context.viewLayout.getCurrentScrollTop() - newScrollPosition.scrollTop);\n        const scrollType = (scrollTopDelta <= this._lineHeight ? 1 /* Immediate */ : e.scrollType);\n        this._context.model.setScrollPosition(newScrollPosition, scrollType);\n        return true;\n    }\n    onScrollChanged(e) {\n        if (this._horizontalRevealRequest && e.scrollLeftChanged) {\n            // cancel any outstanding horizontal reveal request if someone else scrolls horizontally.\n            this._horizontalRevealRequest = null;\n        }\n        if (this._horizontalRevealRequest && e.scrollTopChanged) {\n            const min = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n            const max = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n            if (e.scrollTop < min || e.scrollTop > max) {\n                // cancel any outstanding horizontal reveal request if someone else scrolls vertically.\n                this._horizontalRevealRequest = null;\n            }\n        }\n        this.domNode.setWidth(e.scrollWidth);\n        return this._visibleLines.onScrollChanged(e) || true;\n    }\n    onTokensChanged(e) {\n        return this._visibleLines.onTokensChanged(e);\n    }\n    onZonesChanged(e) {\n        this._context.model.setMaxLineWidth(this._maxLineWidth);\n        return this._visibleLines.onZonesChanged(e);\n    }\n    onThemeChanged(e) {\n        return this._onOptionsMaybeChanged();\n    }\n    // ---- end view event handlers\n    // ----------- HELPERS FOR OTHERS\n    getPositionFromDOMInfo(spanNode, offset) {\n        const viewLineDomNode = this._getViewLineDomNode(spanNode);\n        if (viewLineDomNode === null) {\n            // Couldn't find view line node\n            return null;\n        }\n        const lineNumber = this._getLineNumberFor(viewLineDomNode);\n        if (lineNumber === -1) {\n            // Couldn't find view line node\n            return null;\n        }\n        if (lineNumber < 1 || lineNumber > this._context.model.getLineCount()) {\n            // lineNumber is outside range\n            return null;\n        }\n        if (this._context.model.getLineMaxColumn(lineNumber) === 1) {\n            // Line is empty\n            return new Position(lineNumber, 1);\n        }\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n            // Couldn't find line\n            return null;\n        }\n        let column = this._visibleLines.getVisibleLine(lineNumber).getColumnOfNodeOffset(lineNumber, spanNode, offset);\n        const minColumn = this._context.model.getLineMinColumn(lineNumber);\n        if (column < minColumn) {\n            column = minColumn;\n        }\n        return new Position(lineNumber, column);\n    }\n    _getViewLineDomNode(node) {\n        while (node && node.nodeType === 1) {\n            if (node.className === ViewLine.CLASS_NAME) {\n                return node;\n            }\n            node = node.parentElement;\n        }\n        return null;\n    }\n    /**\n     * @returns the line number of this view line dom node.\n     */\n    _getLineNumberFor(domNode) {\n        const startLineNumber = this._visibleLines.getStartLineNumber();\n        const endLineNumber = this._visibleLines.getEndLineNumber();\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const line = this._visibleLines.getVisibleLine(lineNumber);\n            if (domNode === line.getDomNode()) {\n                return lineNumber;\n            }\n        }\n        return -1;\n    }\n    getLineWidth(lineNumber) {\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n            // Couldn't find line\n            return -1;\n        }\n        return this._visibleLines.getVisibleLine(lineNumber).getWidth();\n    }\n    linesVisibleRangesForRange(_range, includeNewLines) {\n        if (this.shouldRender()) {\n            // Cannot read from the DOM because it is dirty\n            // i.e. the model & the dom are out of sync, so I'd be reading something stale\n            return null;\n        }\n        const originalEndLineNumber = _range.endLineNumber;\n        const range = Range.intersectRanges(_range, this._lastRenderedData.getCurrentVisibleRange());\n        if (!range) {\n            return null;\n        }\n        let visibleRanges = [], visibleRangesLen = 0;\n        const domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\n        let nextLineModelLineNumber = 0;\n        if (includeNewLines) {\n            nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(range.startLineNumber, 1)).lineNumber;\n        }\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        for (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n            if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n                continue;\n            }\n            const startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;\n            const endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);\n            const visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(lineNumber, startColumn, endColumn, domReadingContext);\n            if (!visibleRangesForLine) {\n                continue;\n            }\n            if (includeNewLines && lineNumber < originalEndLineNumber) {\n                const currentLineModelLineNumber = nextLineModelLineNumber;\n                nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber + 1, 1)).lineNumber;\n                if (currentLineModelLineNumber !== nextLineModelLineNumber) {\n                    visibleRangesForLine.ranges[visibleRangesForLine.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth;\n                }\n            }\n            visibleRanges[visibleRangesLen++] = new LineVisibleRanges(visibleRangesForLine.outsideRenderedLine, lineNumber, HorizontalRange.from(visibleRangesForLine.ranges));\n        }\n        if (visibleRangesLen === 0) {\n            return null;\n        }\n        return visibleRanges;\n    }\n    _visibleRangesForLineRange(lineNumber, startColumn, endColumn) {\n        if (this.shouldRender()) {\n            // Cannot read from the DOM because it is dirty\n            // i.e. the model & the dom are out of sync, so I'd be reading something stale\n            return null;\n        }\n        if (lineNumber < this._visibleLines.getStartLineNumber() || lineNumber > this._visibleLines.getEndLineNumber()) {\n            return null;\n        }\n        return this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(lineNumber, startColumn, endColumn, new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot));\n    }\n    visibleRangeForPosition(position) {\n        const visibleRanges = this._visibleRangesForLineRange(position.lineNumber, position.column, position.column);\n        if (!visibleRanges) {\n            return null;\n        }\n        return new HorizontalPosition(visibleRanges.outsideRenderedLine, visibleRanges.ranges[0].left);\n    }\n    // --- implementation\n    updateLineWidths() {\n        this._updateLineWidths(false);\n    }\n    /**\n     * Updates the max line width if it is fast to compute.\n     * Returns true if all lines were taken into account.\n     * Returns false if some lines need to be reevaluated (in a slow fashion).\n     */\n    _updateLineWidthsFast() {\n        return this._updateLineWidths(true);\n    }\n    _updateLineWidthsSlow() {\n        this._updateLineWidths(false);\n    }\n    _updateLineWidths(fast) {\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        let localMaxLineWidth = 1;\n        let allWidthsComputed = true;\n        for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n            const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n            if (fast && !visibleLine.getWidthIsFast()) {\n                // Cannot compute width in a fast way for this line\n                allWidthsComputed = false;\n                continue;\n            }\n            localMaxLineWidth = Math.max(localMaxLineWidth, visibleLine.getWidth());\n        }\n        if (allWidthsComputed && rendStartLineNumber === 1 && rendEndLineNumber === this._context.model.getLineCount()) {\n            // we know the max line width for all the lines\n            this._maxLineWidth = 0;\n        }\n        this._ensureMaxLineWidth(localMaxLineWidth);\n        return allWidthsComputed;\n    }\n    _checkMonospaceFontAssumptions() {\n        // Problems with monospace assumptions are more apparent for longer lines,\n        // as small rounding errors start to sum up, so we will select the longest\n        // line for a closer inspection\n        let longestLineNumber = -1;\n        let longestWidth = -1;\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n            const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n            if (visibleLine.needsMonospaceFontCheck()) {\n                const lineWidth = visibleLine.getWidth();\n                if (lineWidth > longestWidth) {\n                    longestWidth = lineWidth;\n                    longestLineNumber = lineNumber;\n                }\n            }\n        }\n        if (longestLineNumber === -1) {\n            return;\n        }\n        if (!this._visibleLines.getVisibleLine(longestLineNumber).monospaceAssumptionsAreValid()) {\n            for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n                const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n                visibleLine.onMonospaceAssumptionsInvalidated();\n            }\n        }\n    }\n    prepareRender() {\n        throw new Error('Not supported');\n    }\n    render() {\n        throw new Error('Not supported');\n    }\n    renderText(viewportData) {\n        // (1) render lines - ensures lines are in the DOM\n        this._visibleLines.renderLines(viewportData);\n        this._lastRenderedData.setCurrentVisibleRange(viewportData.visibleRange);\n        this.domNode.setWidth(this._context.viewLayout.getScrollWidth());\n        this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1000000));\n        // (2) compute horizontal scroll position:\n        //  - this must happen after the lines are in the DOM since it might need a line that rendered just now\n        //  - it might change `scrollWidth` and `scrollLeft`\n        if (this._horizontalRevealRequest) {\n            const horizontalRevealRequest = this._horizontalRevealRequest;\n            // Check that we have the line that contains the horizontal range in the viewport\n            if (viewportData.startLineNumber <= horizontalRevealRequest.minLineNumber && horizontalRevealRequest.maxLineNumber <= viewportData.endLineNumber) {\n                this._horizontalRevealRequest = null;\n                // allow `visibleRangesForRange2` to work\n                this.onDidRender();\n                // compute new scroll position\n                const newScrollLeft = this._computeScrollLeftToReveal(horizontalRevealRequest);\n                if (newScrollLeft) {\n                    if (!this._isViewportWrapping) {\n                        // ensure `scrollWidth` is large enough\n                        this._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset);\n                    }\n                    // set `scrollLeft`\n                    this._context.model.setScrollPosition({\n                        scrollLeft: newScrollLeft.scrollLeft\n                    }, horizontalRevealRequest.scrollType);\n                }\n            }\n        }\n        // Update max line width (not so important, it is just so the horizontal scrollbar doesn't get too small)\n        if (!this._updateLineWidthsFast()) {\n            // Computing the width of some lines would be slow => delay it\n            this._asyncUpdateLineWidths.schedule();\n        }\n        if (platform.isLinux && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {\n            const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n            const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n            for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n                const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n                if (visibleLine.needsMonospaceFontCheck()) {\n                    this._asyncCheckMonospaceFontAssumptions.schedule();\n                    break;\n                }\n            }\n        }\n        // (3) handle scrolling\n        this._linesContent.setLayerHinting(this._canUseLayerHinting);\n        this._linesContent.setContain('strict');\n        const adjustedScrollTop = this._context.viewLayout.getCurrentScrollTop() - viewportData.bigNumbersDelta;\n        this._linesContent.setTop(-adjustedScrollTop);\n        this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());\n    }\n    // --- width\n    _ensureMaxLineWidth(lineWidth) {\n        const iLineWidth = Math.ceil(lineWidth);\n        if (this._maxLineWidth < iLineWidth) {\n            this._maxLineWidth = iLineWidth;\n            this._context.model.setMaxLineWidth(this._maxLineWidth);\n        }\n    }\n    _computeScrollTopToRevealRange(viewport, source, range, selections, verticalType) {\n        const viewportStartY = viewport.top;\n        const viewportHeight = viewport.height;\n        const viewportEndY = viewportStartY + viewportHeight;\n        let boxIsSingleRange;\n        let boxStartY;\n        let boxEndY;\n        // Have a box that includes one extra line height (for the horizontal scrollbar)\n        if (selections && selections.length > 0) {\n            let minLineNumber = selections[0].startLineNumber;\n            let maxLineNumber = selections[0].endLineNumber;\n            for (let i = 1, len = selections.length; i < len; i++) {\n                const selection = selections[i];\n                minLineNumber = Math.min(minLineNumber, selection.startLineNumber);\n                maxLineNumber = Math.max(maxLineNumber, selection.endLineNumber);\n            }\n            boxIsSingleRange = false;\n            boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(minLineNumber);\n            boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(maxLineNumber) + this._lineHeight;\n        }\n        else if (range) {\n            boxIsSingleRange = true;\n            boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.startLineNumber);\n            boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.endLineNumber) + this._lineHeight;\n        }\n        else {\n            return -1;\n        }\n        const shouldIgnoreScrollOff = source === 'mouse' && this._cursorSurroundingLinesStyle === 'default';\n        if (!shouldIgnoreScrollOff) {\n            const context = Math.min((viewportHeight / this._lineHeight) / 2, this._cursorSurroundingLines);\n            boxStartY -= context * this._lineHeight;\n            boxEndY += Math.max(0, (context - 1)) * this._lineHeight;\n        }\n        if (verticalType === 0 /* Simple */ || verticalType === 4 /* Bottom */) {\n            // Reveal one line more when the last line would be covered by the scrollbar - arrow down case or revealing a line explicitly at bottom\n            boxEndY += this._lineHeight;\n        }\n        let newScrollTop;\n        if (boxEndY - boxStartY > viewportHeight) {\n            // the box is larger than the viewport ... scroll to its top\n            if (!boxIsSingleRange) {\n                // do not reveal multiple cursors if there are more than fit the viewport\n                return -1;\n            }\n            newScrollTop = boxStartY;\n        }\n        else if (verticalType === 5 /* NearTop */ || verticalType === 6 /* NearTopIfOutsideViewport */) {\n            if (verticalType === 6 /* NearTopIfOutsideViewport */ && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\n                // Box is already in the viewport... do nothing\n                newScrollTop = viewportStartY;\n            }\n            else {\n                // We want a gap that is 20% of the viewport, but with a minimum of 5 lines\n                const desiredGapAbove = Math.max(5 * this._lineHeight, viewportHeight * 0.2);\n                // Try to scroll just above the box with the desired gap\n                const desiredScrollTop = boxStartY - desiredGapAbove;\n                // But ensure that the box is not pushed out of viewport\n                const minScrollTop = boxEndY - viewportHeight;\n                newScrollTop = Math.max(minScrollTop, desiredScrollTop);\n            }\n        }\n        else if (verticalType === 1 /* Center */ || verticalType === 2 /* CenterIfOutsideViewport */) {\n            if (verticalType === 2 /* CenterIfOutsideViewport */ && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\n                // Box is already in the viewport... do nothing\n                newScrollTop = viewportStartY;\n            }\n            else {\n                // Box is outside the viewport... center it\n                const boxMiddleY = (boxStartY + boxEndY) / 2;\n                newScrollTop = Math.max(0, boxMiddleY - viewportHeight / 2);\n            }\n        }\n        else {\n            newScrollTop = this._computeMinimumScrolling(viewportStartY, viewportEndY, boxStartY, boxEndY, verticalType === 3 /* Top */, verticalType === 4 /* Bottom */);\n        }\n        return newScrollTop;\n    }\n    _computeScrollLeftToReveal(horizontalRevealRequest) {\n        const viewport = this._context.viewLayout.getCurrentViewport();\n        const viewportStartX = viewport.left;\n        const viewportEndX = viewportStartX + viewport.width;\n        let boxStartX = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n        let boxEndX = 0;\n        if (horizontalRevealRequest.type === 'range') {\n            const visibleRanges = this._visibleRangesForLineRange(horizontalRevealRequest.lineNumber, horizontalRevealRequest.startColumn, horizontalRevealRequest.endColumn);\n            if (!visibleRanges) {\n                return null;\n            }\n            for (const visibleRange of visibleRanges.ranges) {\n                boxStartX = Math.min(boxStartX, Math.round(visibleRange.left));\n                boxEndX = Math.max(boxEndX, Math.round(visibleRange.left + visibleRange.width));\n            }\n        }\n        else {\n            for (const selection of horizontalRevealRequest.selections) {\n                if (selection.startLineNumber !== selection.endLineNumber) {\n                    return null;\n                }\n                const visibleRanges = this._visibleRangesForLineRange(selection.startLineNumber, selection.startColumn, selection.endColumn);\n                if (!visibleRanges) {\n                    return null;\n                }\n                for (const visibleRange of visibleRanges.ranges) {\n                    boxStartX = Math.min(boxStartX, Math.round(visibleRange.left));\n                    boxEndX = Math.max(boxEndX, Math.round(visibleRange.left + visibleRange.width));\n                }\n            }\n        }\n        boxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX);\n        boxEndX += this._revealHorizontalRightPadding;\n        if (horizontalRevealRequest.type === 'selections' && boxEndX - boxStartX > viewport.width) {\n            return null;\n        }\n        const newScrollLeft = this._computeMinimumScrolling(viewportStartX, viewportEndX, boxStartX, boxEndX);\n        return {\n            scrollLeft: newScrollLeft,\n            maxHorizontalOffset: boxEndX\n        };\n    }\n    _computeMinimumScrolling(viewportStart, viewportEnd, boxStart, boxEnd, revealAtStart, revealAtEnd) {\n        viewportStart = viewportStart | 0;\n        viewportEnd = viewportEnd | 0;\n        boxStart = boxStart | 0;\n        boxEnd = boxEnd | 0;\n        revealAtStart = !!revealAtStart;\n        revealAtEnd = !!revealAtEnd;\n        const viewportLength = viewportEnd - viewportStart;\n        const boxLength = boxEnd - boxStart;\n        if (boxLength < viewportLength) {\n            // The box would fit in the viewport\n            if (revealAtStart) {\n                return boxStart;\n            }\n            if (revealAtEnd) {\n                return Math.max(0, boxEnd - viewportLength);\n            }\n            if (boxStart < viewportStart) {\n                // The box is above the viewport\n                return boxStart;\n            }\n            else if (boxEnd > viewportEnd) {\n                // The box is below the viewport\n                return Math.max(0, boxEnd - viewportLength);\n            }\n        }\n        else {\n            // The box would not fit in the viewport\n            // Reveal the beginning of the box\n            return boxStart;\n        }\n        return viewportStart;\n    }\n}\n/**\n * Adds this amount of pixels to the right of lines (no-one wants to type near the edge of the viewport)\n */\nViewLines.HORIZONTAL_EXTRA_PX = 30;\n"]},"metadata":{},"sourceType":"module"}