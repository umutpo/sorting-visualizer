{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { LineTokens } from '../core/lineTokens.js';\nimport { NULL_STATE, nullTokenize2 } from './nullMode.js';\nconst fallback = {\n  getInitialState: () => NULL_STATE,\n  tokenize2: (buffer, hasEOL, state, deltaOffset) => nullTokenize2(0\n  /* Null */\n  , buffer, state, deltaOffset)\n};\nexport function tokenizeToString(text, languageIdCodec) {\n  let tokenizationSupport = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : fallback;\n  return _tokenizeToString(text, languageIdCodec, tokenizationSupport || fallback);\n}\nexport function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize, useNbsp) {\n  let result = `<div>`;\n  let charIndex = startOffset;\n  let tabsCharDelta = 0;\n  let prevIsSpace = true;\n\n  for (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {\n    const tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n\n    if (tokenEndIndex <= startOffset) {\n      continue;\n    }\n\n    let partContent = '';\n\n    for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {\n      const charCode = text.charCodeAt(charIndex);\n\n      switch (charCode) {\n        case 9\n        /* Tab */\n        :\n          let insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n          tabsCharDelta += insertSpacesCount - 1;\n\n          while (insertSpacesCount > 0) {\n            if (useNbsp && prevIsSpace) {\n              partContent += '&#160;';\n              prevIsSpace = false;\n            } else {\n              partContent += ' ';\n              prevIsSpace = true;\n            }\n\n            insertSpacesCount--;\n          }\n\n          break;\n\n        case 60\n        /* LessThan */\n        :\n          partContent += '&lt;';\n          prevIsSpace = false;\n          break;\n\n        case 62\n        /* GreaterThan */\n        :\n          partContent += '&gt;';\n          prevIsSpace = false;\n          break;\n\n        case 38\n        /* Ampersand */\n        :\n          partContent += '&amp;';\n          prevIsSpace = false;\n          break;\n\n        case 0\n        /* Null */\n        :\n          partContent += '&#00;';\n          prevIsSpace = false;\n          break;\n\n        case 65279\n        /* UTF8_BOM */\n        :\n        case 8232\n        /* LINE_SEPARATOR */\n        :\n        case 8233\n        /* PARAGRAPH_SEPARATOR */\n        :\n        case 133\n        /* NEXT_LINE */\n        :\n          partContent += '\\ufffd';\n          prevIsSpace = false;\n          break;\n\n        case 13\n        /* CarriageReturn */\n        :\n          // zero width space, because carriage return would introduce a line break\n          partContent += '&#8203';\n          prevIsSpace = false;\n          break;\n\n        case 32\n        /* Space */\n        :\n          if (useNbsp && prevIsSpace) {\n            partContent += '&#160;';\n            prevIsSpace = false;\n          } else {\n            partContent += ' ';\n            prevIsSpace = true;\n          }\n\n          break;\n\n        default:\n          partContent += String.fromCharCode(charCode);\n          prevIsSpace = false;\n      }\n    }\n\n    result += `<span style=\"${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}\">${partContent}</span>`;\n\n    if (tokenEndIndex > endOffset || charIndex >= endOffset) {\n      break;\n    }\n  }\n\n  result += `</div>`;\n  return result;\n}\n\nfunction _tokenizeToString(text, languageIdCodec, tokenizationSupport) {\n  let result = `<div class=\"monaco-tokenized-source\">`;\n  const lines = strings.splitLines(text);\n  let currentState = tokenizationSupport.getInitialState();\n\n  for (let i = 0, len = lines.length; i < len; i++) {\n    const line = lines[i];\n\n    if (i > 0) {\n      result += `<br/>`;\n    }\n\n    const tokenizationResult = tokenizationSupport.tokenize2(line, true, currentState, 0);\n    LineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n    const lineTokens = new LineTokens(tokenizationResult.tokens, line, languageIdCodec);\n    const viewLineTokens = lineTokens.inflate();\n    let startOffset = 0;\n\n    for (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n      const type = viewLineTokens.getClassName(j);\n      const endIndex = viewLineTokens.getEndOffset(j);\n      result += `<span class=\"${type}\">${strings.escape(line.substring(startOffset, endIndex))}</span>`;\n      startOffset = endIndex;\n    }\n\n    currentState = tokenizationResult.endState;\n  }\n\n  result += `</div>`;\n  return result;\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/common/modes/textToHtmlTokenizer.js"],"names":["strings","LineTokens","NULL_STATE","nullTokenize2","fallback","getInitialState","tokenize2","buffer","hasEOL","state","deltaOffset","tokenizeToString","text","languageIdCodec","tokenizationSupport","_tokenizeToString","tokenizeLineToHTML","viewLineTokens","colorMap","startOffset","endOffset","tabSize","useNbsp","result","charIndex","tabsCharDelta","prevIsSpace","tokenIndex","tokenCount","getCount","tokenEndIndex","getEndOffset","partContent","charCode","charCodeAt","insertSpacesCount","String","fromCharCode","getInlineStyle","lines","splitLines","currentState","i","len","length","line","tokenizationResult","convertToEndOffset","tokens","lineTokens","inflate","j","lenJ","type","getClassName","endIndex","escape","substring","endState"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { LineTokens } from '../core/lineTokens.js';\nimport { NULL_STATE, nullTokenize2 } from './nullMode.js';\nconst fallback = {\n    getInitialState: () => NULL_STATE,\n    tokenize2: (buffer, hasEOL, state, deltaOffset) => nullTokenize2(0 /* Null */, buffer, state, deltaOffset)\n};\nexport function tokenizeToString(text, languageIdCodec, tokenizationSupport = fallback) {\n    return _tokenizeToString(text, languageIdCodec, tokenizationSupport || fallback);\n}\nexport function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize, useNbsp) {\n    let result = `<div>`;\n    let charIndex = startOffset;\n    let tabsCharDelta = 0;\n    let prevIsSpace = true;\n    for (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {\n        const tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n        if (tokenEndIndex <= startOffset) {\n            continue;\n        }\n        let partContent = '';\n        for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {\n            const charCode = text.charCodeAt(charIndex);\n            switch (charCode) {\n                case 9 /* Tab */:\n                    let insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                    tabsCharDelta += insertSpacesCount - 1;\n                    while (insertSpacesCount > 0) {\n                        if (useNbsp && prevIsSpace) {\n                            partContent += '&#160;';\n                            prevIsSpace = false;\n                        }\n                        else {\n                            partContent += ' ';\n                            prevIsSpace = true;\n                        }\n                        insertSpacesCount--;\n                    }\n                    break;\n                case 60 /* LessThan */:\n                    partContent += '&lt;';\n                    prevIsSpace = false;\n                    break;\n                case 62 /* GreaterThan */:\n                    partContent += '&gt;';\n                    prevIsSpace = false;\n                    break;\n                case 38 /* Ampersand */:\n                    partContent += '&amp;';\n                    prevIsSpace = false;\n                    break;\n                case 0 /* Null */:\n                    partContent += '&#00;';\n                    prevIsSpace = false;\n                    break;\n                case 65279 /* UTF8_BOM */:\n                case 8232 /* LINE_SEPARATOR */:\n                case 8233 /* PARAGRAPH_SEPARATOR */:\n                case 133 /* NEXT_LINE */:\n                    partContent += '\\ufffd';\n                    prevIsSpace = false;\n                    break;\n                case 13 /* CarriageReturn */:\n                    // zero width space, because carriage return would introduce a line break\n                    partContent += '&#8203';\n                    prevIsSpace = false;\n                    break;\n                case 32 /* Space */:\n                    if (useNbsp && prevIsSpace) {\n                        partContent += '&#160;';\n                        prevIsSpace = false;\n                    }\n                    else {\n                        partContent += ' ';\n                        prevIsSpace = true;\n                    }\n                    break;\n                default:\n                    partContent += String.fromCharCode(charCode);\n                    prevIsSpace = false;\n            }\n        }\n        result += `<span style=\"${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}\">${partContent}</span>`;\n        if (tokenEndIndex > endOffset || charIndex >= endOffset) {\n            break;\n        }\n    }\n    result += `</div>`;\n    return result;\n}\nfunction _tokenizeToString(text, languageIdCodec, tokenizationSupport) {\n    let result = `<div class=\"monaco-tokenized-source\">`;\n    const lines = strings.splitLines(text);\n    let currentState = tokenizationSupport.getInitialState();\n    for (let i = 0, len = lines.length; i < len; i++) {\n        const line = lines[i];\n        if (i > 0) {\n            result += `<br/>`;\n        }\n        const tokenizationResult = tokenizationSupport.tokenize2(line, true, currentState, 0);\n        LineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n        const lineTokens = new LineTokens(tokenizationResult.tokens, line, languageIdCodec);\n        const viewLineTokens = lineTokens.inflate();\n        let startOffset = 0;\n        for (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n            const type = viewLineTokens.getClassName(j);\n            const endIndex = viewLineTokens.getEndOffset(j);\n            result += `<span class=\"${type}\">${strings.escape(line.substring(startOffset, endIndex))}</span>`;\n            startOffset = endIndex;\n        }\n        currentState = tokenizationResult.endState;\n    }\n    result += `</div>`;\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}