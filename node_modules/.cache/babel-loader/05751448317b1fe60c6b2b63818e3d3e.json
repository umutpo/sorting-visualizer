{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { groupBy } from '../../../base/common/arrays.js';\nimport { dispose } from '../../../base/common/lifecycle.js';\nimport { getLeadingWhitespace } from '../../../base/common/strings.js';\nimport './snippetSession.css';\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { ModelDecorationOptions } from '../../common/model/textModel.js';\nimport { ILabelService } from '../../../platform/label/common/label.js';\nimport * as colors from '../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\nimport { IWorkspaceContextService } from '../../../platform/workspace/common/workspace.js';\nimport { Choice, Placeholder, SnippetParser, Text } from './snippetParser.js';\nimport { ClipboardBasedVariableResolver, CommentBasedVariableResolver, CompositeSnippetVariableResolver, ModelBasedVariableResolver, RandomBasedVariableResolver, SelectionBasedVariableResolver, TimeBasedVariableResolver, WorkspaceBasedVariableResolver } from './snippetVariables.js';\nregisterThemingParticipant((theme, collector) => {\n  function getColorGraceful(name) {\n    const color = theme.getColor(name);\n    return color ? color.toString() : 'transparent';\n  }\n\n  collector.addRule(`.monaco-editor .snippet-placeholder { background-color: ${getColorGraceful(colors.snippetTabstopHighlightBackground)}; outline-color: ${getColorGraceful(colors.snippetTabstopHighlightBorder)}; }`);\n  collector.addRule(`.monaco-editor .finish-snippet-placeholder { background-color: ${getColorGraceful(colors.snippetFinalTabstopHighlightBackground)}; outline-color: ${getColorGraceful(colors.snippetFinalTabstopHighlightBorder)}; }`);\n});\nexport class OneSnippet {\n  constructor(_editor, _snippet, _offset, _snippetLineLeadingWhitespace) {\n    this._editor = _editor;\n    this._snippet = _snippet;\n    this._offset = _offset;\n    this._snippetLineLeadingWhitespace = _snippetLineLeadingWhitespace;\n    this._nestingLevel = 1;\n    this._placeholderGroups = groupBy(_snippet.placeholders, Placeholder.compareByIndex);\n    this._placeholderGroupsIdx = -1;\n  }\n\n  dispose() {\n    if (this._placeholderDecorations) {\n      this._editor.deltaDecorations([...this._placeholderDecorations.values()], []);\n    }\n\n    this._placeholderGroups.length = 0;\n  }\n\n  _initDecorations() {\n    if (this._placeholderDecorations) {\n      // already initialized\n      return;\n    }\n\n    this._placeholderDecorations = new Map();\n\n    const model = this._editor.getModel();\n\n    this._editor.changeDecorations(accessor => {\n      // create a decoration for each placeholder\n      for (const placeholder of this._snippet.placeholders) {\n        const placeholderOffset = this._snippet.offset(placeholder);\n\n        const placeholderLen = this._snippet.fullLen(placeholder);\n\n        const range = Range.fromPositions(model.getPositionAt(this._offset + placeholderOffset), model.getPositionAt(this._offset + placeholderOffset + placeholderLen));\n        const options = placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive;\n        const handle = accessor.addDecoration(range, options);\n\n        this._placeholderDecorations.set(placeholder, handle);\n      }\n    });\n  }\n\n  move(fwd) {\n    if (!this._editor.hasModel()) {\n      return [];\n    }\n\n    this._initDecorations(); // Transform placeholder text if necessary\n\n\n    if (this._placeholderGroupsIdx >= 0) {\n      let operations = [];\n\n      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n        // Check if the placeholder has a transformation\n        if (placeholder.transform) {\n          const id = this._placeholderDecorations.get(placeholder);\n\n          const range = this._editor.getModel().getDecorationRange(id);\n\n          const currentValue = this._editor.getModel().getValueInRange(range);\n\n          const transformedValueLines = placeholder.transform.resolve(currentValue).split(/\\r\\n|\\r|\\n/); // fix indentation for transformed lines\n\n          for (let i = 1; i < transformedValueLines.length; i++) {\n            transformedValueLines[i] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + transformedValueLines[i]);\n          }\n\n          operations.push(EditOperation.replace(range, transformedValueLines.join(this._editor.getModel().getEOL())));\n        }\n      }\n\n      if (operations.length > 0) {\n        this._editor.executeEdits('snippet.placeholderTransform', operations);\n      }\n    }\n\n    let couldSkipThisPlaceholder = false;\n\n    if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {\n      this._placeholderGroupsIdx += 1;\n      couldSkipThisPlaceholder = true;\n    } else if (fwd === false && this._placeholderGroupsIdx > 0) {\n      this._placeholderGroupsIdx -= 1;\n      couldSkipThisPlaceholder = true;\n    } else {// the selection of the current placeholder might\n      // not acurate any more -> simply restore it\n    }\n\n    const newSelections = this._editor.getModel().changeDecorations(accessor => {\n      const activePlaceholders = new Set(); // change stickiness to always grow when typing at its edges\n      // because these decorations represent the currently active\n      // tabstop.\n      // Special case #1: reaching the final tabstop\n      // Special case #2: placeholders enclosing active placeholders\n\n      const selections = [];\n\n      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n        const id = this._placeholderDecorations.get(placeholder);\n\n        const range = this._editor.getModel().getDecorationRange(id);\n\n        selections.push(new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)); // consider to skip this placeholder index when the decoration\n        // range is empty but when the placeholder wasn't. that's a strong\n        // hint that the placeholder has been deleted. (all placeholder must match this)\n\n        couldSkipThisPlaceholder = couldSkipThisPlaceholder && this._hasPlaceholderBeenCollapsed(placeholder);\n        accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n        activePlaceholders.add(placeholder);\n\n        for (const enclosingPlaceholder of this._snippet.enclosingPlaceholders(placeholder)) {\n          const id = this._placeholderDecorations.get(enclosingPlaceholder);\n\n          accessor.changeDecorationOptions(id, enclosingPlaceholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n          activePlaceholders.add(enclosingPlaceholder);\n        }\n      } // change stickness to never grow when typing at its edges\n      // so that in-active tabstops never grow\n\n\n      for (const [placeholder, id] of this._placeholderDecorations) {\n        if (!activePlaceholders.has(placeholder)) {\n          accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive);\n        }\n      }\n\n      return selections;\n    });\n\n    return !couldSkipThisPlaceholder ? newSelections !== null && newSelections !== void 0 ? newSelections : [] : this.move(fwd);\n  }\n\n  _hasPlaceholderBeenCollapsed(placeholder) {\n    // A placeholder is empty when it wasn't empty when authored but\n    // when its tracking decoration is empty. This also applies to all\n    // potential parent placeholders\n    let marker = placeholder;\n\n    while (marker) {\n      if (marker instanceof Placeholder) {\n        const id = this._placeholderDecorations.get(marker);\n\n        const range = this._editor.getModel().getDecorationRange(id);\n\n        if (range.isEmpty() && marker.toString().length > 0) {\n          return true;\n        }\n      }\n\n      marker = marker.parent;\n    }\n\n    return false;\n  }\n\n  get isAtFirstPlaceholder() {\n    return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;\n  }\n\n  get isAtLastPlaceholder() {\n    return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;\n  }\n\n  get hasPlaceholder() {\n    return this._snippet.placeholders.length > 0;\n  }\n\n  computePossibleSelections() {\n    const result = new Map();\n\n    for (const placeholdersWithEqualIndex of this._placeholderGroups) {\n      let ranges;\n\n      for (const placeholder of placeholdersWithEqualIndex) {\n        if (placeholder.isFinalTabstop) {\n          // ignore those\n          break;\n        }\n\n        if (!ranges) {\n          ranges = [];\n          result.set(placeholder.index, ranges);\n        }\n\n        const id = this._placeholderDecorations.get(placeholder);\n\n        const range = this._editor.getModel().getDecorationRange(id);\n\n        if (!range) {\n          // one of the placeholder lost its decoration and\n          // therefore we bail out and pretend the placeholder\n          // (with its mirrors) doesn't exist anymore.\n          result.delete(placeholder.index);\n          break;\n        }\n\n        ranges.push(range);\n      }\n    }\n\n    return result;\n  }\n\n  get choice() {\n    return this._placeholderGroups[this._placeholderGroupsIdx][0].choice;\n  }\n\n  merge(others) {\n    const model = this._editor.getModel();\n\n    this._nestingLevel *= 10;\n\n    this._editor.changeDecorations(accessor => {\n      // For each active placeholder take one snippet and merge it\n      // in that the placeholder (can be many for `$1foo$1foo`). Because\n      // everything is sorted by editor selection we can simply remove\n      // elements from the beginning of the array\n      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n        const nested = others.shift();\n        console.assert(!nested._placeholderDecorations); // Massage placeholder-indicies of the nested snippet to be\n        // sorted right after the insertion point. This ensures we move\n        // through the placeholders in the correct order\n\n        const indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;\n\n        for (const nestedPlaceholder of nested._snippet.placeholderInfo.all) {\n          if (nestedPlaceholder.isFinalTabstop) {\n            nestedPlaceholder.index = placeholder.index + (indexLastPlaceholder + 1) / this._nestingLevel;\n          } else {\n            nestedPlaceholder.index = placeholder.index + nestedPlaceholder.index / this._nestingLevel;\n          }\n        }\n\n        this._snippet.replace(placeholder, nested._snippet.children); // Remove the placeholder at which position are inserting\n        // the snippet and also remove its decoration.\n\n\n        const id = this._placeholderDecorations.get(placeholder);\n\n        accessor.removeDecoration(id);\n\n        this._placeholderDecorations.delete(placeholder); // For each *new* placeholder we create decoration to monitor\n        // how and if it grows/shrinks.\n\n\n        for (const placeholder of nested._snippet.placeholders) {\n          const placeholderOffset = nested._snippet.offset(placeholder);\n\n          const placeholderLen = nested._snippet.fullLen(placeholder);\n\n          const range = Range.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));\n          const handle = accessor.addDecoration(range, OneSnippet._decor.inactive);\n\n          this._placeholderDecorations.set(placeholder, handle);\n        }\n      } // Last, re-create the placeholder groups by sorting placeholders by their index.\n\n\n      this._placeholderGroups = groupBy(this._snippet.placeholders, Placeholder.compareByIndex);\n    });\n  }\n\n}\nOneSnippet._decor = {\n  active: ModelDecorationOptions.register({\n    description: 'snippet-placeholder-1',\n    stickiness: 0\n    /* AlwaysGrowsWhenTypingAtEdges */\n    ,\n    className: 'snippet-placeholder'\n  }),\n  inactive: ModelDecorationOptions.register({\n    description: 'snippet-placeholder-2',\n    stickiness: 1\n    /* NeverGrowsWhenTypingAtEdges */\n    ,\n    className: 'snippet-placeholder'\n  }),\n  activeFinal: ModelDecorationOptions.register({\n    description: 'snippet-placeholder-3',\n    stickiness: 1\n    /* NeverGrowsWhenTypingAtEdges */\n    ,\n    className: 'finish-snippet-placeholder'\n  }),\n  inactiveFinal: ModelDecorationOptions.register({\n    description: 'snippet-placeholder-4',\n    stickiness: 1\n    /* NeverGrowsWhenTypingAtEdges */\n    ,\n    className: 'finish-snippet-placeholder'\n  })\n};\nconst _defaultOptions = {\n  overwriteBefore: 0,\n  overwriteAfter: 0,\n  adjustWhitespace: true,\n  clipboardText: undefined,\n  overtypingCapturer: undefined\n};\nexport class SnippetSession {\n  constructor(editor, template) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _defaultOptions;\n    this._templateMerges = [];\n    this._snippets = [];\n    this._editor = editor;\n    this._template = template;\n    this._options = options;\n  }\n\n  static adjustWhitespace(model, position, snippet, adjustIndentation, adjustNewlines) {\n    const line = model.getLineContent(position.lineNumber);\n    const lineLeadingWhitespace = getLeadingWhitespace(line, 0, position.column - 1); // the snippet as inserted\n\n    let snippetTextString;\n    snippet.walk(marker => {\n      // all text elements that are not inside choice\n      if (!(marker instanceof Text) || marker.parent instanceof Choice) {\n        return true;\n      }\n\n      const lines = marker.value.split(/\\r\\n|\\r|\\n/);\n\n      if (adjustIndentation) {\n        // adjust indentation of snippet test\n        // -the snippet-start doesn't get extra-indented (lineLeadingWhitespace), only normalized\n        // -all N+1 lines get extra-indented and normalized\n        // -the text start get extra-indented and normalized when following a linebreak\n        const offset = snippet.offset(marker);\n\n        if (offset === 0) {\n          // snippet start\n          lines[0] = model.normalizeIndentation(lines[0]);\n        } else {\n          // check if text start is after a linebreak\n          snippetTextString = snippetTextString !== null && snippetTextString !== void 0 ? snippetTextString : snippet.toString();\n          let prevChar = snippetTextString.charCodeAt(offset - 1);\n\n          if (prevChar === 10\n          /* LineFeed */\n          || prevChar === 13\n          /* CarriageReturn */\n          ) {\n            lines[0] = model.normalizeIndentation(lineLeadingWhitespace + lines[0]);\n          }\n        }\n\n        for (let i = 1; i < lines.length; i++) {\n          lines[i] = model.normalizeIndentation(lineLeadingWhitespace + lines[i]);\n        }\n      }\n\n      const newValue = lines.join(model.getEOL());\n\n      if (newValue !== marker.value) {\n        marker.parent.replace(marker, [new Text(newValue)]);\n        snippetTextString = undefined;\n      }\n\n      return true;\n    });\n    return lineLeadingWhitespace;\n  }\n\n  static adjustSelection(model, selection, overwriteBefore, overwriteAfter) {\n    if (overwriteBefore !== 0 || overwriteAfter !== 0) {\n      // overwrite[Before|After] is compute using the position, not the whole\n      // selection. therefore we adjust the selection around that position\n      const {\n        positionLineNumber,\n        positionColumn\n      } = selection;\n      const positionColumnBefore = positionColumn - overwriteBefore;\n      const positionColumnAfter = positionColumn + overwriteAfter;\n      const range = model.validateRange({\n        startLineNumber: positionLineNumber,\n        startColumn: positionColumnBefore,\n        endLineNumber: positionLineNumber,\n        endColumn: positionColumnAfter\n      });\n      selection = Selection.createWithDirection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn, selection.getDirection());\n    }\n\n    return selection;\n  }\n\n  static createEditsAndSnippets(editor, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer) {\n    const edits = [];\n    const snippets = [];\n\n    if (!editor.hasModel()) {\n      return {\n        edits,\n        snippets\n      };\n    }\n\n    const model = editor.getModel();\n    const workspaceService = editor.invokeWithinContext(accessor => accessor.get(IWorkspaceContextService));\n    const modelBasedVariableResolver = editor.invokeWithinContext(accessor => new ModelBasedVariableResolver(accessor.get(ILabelService), model));\n\n    const readClipboardText = () => clipboardText;\n\n    let delta = 0; // know what text the overwrite[Before|After] extensions\n    // of the primary curser have selected because only when\n    // secondary selections extend to the same text we can grow them\n\n    let firstBeforeText = model.getValueInRange(SnippetSession.adjustSelection(model, editor.getSelection(), overwriteBefore, 0));\n    let firstAfterText = model.getValueInRange(SnippetSession.adjustSelection(model, editor.getSelection(), 0, overwriteAfter)); // remember the first non-whitespace column to decide if\n    // `keepWhitespace` should be overruled for secondary selections\n\n    let firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor.getSelection().positionLineNumber); // sort selections by their start position but remeber\n    // the original index. that allows you to create correct\n    // offset-based selection logic without changing the\n    // primary selection\n\n    const indexedSelections = editor.getSelections().map((selection, idx) => ({\n      selection,\n      idx\n    })).sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));\n\n    for (const {\n      selection,\n      idx\n    } of indexedSelections) {\n      // extend selection with the `overwriteBefore` and `overwriteAfter` and then\n      // compare if this matches the extensions of the primary selection\n      let extensionBefore = SnippetSession.adjustSelection(model, selection, overwriteBefore, 0);\n      let extensionAfter = SnippetSession.adjustSelection(model, selection, 0, overwriteAfter);\n\n      if (firstBeforeText !== model.getValueInRange(extensionBefore)) {\n        extensionBefore = selection;\n      }\n\n      if (firstAfterText !== model.getValueInRange(extensionAfter)) {\n        extensionAfter = selection;\n      } // merge the before and after selection into one\n\n\n      const snippetSelection = selection.setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn).setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);\n      const snippet = new SnippetParser().parse(template, true, enforceFinalTabstop); // adjust the template string to match the indentation and\n      // whitespace rules of this insert location (can be different for each cursor)\n      // happens when being asked for (default) or when this is a secondary\n      // cursor and the leading whitespace is different\n\n      const start = snippetSelection.getStartPosition();\n      const snippetLineLeadingWhitespace = SnippetSession.adjustWhitespace(model, start, snippet, adjustWhitespace || idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber), true);\n      snippet.resolveVariables(new CompositeSnippetVariableResolver([modelBasedVariableResolver, new ClipboardBasedVariableResolver(readClipboardText, idx, indexedSelections.length, editor.getOption(70\n      /* multiCursorPaste */\n      ) === 'spread'), new SelectionBasedVariableResolver(model, selection, idx, overtypingCapturer), new CommentBasedVariableResolver(model, selection), new TimeBasedVariableResolver(), new WorkspaceBasedVariableResolver(workspaceService), new RandomBasedVariableResolver()]));\n      const offset = model.getOffsetAt(start) + delta;\n      delta += snippet.toString().length - model.getValueLengthInRange(snippetSelection); // store snippets with the index of their originating selection.\n      // that ensures the primiary cursor stays primary despite not being\n      // the one with lowest start position\n\n      edits[idx] = EditOperation.replace(snippetSelection, snippet.toString());\n      edits[idx].identifier = {\n        major: idx,\n        minor: 0\n      }; // mark the edit so only our undo edits will be used to generate end cursors\n\n      snippets[idx] = new OneSnippet(editor, snippet, offset, snippetLineLeadingWhitespace);\n    }\n\n    return {\n      edits,\n      snippets\n    };\n  }\n\n  dispose() {\n    dispose(this._snippets);\n  }\n\n  _logInfo() {\n    return `template=\"${this._template}\", merged_templates=\"${this._templateMerges.join(' -> ')}\"`;\n  }\n\n  insert() {\n    if (!this._editor.hasModel()) {\n      return;\n    } // make insert edit and start with first selections\n\n\n    const {\n      edits,\n      snippets\n    } = SnippetSession.createEditsAndSnippets(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer);\n    this._snippets = snippets;\n\n    this._editor.executeEdits('snippet', edits, undoEdits => {\n      if (this._snippets[0].hasPlaceholder) {\n        return this._move(true);\n      } else {\n        return undoEdits.filter(edit => !!edit.identifier) // only use our undo edits\n        .map(edit => Selection.fromPositions(edit.range.getEndPosition()));\n      }\n    });\n\n    this._editor.revealRange(this._editor.getSelections()[0]);\n  }\n\n  merge(template) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultOptions;\n\n    if (!this._editor.hasModel()) {\n      return;\n    }\n\n    this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);\n\n    const {\n      edits,\n      snippets\n    } = SnippetSession.createEditsAndSnippets(this._editor, template, options.overwriteBefore, options.overwriteAfter, true, options.adjustWhitespace, options.clipboardText, options.overtypingCapturer);\n\n    this._editor.executeEdits('snippet', edits, undoEdits => {\n      for (const snippet of this._snippets) {\n        snippet.merge(snippets);\n      }\n\n      console.assert(snippets.length === 0);\n\n      if (this._snippets[0].hasPlaceholder) {\n        return this._move(undefined);\n      } else {\n        return undoEdits.filter(edit => !!edit.identifier) // only use our undo edits\n        .map(edit => Selection.fromPositions(edit.range.getEndPosition()));\n      }\n    });\n  }\n\n  next() {\n    const newSelections = this._move(true);\n\n    this._editor.setSelections(newSelections);\n\n    this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n  }\n\n  prev() {\n    const newSelections = this._move(false);\n\n    this._editor.setSelections(newSelections);\n\n    this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n  }\n\n  _move(fwd) {\n    const selections = [];\n\n    for (const snippet of this._snippets) {\n      const oneSelection = snippet.move(fwd);\n      selections.push(...oneSelection);\n    }\n\n    return selections;\n  }\n\n  get isAtFirstPlaceholder() {\n    return this._snippets[0].isAtFirstPlaceholder;\n  }\n\n  get isAtLastPlaceholder() {\n    return this._snippets[0].isAtLastPlaceholder;\n  }\n\n  get hasPlaceholder() {\n    return this._snippets[0].hasPlaceholder;\n  }\n\n  get choice() {\n    return this._snippets[0].choice;\n  }\n\n  isSelectionWithinPlaceholders() {\n    if (!this.hasPlaceholder) {\n      return false;\n    }\n\n    const selections = this._editor.getSelections();\n\n    if (selections.length < this._snippets.length) {\n      // this means we started snippet mode with N\n      // selections and have M (N > M) selections.\n      // So one snippet is without selection -> cancel\n      return false;\n    }\n\n    let allPossibleSelections = new Map();\n\n    for (const snippet of this._snippets) {\n      const possibleSelections = snippet.computePossibleSelections(); // for the first snippet find the placeholder (and its ranges)\n      // that contain at least one selection. for all remaining snippets\n      // the same placeholder (and their ranges) must be used.\n\n      if (allPossibleSelections.size === 0) {\n        for (const [index, ranges] of possibleSelections) {\n          ranges.sort(Range.compareRangesUsingStarts);\n\n          for (const selection of selections) {\n            if (ranges[0].containsRange(selection)) {\n              allPossibleSelections.set(index, []);\n              break;\n            }\n          }\n        }\n      }\n\n      if (allPossibleSelections.size === 0) {\n        // return false if we couldn't associate a selection to\n        // this (the first) snippet\n        return false;\n      } // add selections from 'this' snippet so that we know all\n      // selections for this placeholder\n\n\n      allPossibleSelections.forEach((array, index) => {\n        array.push(...possibleSelections.get(index));\n      });\n    } // sort selections (and later placeholder-ranges). then walk both\n    // arrays and make sure the placeholder-ranges contain the corresponding\n    // selection\n\n\n    selections.sort(Range.compareRangesUsingStarts);\n\n    for (let [index, ranges] of allPossibleSelections) {\n      if (ranges.length !== selections.length) {\n        allPossibleSelections.delete(index);\n        continue;\n      }\n\n      ranges.sort(Range.compareRangesUsingStarts);\n\n      for (let i = 0; i < ranges.length; i++) {\n        if (!ranges[i].containsRange(selections[i])) {\n          allPossibleSelections.delete(index);\n          continue;\n        }\n      }\n    } // from all possible selections we have deleted those\n    // that don't match with the current selection. if we don't\n    // have any left, we don't have a selection anymore\n\n\n    return allPossibleSelections.size > 0;\n  }\n\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.js"],"names":["groupBy","dispose","getLeadingWhitespace","EditOperation","Range","Selection","ModelDecorationOptions","ILabelService","colors","registerThemingParticipant","IWorkspaceContextService","Choice","Placeholder","SnippetParser","Text","ClipboardBasedVariableResolver","CommentBasedVariableResolver","CompositeSnippetVariableResolver","ModelBasedVariableResolver","RandomBasedVariableResolver","SelectionBasedVariableResolver","TimeBasedVariableResolver","WorkspaceBasedVariableResolver","theme","collector","getColorGraceful","name","color","getColor","toString","addRule","snippetTabstopHighlightBackground","snippetTabstopHighlightBorder","snippetFinalTabstopHighlightBackground","snippetFinalTabstopHighlightBorder","OneSnippet","constructor","_editor","_snippet","_offset","_snippetLineLeadingWhitespace","_nestingLevel","_placeholderGroups","placeholders","compareByIndex","_placeholderGroupsIdx","_placeholderDecorations","deltaDecorations","values","length","_initDecorations","Map","model","getModel","changeDecorations","accessor","placeholder","placeholderOffset","offset","placeholderLen","fullLen","range","fromPositions","getPositionAt","options","isFinalTabstop","_decor","inactiveFinal","inactive","handle","addDecoration","set","move","fwd","hasModel","operations","transform","id","get","getDecorationRange","currentValue","getValueInRange","transformedValueLines","resolve","split","i","normalizeIndentation","push","replace","join","getEOL","executeEdits","couldSkipThisPlaceholder","newSelections","activePlaceholders","Set","selections","startLineNumber","startColumn","endLineNumber","endColumn","_hasPlaceholderBeenCollapsed","changeDecorationOptions","activeFinal","active","add","enclosingPlaceholder","enclosingPlaceholders","has","marker","isEmpty","parent","isAtFirstPlaceholder","isAtLastPlaceholder","hasPlaceholder","computePossibleSelections","result","placeholdersWithEqualIndex","ranges","index","delete","choice","merge","others","nested","shift","console","assert","indexLastPlaceholder","placeholderInfo","last","nestedPlaceholder","all","children","removeDecoration","register","description","stickiness","className","_defaultOptions","overwriteBefore","overwriteAfter","adjustWhitespace","clipboardText","undefined","overtypingCapturer","SnippetSession","editor","template","_templateMerges","_snippets","_template","_options","position","snippet","adjustIndentation","adjustNewlines","line","getLineContent","lineNumber","lineLeadingWhitespace","column","snippetTextString","walk","lines","value","prevChar","charCodeAt","newValue","adjustSelection","selection","positionLineNumber","positionColumn","positionColumnBefore","positionColumnAfter","validateRange","createWithDirection","getDirection","createEditsAndSnippets","enforceFinalTabstop","edits","snippets","workspaceService","invokeWithinContext","modelBasedVariableResolver","readClipboardText","delta","firstBeforeText","getSelection","firstAfterText","firstLineFirstNonWhitespace","getLineFirstNonWhitespaceColumn","indexedSelections","getSelections","map","idx","sort","a","b","compareRangesUsingStarts","extensionBefore","extensionAfter","snippetSelection","setStartPosition","setEndPosition","parse","start","getStartPosition","snippetLineLeadingWhitespace","resolveVariables","getOption","getOffsetAt","getValueLengthInRange","identifier","major","minor","_logInfo","insert","undoEdits","_move","filter","edit","getEndPosition","revealRange","next","setSelections","revealPositionInCenterIfOutsideViewport","getPosition","prev","oneSelection","isSelectionWithinPlaceholders","allPossibleSelections","possibleSelections","size","containsRange","forEach","array"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { groupBy } from '../../../base/common/arrays.js';\nimport { dispose } from '../../../base/common/lifecycle.js';\nimport { getLeadingWhitespace } from '../../../base/common/strings.js';\nimport './snippetSession.css';\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { ModelDecorationOptions } from '../../common/model/textModel.js';\nimport { ILabelService } from '../../../platform/label/common/label.js';\nimport * as colors from '../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\nimport { IWorkspaceContextService } from '../../../platform/workspace/common/workspace.js';\nimport { Choice, Placeholder, SnippetParser, Text } from './snippetParser.js';\nimport { ClipboardBasedVariableResolver, CommentBasedVariableResolver, CompositeSnippetVariableResolver, ModelBasedVariableResolver, RandomBasedVariableResolver, SelectionBasedVariableResolver, TimeBasedVariableResolver, WorkspaceBasedVariableResolver } from './snippetVariables.js';\nregisterThemingParticipant((theme, collector) => {\n    function getColorGraceful(name) {\n        const color = theme.getColor(name);\n        return color ? color.toString() : 'transparent';\n    }\n    collector.addRule(`.monaco-editor .snippet-placeholder { background-color: ${getColorGraceful(colors.snippetTabstopHighlightBackground)}; outline-color: ${getColorGraceful(colors.snippetTabstopHighlightBorder)}; }`);\n    collector.addRule(`.monaco-editor .finish-snippet-placeholder { background-color: ${getColorGraceful(colors.snippetFinalTabstopHighlightBackground)}; outline-color: ${getColorGraceful(colors.snippetFinalTabstopHighlightBorder)}; }`);\n});\nexport class OneSnippet {\n    constructor(_editor, _snippet, _offset, _snippetLineLeadingWhitespace) {\n        this._editor = _editor;\n        this._snippet = _snippet;\n        this._offset = _offset;\n        this._snippetLineLeadingWhitespace = _snippetLineLeadingWhitespace;\n        this._nestingLevel = 1;\n        this._placeholderGroups = groupBy(_snippet.placeholders, Placeholder.compareByIndex);\n        this._placeholderGroupsIdx = -1;\n    }\n    dispose() {\n        if (this._placeholderDecorations) {\n            this._editor.deltaDecorations([...this._placeholderDecorations.values()], []);\n        }\n        this._placeholderGroups.length = 0;\n    }\n    _initDecorations() {\n        if (this._placeholderDecorations) {\n            // already initialized\n            return;\n        }\n        this._placeholderDecorations = new Map();\n        const model = this._editor.getModel();\n        this._editor.changeDecorations(accessor => {\n            // create a decoration for each placeholder\n            for (const placeholder of this._snippet.placeholders) {\n                const placeholderOffset = this._snippet.offset(placeholder);\n                const placeholderLen = this._snippet.fullLen(placeholder);\n                const range = Range.fromPositions(model.getPositionAt(this._offset + placeholderOffset), model.getPositionAt(this._offset + placeholderOffset + placeholderLen));\n                const options = placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive;\n                const handle = accessor.addDecoration(range, options);\n                this._placeholderDecorations.set(placeholder, handle);\n            }\n        });\n    }\n    move(fwd) {\n        if (!this._editor.hasModel()) {\n            return [];\n        }\n        this._initDecorations();\n        // Transform placeholder text if necessary\n        if (this._placeholderGroupsIdx >= 0) {\n            let operations = [];\n            for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n                // Check if the placeholder has a transformation\n                if (placeholder.transform) {\n                    const id = this._placeholderDecorations.get(placeholder);\n                    const range = this._editor.getModel().getDecorationRange(id);\n                    const currentValue = this._editor.getModel().getValueInRange(range);\n                    const transformedValueLines = placeholder.transform.resolve(currentValue).split(/\\r\\n|\\r|\\n/);\n                    // fix indentation for transformed lines\n                    for (let i = 1; i < transformedValueLines.length; i++) {\n                        transformedValueLines[i] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + transformedValueLines[i]);\n                    }\n                    operations.push(EditOperation.replace(range, transformedValueLines.join(this._editor.getModel().getEOL())));\n                }\n            }\n            if (operations.length > 0) {\n                this._editor.executeEdits('snippet.placeholderTransform', operations);\n            }\n        }\n        let couldSkipThisPlaceholder = false;\n        if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {\n            this._placeholderGroupsIdx += 1;\n            couldSkipThisPlaceholder = true;\n        }\n        else if (fwd === false && this._placeholderGroupsIdx > 0) {\n            this._placeholderGroupsIdx -= 1;\n            couldSkipThisPlaceholder = true;\n        }\n        else {\n            // the selection of the current placeholder might\n            // not acurate any more -> simply restore it\n        }\n        const newSelections = this._editor.getModel().changeDecorations(accessor => {\n            const activePlaceholders = new Set();\n            // change stickiness to always grow when typing at its edges\n            // because these decorations represent the currently active\n            // tabstop.\n            // Special case #1: reaching the final tabstop\n            // Special case #2: placeholders enclosing active placeholders\n            const selections = [];\n            for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n                const id = this._placeholderDecorations.get(placeholder);\n                const range = this._editor.getModel().getDecorationRange(id);\n                selections.push(new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn));\n                // consider to skip this placeholder index when the decoration\n                // range is empty but when the placeholder wasn't. that's a strong\n                // hint that the placeholder has been deleted. (all placeholder must match this)\n                couldSkipThisPlaceholder = couldSkipThisPlaceholder && this._hasPlaceholderBeenCollapsed(placeholder);\n                accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n                activePlaceholders.add(placeholder);\n                for (const enclosingPlaceholder of this._snippet.enclosingPlaceholders(placeholder)) {\n                    const id = this._placeholderDecorations.get(enclosingPlaceholder);\n                    accessor.changeDecorationOptions(id, enclosingPlaceholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n                    activePlaceholders.add(enclosingPlaceholder);\n                }\n            }\n            // change stickness to never grow when typing at its edges\n            // so that in-active tabstops never grow\n            for (const [placeholder, id] of this._placeholderDecorations) {\n                if (!activePlaceholders.has(placeholder)) {\n                    accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive);\n                }\n            }\n            return selections;\n        });\n        return !couldSkipThisPlaceholder ? newSelections !== null && newSelections !== void 0 ? newSelections : [] : this.move(fwd);\n    }\n    _hasPlaceholderBeenCollapsed(placeholder) {\n        // A placeholder is empty when it wasn't empty when authored but\n        // when its tracking decoration is empty. This also applies to all\n        // potential parent placeholders\n        let marker = placeholder;\n        while (marker) {\n            if (marker instanceof Placeholder) {\n                const id = this._placeholderDecorations.get(marker);\n                const range = this._editor.getModel().getDecorationRange(id);\n                if (range.isEmpty() && marker.toString().length > 0) {\n                    return true;\n                }\n            }\n            marker = marker.parent;\n        }\n        return false;\n    }\n    get isAtFirstPlaceholder() {\n        return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;\n    }\n    get isAtLastPlaceholder() {\n        return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;\n    }\n    get hasPlaceholder() {\n        return this._snippet.placeholders.length > 0;\n    }\n    computePossibleSelections() {\n        const result = new Map();\n        for (const placeholdersWithEqualIndex of this._placeholderGroups) {\n            let ranges;\n            for (const placeholder of placeholdersWithEqualIndex) {\n                if (placeholder.isFinalTabstop) {\n                    // ignore those\n                    break;\n                }\n                if (!ranges) {\n                    ranges = [];\n                    result.set(placeholder.index, ranges);\n                }\n                const id = this._placeholderDecorations.get(placeholder);\n                const range = this._editor.getModel().getDecorationRange(id);\n                if (!range) {\n                    // one of the placeholder lost its decoration and\n                    // therefore we bail out and pretend the placeholder\n                    // (with its mirrors) doesn't exist anymore.\n                    result.delete(placeholder.index);\n                    break;\n                }\n                ranges.push(range);\n            }\n        }\n        return result;\n    }\n    get choice() {\n        return this._placeholderGroups[this._placeholderGroupsIdx][0].choice;\n    }\n    merge(others) {\n        const model = this._editor.getModel();\n        this._nestingLevel *= 10;\n        this._editor.changeDecorations(accessor => {\n            // For each active placeholder take one snippet and merge it\n            // in that the placeholder (can be many for `$1foo$1foo`). Because\n            // everything is sorted by editor selection we can simply remove\n            // elements from the beginning of the array\n            for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n                const nested = others.shift();\n                console.assert(!nested._placeholderDecorations);\n                // Massage placeholder-indicies of the nested snippet to be\n                // sorted right after the insertion point. This ensures we move\n                // through the placeholders in the correct order\n                const indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;\n                for (const nestedPlaceholder of nested._snippet.placeholderInfo.all) {\n                    if (nestedPlaceholder.isFinalTabstop) {\n                        nestedPlaceholder.index = placeholder.index + ((indexLastPlaceholder + 1) / this._nestingLevel);\n                    }\n                    else {\n                        nestedPlaceholder.index = placeholder.index + (nestedPlaceholder.index / this._nestingLevel);\n                    }\n                }\n                this._snippet.replace(placeholder, nested._snippet.children);\n                // Remove the placeholder at which position are inserting\n                // the snippet and also remove its decoration.\n                const id = this._placeholderDecorations.get(placeholder);\n                accessor.removeDecoration(id);\n                this._placeholderDecorations.delete(placeholder);\n                // For each *new* placeholder we create decoration to monitor\n                // how and if it grows/shrinks.\n                for (const placeholder of nested._snippet.placeholders) {\n                    const placeholderOffset = nested._snippet.offset(placeholder);\n                    const placeholderLen = nested._snippet.fullLen(placeholder);\n                    const range = Range.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));\n                    const handle = accessor.addDecoration(range, OneSnippet._decor.inactive);\n                    this._placeholderDecorations.set(placeholder, handle);\n                }\n            }\n            // Last, re-create the placeholder groups by sorting placeholders by their index.\n            this._placeholderGroups = groupBy(this._snippet.placeholders, Placeholder.compareByIndex);\n        });\n    }\n}\nOneSnippet._decor = {\n    active: ModelDecorationOptions.register({ description: 'snippet-placeholder-1', stickiness: 0 /* AlwaysGrowsWhenTypingAtEdges */, className: 'snippet-placeholder' }),\n    inactive: ModelDecorationOptions.register({ description: 'snippet-placeholder-2', stickiness: 1 /* NeverGrowsWhenTypingAtEdges */, className: 'snippet-placeholder' }),\n    activeFinal: ModelDecorationOptions.register({ description: 'snippet-placeholder-3', stickiness: 1 /* NeverGrowsWhenTypingAtEdges */, className: 'finish-snippet-placeholder' }),\n    inactiveFinal: ModelDecorationOptions.register({ description: 'snippet-placeholder-4', stickiness: 1 /* NeverGrowsWhenTypingAtEdges */, className: 'finish-snippet-placeholder' }),\n};\nconst _defaultOptions = {\n    overwriteBefore: 0,\n    overwriteAfter: 0,\n    adjustWhitespace: true,\n    clipboardText: undefined,\n    overtypingCapturer: undefined\n};\nexport class SnippetSession {\n    constructor(editor, template, options = _defaultOptions) {\n        this._templateMerges = [];\n        this._snippets = [];\n        this._editor = editor;\n        this._template = template;\n        this._options = options;\n    }\n    static adjustWhitespace(model, position, snippet, adjustIndentation, adjustNewlines) {\n        const line = model.getLineContent(position.lineNumber);\n        const lineLeadingWhitespace = getLeadingWhitespace(line, 0, position.column - 1);\n        // the snippet as inserted\n        let snippetTextString;\n        snippet.walk(marker => {\n            // all text elements that are not inside choice\n            if (!(marker instanceof Text) || marker.parent instanceof Choice) {\n                return true;\n            }\n            const lines = marker.value.split(/\\r\\n|\\r|\\n/);\n            if (adjustIndentation) {\n                // adjust indentation of snippet test\n                // -the snippet-start doesn't get extra-indented (lineLeadingWhitespace), only normalized\n                // -all N+1 lines get extra-indented and normalized\n                // -the text start get extra-indented and normalized when following a linebreak\n                const offset = snippet.offset(marker);\n                if (offset === 0) {\n                    // snippet start\n                    lines[0] = model.normalizeIndentation(lines[0]);\n                }\n                else {\n                    // check if text start is after a linebreak\n                    snippetTextString = snippetTextString !== null && snippetTextString !== void 0 ? snippetTextString : snippet.toString();\n                    let prevChar = snippetTextString.charCodeAt(offset - 1);\n                    if (prevChar === 10 /* LineFeed */ || prevChar === 13 /* CarriageReturn */) {\n                        lines[0] = model.normalizeIndentation(lineLeadingWhitespace + lines[0]);\n                    }\n                }\n                for (let i = 1; i < lines.length; i++) {\n                    lines[i] = model.normalizeIndentation(lineLeadingWhitespace + lines[i]);\n                }\n            }\n            const newValue = lines.join(model.getEOL());\n            if (newValue !== marker.value) {\n                marker.parent.replace(marker, [new Text(newValue)]);\n                snippetTextString = undefined;\n            }\n            return true;\n        });\n        return lineLeadingWhitespace;\n    }\n    static adjustSelection(model, selection, overwriteBefore, overwriteAfter) {\n        if (overwriteBefore !== 0 || overwriteAfter !== 0) {\n            // overwrite[Before|After] is compute using the position, not the whole\n            // selection. therefore we adjust the selection around that position\n            const { positionLineNumber, positionColumn } = selection;\n            const positionColumnBefore = positionColumn - overwriteBefore;\n            const positionColumnAfter = positionColumn + overwriteAfter;\n            const range = model.validateRange({\n                startLineNumber: positionLineNumber,\n                startColumn: positionColumnBefore,\n                endLineNumber: positionLineNumber,\n                endColumn: positionColumnAfter\n            });\n            selection = Selection.createWithDirection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn, selection.getDirection());\n        }\n        return selection;\n    }\n    static createEditsAndSnippets(editor, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer) {\n        const edits = [];\n        const snippets = [];\n        if (!editor.hasModel()) {\n            return { edits, snippets };\n        }\n        const model = editor.getModel();\n        const workspaceService = editor.invokeWithinContext(accessor => accessor.get(IWorkspaceContextService));\n        const modelBasedVariableResolver = editor.invokeWithinContext(accessor => new ModelBasedVariableResolver(accessor.get(ILabelService), model));\n        const readClipboardText = () => clipboardText;\n        let delta = 0;\n        // know what text the overwrite[Before|After] extensions\n        // of the primary curser have selected because only when\n        // secondary selections extend to the same text we can grow them\n        let firstBeforeText = model.getValueInRange(SnippetSession.adjustSelection(model, editor.getSelection(), overwriteBefore, 0));\n        let firstAfterText = model.getValueInRange(SnippetSession.adjustSelection(model, editor.getSelection(), 0, overwriteAfter));\n        // remember the first non-whitespace column to decide if\n        // `keepWhitespace` should be overruled for secondary selections\n        let firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor.getSelection().positionLineNumber);\n        // sort selections by their start position but remeber\n        // the original index. that allows you to create correct\n        // offset-based selection logic without changing the\n        // primary selection\n        const indexedSelections = editor.getSelections()\n            .map((selection, idx) => ({ selection, idx }))\n            .sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));\n        for (const { selection, idx } of indexedSelections) {\n            // extend selection with the `overwriteBefore` and `overwriteAfter` and then\n            // compare if this matches the extensions of the primary selection\n            let extensionBefore = SnippetSession.adjustSelection(model, selection, overwriteBefore, 0);\n            let extensionAfter = SnippetSession.adjustSelection(model, selection, 0, overwriteAfter);\n            if (firstBeforeText !== model.getValueInRange(extensionBefore)) {\n                extensionBefore = selection;\n            }\n            if (firstAfterText !== model.getValueInRange(extensionAfter)) {\n                extensionAfter = selection;\n            }\n            // merge the before and after selection into one\n            const snippetSelection = selection\n                .setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn)\n                .setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);\n            const snippet = new SnippetParser().parse(template, true, enforceFinalTabstop);\n            // adjust the template string to match the indentation and\n            // whitespace rules of this insert location (can be different for each cursor)\n            // happens when being asked for (default) or when this is a secondary\n            // cursor and the leading whitespace is different\n            const start = snippetSelection.getStartPosition();\n            const snippetLineLeadingWhitespace = SnippetSession.adjustWhitespace(model, start, snippet, adjustWhitespace || (idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber)), true);\n            snippet.resolveVariables(new CompositeSnippetVariableResolver([\n                modelBasedVariableResolver,\n                new ClipboardBasedVariableResolver(readClipboardText, idx, indexedSelections.length, editor.getOption(70 /* multiCursorPaste */) === 'spread'),\n                new SelectionBasedVariableResolver(model, selection, idx, overtypingCapturer),\n                new CommentBasedVariableResolver(model, selection),\n                new TimeBasedVariableResolver,\n                new WorkspaceBasedVariableResolver(workspaceService),\n                new RandomBasedVariableResolver,\n            ]));\n            const offset = model.getOffsetAt(start) + delta;\n            delta += snippet.toString().length - model.getValueLengthInRange(snippetSelection);\n            // store snippets with the index of their originating selection.\n            // that ensures the primiary cursor stays primary despite not being\n            // the one with lowest start position\n            edits[idx] = EditOperation.replace(snippetSelection, snippet.toString());\n            edits[idx].identifier = { major: idx, minor: 0 }; // mark the edit so only our undo edits will be used to generate end cursors\n            snippets[idx] = new OneSnippet(editor, snippet, offset, snippetLineLeadingWhitespace);\n        }\n        return { edits, snippets };\n    }\n    dispose() {\n        dispose(this._snippets);\n    }\n    _logInfo() {\n        return `template=\"${this._template}\", merged_templates=\"${this._templateMerges.join(' -> ')}\"`;\n    }\n    insert() {\n        if (!this._editor.hasModel()) {\n            return;\n        }\n        // make insert edit and start with first selections\n        const { edits, snippets } = SnippetSession.createEditsAndSnippets(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer);\n        this._snippets = snippets;\n        this._editor.executeEdits('snippet', edits, undoEdits => {\n            if (this._snippets[0].hasPlaceholder) {\n                return this._move(true);\n            }\n            else {\n                return undoEdits\n                    .filter(edit => !!edit.identifier) // only use our undo edits\n                    .map(edit => Selection.fromPositions(edit.range.getEndPosition()));\n            }\n        });\n        this._editor.revealRange(this._editor.getSelections()[0]);\n    }\n    merge(template, options = _defaultOptions) {\n        if (!this._editor.hasModel()) {\n            return;\n        }\n        this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);\n        const { edits, snippets } = SnippetSession.createEditsAndSnippets(this._editor, template, options.overwriteBefore, options.overwriteAfter, true, options.adjustWhitespace, options.clipboardText, options.overtypingCapturer);\n        this._editor.executeEdits('snippet', edits, undoEdits => {\n            for (const snippet of this._snippets) {\n                snippet.merge(snippets);\n            }\n            console.assert(snippets.length === 0);\n            if (this._snippets[0].hasPlaceholder) {\n                return this._move(undefined);\n            }\n            else {\n                return (undoEdits\n                    .filter(edit => !!edit.identifier) // only use our undo edits\n                    .map(edit => Selection.fromPositions(edit.range.getEndPosition())));\n            }\n        });\n    }\n    next() {\n        const newSelections = this._move(true);\n        this._editor.setSelections(newSelections);\n        this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n    }\n    prev() {\n        const newSelections = this._move(false);\n        this._editor.setSelections(newSelections);\n        this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n    }\n    _move(fwd) {\n        const selections = [];\n        for (const snippet of this._snippets) {\n            const oneSelection = snippet.move(fwd);\n            selections.push(...oneSelection);\n        }\n        return selections;\n    }\n    get isAtFirstPlaceholder() {\n        return this._snippets[0].isAtFirstPlaceholder;\n    }\n    get isAtLastPlaceholder() {\n        return this._snippets[0].isAtLastPlaceholder;\n    }\n    get hasPlaceholder() {\n        return this._snippets[0].hasPlaceholder;\n    }\n    get choice() {\n        return this._snippets[0].choice;\n    }\n    isSelectionWithinPlaceholders() {\n        if (!this.hasPlaceholder) {\n            return false;\n        }\n        const selections = this._editor.getSelections();\n        if (selections.length < this._snippets.length) {\n            // this means we started snippet mode with N\n            // selections and have M (N > M) selections.\n            // So one snippet is without selection -> cancel\n            return false;\n        }\n        let allPossibleSelections = new Map();\n        for (const snippet of this._snippets) {\n            const possibleSelections = snippet.computePossibleSelections();\n            // for the first snippet find the placeholder (and its ranges)\n            // that contain at least one selection. for all remaining snippets\n            // the same placeholder (and their ranges) must be used.\n            if (allPossibleSelections.size === 0) {\n                for (const [index, ranges] of possibleSelections) {\n                    ranges.sort(Range.compareRangesUsingStarts);\n                    for (const selection of selections) {\n                        if (ranges[0].containsRange(selection)) {\n                            allPossibleSelections.set(index, []);\n                            break;\n                        }\n                    }\n                }\n            }\n            if (allPossibleSelections.size === 0) {\n                // return false if we couldn't associate a selection to\n                // this (the first) snippet\n                return false;\n            }\n            // add selections from 'this' snippet so that we know all\n            // selections for this placeholder\n            allPossibleSelections.forEach((array, index) => {\n                array.push(...possibleSelections.get(index));\n            });\n        }\n        // sort selections (and later placeholder-ranges). then walk both\n        // arrays and make sure the placeholder-ranges contain the corresponding\n        // selection\n        selections.sort(Range.compareRangesUsingStarts);\n        for (let [index, ranges] of allPossibleSelections) {\n            if (ranges.length !== selections.length) {\n                allPossibleSelections.delete(index);\n                continue;\n            }\n            ranges.sort(Range.compareRangesUsingStarts);\n            for (let i = 0; i < ranges.length; i++) {\n                if (!ranges[i].containsRange(selections[i])) {\n                    allPossibleSelections.delete(index);\n                    continue;\n                }\n            }\n        }\n        // from all possible selections we have deleted those\n        // that don't match with the current selection. if we don't\n        // have any left, we don't have a selection anymore\n        return allPossibleSelections.size > 0;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}