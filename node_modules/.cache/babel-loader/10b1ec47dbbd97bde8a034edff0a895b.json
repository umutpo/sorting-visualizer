{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { CursorColumns, EditOperationResult, isQuote } from './cursorCommon.js';\nimport { getMapForWordSeparators } from './wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { IndentAction } from '../modes/languageConfiguration.js';\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\nexport class TypeOperations {\n  static indent(config, model, selections) {\n    if (model === null || selections === null) {\n      return [];\n    }\n\n    let commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ShiftCommand(selections[i], {\n        isUnshift: false,\n        tabSize: config.tabSize,\n        indentSize: config.indentSize,\n        insertSpaces: config.insertSpaces,\n        useTabStops: config.useTabStops,\n        autoIndent: config.autoIndent\n      });\n    }\n\n    return commands;\n  }\n\n  static outdent(config, model, selections) {\n    let commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ShiftCommand(selections[i], {\n        isUnshift: true,\n        tabSize: config.tabSize,\n        indentSize: config.indentSize,\n        insertSpaces: config.insertSpaces,\n        useTabStops: config.useTabStops,\n        autoIndent: config.autoIndent\n      });\n    }\n\n    return commands;\n  }\n\n  static shiftIndent(config, indentation, count) {\n    count = count || 1;\n    return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n  }\n\n  static unshiftIndent(config, indentation, count) {\n    count = count || 1;\n    return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n  }\n\n  static _distributedPaste(config, model, selections, text) {\n    let commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ReplaceCommand(selections[i], text[i]);\n    }\n\n    return new EditOperationResult(0\n    /* Other */\n    , commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  }\n\n  static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n    let commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      let position = selection.getPosition();\n\n      if (pasteOnNewLine && !selection.isEmpty()) {\n        pasteOnNewLine = false;\n      }\n\n      if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n        pasteOnNewLine = false;\n      }\n\n      if (pasteOnNewLine) {\n        // Paste entire line at the beginning of line\n        let typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n        commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n      } else {\n        commands[i] = new ReplaceCommand(selection, text);\n      }\n    }\n\n    return new EditOperationResult(0\n    /* Other */\n    , commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  }\n\n  static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n    if (pasteOnNewLine) {\n      return null;\n    }\n\n    if (selections.length === 1) {\n      return null;\n    }\n\n    if (multicursorText && multicursorText.length === selections.length) {\n      return multicursorText;\n    }\n\n    if (config.multiCursorPaste === 'spread') {\n      // Try to spread the pasted text in case the line count matches the cursor count\n      // Remove trailing \\n if present\n      if (text.charCodeAt(text.length - 1) === 10\n      /* LineFeed */\n      ) {\n        text = text.substr(0, text.length - 1);\n      } // Remove trailing \\r if present\n\n\n      if (text.charCodeAt(text.length - 1) === 13\n      /* CarriageReturn */\n      ) {\n        text = text.substr(0, text.length - 1);\n      }\n\n      let lines = strings.splitLines(text);\n\n      if (lines.length === selections.length) {\n        return lines;\n      }\n    }\n\n    return null;\n  }\n\n  static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n    const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n\n    if (distributedPaste) {\n      selections = selections.sort(Range.compareRangesUsingStarts);\n      return this._distributedPaste(config, model, selections, distributedPaste);\n    } else {\n      return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n    }\n  }\n\n  static _goodIndentForLine(config, model, lineNumber) {\n    let action = null;\n    let indentation = '';\n    const expectedIndentAction = LanguageConfigurationRegistry.getInheritIndentForLine(config.autoIndent, model, lineNumber, false);\n\n    if (expectedIndentAction) {\n      action = expectedIndentAction.action;\n      indentation = expectedIndentAction.indentation;\n    } else if (lineNumber > 1) {\n      let lastLineNumber;\n\n      for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n        const lineText = model.getLineContent(lastLineNumber);\n        const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n\n        if (nonWhitespaceIdx >= 0) {\n          break;\n        }\n      }\n\n      if (lastLineNumber < 1) {\n        // No previous line with content found\n        return null;\n      }\n\n      const maxColumn = model.getLineMaxColumn(lastLineNumber);\n      const expectedEnterAction = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn));\n\n      if (expectedEnterAction) {\n        indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n      }\n    }\n\n    if (action) {\n      if (action === IndentAction.Indent) {\n        indentation = TypeOperations.shiftIndent(config, indentation);\n      }\n\n      if (action === IndentAction.Outdent) {\n        indentation = TypeOperations.unshiftIndent(config, indentation);\n      }\n\n      indentation = config.normalizeIndentation(indentation);\n    }\n\n    if (!indentation) {\n      return null;\n    }\n\n    return indentation;\n  }\n\n  static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n    let typeText = '';\n    let position = selection.getStartPosition();\n\n    if (config.insertSpaces) {\n      let visibleColumnFromColumn = CursorColumns.visibleColumnFromColumn2(config, model, position);\n      let indentSize = config.indentSize;\n      let spacesCnt = indentSize - visibleColumnFromColumn % indentSize;\n\n      for (let i = 0; i < spacesCnt; i++) {\n        typeText += ' ';\n      }\n    } else {\n      typeText = '\\t';\n    }\n\n    return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n  }\n\n  static tab(config, model, selections) {\n    let commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n\n      if (selection.isEmpty()) {\n        let lineText = model.getLineContent(selection.startLineNumber);\n\n        if (/^\\s*$/.test(lineText) && model.isCheapToTokenize(selection.startLineNumber)) {\n          let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n\n          goodIndent = goodIndent || '\\t';\n          let possibleTypeText = config.normalizeIndentation(goodIndent);\n\n          if (!lineText.startsWith(possibleTypeText)) {\n            commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n            continue;\n          }\n        }\n\n        commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n      } else {\n        if (selection.startLineNumber === selection.endLineNumber) {\n          let lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n\n          if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n            // This is a single line selection that is not the entire line\n            commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n            continue;\n          }\n        }\n\n        commands[i] = new ShiftCommand(selection, {\n          isUnshift: false,\n          tabSize: config.tabSize,\n          indentSize: config.indentSize,\n          insertSpaces: config.insertSpaces,\n          useTabStops: config.useTabStops,\n          autoIndent: config.autoIndent\n        });\n      }\n    }\n\n    return commands;\n  }\n\n  static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n    const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n    return new EditOperationResult(4\n    /* TypingOther */\n    , commands, {\n      shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4\n      /* TypingOther */\n      ),\n      shouldPushStackElementAfter: false\n    });\n  }\n\n  static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n    if (!selection.isEmpty()) {\n      // looks like https://github.com/microsoft/vscode/issues/2773\n      // where a cursor operation occurred before a canceled composition\n      // => ignore composition\n      return null;\n    }\n\n    const pos = selection.getPosition();\n    const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n    const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n    const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n    const oldText = model.getValueInRange(range);\n\n    if (oldText === text && positionDelta === 0) {\n      // => ignore composition that doesn't do anything\n      return null;\n    }\n\n    return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n  }\n\n  static _typeCommand(range, text, keepPosition) {\n    if (keepPosition) {\n      return new ReplaceCommandWithoutChangingPosition(range, text, true);\n    } else {\n      return new ReplaceCommand(range, text, true);\n    }\n  }\n\n  static _enter(config, model, keepPosition, range) {\n    if (config.autoIndent === 0\n    /* None */\n    ) {\n      return TypeOperations._typeCommand(range, '\\n', keepPosition);\n    }\n\n    if (!model.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1\n    /* Keep */\n    ) {\n      let lineText = model.getLineContent(range.startLineNumber);\n      let indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n      return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n\n    const r = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, range);\n\n    if (r) {\n      if (r.indentAction === IndentAction.None) {\n        // Nothing special\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n      } else if (r.indentAction === IndentAction.Indent) {\n        // Indent once\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n      } else if (r.indentAction === IndentAction.IndentOutdent) {\n        // Ultra special\n        const normalIndent = config.normalizeIndentation(r.indentation);\n        const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n        const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n\n        if (keepPosition) {\n          return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n        } else {\n          return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n        }\n      } else if (r.indentAction === IndentAction.Outdent) {\n        const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n      }\n    }\n\n    const lineText = model.getLineContent(range.startLineNumber);\n    const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n\n    if (config.autoIndent >= 4\n    /* Full */\n    ) {\n      const ir = LanguageConfigurationRegistry.getIndentForEnter(config.autoIndent, model, range, {\n        unshiftIndent: indent => {\n          return TypeOperations.unshiftIndent(config, indent);\n        },\n        shiftIndent: indent => {\n          return TypeOperations.shiftIndent(config, indent);\n        },\n        normalizeIndentation: indent => {\n          return config.normalizeIndentation(indent);\n        }\n      });\n\n      if (ir) {\n        let oldEndViewColumn = CursorColumns.visibleColumnFromColumn2(config, model, range.getEndPosition());\n        const oldEndColumn = range.endColumn;\n        const newLineContent = model.getLineContent(range.endLineNumber);\n        const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n\n        if (firstNonWhitespace >= 0) {\n          range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n        } else {\n          range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n        }\n\n        if (keepPosition) {\n          return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n        } else {\n          let offset = 0;\n\n          if (oldEndColumn <= firstNonWhitespace + 1) {\n            if (!config.insertSpaces) {\n              oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n            }\n\n            offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n          }\n\n          return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n        }\n      }\n    }\n\n    return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n  }\n\n  static _isAutoIndentType(config, model, selections) {\n    if (config.autoIndent < 4\n    /* Full */\n    ) {\n      return false;\n    }\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      if (!model.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  static _runAutoIndentType(config, model, range, ch) {\n    const currentIndentation = LanguageConfigurationRegistry.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n    const actualIndentation = LanguageConfigurationRegistry.getIndentActionForType(config.autoIndent, model, range, ch, {\n      shiftIndent: indentation => {\n        return TypeOperations.shiftIndent(config, indentation);\n      },\n      unshiftIndent: indentation => {\n        return TypeOperations.unshiftIndent(config, indentation);\n      }\n    });\n\n    if (actualIndentation === null) {\n      return null;\n    }\n\n    if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n      const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n\n      if (firstNonWhitespace === 0) {\n        return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n      } else {\n        return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n      }\n    }\n\n    return null;\n  }\n\n  static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n    if (config.autoClosingOvertype === 'never') {\n      return false;\n    }\n\n    if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n      return false;\n    }\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n\n      if (!selection.isEmpty()) {\n        return false;\n      }\n\n      const position = selection.getPosition();\n      const lineText = model.getLineContent(position.lineNumber);\n      const afterCharacter = lineText.charAt(position.column - 1);\n\n      if (afterCharacter !== ch) {\n        return false;\n      } // Do not over-type quotes after a backslash\n\n\n      const chIsQuote = isQuote(ch);\n      const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0\n      /* Null */\n      ;\n\n      if (beforeCharacter === 92\n      /* Backslash */\n      && chIsQuote) {\n        return false;\n      } // Must over-type a closing character typed by the editor\n\n\n      if (config.autoClosingOvertype === 'auto') {\n        let found = false;\n\n        for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n          const autoClosedCharacter = autoClosedCharacters[j];\n\n          if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n            found = true;\n            break;\n          }\n        }\n\n        if (!found) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n    let commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      const position = selection.getPosition();\n      const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n      commands[i] = new ReplaceCommand(typeSelection, ch);\n    }\n\n    return new EditOperationResult(4\n    /* TypingOther */\n    , commands, {\n      shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4\n      /* TypingOther */\n      ),\n      shouldPushStackElementAfter: false\n    });\n  }\n\n  static _isBeforeClosingBrace(config, lineAfter) {\n    // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n    const nextChar = lineAfter.charAt(0);\n    const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n    const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n    const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n    const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n    return !isBeforeStartingBrace && isBeforeClosingBrace;\n  }\n\n  static _findAutoClosingPairOpen(config, model, positions, ch) {\n    const autoClosingPairCandidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n\n    if (!autoClosingPairCandidates) {\n      return null;\n    } // Determine which auto-closing pair it is\n\n\n    let autoClosingPair = null;\n\n    for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n      if (autoClosingPair === null || autoClosingPairCandidate.open.length > autoClosingPair.open.length) {\n        let candidateIsMatch = true;\n\n        for (const position of positions) {\n          const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - autoClosingPairCandidate.open.length + 1, position.lineNumber, position.column));\n\n          if (relevantText + ch !== autoClosingPairCandidate.open) {\n            candidateIsMatch = false;\n            break;\n          }\n        }\n\n        if (candidateIsMatch) {\n          autoClosingPair = autoClosingPairCandidate;\n        }\n      }\n    }\n\n    return autoClosingPair;\n  }\n\n  static _findSubAutoClosingPairClose(config, autoClosingPair) {\n    if (autoClosingPair.open.length <= 1) {\n      return '';\n    }\n\n    const lastChar = autoClosingPair.close.charAt(autoClosingPair.close.length - 1); // get candidates with the same last character as close\n\n    const subPairCandidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n    let subPairMatch = null;\n\n    for (const x of subPairCandidates) {\n      if (x.open !== autoClosingPair.open && autoClosingPair.open.includes(x.open) && autoClosingPair.close.endsWith(x.close)) {\n        if (!subPairMatch || x.open.length > subPairMatch.open.length) {\n          subPairMatch = x;\n        }\n      }\n    }\n\n    if (subPairMatch) {\n      return subPairMatch.close;\n    } else {\n      return '';\n    }\n  }\n\n  static _getAutoClosingPairClose(config, model, selections, ch, insertOpenCharacter) {\n    const chIsQuote = isQuote(ch);\n    const autoCloseConfig = chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets;\n\n    if (autoCloseConfig === 'never') {\n      return null;\n    }\n\n    const autoClosingPair = this._findAutoClosingPairOpen(config, model, selections.map(s => s.getPosition()), ch);\n\n    if (!autoClosingPair) {\n      return null;\n    }\n\n    const subAutoClosingPairClose = this._findSubAutoClosingPairClose(config, autoClosingPair);\n\n    let isSubAutoClosingPairPresent = true;\n    const shouldAutoCloseBefore = chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket;\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n\n      if (!selection.isEmpty()) {\n        return null;\n      }\n\n      const position = selection.getPosition();\n      const lineText = model.getLineContent(position.lineNumber);\n      const lineAfter = lineText.substring(position.column - 1);\n\n      if (!lineAfter.startsWith(subAutoClosingPairClose)) {\n        isSubAutoClosingPairPresent = false;\n      } // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n\n\n      if (lineText.length > position.column - 1) {\n        const characterAfter = lineText.charAt(position.column - 1);\n\n        const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n\n        if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n          return null;\n        }\n      }\n\n      if (!model.isCheapToTokenize(position.lineNumber)) {\n        // Do not force tokenization\n        return null;\n      } // Do not auto-close ' or \" after a word character\n\n\n      if (autoClosingPair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n\n        if (insertOpenCharacter && position.column > 1 && wordSeparators.get(lineText.charCodeAt(position.column - 2)) === 0\n        /* Regular */\n        ) {\n          return null;\n        }\n\n        if (!insertOpenCharacter && position.column > 2 && wordSeparators.get(lineText.charCodeAt(position.column - 3)) === 0\n        /* Regular */\n        ) {\n          return null;\n        }\n      }\n\n      model.forceTokenization(position.lineNumber);\n      const lineTokens = model.getLineTokens(position.lineNumber);\n      let shouldAutoClosePair = false;\n\n      try {\n        shouldAutoClosePair = LanguageConfigurationRegistry.shouldAutoClosePair(autoClosingPair, lineTokens, insertOpenCharacter ? position.column : position.column - 1);\n      } catch (e) {\n        onUnexpectedError(e);\n      }\n\n      if (!shouldAutoClosePair) {\n        return null;\n      }\n    }\n\n    if (isSubAutoClosingPairPresent) {\n      return autoClosingPair.close.substring(0, autoClosingPair.close.length - subAutoClosingPairClose.length);\n    } else {\n      return autoClosingPair.close;\n    }\n  }\n\n  static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, insertOpenCharacter, autoClosingPairClose) {\n    let commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      commands[i] = new TypeWithAutoClosingCommand(selection, ch, insertOpenCharacter, autoClosingPairClose);\n    }\n\n    return new EditOperationResult(4\n    /* TypingOther */\n    , commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: false\n    });\n  }\n\n  static _shouldSurroundChar(config, ch) {\n    if (isQuote(ch)) {\n      return config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined';\n    } else {\n      // Character is a bracket\n      return config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined';\n    }\n  }\n\n  static _isSurroundSelectionType(config, model, selections, ch) {\n    if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n      return false;\n    }\n\n    const isTypingAQuoteCharacter = isQuote(ch);\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n\n      if (selection.isEmpty()) {\n        return false;\n      }\n\n      let selectionContainsOnlyWhitespace = true;\n\n      for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n        const lineText = model.getLineContent(lineNumber);\n        const startIndex = lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0;\n        const endIndex = lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length;\n        const selectedText = lineText.substring(startIndex, endIndex);\n\n        if (/[^ \\t]/.test(selectedText)) {\n          // this selected text contains something other than whitespace\n          selectionContainsOnlyWhitespace = false;\n          break;\n        }\n      }\n\n      if (selectionContainsOnlyWhitespace) {\n        return false;\n      }\n\n      if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n        const selectionText = model.getValueInRange(selection);\n\n        if (isQuote(selectionText)) {\n          // Typing a quote character on top of another quote character\n          // => disable surround selection type\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n    let commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      const closeCharacter = config.surroundingPairs[ch];\n      commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n    }\n\n    return new EditOperationResult(0\n    /* Other */\n    , commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  }\n\n  static _isTypeInterceptorElectricChar(config, model, selections) {\n    if (selections.length === 1 && model.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n    if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n      return null;\n    }\n\n    let position = selection.getPosition();\n    model.forceTokenization(position.lineNumber);\n    let lineTokens = model.getLineTokens(position.lineNumber);\n    let electricAction;\n\n    try {\n      electricAction = LanguageConfigurationRegistry.onElectricCharacter(ch, lineTokens, position.column);\n    } catch (e) {\n      onUnexpectedError(e);\n      return null;\n    }\n\n    if (!electricAction) {\n      return null;\n    }\n\n    if (electricAction.matchOpenBracket) {\n      let endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n      let match = model.findMatchingBracketUp(electricAction.matchOpenBracket, {\n        lineNumber: position.lineNumber,\n        column: endColumn\n      });\n\n      if (match) {\n        if (match.startLineNumber === position.lineNumber) {\n          // matched something on the same line => no change in indentation\n          return null;\n        }\n\n        let matchLine = model.getLineContent(match.startLineNumber);\n        let matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n        let newIndentation = config.normalizeIndentation(matchLineIndentation);\n        let lineText = model.getLineContent(position.lineNumber);\n        let lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n        let prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n        let typeText = newIndentation + prefix + ch;\n        let typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n        const command = new ReplaceCommand(typeSelection, typeText);\n        return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n          shouldPushStackElementBefore: false,\n          shouldPushStackElementAfter: true\n        });\n      }\n    }\n\n    return null;\n  }\n  /**\n   * This is very similar with typing, but the character is already in the text buffer!\n   */\n\n\n  static compositionEndWithInterceptors(prevEditOperationType, config, model, selectionsWhenCompositionStarted, selections, autoClosedCharacters) {\n    if (!selectionsWhenCompositionStarted || Selection.selectionsArrEqual(selectionsWhenCompositionStarted, selections)) {\n      // no content was typed\n      return null;\n    }\n\n    let ch = null; // extract last typed character\n\n    for (const selection of selections) {\n      if (!selection.isEmpty()) {\n        return null;\n      }\n\n      const position = selection.getPosition();\n      const currentChar = model.getValueInRange(new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column));\n\n      if (ch === null) {\n        ch = currentChar;\n      } else if (ch !== currentChar) {\n        return null;\n      }\n    }\n\n    if (!ch) {\n      return null;\n    }\n\n    if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n      // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n      const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n      return new EditOperationResult(4\n      /* TypingOther */\n      , commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: false\n      });\n    }\n\n    const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n\n    if (autoClosingPairClose !== null) {\n      return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n    }\n\n    return null;\n  }\n\n  static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n    if (!isDoingComposition && ch === '\\n') {\n      let commands = [];\n\n      for (let i = 0, len = selections.length; i < len; i++) {\n        commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n      }\n\n      return new EditOperationResult(4\n      /* TypingOther */\n      , commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: false\n      });\n    }\n\n    if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n      let commands = [];\n      let autoIndentFails = false;\n\n      for (let i = 0, len = selections.length; i < len; i++) {\n        commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n\n        if (!commands[i]) {\n          autoIndentFails = true;\n          break;\n        }\n      }\n\n      if (!autoIndentFails) {\n        return new EditOperationResult(4\n        /* TypingOther */\n        , commands, {\n          shouldPushStackElementBefore: true,\n          shouldPushStackElementAfter: false\n        });\n      }\n    }\n\n    if (!isDoingComposition && this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n      return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n    }\n\n    if (!isDoingComposition) {\n      const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n\n      if (autoClosingPairClose) {\n        return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n      }\n    }\n\n    if (this._isSurroundSelectionType(config, model, selections, ch)) {\n      return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n    } // Electric characters make sense only when dealing with a single cursor,\n    // as multiple cursors typing brackets for example would interfer with bracket matching\n\n\n    if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n      const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n\n      if (r) {\n        return r;\n      }\n    } // A simple character type\n\n\n    let commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ReplaceCommand(selections[i], ch);\n    }\n\n    const opType = getTypingOperation(ch, prevEditOperationType);\n    return new EditOperationResult(opType, commands, {\n      shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n      shouldPushStackElementAfter: false\n    });\n  }\n\n  static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n    let commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ReplaceCommand(selections[i], str);\n    }\n\n    const opType = getTypingOperation(str, prevEditOperationType);\n    return new EditOperationResult(opType, commands, {\n      shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n      shouldPushStackElementAfter: false\n    });\n  }\n\n  static lineInsertBefore(config, model, selections) {\n    if (model === null || selections === null) {\n      return [];\n    }\n\n    let commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      let lineNumber = selections[i].positionLineNumber;\n\n      if (lineNumber === 1) {\n        commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n      } else {\n        lineNumber--;\n        let column = model.getLineMaxColumn(lineNumber);\n        commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n      }\n    }\n\n    return commands;\n  }\n\n  static lineInsertAfter(config, model, selections) {\n    if (model === null || selections === null) {\n      return [];\n    }\n\n    let commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const lineNumber = selections[i].positionLineNumber;\n      let column = model.getLineMaxColumn(lineNumber);\n      commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n    }\n\n    return commands;\n  }\n\n  static lineBreakInsert(config, model, selections) {\n    let commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = this._enter(config, model, true, selections[i]);\n    }\n\n    return commands;\n  }\n\n}\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n  constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n    super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\n    this._openCharacter = openCharacter;\n    this._closeCharacter = closeCharacter;\n    this.closeCharacterRange = null;\n    this.enclosingRange = null;\n  }\n\n  computeCursorState(model, helper) {\n    let inverseEditOperations = helper.getInverseEditOperations();\n    let range = inverseEditOperations[0].range;\n    this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n    this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n    return super.computeCursorState(model, helper);\n  }\n\n}\n\nfunction getTypingOperation(typedText, previousTypingOperation) {\n  if (typedText === ' ') {\n    return previousTypingOperation === 5\n    /* TypingFirstSpace */\n    || previousTypingOperation === 6\n    /* TypingConsecutiveSpace */\n    ? 6\n    /* TypingConsecutiveSpace */\n    : 5\n    /* TypingFirstSpace */\n    ;\n  }\n\n  return 4\n  /* TypingOther */\n  ;\n}\n\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n  if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n    // Always set an undo stop before non-type operations\n    return true;\n  }\n\n  if (previousTypingOperation === 5\n  /* TypingFirstSpace */\n  ) {\n    // `abc |d`: No undo stop\n    // `abc  |d`: Undo stop\n    return false;\n  } // Insert undo stop between different operation types\n\n\n  return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\n\nfunction normalizeOperationType(type) {\n  return type === 6\n  /* TypingConsecutiveSpace */\n  || type === 5\n  /* TypingFirstSpace */\n  ? 'space' : type;\n}\n\nfunction isTypingOperation(type) {\n  return type === 4\n  /* TypingOther */\n  || type === 5\n  /* TypingFirstSpace */\n  || type === 6\n  /* TypingConsecutiveSpace */\n  ;\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/common/controller/cursorTypeOperations.js"],"names":["onUnexpectedError","strings","ReplaceCommand","ReplaceCommandWithOffsetCursorState","ReplaceCommandWithoutChangingPosition","ReplaceCommandThatPreservesSelection","ShiftCommand","SurroundSelectionCommand","CursorColumns","EditOperationResult","isQuote","getMapForWordSeparators","Range","Selection","IndentAction","LanguageConfigurationRegistry","TypeOperations","indent","config","model","selections","commands","i","len","length","isUnshift","tabSize","indentSize","insertSpaces","useTabStops","autoIndent","outdent","shiftIndent","indentation","count","unshiftIndent","_distributedPaste","text","shouldPushStackElementBefore","shouldPushStackElementAfter","_simplePaste","pasteOnNewLine","selection","position","getPosition","isEmpty","indexOf","typeSelection","lineNumber","_distributePasteToCursors","multicursorText","multiCursorPaste","charCodeAt","substr","lines","splitLines","paste","distributedPaste","sort","compareRangesUsingStarts","_goodIndentForLine","action","expectedIndentAction","getInheritIndentForLine","lastLineNumber","lineText","getLineContent","nonWhitespaceIdx","lastNonWhitespaceIndex","maxColumn","getLineMaxColumn","expectedEnterAction","getEnterAction","appendText","Indent","Outdent","normalizeIndentation","_replaceJumpToNextIndent","insertsAutoWhitespace","typeText","getStartPosition","visibleColumnFromColumn","visibleColumnFromColumn2","spacesCnt","tab","startLineNumber","test","isCheapToTokenize","goodIndent","possibleTypeText","startsWith","endLineNumber","lineMaxColumn","startColumn","endColumn","compositionType","prevEditOperationType","replacePrevCharCnt","replaceNextCharCnt","positionDelta","map","_compositionType","shouldPushStackElementBetween","pos","Math","max","column","min","range","oldText","getValueInRange","_typeCommand","keepPosition","_enter","getLeadingWhitespace","substring","r","indentAction","None","IndentOutdent","normalIndent","increasedIndent","actualIndentation","ir","getIndentForEnter","oldEndViewColumn","getEndPosition","oldEndColumn","newLineContent","firstNonWhitespace","firstNonWhitespaceIndex","setEndPosition","afterEnter","offset","ceil","_isAutoIndentType","_runAutoIndentType","ch","currentIndentation","getIndentationAtPosition","getIndentActionForType","getLineFirstNonWhitespaceColumn","_isAutoClosingOvertype","autoClosedCharacters","autoClosingOvertype","autoClosingPairs","autoClosingPairsCloseSingleChar","has","afterCharacter","charAt","chIsQuote","beforeCharacter","found","j","lenJ","autoClosedCharacter","_runAutoClosingOvertype","_isBeforeClosingBrace","lineAfter","nextChar","potentialStartingBraces","autoClosingPairsOpenByStart","get","potentialClosingBraces","autoClosingPairsCloseByStart","isBeforeStartingBrace","some","x","open","isBeforeClosingBrace","close","_findAutoClosingPairOpen","positions","autoClosingPairCandidates","autoClosingPairsOpenByEnd","autoClosingPair","autoClosingPairCandidate","candidateIsMatch","relevantText","_findSubAutoClosingPairClose","lastChar","subPairCandidates","autoClosingPairsCloseByEnd","subPairMatch","includes","endsWith","_getAutoClosingPairClose","insertOpenCharacter","autoCloseConfig","autoClosingQuotes","autoClosingBrackets","s","subAutoClosingPairClose","isSubAutoClosingPairPresent","shouldAutoCloseBefore","quote","bracket","characterAfter","isBeforeCloseBrace","wordSeparators","forceTokenization","lineTokens","getLineTokens","shouldAutoClosePair","e","_runAutoClosingOpenCharType","autoClosingPairClose","TypeWithAutoClosingCommand","_shouldSurroundChar","autoSurround","_isSurroundSelectionType","surroundingPairs","hasOwnProperty","isTypingAQuoteCharacter","selectionContainsOnlyWhitespace","startIndex","endIndex","selectedText","selectionText","_runSurroundSelectionType","closeCharacter","_isTypeInterceptorElectricChar","_typeInterceptorElectricChar","electricChars","electricAction","onElectricCharacter","matchOpenBracket","lastIndexOf","match","findMatchingBracketUp","matchLine","matchLineIndentation","newIndentation","lineFirstNonBlankColumn","prefix","command","getTypingOperation","compositionEndWithInterceptors","selectionsWhenCompositionStarted","selectionsArrEqual","currentChar","positionLineNumber","positionColumn","typeWithInterceptors","isDoingComposition","autoIndentFails","opType","typeWithoutInterceptors","str","lineInsertBefore","lineInsertAfter","lineBreakInsert","constructor","openCharacter","_openCharacter","_closeCharacter","closeCharacterRange","enclosingRange","computeCursorState","helper","inverseEditOperations","getInverseEditOperations","typedText","previousTypingOperation","typingOperation","isTypingOperation","normalizeOperationType","type"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { CursorColumns, EditOperationResult, isQuote } from './cursorCommon.js';\nimport { getMapForWordSeparators } from './wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { IndentAction } from '../modes/languageConfiguration.js';\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\nexport class TypeOperations {\n    static indent(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: false,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            });\n        }\n        return commands;\n    }\n    static outdent(config, model, selections) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: true,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            });\n        }\n        return commands;\n    }\n    static shiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static unshiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static _distributedPaste(config, model, selections, text) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\n        }\n        return new EditOperationResult(0 /* Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            let position = selection.getPosition();\n            if (pasteOnNewLine && !selection.isEmpty()) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine) {\n                // Paste entire line at the beginning of line\n                let typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, text);\n            }\n        }\n        return new EditOperationResult(0 /* Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n        if (pasteOnNewLine) {\n            return null;\n        }\n        if (selections.length === 1) {\n            return null;\n        }\n        if (multicursorText && multicursorText.length === selections.length) {\n            return multicursorText;\n        }\n        if (config.multiCursorPaste === 'spread') {\n            // Try to spread the pasted text in case the line count matches the cursor count\n            // Remove trailing \\n if present\n            if (text.charCodeAt(text.length - 1) === 10 /* LineFeed */) {\n                text = text.substr(0, text.length - 1);\n            }\n            // Remove trailing \\r if present\n            if (text.charCodeAt(text.length - 1) === 13 /* CarriageReturn */) {\n                text = text.substr(0, text.length - 1);\n            }\n            let lines = strings.splitLines(text);\n            if (lines.length === selections.length) {\n                return lines;\n            }\n        }\n        return null;\n    }\n    static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n        if (distributedPaste) {\n            selections = selections.sort(Range.compareRangesUsingStarts);\n            return this._distributedPaste(config, model, selections, distributedPaste);\n        }\n        else {\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n        }\n    }\n    static _goodIndentForLine(config, model, lineNumber) {\n        let action = null;\n        let indentation = '';\n        const expectedIndentAction = LanguageConfigurationRegistry.getInheritIndentForLine(config.autoIndent, model, lineNumber, false);\n        if (expectedIndentAction) {\n            action = expectedIndentAction.action;\n            indentation = expectedIndentAction.indentation;\n        }\n        else if (lineNumber > 1) {\n            let lastLineNumber;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                const lineText = model.getLineContent(lastLineNumber);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n            }\n            if (lastLineNumber < 1) {\n                // No previous line with content found\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\n            const expectedEnterAction = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn));\n            if (expectedEnterAction) {\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n            }\n        }\n        if (action) {\n            if (action === IndentAction.Indent) {\n                indentation = TypeOperations.shiftIndent(config, indentation);\n            }\n            if (action === IndentAction.Outdent) {\n                indentation = TypeOperations.unshiftIndent(config, indentation);\n            }\n            indentation = config.normalizeIndentation(indentation);\n        }\n        if (!indentation) {\n            return null;\n        }\n        return indentation;\n    }\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n        let typeText = '';\n        let position = selection.getStartPosition();\n        if (config.insertSpaces) {\n            let visibleColumnFromColumn = CursorColumns.visibleColumnFromColumn2(config, model, position);\n            let indentSize = config.indentSize;\n            let spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n            for (let i = 0; i < spacesCnt; i++) {\n                typeText += ' ';\n            }\n        }\n        else {\n            typeText = '\\t';\n        }\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n    static tab(config, model, selections) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                let lineText = model.getLineContent(selection.startLineNumber);\n                if (/^\\s*$/.test(lineText) && model.isCheapToTokenize(selection.startLineNumber)) {\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                    goodIndent = goodIndent || '\\t';\n                    let possibleTypeText = config.normalizeIndentation(goodIndent);\n                    if (!lineText.startsWith(possibleTypeText)) {\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                        continue;\n                    }\n                }\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n            }\n            else {\n                if (selection.startLineNumber === selection.endLineNumber) {\n                    let lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                        // This is a single line selection that is not the entire line\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                        continue;\n                    }\n                }\n                commands[i] = new ShiftCommand(selection, {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops,\n                    autoIndent: config.autoIndent\n                });\n            }\n        }\n        return commands;\n    }\n    static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        return new EditOperationResult(4 /* TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!selection.isEmpty()) {\n            // looks like https://github.com/microsoft/vscode/issues/2773\n            // where a cursor operation occurred before a canceled composition\n            // => ignore composition\n            return null;\n        }\n        const pos = selection.getPosition();\n        const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n        const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n        const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n        const oldText = model.getValueInRange(range);\n        if (oldText === text && positionDelta === 0) {\n            // => ignore composition that doesn't do anything\n            return null;\n        }\n        return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n    }\n    static _typeCommand(range, text, keepPosition) {\n        if (keepPosition) {\n            return new ReplaceCommandWithoutChangingPosition(range, text, true);\n        }\n        else {\n            return new ReplaceCommand(range, text, true);\n        }\n    }\n    static _enter(config, model, keepPosition, range) {\n        if (config.autoIndent === 0 /* None */) {\n            return TypeOperations._typeCommand(range, '\\n', keepPosition);\n        }\n        if (!model.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* Keep */) {\n            let lineText = model.getLineContent(range.startLineNumber);\n            let indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n            return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n        }\n        const r = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, range);\n        if (r) {\n            if (r.indentAction === IndentAction.None) {\n                // Nothing special\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.Indent) {\n                // Indent once\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.IndentOutdent) {\n                // Ultra special\n                const normalIndent = config.normalizeIndentation(r.indentation);\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                }\n                else {\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                }\n            }\n            else if (r.indentAction === IndentAction.Outdent) {\n                const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n            }\n        }\n        const lineText = model.getLineContent(range.startLineNumber);\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n        if (config.autoIndent >= 4 /* Full */) {\n            const ir = LanguageConfigurationRegistry.getIndentForEnter(config.autoIndent, model, range, {\n                unshiftIndent: (indent) => {\n                    return TypeOperations.unshiftIndent(config, indent);\n                },\n                shiftIndent: (indent) => {\n                    return TypeOperations.shiftIndent(config, indent);\n                },\n                normalizeIndentation: (indent) => {\n                    return config.normalizeIndentation(indent);\n                }\n            });\n            if (ir) {\n                let oldEndViewColumn = CursorColumns.visibleColumnFromColumn2(config, model, range.getEndPosition());\n                const oldEndColumn = range.endColumn;\n                const newLineContent = model.getLineContent(range.endLineNumber);\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n                if (firstNonWhitespace >= 0) {\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n                }\n                else {\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n                }\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n                }\n                else {\n                    let offset = 0;\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\n                        if (!config.insertSpaces) {\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                        }\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                    }\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n                }\n            }\n        }\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    static _isAutoIndentType(config, model, selections) {\n        if (config.autoIndent < 4 /* Full */) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            if (!model.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _runAutoIndentType(config, model, range, ch) {\n        const currentIndentation = LanguageConfigurationRegistry.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        const actualIndentation = LanguageConfigurationRegistry.getIndentActionForType(config.autoIndent, model, range, ch, {\n            shiftIndent: (indentation) => {\n                return TypeOperations.shiftIndent(config, indentation);\n            },\n            unshiftIndent: (indentation) => {\n                return TypeOperations.unshiftIndent(config, indentation);\n            },\n        });\n        if (actualIndentation === null) {\n            return null;\n        }\n        if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n            const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n            if (firstNonWhitespace === 0) {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n            }\n            else {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) +\n                    model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n            }\n        }\n        return null;\n    }\n    static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n        if (config.autoClosingOvertype === 'never') {\n            return false;\n        }\n        if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const position = selection.getPosition();\n            const lineText = model.getLineContent(position.lineNumber);\n            const afterCharacter = lineText.charAt(position.column - 1);\n            if (afterCharacter !== ch) {\n                return false;\n            }\n            // Do not over-type quotes after a backslash\n            const chIsQuote = isQuote(ch);\n            const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* Null */;\n            if (beforeCharacter === 92 /* Backslash */ && chIsQuote) {\n                return false;\n            }\n            // Must over-type a closing character typed by the editor\n            if (config.autoClosingOvertype === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(typeSelection, ch);\n        }\n        return new EditOperationResult(4 /* TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _isBeforeClosingBrace(config, lineAfter) {\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n        const nextChar = lineAfter.charAt(0);\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\n        const autoClosingPairCandidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n        if (!autoClosingPairCandidates) {\n            return null;\n        }\n        // Determine which auto-closing pair it is\n        let autoClosingPair = null;\n        for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n            if (autoClosingPair === null || autoClosingPairCandidate.open.length > autoClosingPair.open.length) {\n                let candidateIsMatch = true;\n                for (const position of positions) {\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - autoClosingPairCandidate.open.length + 1, position.lineNumber, position.column));\n                    if (relevantText + ch !== autoClosingPairCandidate.open) {\n                        candidateIsMatch = false;\n                        break;\n                    }\n                }\n                if (candidateIsMatch) {\n                    autoClosingPair = autoClosingPairCandidate;\n                }\n            }\n        }\n        return autoClosingPair;\n    }\n    static _findSubAutoClosingPairClose(config, autoClosingPair) {\n        if (autoClosingPair.open.length <= 1) {\n            return '';\n        }\n        const lastChar = autoClosingPair.close.charAt(autoClosingPair.close.length - 1);\n        // get candidates with the same last character as close\n        const subPairCandidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n        let subPairMatch = null;\n        for (const x of subPairCandidates) {\n            if (x.open !== autoClosingPair.open && autoClosingPair.open.includes(x.open) && autoClosingPair.close.endsWith(x.close)) {\n                if (!subPairMatch || x.open.length > subPairMatch.open.length) {\n                    subPairMatch = x;\n                }\n            }\n        }\n        if (subPairMatch) {\n            return subPairMatch.close;\n        }\n        else {\n            return '';\n        }\n    }\n    static _getAutoClosingPairClose(config, model, selections, ch, insertOpenCharacter) {\n        const chIsQuote = isQuote(ch);\n        const autoCloseConfig = chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets;\n        if (autoCloseConfig === 'never') {\n            return null;\n        }\n        const autoClosingPair = this._findAutoClosingPairOpen(config, model, selections.map(s => s.getPosition()), ch);\n        if (!autoClosingPair) {\n            return null;\n        }\n        const subAutoClosingPairClose = this._findSubAutoClosingPairClose(config, autoClosingPair);\n        let isSubAutoClosingPairPresent = true;\n        const shouldAutoCloseBefore = chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket;\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (!selection.isEmpty()) {\n                return null;\n            }\n            const position = selection.getPosition();\n            const lineText = model.getLineContent(position.lineNumber);\n            const lineAfter = lineText.substring(position.column - 1);\n            if (!lineAfter.startsWith(subAutoClosingPairClose)) {\n                isSubAutoClosingPairPresent = false;\n            }\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n            if (lineText.length > position.column - 1) {\n                const characterAfter = lineText.charAt(position.column - 1);\n                const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                    return null;\n                }\n            }\n            if (!model.isCheapToTokenize(position.lineNumber)) {\n                // Do not force tokenization\n                return null;\n            }\n            // Do not auto-close ' or \" after a word character\n            if (autoClosingPair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n                if (insertOpenCharacter && position.column > 1 && wordSeparators.get(lineText.charCodeAt(position.column - 2)) === 0 /* Regular */) {\n                    return null;\n                }\n                if (!insertOpenCharacter && position.column > 2 && wordSeparators.get(lineText.charCodeAt(position.column - 3)) === 0 /* Regular */) {\n                    return null;\n                }\n            }\n            model.forceTokenization(position.lineNumber);\n            const lineTokens = model.getLineTokens(position.lineNumber);\n            let shouldAutoClosePair = false;\n            try {\n                shouldAutoClosePair = LanguageConfigurationRegistry.shouldAutoClosePair(autoClosingPair, lineTokens, insertOpenCharacter ? position.column : position.column - 1);\n            }\n            catch (e) {\n                onUnexpectedError(e);\n            }\n            if (!shouldAutoClosePair) {\n                return null;\n            }\n        }\n        if (isSubAutoClosingPairPresent) {\n            return autoClosingPair.close.substring(0, autoClosingPair.close.length - subAutoClosingPairClose.length);\n        }\n        else {\n            return autoClosingPair.close;\n        }\n    }\n    static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, insertOpenCharacter, autoClosingPairClose) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, insertOpenCharacter, autoClosingPairClose);\n        }\n        return new EditOperationResult(4 /* TypingOther */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _shouldSurroundChar(config, ch) {\n        if (isQuote(ch)) {\n            return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n        }\n        else {\n            // Character is a bracket\n            return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n        }\n    }\n    static _isSurroundSelectionType(config, model, selections, ch) {\n        if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n            return false;\n        }\n        const isTypingAQuoteCharacter = isQuote(ch);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                return false;\n            }\n            let selectionContainsOnlyWhitespace = true;\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                const selectedText = lineText.substring(startIndex, endIndex);\n                if (/[^ \\t]/.test(selectedText)) {\n                    // this selected text contains something other than whitespace\n                    selectionContainsOnlyWhitespace = false;\n                    break;\n                }\n            }\n            if (selectionContainsOnlyWhitespace) {\n                return false;\n            }\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                const selectionText = model.getValueInRange(selection);\n                if (isQuote(selectionText)) {\n                    // Typing a quote character on top of another quote character\n                    // => disable surround selection type\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const closeCharacter = config.surroundingPairs[ch];\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n        }\n        return new EditOperationResult(0 /* Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _isTypeInterceptorElectricChar(config, model, selections) {\n        if (selections.length === 1 && model.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n            return true;\n        }\n        return false;\n    }\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n            return null;\n        }\n        let position = selection.getPosition();\n        model.forceTokenization(position.lineNumber);\n        let lineTokens = model.getLineTokens(position.lineNumber);\n        let electricAction;\n        try {\n            electricAction = LanguageConfigurationRegistry.onElectricCharacter(ch, lineTokens, position.column);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n        if (!electricAction) {\n            return null;\n        }\n        if (electricAction.matchOpenBracket) {\n            let endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n            let match = model.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                lineNumber: position.lineNumber,\n                column: endColumn\n            });\n            if (match) {\n                if (match.startLineNumber === position.lineNumber) {\n                    // matched something on the same line => no change in indentation\n                    return null;\n                }\n                let matchLine = model.getLineContent(match.startLineNumber);\n                let matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                let newIndentation = config.normalizeIndentation(matchLineIndentation);\n                let lineText = model.getLineContent(position.lineNumber);\n                let lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                let prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                let typeText = newIndentation + prefix + ch;\n                let typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n                const command = new ReplaceCommand(typeSelection, typeText);\n                return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n        }\n        return null;\n    }\n    /**\n     * This is very similar with typing, but the character is already in the text buffer!\n     */\n    static compositionEndWithInterceptors(prevEditOperationType, config, model, selectionsWhenCompositionStarted, selections, autoClosedCharacters) {\n        if (!selectionsWhenCompositionStarted || Selection.selectionsArrEqual(selectionsWhenCompositionStarted, selections)) {\n            // no content was typed\n            return null;\n        }\n        let ch = null;\n        // extract last typed character\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n            const position = selection.getPosition();\n            const currentChar = model.getValueInRange(new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column));\n            if (ch === null) {\n                ch = currentChar;\n            }\n            else if (ch !== currentChar) {\n                return null;\n            }\n        }\n        if (!ch) {\n            return null;\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n            return new EditOperationResult(4 /* TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n        if (autoClosingPairClose !== null) {\n            return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n        }\n        return null;\n    }\n    static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        if (!isDoingComposition && ch === '\\n') {\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n            }\n            return new EditOperationResult(4 /* TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false,\n            });\n        }\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n            let commands = [];\n            let autoIndentFails = false;\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n                if (!commands[i]) {\n                    autoIndentFails = true;\n                    break;\n                }\n            }\n            if (!autoIndentFails) {\n                return new EditOperationResult(4 /* TypingOther */, commands, {\n                    shouldPushStackElementBefore: true,\n                    shouldPushStackElementAfter: false,\n                });\n            }\n        }\n        if (!isDoingComposition && this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n        }\n        if (!isDoingComposition) {\n            const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n            if (autoClosingPairClose) {\n                return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n            }\n        }\n        if (this._isSurroundSelectionType(config, model, selections, ch)) {\n            return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n        }\n        // Electric characters make sense only when dealing with a single cursor,\n        // as multiple cursors typing brackets for example would interfer with bracket matching\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n            if (r) {\n                return r;\n            }\n        }\n        // A simple character type\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], ch);\n        }\n        const opType = getTypingOperation(ch, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], str);\n        }\n        const opType = getTypingOperation(str, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static lineInsertBefore(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let lineNumber = selections[i].positionLineNumber;\n            if (lineNumber === 1) {\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n            }\n            else {\n                lineNumber--;\n                let column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n            }\n        }\n        return commands;\n    }\n    static lineInsertAfter(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const lineNumber = selections[i].positionLineNumber;\n            let column = model.getLineMaxColumn(lineNumber);\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n        return commands;\n    }\n    static lineBreakInsert(config, model, selections) {\n        let commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = this._enter(config, model, true, selections[i]);\n        }\n        return commands;\n    }\n}\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n        super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\n        this._openCharacter = openCharacter;\n        this._closeCharacter = closeCharacter;\n        this.closeCharacterRange = null;\n        this.enclosingRange = null;\n    }\n    computeCursorState(model, helper) {\n        let inverseEditOperations = helper.getInverseEditOperations();\n        let range = inverseEditOperations[0].range;\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        return super.computeCursorState(model, helper);\n    }\n}\nfunction getTypingOperation(typedText, previousTypingOperation) {\n    if (typedText === ' ') {\n        return previousTypingOperation === 5 /* TypingFirstSpace */\n            || previousTypingOperation === 6 /* TypingConsecutiveSpace */\n            ? 6 /* TypingConsecutiveSpace */\n            : 5 /* TypingFirstSpace */;\n    }\n    return 4 /* TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n    if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n        // Always set an undo stop before non-type operations\n        return true;\n    }\n    if (previousTypingOperation === 5 /* TypingFirstSpace */) {\n        // `abc |d`: No undo stop\n        // `abc  |d`: Undo stop\n        return false;\n    }\n    // Insert undo stop between different operation types\n    return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n    return (type === 6 /* TypingConsecutiveSpace */ || type === 5 /* TypingFirstSpace */)\n        ? 'space'\n        : type;\n}\nfunction isTypingOperation(type) {\n    return type === 4 /* TypingOther */\n        || type === 5 /* TypingFirstSpace */\n        || type === 6 /* TypingConsecutiveSpace */;\n}\n"]},"metadata":{},"sourceType":"module"}