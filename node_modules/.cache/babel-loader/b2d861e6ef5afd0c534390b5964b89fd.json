{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as mime from '../../../base/common/mime.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ModesRegistry, PLAINTEXT_MODE_ID } from '../modes/modesRegistry.js';\nimport { NULL_MODE_ID } from '../modes/nullMode.js';\nimport { Extensions } from '../../../platform/configuration/common/configurationRegistry.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nexport class LanguageIdCodec {\n  constructor() {\n    this._languageIdToLanguage = [];\n    this._languageToLanguageId = new Map();\n\n    this._register(NULL_MODE_ID, 0\n    /* Null */\n    );\n\n    this._register(PLAINTEXT_MODE_ID, 1\n    /* PlainText */\n    );\n\n    this._nextLanguageId = 2;\n  }\n\n  _register(language, languageId) {\n    this._languageIdToLanguage[languageId] = language;\n\n    this._languageToLanguageId.set(language, languageId);\n  }\n\n  register(language) {\n    if (this._languageToLanguageId.has(language)) {\n      return;\n    }\n\n    const languageId = this._nextLanguageId++;\n\n    this._register(language, languageId);\n  }\n\n  encodeLanguageId(languageId) {\n    return this._languageToLanguageId.get(languageId) || 0\n    /* Null */\n    ;\n  }\n\n  decodeLanguageId(languageId) {\n    return this._languageIdToLanguage[languageId] || NULL_MODE_ID;\n  }\n\n}\nexport class LanguagesRegistry extends Disposable {\n  constructor() {\n    let useModesRegistry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let warnOnOverwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super();\n    this._onDidChange = this._register(new Emitter());\n    this.onDidChange = this._onDidChange.event;\n    LanguagesRegistry.instanceCount++;\n    this._warnOnOverwrite = warnOnOverwrite;\n    this.languageIdCodec = new LanguageIdCodec();\n    this._languages = {};\n    this._mimeTypesMap = {};\n    this._nameMap = {};\n    this._lowercaseNameMap = {};\n\n    if (useModesRegistry) {\n      this._initializeFromRegistry();\n\n      this._register(ModesRegistry.onDidChangeLanguages(m => {\n        // console.log(`onDidChangeLanguages - inst count: ${LanguagesRegistry.instanceCount}`);\n        this._initializeFromRegistry();\n      }));\n    }\n  }\n\n  dispose() {\n    LanguagesRegistry.instanceCount--;\n    super.dispose();\n  }\n\n  _initializeFromRegistry() {\n    this._languages = {};\n    this._mimeTypesMap = {};\n    this._nameMap = {};\n    this._lowercaseNameMap = {};\n    mime.clearTextMimes();\n    const desc = ModesRegistry.getLanguages();\n\n    this._registerLanguages(desc);\n  }\n\n  _registerLanguages(desc) {\n    for (const d of desc) {\n      this._registerLanguage(d);\n    } // Rebuild fast path maps\n\n\n    this._mimeTypesMap = {};\n    this._nameMap = {};\n    this._lowercaseNameMap = {};\n    Object.keys(this._languages).forEach(langId => {\n      let language = this._languages[langId];\n\n      if (language.name) {\n        this._nameMap[language.name] = language.identifier;\n      }\n\n      language.aliases.forEach(alias => {\n        this._lowercaseNameMap[alias.toLowerCase()] = language.identifier;\n      });\n      language.mimetypes.forEach(mimetype => {\n        this._mimeTypesMap[mimetype] = language.identifier;\n      });\n    });\n    Registry.as(Extensions.Configuration).registerOverrideIdentifiers(ModesRegistry.getLanguages().map(language => language.id));\n\n    this._onDidChange.fire();\n  }\n\n  _registerLanguage(lang) {\n    const langId = lang.id;\n    let resolvedLanguage;\n\n    if (hasOwnProperty.call(this._languages, langId)) {\n      resolvedLanguage = this._languages[langId];\n    } else {\n      this.languageIdCodec.register(langId);\n      resolvedLanguage = {\n        identifier: langId,\n        name: null,\n        mimetypes: [],\n        aliases: [],\n        extensions: [],\n        filenames: [],\n        configurationFiles: []\n      };\n      this._languages[langId] = resolvedLanguage;\n    }\n\n    this._mergeLanguage(resolvedLanguage, lang);\n  }\n\n  _mergeLanguage(resolvedLanguage, lang) {\n    const langId = lang.id;\n    let primaryMime = null;\n\n    if (Array.isArray(lang.mimetypes) && lang.mimetypes.length > 0) {\n      resolvedLanguage.mimetypes.push(...lang.mimetypes);\n      primaryMime = lang.mimetypes[0];\n    }\n\n    if (!primaryMime) {\n      primaryMime = `text/x-${langId}`;\n      resolvedLanguage.mimetypes.push(primaryMime);\n    }\n\n    if (Array.isArray(lang.extensions)) {\n      if (lang.configuration) {\n        // insert first as this appears to be the 'primary' language definition\n        resolvedLanguage.extensions = lang.extensions.concat(resolvedLanguage.extensions);\n      } else {\n        resolvedLanguage.extensions = resolvedLanguage.extensions.concat(lang.extensions);\n      }\n\n      for (let extension of lang.extensions) {\n        mime.registerTextMime({\n          id: langId,\n          mime: primaryMime,\n          extension: extension\n        }, this._warnOnOverwrite);\n      }\n    }\n\n    if (Array.isArray(lang.filenames)) {\n      for (let filename of lang.filenames) {\n        mime.registerTextMime({\n          id: langId,\n          mime: primaryMime,\n          filename: filename\n        }, this._warnOnOverwrite);\n        resolvedLanguage.filenames.push(filename);\n      }\n    }\n\n    if (Array.isArray(lang.filenamePatterns)) {\n      for (let filenamePattern of lang.filenamePatterns) {\n        mime.registerTextMime({\n          id: langId,\n          mime: primaryMime,\n          filepattern: filenamePattern\n        }, this._warnOnOverwrite);\n      }\n    }\n\n    if (typeof lang.firstLine === 'string' && lang.firstLine.length > 0) {\n      let firstLineRegexStr = lang.firstLine;\n\n      if (firstLineRegexStr.charAt(0) !== '^') {\n        firstLineRegexStr = '^' + firstLineRegexStr;\n      }\n\n      try {\n        let firstLineRegex = new RegExp(firstLineRegexStr);\n\n        if (!strings.regExpLeadsToEndlessLoop(firstLineRegex)) {\n          mime.registerTextMime({\n            id: langId,\n            mime: primaryMime,\n            firstline: firstLineRegex\n          }, this._warnOnOverwrite);\n        }\n      } catch (err) {\n        // Most likely, the regex was bad\n        onUnexpectedError(err);\n      }\n    }\n\n    resolvedLanguage.aliases.push(langId);\n    let langAliases = null;\n\n    if (typeof lang.aliases !== 'undefined' && Array.isArray(lang.aliases)) {\n      if (lang.aliases.length === 0) {\n        // signal that this language should not get a name\n        langAliases = [null];\n      } else {\n        langAliases = lang.aliases;\n      }\n    }\n\n    if (langAliases !== null) {\n      for (const langAlias of langAliases) {\n        if (!langAlias || langAlias.length === 0) {\n          continue;\n        }\n\n        resolvedLanguage.aliases.push(langAlias);\n      }\n    }\n\n    let containsAliases = langAliases !== null && langAliases.length > 0;\n\n    if (containsAliases && langAliases[0] === null) {// signal that this language should not get a name\n    } else {\n      let bestName = (containsAliases ? langAliases[0] : null) || langId;\n\n      if (containsAliases || !resolvedLanguage.name) {\n        resolvedLanguage.name = bestName;\n      }\n    }\n\n    if (lang.configuration) {\n      resolvedLanguage.configurationFiles.push(lang.configuration);\n    }\n  }\n\n  isRegisteredMode(mimetypeOrModeId) {\n    // Is this a known mime type ?\n    if (hasOwnProperty.call(this._mimeTypesMap, mimetypeOrModeId)) {\n      return true;\n    } // Is this a known mode id ?\n\n\n    return hasOwnProperty.call(this._languages, mimetypeOrModeId);\n  }\n\n  getModeIdForLanguageNameLowercase(languageNameLower) {\n    if (!hasOwnProperty.call(this._lowercaseNameMap, languageNameLower)) {\n      return null;\n    }\n\n    return this._lowercaseNameMap[languageNameLower];\n  }\n\n  extractModeIds(commaSeparatedMimetypesOrCommaSeparatedIds) {\n    if (!commaSeparatedMimetypesOrCommaSeparatedIds) {\n      return [];\n    }\n\n    return commaSeparatedMimetypesOrCommaSeparatedIds.split(',').map(mimeTypeOrId => mimeTypeOrId.trim()).map(mimeTypeOrId => {\n      if (hasOwnProperty.call(this._mimeTypesMap, mimeTypeOrId)) {\n        return this._mimeTypesMap[mimeTypeOrId];\n      }\n\n      return mimeTypeOrId;\n    }).filter(languageId => {\n      return hasOwnProperty.call(this._languages, languageId);\n    });\n  }\n\n  validateLanguageId(languageId) {\n    if (!languageId || languageId === NULL_MODE_ID) {\n      return NULL_MODE_ID;\n    }\n\n    if (!hasOwnProperty.call(this._languages, languageId)) {\n      return null;\n    }\n\n    return languageId;\n  }\n\n  getModeIdsFromFilepathOrFirstLine(resource, firstLine) {\n    if (!resource && !firstLine) {\n      return [];\n    }\n\n    let mimeTypes = mime.guessMimeTypes(resource, firstLine);\n    return this.extractModeIds(mimeTypes.join(','));\n  }\n\n}\nLanguagesRegistry.instanceCount = 0;","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/common/services/languagesRegistry.js"],"names":["onUnexpectedError","Emitter","Disposable","mime","strings","ModesRegistry","PLAINTEXT_MODE_ID","NULL_MODE_ID","Extensions","Registry","hasOwnProperty","Object","prototype","LanguageIdCodec","constructor","_languageIdToLanguage","_languageToLanguageId","Map","_register","_nextLanguageId","language","languageId","set","register","has","encodeLanguageId","get","decodeLanguageId","LanguagesRegistry","useModesRegistry","warnOnOverwrite","_onDidChange","onDidChange","event","instanceCount","_warnOnOverwrite","languageIdCodec","_languages","_mimeTypesMap","_nameMap","_lowercaseNameMap","_initializeFromRegistry","onDidChangeLanguages","m","dispose","clearTextMimes","desc","getLanguages","_registerLanguages","d","_registerLanguage","keys","forEach","langId","name","identifier","aliases","alias","toLowerCase","mimetypes","mimetype","as","Configuration","registerOverrideIdentifiers","map","id","fire","lang","resolvedLanguage","call","extensions","filenames","configurationFiles","_mergeLanguage","primaryMime","Array","isArray","length","push","configuration","concat","extension","registerTextMime","filename","filenamePatterns","filenamePattern","filepattern","firstLine","firstLineRegexStr","charAt","firstLineRegex","RegExp","regExpLeadsToEndlessLoop","firstline","err","langAliases","langAlias","containsAliases","bestName","isRegisteredMode","mimetypeOrModeId","getModeIdForLanguageNameLowercase","languageNameLower","extractModeIds","commaSeparatedMimetypesOrCommaSeparatedIds","split","mimeTypeOrId","trim","filter","validateLanguageId","getModeIdsFromFilepathOrFirstLine","resource","mimeTypes","guessMimeTypes","join"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as mime from '../../../base/common/mime.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ModesRegistry, PLAINTEXT_MODE_ID } from '../modes/modesRegistry.js';\nimport { NULL_MODE_ID } from '../modes/nullMode.js';\nimport { Extensions } from '../../../platform/configuration/common/configurationRegistry.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nexport class LanguageIdCodec {\n    constructor() {\n        this._languageIdToLanguage = [];\n        this._languageToLanguageId = new Map();\n        this._register(NULL_MODE_ID, 0 /* Null */);\n        this._register(PLAINTEXT_MODE_ID, 1 /* PlainText */);\n        this._nextLanguageId = 2;\n    }\n    _register(language, languageId) {\n        this._languageIdToLanguage[languageId] = language;\n        this._languageToLanguageId.set(language, languageId);\n    }\n    register(language) {\n        if (this._languageToLanguageId.has(language)) {\n            return;\n        }\n        const languageId = this._nextLanguageId++;\n        this._register(language, languageId);\n    }\n    encodeLanguageId(languageId) {\n        return this._languageToLanguageId.get(languageId) || 0 /* Null */;\n    }\n    decodeLanguageId(languageId) {\n        return this._languageIdToLanguage[languageId] || NULL_MODE_ID;\n    }\n}\nexport class LanguagesRegistry extends Disposable {\n    constructor(useModesRegistry = true, warnOnOverwrite = false) {\n        super();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        LanguagesRegistry.instanceCount++;\n        this._warnOnOverwrite = warnOnOverwrite;\n        this.languageIdCodec = new LanguageIdCodec();\n        this._languages = {};\n        this._mimeTypesMap = {};\n        this._nameMap = {};\n        this._lowercaseNameMap = {};\n        if (useModesRegistry) {\n            this._initializeFromRegistry();\n            this._register(ModesRegistry.onDidChangeLanguages((m) => {\n                // console.log(`onDidChangeLanguages - inst count: ${LanguagesRegistry.instanceCount}`);\n                this._initializeFromRegistry();\n            }));\n        }\n    }\n    dispose() {\n        LanguagesRegistry.instanceCount--;\n        super.dispose();\n    }\n    _initializeFromRegistry() {\n        this._languages = {};\n        this._mimeTypesMap = {};\n        this._nameMap = {};\n        this._lowercaseNameMap = {};\n        mime.clearTextMimes();\n        const desc = ModesRegistry.getLanguages();\n        this._registerLanguages(desc);\n    }\n    _registerLanguages(desc) {\n        for (const d of desc) {\n            this._registerLanguage(d);\n        }\n        // Rebuild fast path maps\n        this._mimeTypesMap = {};\n        this._nameMap = {};\n        this._lowercaseNameMap = {};\n        Object.keys(this._languages).forEach((langId) => {\n            let language = this._languages[langId];\n            if (language.name) {\n                this._nameMap[language.name] = language.identifier;\n            }\n            language.aliases.forEach((alias) => {\n                this._lowercaseNameMap[alias.toLowerCase()] = language.identifier;\n            });\n            language.mimetypes.forEach((mimetype) => {\n                this._mimeTypesMap[mimetype] = language.identifier;\n            });\n        });\n        Registry.as(Extensions.Configuration).registerOverrideIdentifiers(ModesRegistry.getLanguages().map(language => language.id));\n        this._onDidChange.fire();\n    }\n    _registerLanguage(lang) {\n        const langId = lang.id;\n        let resolvedLanguage;\n        if (hasOwnProperty.call(this._languages, langId)) {\n            resolvedLanguage = this._languages[langId];\n        }\n        else {\n            this.languageIdCodec.register(langId);\n            resolvedLanguage = {\n                identifier: langId,\n                name: null,\n                mimetypes: [],\n                aliases: [],\n                extensions: [],\n                filenames: [],\n                configurationFiles: []\n            };\n            this._languages[langId] = resolvedLanguage;\n        }\n        this._mergeLanguage(resolvedLanguage, lang);\n    }\n    _mergeLanguage(resolvedLanguage, lang) {\n        const langId = lang.id;\n        let primaryMime = null;\n        if (Array.isArray(lang.mimetypes) && lang.mimetypes.length > 0) {\n            resolvedLanguage.mimetypes.push(...lang.mimetypes);\n            primaryMime = lang.mimetypes[0];\n        }\n        if (!primaryMime) {\n            primaryMime = `text/x-${langId}`;\n            resolvedLanguage.mimetypes.push(primaryMime);\n        }\n        if (Array.isArray(lang.extensions)) {\n            if (lang.configuration) {\n                // insert first as this appears to be the 'primary' language definition\n                resolvedLanguage.extensions = lang.extensions.concat(resolvedLanguage.extensions);\n            }\n            else {\n                resolvedLanguage.extensions = resolvedLanguage.extensions.concat(lang.extensions);\n            }\n            for (let extension of lang.extensions) {\n                mime.registerTextMime({ id: langId, mime: primaryMime, extension: extension }, this._warnOnOverwrite);\n            }\n        }\n        if (Array.isArray(lang.filenames)) {\n            for (let filename of lang.filenames) {\n                mime.registerTextMime({ id: langId, mime: primaryMime, filename: filename }, this._warnOnOverwrite);\n                resolvedLanguage.filenames.push(filename);\n            }\n        }\n        if (Array.isArray(lang.filenamePatterns)) {\n            for (let filenamePattern of lang.filenamePatterns) {\n                mime.registerTextMime({ id: langId, mime: primaryMime, filepattern: filenamePattern }, this._warnOnOverwrite);\n            }\n        }\n        if (typeof lang.firstLine === 'string' && lang.firstLine.length > 0) {\n            let firstLineRegexStr = lang.firstLine;\n            if (firstLineRegexStr.charAt(0) !== '^') {\n                firstLineRegexStr = '^' + firstLineRegexStr;\n            }\n            try {\n                let firstLineRegex = new RegExp(firstLineRegexStr);\n                if (!strings.regExpLeadsToEndlessLoop(firstLineRegex)) {\n                    mime.registerTextMime({ id: langId, mime: primaryMime, firstline: firstLineRegex }, this._warnOnOverwrite);\n                }\n            }\n            catch (err) {\n                // Most likely, the regex was bad\n                onUnexpectedError(err);\n            }\n        }\n        resolvedLanguage.aliases.push(langId);\n        let langAliases = null;\n        if (typeof lang.aliases !== 'undefined' && Array.isArray(lang.aliases)) {\n            if (lang.aliases.length === 0) {\n                // signal that this language should not get a name\n                langAliases = [null];\n            }\n            else {\n                langAliases = lang.aliases;\n            }\n        }\n        if (langAliases !== null) {\n            for (const langAlias of langAliases) {\n                if (!langAlias || langAlias.length === 0) {\n                    continue;\n                }\n                resolvedLanguage.aliases.push(langAlias);\n            }\n        }\n        let containsAliases = (langAliases !== null && langAliases.length > 0);\n        if (containsAliases && langAliases[0] === null) {\n            // signal that this language should not get a name\n        }\n        else {\n            let bestName = (containsAliases ? langAliases[0] : null) || langId;\n            if (containsAliases || !resolvedLanguage.name) {\n                resolvedLanguage.name = bestName;\n            }\n        }\n        if (lang.configuration) {\n            resolvedLanguage.configurationFiles.push(lang.configuration);\n        }\n    }\n    isRegisteredMode(mimetypeOrModeId) {\n        // Is this a known mime type ?\n        if (hasOwnProperty.call(this._mimeTypesMap, mimetypeOrModeId)) {\n            return true;\n        }\n        // Is this a known mode id ?\n        return hasOwnProperty.call(this._languages, mimetypeOrModeId);\n    }\n    getModeIdForLanguageNameLowercase(languageNameLower) {\n        if (!hasOwnProperty.call(this._lowercaseNameMap, languageNameLower)) {\n            return null;\n        }\n        return this._lowercaseNameMap[languageNameLower];\n    }\n    extractModeIds(commaSeparatedMimetypesOrCommaSeparatedIds) {\n        if (!commaSeparatedMimetypesOrCommaSeparatedIds) {\n            return [];\n        }\n        return (commaSeparatedMimetypesOrCommaSeparatedIds.\n            split(',').\n            map((mimeTypeOrId) => mimeTypeOrId.trim()).\n            map((mimeTypeOrId) => {\n            if (hasOwnProperty.call(this._mimeTypesMap, mimeTypeOrId)) {\n                return this._mimeTypesMap[mimeTypeOrId];\n            }\n            return mimeTypeOrId;\n        }).\n            filter((languageId) => {\n            return hasOwnProperty.call(this._languages, languageId);\n        }));\n    }\n    validateLanguageId(languageId) {\n        if (!languageId || languageId === NULL_MODE_ID) {\n            return NULL_MODE_ID;\n        }\n        if (!hasOwnProperty.call(this._languages, languageId)) {\n            return null;\n        }\n        return languageId;\n    }\n    getModeIdsFromFilepathOrFirstLine(resource, firstLine) {\n        if (!resource && !firstLine) {\n            return [];\n        }\n        let mimeTypes = mime.guessMimeTypes(resource, firstLine);\n        return this.extractModeIds(mimeTypes.join(','));\n    }\n}\nLanguagesRegistry.instanceCount = 0;\n"]},"metadata":{},"sourceType":"module"}