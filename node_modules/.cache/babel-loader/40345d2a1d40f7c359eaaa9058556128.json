{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { Codicon } from '../../../base/common/codicons.js';\nimport { pieceToQuery, prepareQuery, scoreFuzzy2 } from '../../../base/common/fuzzyScorer.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../base/common/lifecycle.js';\nimport { format, trim } from '../../../base/common/strings.js';\nimport { Range } from '../../common/core/range.js';\nimport { DocumentSymbolProviderRegistry, SymbolKinds } from '../../common/modes.js';\nimport { OutlineModel } from '../documentSymbols/outlineModel.js';\nimport { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';\nimport { localize } from '../../../nls.js';\nexport class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.create(null);\n    super(options);\n    this.options = options;\n    this.options.canAcceptInBackground = true;\n  }\n\n  provideWithoutTextEditor(picker) {\n    this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutEditor', \"To go to a symbol, first open a text editor with symbol information.\"));\n    return Disposable.None;\n  }\n\n  provideWithTextEditor(context, picker, token) {\n    const editor = context.editor;\n    const model = this.getModel(editor);\n\n    if (!model) {\n      return Disposable.None;\n    } // Provide symbols from model if available in registry\n\n\n    if (DocumentSymbolProviderRegistry.has(model)) {\n      return this.doProvideWithEditorSymbols(context, model, picker, token);\n    } // Otherwise show an entry for a model without registry\n    // But give a chance to resolve the symbols at a later\n    // point if possible\n\n\n    return this.doProvideWithoutEditorSymbols(context, model, picker, token);\n  }\n\n  doProvideWithoutEditorSymbols(context, model, picker, token) {\n    const disposables = new DisposableStore(); // Generic pick for not having any symbol information\n\n    this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutSymbolProvider', \"The active text editor does not provide symbol information.\")); // Wait for changes to the registry and see if eventually\n    // we do get symbols. This can happen if the picker is opened\n    // very early after the model has loaded but before the\n    // language registry is ready.\n    // https://github.com/microsoft/vscode/issues/70607\n\n    (() => __awaiter(this, void 0, void 0, function* () {\n      const result = yield this.waitForLanguageSymbolRegistry(model, disposables);\n\n      if (!result || token.isCancellationRequested) {\n        return;\n      }\n\n      disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));\n    }))();\n\n    return disposables;\n  }\n\n  provideLabelPick(picker, label) {\n    picker.items = [{\n      label,\n      index: 0,\n      kind: 14\n      /* String */\n\n    }];\n    picker.ariaLabel = label;\n  }\n\n  waitForLanguageSymbolRegistry(model, disposables) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (DocumentSymbolProviderRegistry.has(model)) {\n        return true;\n      }\n\n      let symbolProviderRegistryPromiseResolve;\n      const symbolProviderRegistryPromise = new Promise(resolve => symbolProviderRegistryPromiseResolve = resolve); // Resolve promise when registry knows model\n\n      const symbolProviderListener = disposables.add(DocumentSymbolProviderRegistry.onDidChange(() => {\n        if (DocumentSymbolProviderRegistry.has(model)) {\n          symbolProviderListener.dispose();\n          symbolProviderRegistryPromiseResolve(true);\n        }\n      })); // Resolve promise when we get disposed too\n\n      disposables.add(toDisposable(() => symbolProviderRegistryPromiseResolve(false)));\n      return symbolProviderRegistryPromise;\n    });\n  }\n\n  doProvideWithEditorSymbols(context, model, picker, token) {\n    const editor = context.editor;\n    const disposables = new DisposableStore(); // Goto symbol once picked\n\n    disposables.add(picker.onDidAccept(event => {\n      const [item] = picker.selectedItems;\n\n      if (item && item.range) {\n        this.gotoLocation(context, {\n          range: item.range.selection,\n          keyMods: picker.keyMods,\n          preserveFocus: event.inBackground\n        });\n\n        if (!event.inBackground) {\n          picker.hide();\n        }\n      }\n    })); // Goto symbol side by side if enabled\n\n    disposables.add(picker.onDidTriggerItemButton(_ref => {\n      let {\n        item\n      } = _ref;\n\n      if (item && item.range) {\n        this.gotoLocation(context, {\n          range: item.range.selection,\n          keyMods: picker.keyMods,\n          forceSideBySide: true\n        });\n        picker.hide();\n      }\n    })); // Resolve symbols from document once and reuse this\n    // request for all filtering and typing then on\n\n    const symbolsPromise = this.getDocumentSymbols(model, token); // Set initial picks and update on type\n\n    let picksCts = undefined;\n\n    const updatePickerItems = () => __awaiter(this, void 0, void 0, function* () {\n      // Cancel any previous ask for picks and busy\n      picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);\n      picker.busy = false; // Create new cancellation source for this run\n\n      picksCts = new CancellationTokenSource(token); // Collect symbol picks\n\n      picker.busy = true;\n\n      try {\n        const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider.PREFIX.length).trim());\n        const items = yield this.doGetSymbolPicks(symbolsPromise, query, undefined, picksCts.token);\n\n        if (token.isCancellationRequested) {\n          return;\n        }\n\n        if (items.length > 0) {\n          picker.items = items;\n        } else {\n          if (query.original.length > 0) {\n            this.provideLabelPick(picker, localize('noMatchingSymbolResults', \"No matching editor symbols\"));\n          } else {\n            this.provideLabelPick(picker, localize('noSymbolResults', \"No editor symbols\"));\n          }\n        }\n      } finally {\n        if (!token.isCancellationRequested) {\n          picker.busy = false;\n        }\n      }\n    });\n\n    disposables.add(picker.onDidChangeValue(() => updatePickerItems()));\n    updatePickerItems(); // Reveal and decorate when active item changes\n    // However, ignore the very first event so that\n    // opening the picker is not immediately revealing\n    // and decorating the first entry.\n\n    let ignoreFirstActiveEvent = true;\n    disposables.add(picker.onDidChangeActive(() => {\n      const [item] = picker.activeItems;\n\n      if (item && item.range) {\n        if (ignoreFirstActiveEvent) {\n          ignoreFirstActiveEvent = false;\n          return;\n        } // Reveal\n\n\n        editor.revealRangeInCenter(item.range.selection, 0\n        /* Smooth */\n        ); // Decorate\n\n        this.addDecorations(editor, item.range.decoration);\n      }\n    }));\n    return disposables;\n  }\n\n  doGetSymbolPicks(symbolsPromise, query, options, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const symbols = yield symbolsPromise;\n\n      if (token.isCancellationRequested) {\n        return [];\n      }\n\n      const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX) === 0;\n      const filterPos = filterBySymbolKind ? 1 : 0; // Split between symbol and container query\n\n      let symbolQuery;\n      let containerQuery;\n\n      if (query.values && query.values.length > 1) {\n        symbolQuery = pieceToQuery(query.values[0]); // symbol: only match on first part\n\n        containerQuery = pieceToQuery(query.values.slice(1)); // container: match on all but first parts\n      } else {\n        symbolQuery = query;\n      } // Convert to symbol picks and apply filtering\n\n\n      const filteredSymbolPicks = [];\n\n      for (let index = 0; index < symbols.length; index++) {\n        const symbol = symbols[index];\n        const symbolLabel = trim(symbol.name);\n        const symbolLabelWithIcon = `$(symbol-${SymbolKinds.toString(symbol.kind) || 'property'}) ${symbolLabel}`;\n        const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;\n        let containerLabel = symbol.containerName;\n\n        if (options === null || options === void 0 ? void 0 : options.extraContainerLabel) {\n          if (containerLabel) {\n            containerLabel = `${options.extraContainerLabel} • ${containerLabel}`;\n          } else {\n            containerLabel = options.extraContainerLabel;\n          }\n        }\n\n        let symbolScore = undefined;\n        let symbolMatches = undefined;\n        let containerScore = undefined;\n        let containerMatches = undefined;\n\n        if (query.original.length > filterPos) {\n          // First: try to score on the entire query, it is possible that\n          // the symbol matches perfectly (e.g. searching for \"change log\"\n          // can be a match on a markdown symbol \"change log\"). In that\n          // case we want to skip the container query altogether.\n          let skipContainerQuery = false;\n\n          if (symbolQuery !== query) {\n            [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, Object.assign(Object.assign({}, query), {\n              values: undefined\n              /* disable multi-query support */\n\n            }), filterPos, symbolLabelIconOffset);\n\n            if (typeof symbolScore === 'number') {\n              skipContainerQuery = true; // since we consumed the query, skip any container matching\n            }\n          } // Otherwise: score on the symbol query and match on the container later\n\n\n          if (typeof symbolScore !== 'number') {\n            [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);\n\n            if (typeof symbolScore !== 'number') {\n              continue;\n            }\n          } // Score by container if specified\n\n\n          if (!skipContainerQuery && containerQuery) {\n            if (containerLabel && containerQuery.original.length > 0) {\n              [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);\n            }\n\n            if (typeof containerScore !== 'number') {\n              continue;\n            }\n\n            if (typeof symbolScore === 'number') {\n              symbolScore += containerScore; // boost symbolScore by containerScore\n            }\n          }\n        }\n\n        const deprecated = symbol.tags && symbol.tags.indexOf(1\n        /* Deprecated */\n        ) >= 0;\n        filteredSymbolPicks.push({\n          index,\n          kind: symbol.kind,\n          score: symbolScore,\n          label: symbolLabelWithIcon,\n          ariaLabel: symbolLabel,\n          description: containerLabel,\n          highlights: deprecated ? undefined : {\n            label: symbolMatches,\n            description: containerMatches\n          },\n          range: {\n            selection: Range.collapseToStart(symbol.selectionRange),\n            decoration: symbol.range\n          },\n          strikethrough: deprecated,\n          buttons: (() => {\n            var _a, _b;\n\n            const openSideBySideDirection = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.openSideBySideDirection) ? (_b = this.options) === null || _b === void 0 ? void 0 : _b.openSideBySideDirection() : undefined;\n\n            if (!openSideBySideDirection) {\n              return undefined;\n            }\n\n            return [{\n              iconClass: openSideBySideDirection === 'right' ? Codicon.splitHorizontal.classNames : Codicon.splitVertical.classNames,\n              tooltip: openSideBySideDirection === 'right' ? localize('openToSide', \"Open to the Side\") : localize('openToBottom', \"Open to the Bottom\")\n            }];\n          })()\n        });\n      } // Sort by score\n\n\n      const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ? this.compareByKindAndScore(symbolA, symbolB) : this.compareByScore(symbolA, symbolB)); // Add separator for types\n      // - @  only total number of symbols\n      // - @: grouped by symbol kind\n\n      let symbolPicks = [];\n\n      if (filterBySymbolKind) {\n        let lastSymbolKind = undefined;\n        let lastSeparator = undefined;\n        let lastSymbolKindCounter = 0;\n\n        function updateLastSeparatorLabel() {\n          if (lastSeparator && typeof lastSymbolKind === 'number' && lastSymbolKindCounter > 0) {\n            lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);\n          }\n        }\n\n        for (const symbolPick of sortedFilteredSymbolPicks) {\n          // Found new kind\n          if (lastSymbolKind !== symbolPick.kind) {\n            // Update last separator with number of symbols we found for kind\n            updateLastSeparatorLabel();\n            lastSymbolKind = symbolPick.kind;\n            lastSymbolKindCounter = 1; // Add new separator for new kind\n\n            lastSeparator = {\n              type: 'separator'\n            };\n            symbolPicks.push(lastSeparator);\n          } // Existing kind, keep counting\n          else {\n            lastSymbolKindCounter++;\n          } // Add to final result\n\n\n          symbolPicks.push(symbolPick);\n        } // Update last separator with number of symbols we found for kind\n\n\n        updateLastSeparatorLabel();\n      } else if (sortedFilteredSymbolPicks.length > 0) {\n        symbolPicks = [{\n          label: localize('symbols', \"symbols ({0})\", filteredSymbolPicks.length),\n          type: 'separator'\n        }, ...sortedFilteredSymbolPicks];\n      }\n\n      return symbolPicks;\n    });\n  }\n\n  compareByScore(symbolA, symbolB) {\n    if (typeof symbolA.score !== 'number' && typeof symbolB.score === 'number') {\n      return 1;\n    } else if (typeof symbolA.score === 'number' && typeof symbolB.score !== 'number') {\n      return -1;\n    }\n\n    if (typeof symbolA.score === 'number' && typeof symbolB.score === 'number') {\n      if (symbolA.score > symbolB.score) {\n        return -1;\n      } else if (symbolA.score < symbolB.score) {\n        return 1;\n      }\n    }\n\n    if (symbolA.index < symbolB.index) {\n      return -1;\n    } else if (symbolA.index > symbolB.index) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n  compareByKindAndScore(symbolA, symbolB) {\n    const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;\n    const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND; // Sort by type first if scoped search\n\n    const result = kindA.localeCompare(kindB);\n\n    if (result === 0) {\n      return this.compareByScore(symbolA, symbolB);\n    }\n\n    return result;\n  }\n\n  getDocumentSymbols(document, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const model = yield OutlineModel.create(document, token);\n      return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();\n    });\n  }\n\n}\nAbstractGotoSymbolQuickAccessProvider.PREFIX = '@';\nAbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX = ':';\nAbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY = `${AbstractGotoSymbolQuickAccessProvider.PREFIX}${AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX}`; // #region NLS Helpers\n\nconst FALLBACK_NLS_SYMBOL_KIND = localize('property', \"properties ({0})\");\nconst NLS_SYMBOL_KIND_CACHE = {\n  [5\n  /* Method */\n  ]: localize('method', \"methods ({0})\"),\n  [11\n  /* Function */\n  ]: localize('function', \"functions ({0})\"),\n  [8\n  /* Constructor */\n  ]: localize('_constructor', \"constructors ({0})\"),\n  [12\n  /* Variable */\n  ]: localize('variable', \"variables ({0})\"),\n  [4\n  /* Class */\n  ]: localize('class', \"classes ({0})\"),\n  [22\n  /* Struct */\n  ]: localize('struct', \"structs ({0})\"),\n  [23\n  /* Event */\n  ]: localize('event', \"events ({0})\"),\n  [24\n  /* Operator */\n  ]: localize('operator', \"operators ({0})\"),\n  [10\n  /* Interface */\n  ]: localize('interface', \"interfaces ({0})\"),\n  [2\n  /* Namespace */\n  ]: localize('namespace', \"namespaces ({0})\"),\n  [3\n  /* Package */\n  ]: localize('package', \"packages ({0})\"),\n  [25\n  /* TypeParameter */\n  ]: localize('typeParameter', \"type parameters ({0})\"),\n  [1\n  /* Module */\n  ]: localize('modules', \"modules ({0})\"),\n  [6\n  /* Property */\n  ]: localize('property', \"properties ({0})\"),\n  [9\n  /* Enum */\n  ]: localize('enum', \"enumerations ({0})\"),\n  [21\n  /* EnumMember */\n  ]: localize('enumMember', \"enumeration members ({0})\"),\n  [14\n  /* String */\n  ]: localize('string', \"strings ({0})\"),\n  [0\n  /* File */\n  ]: localize('file', \"files ({0})\"),\n  [17\n  /* Array */\n  ]: localize('array', \"arrays ({0})\"),\n  [15\n  /* Number */\n  ]: localize('number', \"numbers ({0})\"),\n  [16\n  /* Boolean */\n  ]: localize('boolean', \"booleans ({0})\"),\n  [18\n  /* Object */\n  ]: localize('object', \"objects ({0})\"),\n  [19\n  /* Key */\n  ]: localize('key', \"keys ({0})\"),\n  [7\n  /* Field */\n  ]: localize('field', \"fields ({0})\"),\n  [13\n  /* Constant */\n  ]: localize('constant', \"constants ({0})\")\n}; //#endregion","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/gotoSymbolQuickAccess.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","CancellationTokenSource","Codicon","pieceToQuery","prepareQuery","scoreFuzzy2","Disposable","DisposableStore","toDisposable","format","trim","Range","DocumentSymbolProviderRegistry","SymbolKinds","OutlineModel","AbstractEditorNavigationQuickAccessProvider","localize","AbstractGotoSymbolQuickAccessProvider","constructor","options","Object","create","canAcceptInBackground","provideWithoutTextEditor","picker","provideLabelPick","None","provideWithTextEditor","context","token","editor","model","getModel","has","doProvideWithEditorSymbols","doProvideWithoutEditorSymbols","disposables","waitForLanguageSymbolRegistry","isCancellationRequested","add","label","items","index","kind","ariaLabel","symbolProviderRegistryPromiseResolve","symbolProviderRegistryPromise","symbolProviderListener","onDidChange","dispose","onDidAccept","event","item","selectedItems","range","gotoLocation","selection","keyMods","preserveFocus","inBackground","hide","onDidTriggerItemButton","forceSideBySide","symbolsPromise","getDocumentSymbols","picksCts","undefined","updatePickerItems","busy","query","substr","PREFIX","length","doGetSymbolPicks","original","onDidChangeValue","ignoreFirstActiveEvent","onDidChangeActive","activeItems","revealRangeInCenter","addDecorations","decoration","symbols","filterBySymbolKind","indexOf","SCOPE_PREFIX","filterPos","symbolQuery","containerQuery","values","slice","filteredSymbolPicks","symbol","symbolLabel","name","symbolLabelWithIcon","toString","symbolLabelIconOffset","containerLabel","containerName","extraContainerLabel","symbolScore","symbolMatches","containerScore","containerMatches","skipContainerQuery","assign","deprecated","tags","push","score","description","highlights","collapseToStart","selectionRange","strikethrough","buttons","_a","_b","openSideBySideDirection","iconClass","splitHorizontal","classNames","splitVertical","tooltip","sortedFilteredSymbolPicks","sort","symbolA","symbolB","compareByKindAndScore","compareByScore","symbolPicks","lastSymbolKind","lastSeparator","lastSymbolKindCounter","updateLastSeparatorLabel","NLS_SYMBOL_KIND_CACHE","FALLBACK_NLS_SYMBOL_KIND","symbolPick","type","kindA","kindB","localeCompare","document","asListOfDocumentSymbols","PREFIX_BY_CATEGORY"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { Codicon } from '../../../base/common/codicons.js';\nimport { pieceToQuery, prepareQuery, scoreFuzzy2 } from '../../../base/common/fuzzyScorer.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../base/common/lifecycle.js';\nimport { format, trim } from '../../../base/common/strings.js';\nimport { Range } from '../../common/core/range.js';\nimport { DocumentSymbolProviderRegistry, SymbolKinds } from '../../common/modes.js';\nimport { OutlineModel } from '../documentSymbols/outlineModel.js';\nimport { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';\nimport { localize } from '../../../nls.js';\nexport class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {\n    constructor(options = Object.create(null)) {\n        super(options);\n        this.options = options;\n        this.options.canAcceptInBackground = true;\n    }\n    provideWithoutTextEditor(picker) {\n        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutEditor', \"To go to a symbol, first open a text editor with symbol information.\"));\n        return Disposable.None;\n    }\n    provideWithTextEditor(context, picker, token) {\n        const editor = context.editor;\n        const model = this.getModel(editor);\n        if (!model) {\n            return Disposable.None;\n        }\n        // Provide symbols from model if available in registry\n        if (DocumentSymbolProviderRegistry.has(model)) {\n            return this.doProvideWithEditorSymbols(context, model, picker, token);\n        }\n        // Otherwise show an entry for a model without registry\n        // But give a chance to resolve the symbols at a later\n        // point if possible\n        return this.doProvideWithoutEditorSymbols(context, model, picker, token);\n    }\n    doProvideWithoutEditorSymbols(context, model, picker, token) {\n        const disposables = new DisposableStore();\n        // Generic pick for not having any symbol information\n        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutSymbolProvider', \"The active text editor does not provide symbol information.\"));\n        // Wait for changes to the registry and see if eventually\n        // we do get symbols. This can happen if the picker is opened\n        // very early after the model has loaded but before the\n        // language registry is ready.\n        // https://github.com/microsoft/vscode/issues/70607\n        (() => __awaiter(this, void 0, void 0, function* () {\n            const result = yield this.waitForLanguageSymbolRegistry(model, disposables);\n            if (!result || token.isCancellationRequested) {\n                return;\n            }\n            disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));\n        }))();\n        return disposables;\n    }\n    provideLabelPick(picker, label) {\n        picker.items = [{ label, index: 0, kind: 14 /* String */ }];\n        picker.ariaLabel = label;\n    }\n    waitForLanguageSymbolRegistry(model, disposables) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (DocumentSymbolProviderRegistry.has(model)) {\n                return true;\n            }\n            let symbolProviderRegistryPromiseResolve;\n            const symbolProviderRegistryPromise = new Promise(resolve => symbolProviderRegistryPromiseResolve = resolve);\n            // Resolve promise when registry knows model\n            const symbolProviderListener = disposables.add(DocumentSymbolProviderRegistry.onDidChange(() => {\n                if (DocumentSymbolProviderRegistry.has(model)) {\n                    symbolProviderListener.dispose();\n                    symbolProviderRegistryPromiseResolve(true);\n                }\n            }));\n            // Resolve promise when we get disposed too\n            disposables.add(toDisposable(() => symbolProviderRegistryPromiseResolve(false)));\n            return symbolProviderRegistryPromise;\n        });\n    }\n    doProvideWithEditorSymbols(context, model, picker, token) {\n        const editor = context.editor;\n        const disposables = new DisposableStore();\n        // Goto symbol once picked\n        disposables.add(picker.onDidAccept(event => {\n            const [item] = picker.selectedItems;\n            if (item && item.range) {\n                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, preserveFocus: event.inBackground });\n                if (!event.inBackground) {\n                    picker.hide();\n                }\n            }\n        }));\n        // Goto symbol side by side if enabled\n        disposables.add(picker.onDidTriggerItemButton(({ item }) => {\n            if (item && item.range) {\n                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, forceSideBySide: true });\n                picker.hide();\n            }\n        }));\n        // Resolve symbols from document once and reuse this\n        // request for all filtering and typing then on\n        const symbolsPromise = this.getDocumentSymbols(model, token);\n        // Set initial picks and update on type\n        let picksCts = undefined;\n        const updatePickerItems = () => __awaiter(this, void 0, void 0, function* () {\n            // Cancel any previous ask for picks and busy\n            picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);\n            picker.busy = false;\n            // Create new cancellation source for this run\n            picksCts = new CancellationTokenSource(token);\n            // Collect symbol picks\n            picker.busy = true;\n            try {\n                const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider.PREFIX.length).trim());\n                const items = yield this.doGetSymbolPicks(symbolsPromise, query, undefined, picksCts.token);\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                if (items.length > 0) {\n                    picker.items = items;\n                }\n                else {\n                    if (query.original.length > 0) {\n                        this.provideLabelPick(picker, localize('noMatchingSymbolResults', \"No matching editor symbols\"));\n                    }\n                    else {\n                        this.provideLabelPick(picker, localize('noSymbolResults', \"No editor symbols\"));\n                    }\n                }\n            }\n            finally {\n                if (!token.isCancellationRequested) {\n                    picker.busy = false;\n                }\n            }\n        });\n        disposables.add(picker.onDidChangeValue(() => updatePickerItems()));\n        updatePickerItems();\n        // Reveal and decorate when active item changes\n        // However, ignore the very first event so that\n        // opening the picker is not immediately revealing\n        // and decorating the first entry.\n        let ignoreFirstActiveEvent = true;\n        disposables.add(picker.onDidChangeActive(() => {\n            const [item] = picker.activeItems;\n            if (item && item.range) {\n                if (ignoreFirstActiveEvent) {\n                    ignoreFirstActiveEvent = false;\n                    return;\n                }\n                // Reveal\n                editor.revealRangeInCenter(item.range.selection, 0 /* Smooth */);\n                // Decorate\n                this.addDecorations(editor, item.range.decoration);\n            }\n        }));\n        return disposables;\n    }\n    doGetSymbolPicks(symbolsPromise, query, options, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const symbols = yield symbolsPromise;\n            if (token.isCancellationRequested) {\n                return [];\n            }\n            const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX) === 0;\n            const filterPos = filterBySymbolKind ? 1 : 0;\n            // Split between symbol and container query\n            let symbolQuery;\n            let containerQuery;\n            if (query.values && query.values.length > 1) {\n                symbolQuery = pieceToQuery(query.values[0]); // symbol: only match on first part\n                containerQuery = pieceToQuery(query.values.slice(1)); // container: match on all but first parts\n            }\n            else {\n                symbolQuery = query;\n            }\n            // Convert to symbol picks and apply filtering\n            const filteredSymbolPicks = [];\n            for (let index = 0; index < symbols.length; index++) {\n                const symbol = symbols[index];\n                const symbolLabel = trim(symbol.name);\n                const symbolLabelWithIcon = `$(symbol-${SymbolKinds.toString(symbol.kind) || 'property'}) ${symbolLabel}`;\n                const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;\n                let containerLabel = symbol.containerName;\n                if (options === null || options === void 0 ? void 0 : options.extraContainerLabel) {\n                    if (containerLabel) {\n                        containerLabel = `${options.extraContainerLabel} • ${containerLabel}`;\n                    }\n                    else {\n                        containerLabel = options.extraContainerLabel;\n                    }\n                }\n                let symbolScore = undefined;\n                let symbolMatches = undefined;\n                let containerScore = undefined;\n                let containerMatches = undefined;\n                if (query.original.length > filterPos) {\n                    // First: try to score on the entire query, it is possible that\n                    // the symbol matches perfectly (e.g. searching for \"change log\"\n                    // can be a match on a markdown symbol \"change log\"). In that\n                    // case we want to skip the container query altogether.\n                    let skipContainerQuery = false;\n                    if (symbolQuery !== query) {\n                        [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, Object.assign(Object.assign({}, query), { values: undefined /* disable multi-query support */ }), filterPos, symbolLabelIconOffset);\n                        if (typeof symbolScore === 'number') {\n                            skipContainerQuery = true; // since we consumed the query, skip any container matching\n                        }\n                    }\n                    // Otherwise: score on the symbol query and match on the container later\n                    if (typeof symbolScore !== 'number') {\n                        [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);\n                        if (typeof symbolScore !== 'number') {\n                            continue;\n                        }\n                    }\n                    // Score by container if specified\n                    if (!skipContainerQuery && containerQuery) {\n                        if (containerLabel && containerQuery.original.length > 0) {\n                            [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);\n                        }\n                        if (typeof containerScore !== 'number') {\n                            continue;\n                        }\n                        if (typeof symbolScore === 'number') {\n                            symbolScore += containerScore; // boost symbolScore by containerScore\n                        }\n                    }\n                }\n                const deprecated = symbol.tags && symbol.tags.indexOf(1 /* Deprecated */) >= 0;\n                filteredSymbolPicks.push({\n                    index,\n                    kind: symbol.kind,\n                    score: symbolScore,\n                    label: symbolLabelWithIcon,\n                    ariaLabel: symbolLabel,\n                    description: containerLabel,\n                    highlights: deprecated ? undefined : {\n                        label: symbolMatches,\n                        description: containerMatches\n                    },\n                    range: {\n                        selection: Range.collapseToStart(symbol.selectionRange),\n                        decoration: symbol.range\n                    },\n                    strikethrough: deprecated,\n                    buttons: (() => {\n                        var _a, _b;\n                        const openSideBySideDirection = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.openSideBySideDirection) ? (_b = this.options) === null || _b === void 0 ? void 0 : _b.openSideBySideDirection() : undefined;\n                        if (!openSideBySideDirection) {\n                            return undefined;\n                        }\n                        return [\n                            {\n                                iconClass: openSideBySideDirection === 'right' ? Codicon.splitHorizontal.classNames : Codicon.splitVertical.classNames,\n                                tooltip: openSideBySideDirection === 'right' ? localize('openToSide', \"Open to the Side\") : localize('openToBottom', \"Open to the Bottom\")\n                            }\n                        ];\n                    })()\n                });\n            }\n            // Sort by score\n            const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ?\n                this.compareByKindAndScore(symbolA, symbolB) :\n                this.compareByScore(symbolA, symbolB));\n            // Add separator for types\n            // - @  only total number of symbols\n            // - @: grouped by symbol kind\n            let symbolPicks = [];\n            if (filterBySymbolKind) {\n                let lastSymbolKind = undefined;\n                let lastSeparator = undefined;\n                let lastSymbolKindCounter = 0;\n                function updateLastSeparatorLabel() {\n                    if (lastSeparator && typeof lastSymbolKind === 'number' && lastSymbolKindCounter > 0) {\n                        lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);\n                    }\n                }\n                for (const symbolPick of sortedFilteredSymbolPicks) {\n                    // Found new kind\n                    if (lastSymbolKind !== symbolPick.kind) {\n                        // Update last separator with number of symbols we found for kind\n                        updateLastSeparatorLabel();\n                        lastSymbolKind = symbolPick.kind;\n                        lastSymbolKindCounter = 1;\n                        // Add new separator for new kind\n                        lastSeparator = { type: 'separator' };\n                        symbolPicks.push(lastSeparator);\n                    }\n                    // Existing kind, keep counting\n                    else {\n                        lastSymbolKindCounter++;\n                    }\n                    // Add to final result\n                    symbolPicks.push(symbolPick);\n                }\n                // Update last separator with number of symbols we found for kind\n                updateLastSeparatorLabel();\n            }\n            else if (sortedFilteredSymbolPicks.length > 0) {\n                symbolPicks = [\n                    { label: localize('symbols', \"symbols ({0})\", filteredSymbolPicks.length), type: 'separator' },\n                    ...sortedFilteredSymbolPicks\n                ];\n            }\n            return symbolPicks;\n        });\n    }\n    compareByScore(symbolA, symbolB) {\n        if (typeof symbolA.score !== 'number' && typeof symbolB.score === 'number') {\n            return 1;\n        }\n        else if (typeof symbolA.score === 'number' && typeof symbolB.score !== 'number') {\n            return -1;\n        }\n        if (typeof symbolA.score === 'number' && typeof symbolB.score === 'number') {\n            if (symbolA.score > symbolB.score) {\n                return -1;\n            }\n            else if (symbolA.score < symbolB.score) {\n                return 1;\n            }\n        }\n        if (symbolA.index < symbolB.index) {\n            return -1;\n        }\n        else if (symbolA.index > symbolB.index) {\n            return 1;\n        }\n        return 0;\n    }\n    compareByKindAndScore(symbolA, symbolB) {\n        const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;\n        const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;\n        // Sort by type first if scoped search\n        const result = kindA.localeCompare(kindB);\n        if (result === 0) {\n            return this.compareByScore(symbolA, symbolB);\n        }\n        return result;\n    }\n    getDocumentSymbols(document, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const model = yield OutlineModel.create(document, token);\n            return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();\n        });\n    }\n}\nAbstractGotoSymbolQuickAccessProvider.PREFIX = '@';\nAbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX = ':';\nAbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY = `${AbstractGotoSymbolQuickAccessProvider.PREFIX}${AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX}`;\n// #region NLS Helpers\nconst FALLBACK_NLS_SYMBOL_KIND = localize('property', \"properties ({0})\");\nconst NLS_SYMBOL_KIND_CACHE = {\n    [5 /* Method */]: localize('method', \"methods ({0})\"),\n    [11 /* Function */]: localize('function', \"functions ({0})\"),\n    [8 /* Constructor */]: localize('_constructor', \"constructors ({0})\"),\n    [12 /* Variable */]: localize('variable', \"variables ({0})\"),\n    [4 /* Class */]: localize('class', \"classes ({0})\"),\n    [22 /* Struct */]: localize('struct', \"structs ({0})\"),\n    [23 /* Event */]: localize('event', \"events ({0})\"),\n    [24 /* Operator */]: localize('operator', \"operators ({0})\"),\n    [10 /* Interface */]: localize('interface', \"interfaces ({0})\"),\n    [2 /* Namespace */]: localize('namespace', \"namespaces ({0})\"),\n    [3 /* Package */]: localize('package', \"packages ({0})\"),\n    [25 /* TypeParameter */]: localize('typeParameter', \"type parameters ({0})\"),\n    [1 /* Module */]: localize('modules', \"modules ({0})\"),\n    [6 /* Property */]: localize('property', \"properties ({0})\"),\n    [9 /* Enum */]: localize('enum', \"enumerations ({0})\"),\n    [21 /* EnumMember */]: localize('enumMember', \"enumeration members ({0})\"),\n    [14 /* String */]: localize('string', \"strings ({0})\"),\n    [0 /* File */]: localize('file', \"files ({0})\"),\n    [17 /* Array */]: localize('array', \"arrays ({0})\"),\n    [15 /* Number */]: localize('number', \"numbers ({0})\"),\n    [16 /* Boolean */]: localize('boolean', \"booleans ({0})\"),\n    [18 /* Object */]: localize('object', \"objects ({0})\"),\n    [19 /* Key */]: localize('key', \"keys ({0})\"),\n    [7 /* Field */]: localize('field', \"fields ({0})\"),\n    [13 /* Constant */]: localize('constant', \"constants ({0})\")\n};\n//#endregion\n"]},"metadata":{},"sourceType":"module"}