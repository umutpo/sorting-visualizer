{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TextModel } from '../../common/model/textModel.js';\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\nimport { FoldingRegions, MAX_LINE_NUMBER } from './foldingRanges.js';\nconst MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT = 5000;\nexport const ID_INDENT_PROVIDER = 'indent';\nexport class IndentRangeProvider {\n  constructor(editorModel) {\n    this.editorModel = editorModel;\n    this.id = ID_INDENT_PROVIDER;\n  }\n\n  dispose() {}\n\n  compute(cancelationToken) {\n    let foldingRules = LanguageConfigurationRegistry.getFoldingRules(this.editorModel.getLanguageId());\n    let offSide = foldingRules && !!foldingRules.offSide;\n    let markers = foldingRules && foldingRules.markers;\n    return Promise.resolve(computeRanges(this.editorModel, offSide, markers));\n  }\n\n} // public only for testing\n\nexport class RangesCollector {\n  constructor(foldingRangesLimit) {\n    this._startIndexes = [];\n    this._endIndexes = [];\n    this._indentOccurrences = [];\n    this._length = 0;\n    this._foldingRangesLimit = foldingRangesLimit;\n  }\n\n  insertFirst(startLineNumber, endLineNumber, indent) {\n    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n      return;\n    }\n\n    let index = this._length;\n    this._startIndexes[index] = startLineNumber;\n    this._endIndexes[index] = endLineNumber;\n    this._length++;\n\n    if (indent < 1000) {\n      this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;\n    }\n  }\n\n  toIndentRanges(model) {\n    if (this._length <= this._foldingRangesLimit) {\n      // reverse and create arrays of the exact length\n      let startIndexes = new Uint32Array(this._length);\n      let endIndexes = new Uint32Array(this._length);\n\n      for (let i = this._length - 1, k = 0; i >= 0; i--, k++) {\n        startIndexes[k] = this._startIndexes[i];\n        endIndexes[k] = this._endIndexes[i];\n      }\n\n      return new FoldingRegions(startIndexes, endIndexes);\n    } else {\n      let entries = 0;\n      let maxIndent = this._indentOccurrences.length;\n\n      for (let i = 0; i < this._indentOccurrences.length; i++) {\n        let n = this._indentOccurrences[i];\n\n        if (n) {\n          if (n + entries > this._foldingRangesLimit) {\n            maxIndent = i;\n            break;\n          }\n\n          entries += n;\n        }\n      }\n\n      const tabSize = model.getOptions().tabSize; // reverse and create arrays of the exact length\n\n      let startIndexes = new Uint32Array(this._foldingRangesLimit);\n      let endIndexes = new Uint32Array(this._foldingRangesLimit);\n\n      for (let i = this._length - 1, k = 0; i >= 0; i--) {\n        let startIndex = this._startIndexes[i];\n        let lineContent = model.getLineContent(startIndex);\n        let indent = TextModel.computeIndentLevel(lineContent, tabSize);\n\n        if (indent < maxIndent || indent === maxIndent && entries++ < this._foldingRangesLimit) {\n          startIndexes[k] = startIndex;\n          endIndexes[k] = this._endIndexes[i];\n          k++;\n        }\n      }\n\n      return new FoldingRegions(startIndexes, endIndexes);\n    }\n  }\n\n}\nexport function computeRanges(model, offSide, markers) {\n  let foldingRangesLimit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT;\n  const tabSize = model.getOptions().tabSize;\n  let result = new RangesCollector(foldingRangesLimit);\n  let pattern = undefined;\n\n  if (markers) {\n    pattern = new RegExp(`(${markers.start.source})|(?:${markers.end.source})`);\n  }\n\n  let previousRegions = [];\n  let line = model.getLineCount() + 1;\n  previousRegions.push({\n    indent: -1,\n    endAbove: line,\n    line\n  }); // sentinel, to make sure there's at least one entry\n\n  for (let line = model.getLineCount(); line > 0; line--) {\n    let lineContent = model.getLineContent(line);\n    let indent = TextModel.computeIndentLevel(lineContent, tabSize);\n    let previous = previousRegions[previousRegions.length - 1];\n\n    if (indent === -1) {\n      if (offSide) {\n        // for offSide languages, empty lines are associated to the previous block\n        // note: the next block is already written to the results, so this only\n        // impacts the end position of the block before\n        previous.endAbove = line;\n      }\n\n      continue; // only whitespace\n    }\n\n    let m;\n\n    if (pattern && (m = lineContent.match(pattern))) {\n      // folding pattern match\n      if (m[1]) {\n        // start pattern match\n        // discard all regions until the folding pattern\n        let i = previousRegions.length - 1;\n\n        while (i > 0 && previousRegions[i].indent !== -2) {\n          i--;\n        }\n\n        if (i > 0) {\n          previousRegions.length = i + 1;\n          previous = previousRegions[i]; // new folding range from pattern, includes the end line\n\n          result.insertFirst(line, previous.line, indent);\n          previous.line = line;\n          previous.indent = indent;\n          previous.endAbove = line;\n          continue;\n        } else {// no end marker found, treat line as a regular line\n        }\n      } else {\n        // end pattern match\n        previousRegions.push({\n          indent: -2,\n          endAbove: line,\n          line\n        });\n        continue;\n      }\n    }\n\n    if (previous.indent > indent) {\n      // discard all regions with larger indent\n      do {\n        previousRegions.pop();\n        previous = previousRegions[previousRegions.length - 1];\n      } while (previous.indent > indent); // new folding range\n\n\n      let endLineNumber = previous.endAbove - 1;\n\n      if (endLineNumber - line >= 1) {\n        // needs at east size 1\n        result.insertFirst(line, endLineNumber, indent);\n      }\n    }\n\n    if (previous.indent === indent) {\n      previous.endAbove = line;\n    } else {\n      // previous.indent < indent\n      // new region with a bigger indent\n      previousRegions.push({\n        indent,\n        endAbove: line,\n        line\n      });\n    }\n  }\n\n  return result.toIndentRanges(model);\n}","map":{"version":3,"sources":["/home/umut/Documents/cs/cs410/Project2Group14/node_modules/monaco-editor/esm/vs/editor/contrib/folding/indentRangeProvider.js"],"names":["TextModel","LanguageConfigurationRegistry","FoldingRegions","MAX_LINE_NUMBER","MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT","ID_INDENT_PROVIDER","IndentRangeProvider","constructor","editorModel","id","dispose","compute","cancelationToken","foldingRules","getFoldingRules","getLanguageId","offSide","markers","Promise","resolve","computeRanges","RangesCollector","foldingRangesLimit","_startIndexes","_endIndexes","_indentOccurrences","_length","_foldingRangesLimit","insertFirst","startLineNumber","endLineNumber","indent","index","toIndentRanges","model","startIndexes","Uint32Array","endIndexes","i","k","entries","maxIndent","length","n","tabSize","getOptions","startIndex","lineContent","getLineContent","computeIndentLevel","result","pattern","undefined","RegExp","start","source","end","previousRegions","line","getLineCount","push","endAbove","previous","m","match","pop"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TextModel } from '../../common/model/textModel.js';\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\nimport { FoldingRegions, MAX_LINE_NUMBER } from './foldingRanges.js';\nconst MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT = 5000;\nexport const ID_INDENT_PROVIDER = 'indent';\nexport class IndentRangeProvider {\n    constructor(editorModel) {\n        this.editorModel = editorModel;\n        this.id = ID_INDENT_PROVIDER;\n    }\n    dispose() {\n    }\n    compute(cancelationToken) {\n        let foldingRules = LanguageConfigurationRegistry.getFoldingRules(this.editorModel.getLanguageId());\n        let offSide = foldingRules && !!foldingRules.offSide;\n        let markers = foldingRules && foldingRules.markers;\n        return Promise.resolve(computeRanges(this.editorModel, offSide, markers));\n    }\n}\n// public only for testing\nexport class RangesCollector {\n    constructor(foldingRangesLimit) {\n        this._startIndexes = [];\n        this._endIndexes = [];\n        this._indentOccurrences = [];\n        this._length = 0;\n        this._foldingRangesLimit = foldingRangesLimit;\n    }\n    insertFirst(startLineNumber, endLineNumber, indent) {\n        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n            return;\n        }\n        let index = this._length;\n        this._startIndexes[index] = startLineNumber;\n        this._endIndexes[index] = endLineNumber;\n        this._length++;\n        if (indent < 1000) {\n            this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;\n        }\n    }\n    toIndentRanges(model) {\n        if (this._length <= this._foldingRangesLimit) {\n            // reverse and create arrays of the exact length\n            let startIndexes = new Uint32Array(this._length);\n            let endIndexes = new Uint32Array(this._length);\n            for (let i = this._length - 1, k = 0; i >= 0; i--, k++) {\n                startIndexes[k] = this._startIndexes[i];\n                endIndexes[k] = this._endIndexes[i];\n            }\n            return new FoldingRegions(startIndexes, endIndexes);\n        }\n        else {\n            let entries = 0;\n            let maxIndent = this._indentOccurrences.length;\n            for (let i = 0; i < this._indentOccurrences.length; i++) {\n                let n = this._indentOccurrences[i];\n                if (n) {\n                    if (n + entries > this._foldingRangesLimit) {\n                        maxIndent = i;\n                        break;\n                    }\n                    entries += n;\n                }\n            }\n            const tabSize = model.getOptions().tabSize;\n            // reverse and create arrays of the exact length\n            let startIndexes = new Uint32Array(this._foldingRangesLimit);\n            let endIndexes = new Uint32Array(this._foldingRangesLimit);\n            for (let i = this._length - 1, k = 0; i >= 0; i--) {\n                let startIndex = this._startIndexes[i];\n                let lineContent = model.getLineContent(startIndex);\n                let indent = TextModel.computeIndentLevel(lineContent, tabSize);\n                if (indent < maxIndent || (indent === maxIndent && entries++ < this._foldingRangesLimit)) {\n                    startIndexes[k] = startIndex;\n                    endIndexes[k] = this._endIndexes[i];\n                    k++;\n                }\n            }\n            return new FoldingRegions(startIndexes, endIndexes);\n        }\n    }\n}\nexport function computeRanges(model, offSide, markers, foldingRangesLimit = MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT) {\n    const tabSize = model.getOptions().tabSize;\n    let result = new RangesCollector(foldingRangesLimit);\n    let pattern = undefined;\n    if (markers) {\n        pattern = new RegExp(`(${markers.start.source})|(?:${markers.end.source})`);\n    }\n    let previousRegions = [];\n    let line = model.getLineCount() + 1;\n    previousRegions.push({ indent: -1, endAbove: line, line }); // sentinel, to make sure there's at least one entry\n    for (let line = model.getLineCount(); line > 0; line--) {\n        let lineContent = model.getLineContent(line);\n        let indent = TextModel.computeIndentLevel(lineContent, tabSize);\n        let previous = previousRegions[previousRegions.length - 1];\n        if (indent === -1) {\n            if (offSide) {\n                // for offSide languages, empty lines are associated to the previous block\n                // note: the next block is already written to the results, so this only\n                // impacts the end position of the block before\n                previous.endAbove = line;\n            }\n            continue; // only whitespace\n        }\n        let m;\n        if (pattern && (m = lineContent.match(pattern))) {\n            // folding pattern match\n            if (m[1]) { // start pattern match\n                // discard all regions until the folding pattern\n                let i = previousRegions.length - 1;\n                while (i > 0 && previousRegions[i].indent !== -2) {\n                    i--;\n                }\n                if (i > 0) {\n                    previousRegions.length = i + 1;\n                    previous = previousRegions[i];\n                    // new folding range from pattern, includes the end line\n                    result.insertFirst(line, previous.line, indent);\n                    previous.line = line;\n                    previous.indent = indent;\n                    previous.endAbove = line;\n                    continue;\n                }\n                else {\n                    // no end marker found, treat line as a regular line\n                }\n            }\n            else { // end pattern match\n                previousRegions.push({ indent: -2, endAbove: line, line });\n                continue;\n            }\n        }\n        if (previous.indent > indent) {\n            // discard all regions with larger indent\n            do {\n                previousRegions.pop();\n                previous = previousRegions[previousRegions.length - 1];\n            } while (previous.indent > indent);\n            // new folding range\n            let endLineNumber = previous.endAbove - 1;\n            if (endLineNumber - line >= 1) { // needs at east size 1\n                result.insertFirst(line, endLineNumber, indent);\n            }\n        }\n        if (previous.indent === indent) {\n            previous.endAbove = line;\n        }\n        else { // previous.indent < indent\n            // new region with a bigger indent\n            previousRegions.push({ indent, endAbove: line, line });\n        }\n    }\n    return result.toIndentRanges(model);\n}\n"]},"metadata":{},"sourceType":"module"}